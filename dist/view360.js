(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("@egjs/component"), require("@egjs/axes"));
	else if(typeof define === 'function' && define.amd)
		define("view360", ["@egjs/component", "@egjs/axes"], factory);
	else if(typeof exports === 'object')
		exports["view360"] = factory(require("@egjs/component"), require("@egjs/axes"));
	else
		root["eg"] = root["eg"] || {}, root["eg"]["view360"] = factory(root["eg"]["Component"], root["eg"]["Axes"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_11__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 69);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.ROTATE_CONSTANT = exports.vec3 = exports.vec2 = exports.quat = exports.mat4 = exports.glMatrix = exports.util = undefined;

var _common = __webpack_require__(2);

var _common2 = _interopRequireDefault(_common);

var _vec = __webpack_require__(44);

var _vec2 = _interopRequireDefault(_vec);

var _vec3 = __webpack_require__(43);

var _vec4 = _interopRequireDefault(_vec3);

var _quat = __webpack_require__(42);

var _quat2 = _interopRequireDefault(_quat);

var _mat = __webpack_require__(41);

var _mat2 = _interopRequireDefault(_mat);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function quatToVec3(quaternion) {
	var baseV = _vec2["default"].fromValues(0, 0, 1);

	_vec2["default"].transformQuat(baseV, baseV, quaternion);
	return baseV;
} /**
   * Original Code
   * https://github.com/toji/gl-matrix/blob/v2.3.2/src/gl-matrix.js
   * Math Util
   * modified by egjs
   */
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.2
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

// Some minimal math functionality borrowed from gl-Matrix and stripped down
// for the purposes of this library.

var util = {};

util.isPowerOfTwo = function (n) {
	return n && (n & n - 1) === 0;
};

util.extractPitchFromQuat = function (quaternion) {
	var baseV = quatToVec3(quaternion);

	return -1 * Math.atan2(baseV[1], Math.sqrt(Math.pow(baseV[0], 2) + Math.pow(baseV[2], 2)));
};

// implement reference
// the general equation of a plane : http://www.gisdeveloper.co.kr/entry/평면의-공식
// calculating angle between two vectors : http://darkpgmr.tistory.com/121
var ROTATE_CONSTANT = {
	PITCH_DELTA: 1,
	YAW_DELTA_BY_ROLL: 2,
	YAW_DELTA_BY_YAW: 3
};

ROTATE_CONSTANT[ROTATE_CONSTANT.PITCH_DELTA] = {
	targetAxis: [0, 1, 0],
	meshPoint: [0, 0, 1]
};
ROTATE_CONSTANT[ROTATE_CONSTANT.YAW_DELTA_BY_ROLL] = {
	targetAxis: [0, 1, 0],
	meshPoint: [1, 0, 0]
};
ROTATE_CONSTANT[ROTATE_CONSTANT.YAW_DELTA_BY_YAW] = {
	targetAxis: [1, 0, 0],
	meshPoint: [0, 0, 1]
};

function getRotationDelta(prevQ, curQ, rotateKind) {
	var targetAxis = _vec2["default"].fromValues(ROTATE_CONSTANT[rotateKind].targetAxis[0], ROTATE_CONSTANT[rotateKind].targetAxis[1], ROTATE_CONSTANT[rotateKind].targetAxis[2]);
	var meshPoint = ROTATE_CONSTANT[rotateKind].meshPoint;

	var prevQuaternion = _quat2["default"].clone(prevQ);
	var curQuaternion = _quat2["default"].clone(curQ);

	_quat2["default"].normalize(prevQuaternion, prevQuaternion);
	_quat2["default"].normalize(curQuaternion, curQuaternion);

	var prevPoint = _vec2["default"].fromValues(0, 0, 1);
	var curPoint = _vec2["default"].fromValues(0, 0, 1);

	_vec2["default"].transformQuat(prevPoint, prevPoint, prevQuaternion);
	_vec2["default"].transformQuat(curPoint, curPoint, curQuaternion);
	_vec2["default"].transformQuat(targetAxis, targetAxis, curQuaternion);

	var rotateDistance = _vec2["default"].dot(targetAxis, _vec2["default"].cross(_vec2["default"].create(), prevPoint, curPoint));
	var rotateDirection = rotateDistance > 0 ? 1 : -1;

	// when counter clock wise, use vec3.fromValues(0,1,0)
	// when clock wise, use vec3.fromValues(0,-1,0)
	// const meshPoint1 = vec3.fromValues(0, 0, 0);
	var meshPoint2 = _vec2["default"].fromValues(meshPoint[0], meshPoint[1], meshPoint[2]);

	var meshPoint3 = void 0;

	if (rotateKind !== ROTATE_CONSTANT.YAW_DELTA_BY_YAW) {
		meshPoint3 = _vec2["default"].fromValues(0, rotateDirection, 0);
	} else {
		meshPoint3 = _vec2["default"].fromValues(rotateDirection, 0, 0);
	}

	_vec2["default"].transformQuat(meshPoint2, meshPoint2, curQuaternion);
	_vec2["default"].transformQuat(meshPoint3, meshPoint3, curQuaternion);

	var vecU = meshPoint2;
	var vecV = meshPoint3;
	var vecN = _vec2["default"].create();

	_vec2["default"].cross(vecN, vecU, vecV);
	_vec2["default"].normalize(vecN, vecN);

	var coefficientA = vecN[0];
	var coefficientB = vecN[1];
	var coefficientC = vecN[2];
	//	const coefficientD = -1 * vec3.dot(vecN, meshPoint1);

	// a point on the plane
	curPoint = _vec2["default"].fromValues(meshPoint[0], meshPoint[1], meshPoint[2]);
	_vec2["default"].transformQuat(curPoint, curPoint, curQuaternion);

	// a point should project on the plane
	prevPoint = _vec2["default"].fromValues(meshPoint[0], meshPoint[1], meshPoint[2]);
	_vec2["default"].transformQuat(prevPoint, prevPoint, prevQuaternion);

	// distance between prevPoint and the plane
	var distance = Math.abs(prevPoint[0] * coefficientA + prevPoint[1] * coefficientB + prevPoint[2] * coefficientC);

	var projectedPrevPoint = _vec2["default"].create();

	_vec2["default"].subtract(projectedPrevPoint, prevPoint, _vec2["default"].scale(_vec2["default"].create(), vecN, distance));

	var trigonometricRatio = (projectedPrevPoint[0] * curPoint[0] + projectedPrevPoint[1] * curPoint[1] + projectedPrevPoint[2] * curPoint[2]) / (_vec2["default"].length(projectedPrevPoint) * _vec2["default"].length(curPoint));

	// defensive block
	if (trigonometricRatio > 1) {
		trigonometricRatio = 1;
	}

	var theta = Math.acos(trigonometricRatio);

	var crossVec = _vec2["default"].cross(_vec2["default"].create(), curPoint, projectedPrevPoint);

	distance = coefficientA * crossVec[0] + coefficientB * crossVec[1] + coefficientC * crossVec[2];

	var thetaDirection = void 0;

	if (rotateKind !== ROTATE_CONSTANT.YAW_DELTA_BY_YAW) {
		thetaDirection = distance > 0 ? 1 : -1;
	} else {
		thetaDirection = distance < 0 ? 1 : -1;
	}

	var deltaRadian = theta * thetaDirection * rotateDirection;

	return _common2["default"].toDegree(deltaRadian);
}

util.getRotationDelta = getRotationDelta;

exports.util = util;
exports.glMatrix = _common2["default"];
exports.mat4 = _mat2["default"];
exports.quat = _quat2["default"];
exports.vec2 = _vec4["default"];
exports.vec3 = _vec2["default"];
exports.ROTATE_CONSTANT = ROTATE_CONSTANT;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Original Code
 * https://github.com/toji/gl-matrix/blob/v2.3.2/src/gl-matrix/common.js
 * Common utilities
 * modified by egjs
 */
var glMatrix = {};

glMatrix.ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;

var degree = Math.PI / 180;

glMatrix.toRadian = function (a) {
     return a * degree;
};

glMatrix.toDegree = function (a) {
     return a / degree;
};

// glMatrix.EPSILON = 0.000001;
glMatrix.EPSILON = 0.0001;

module.exports = glMatrix;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Copyright (c) 2017 NAVER Corp.
 * @egjs/agent project is licensed under the MIT license
 * 
 * @egjs/agent JavaScript library
 * 
 * 
 * @version 2.1.2
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["agent"] = factory();
	else
		root["eg"] = root["eg"] || {}, root["eg"]["agent"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _agent = __webpack_require__(1);

var _agent2 = _interopRequireDefault(_agent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

module.exports = _agent2["default"]; /**
                                      * Copyright (c) NAVER Corp.
                                      * egjs-agent projects are licensed under the MIT license
                                      */

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _browser = __webpack_require__(2);

var _Parser = __webpack_require__(3);

var _Parser2 = _interopRequireDefault(_Parser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @namespace eg
 */

/**
 * Extracts browser and operating system information from the user agent string.
 * @ko 유저 에이전트 문자열에서 브라우저와 운영체제 정보를 추출한다.
 * @function eg#agent
 * @param {String} [userAgent=navigator.userAgent] user agent string to parse <ko>파싱할 유저에이전트 문자열</ko>
 * @return {Object} agentInfo
 * @return {Object} agentInfo.os os Operating system information <ko>운영체제 정보</ko>
 * @return {String} agentInfo.os.name Operating system name (android, ios, window, mac, unknown) <ko>운영체제 이름 (android, ios, window, mac, unknown)</ko>
 * @return {String} agentInfo.os.version Operating system version <ko>운영체제 버전</ko>
 * @return {String} agentInfo.browser Browser information <ko>브라우저 정보</ko>
 * @return {String} agentInfo.browser.name Browser name (safari, chrome, sbrowser, ie, firefox, unknown) <ko>브라우저 이름 (safari, chrome, sbrowser, ie, firefox, unknown)</ko>
 * @return {String} agentInfo.browser.version Browser version <ko>브라우저 버전 </ko>
 * @return {Boolean} agentInfo.browser.webview Indicates whether the browser is inapp<ko>웹뷰 브라우저 여부</ko>
 * @return {Boolean} agentInfo.isMobile Indicates whether the browser is for mobile<ko>모바일 브라우저 여부</ko>
 */
/**
 * Copyright (c) NAVER Corp.
 * egjs-agent projects are licensed under the MIT license
 */
function agent() {
  var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _browser.navigator.userAgent;

  _Parser2["default"].setUa(ua);

  var agentInfo = {
    os: _Parser2["default"].getOs(),
    browser: _Parser2["default"].getBrowser(),
    isMobile: _Parser2["default"].getIsMobile()
  };

  agentInfo.browser.name = agentInfo.browser.name.toLowerCase();
  agentInfo.os.name = agentInfo.os.name.toLowerCase();
  agentInfo.os.version = agentInfo.os.version.toLowerCase();

  if (agentInfo.os.name === "ios" && agentInfo.browser.webview) {
    agentInfo.browser.version = "-1";
  }

  return agentInfo;
}
agent.VERSION = "2.1.2";
exports["default"] = agent;
module.exports = exports["default"];

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var win = typeof window !== "undefined" && window || {};

var RegExp = exports.RegExp = win.RegExp;
var navigator = exports.navigator = win.navigator;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _parseRules = __webpack_require__(4);

var _parseRules2 = _interopRequireDefault(_parseRules);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var UA = void 0;

function setUa(ua) {
	UA = ua;
}

function isMatched(base, target) {
	return target && target.test ? !!target.test(base) : base.indexOf(target) > -1;
}

function getIdentityStringFromArray(rules, defaultStrings) {
	var matchedRule = rules.filter(function (rule) {
		return isMatched(UA, rule.criteria);
	})[0];

	return matchedRule && matchedRule.identity || defaultStrings.name;
}

function getRule(rules, targetIdentity) {
	return rules.filter(function (rule) {
		var criteria = rule.criteria;
		var identityMatched = new RegExp(rule.identity, "i").test(targetIdentity);

		if (criteria ? identityMatched && isMatched(UA, criteria) : identityMatched) {
			return true;
		} else {
			return false;
		}
	})[0];
}

function getBrowserName() {
	return getIdentityStringFromArray(_parseRules2["default"].browser, _parseRules2["default"].defaultString.browser);
}

function getBrowserRule(browserName) {
	var rule = getRule(_parseRules2["default"].browser, browserName);

	if (!rule) {
		rule = {
			criteria: browserName,
			versionSearch: browserName,
			identity: browserName
		};
	}

	return rule;
}

function extractBrowserVersion(versionToken, ua) {
	var browserVersion = _parseRules2["default"].defaultString.browser.version;
	var versionRegexResult = new RegExp("(" + versionToken + ")", "i").exec(ua);

	if (!versionRegexResult) {
		return browserVersion;
	}

	var versionTokenIndex = versionRegexResult.index;
	var verTkn = versionRegexResult[0];

	if (versionTokenIndex > -1) {
		var versionIndex = versionTokenIndex + verTkn.length + 1;

		browserVersion = ua.substring(versionIndex).split(" ")[0].replace(/_/g, ".").replace(/;|\)/g, "");
	}
	return browserVersion;
}

function getBrowserVersion(browserName) {
	if (!browserName) {
		return undefined;
	}

	// console.log(browserRule);
	// const versionToken = browserRule ? browserRule.versionSearch : browserName;
	var browserRule = getBrowserRule(browserName);
	var versionToken = browserRule.versionSearch || browserName;
	var browserVersion = extractBrowserVersion(versionToken, UA);

	return browserVersion;
}

function isWebview() {
	var webviewRules = _parseRules2["default"].webview;
	var browserVersion = void 0;

	return webviewRules.filter(function (rule) {
		return isMatched(UA, rule.criteria);
	}).some(function (rule) {
		browserVersion = extractBrowserVersion(rule.browserVersionSearch, UA);
		if (isMatched(UA, rule.webviewToken) || isMatched(browserVersion, rule.webviewBrowserVersion)) {
			return true;
		} else {
			return false;
		}
	});
}

function getOSRule(osName) {
	return getRule(_parseRules2["default"].os, osName);
}

function getOsName() {
	return getIdentityStringFromArray(_parseRules2["default"].os, _parseRules2["default"].defaultString.os);
}

function getOsVersion(osName) {
	var osRule = getOSRule(osName) || {};
	var defaultOSVersion = _parseRules2["default"].defaultString.os.version;
	var osVersion = void 0;

	if (!osName) {
		return undefined;
	}
	if (osRule.versionAlias) {
		return osRule.versionAlias;
	}
	var osVersionToken = osRule.versionSearch || osName;
	var osVersionRegex = new RegExp("(" + osVersionToken + ")\\s([\\d_\\.]+|\\d_0)", "i");
	var osVersionRegexResult = osVersionRegex.exec(UA);

	if (osVersionRegexResult) {
		osVersion = osVersionRegex.exec(UA)[2].replace(/_/g, ".").replace(/;|\)/g, "");
	}
	return osVersion || defaultOSVersion;
}

function getOs() {
	var name = getOsName();
	var version = getOsVersion(name);

	return { name: name, version: version };
}

function getBrowser() {
	var name = getBrowserName();
	var version = getBrowserVersion(name);

	return { name: name, version: version, webview: isWebview() };
}

function getIsMobile() {
	return UA.indexOf("Mobi") !== -1;
}

exports["default"] = {
	getOs: getOs,
	getBrowser: getBrowser,
	getIsMobile: getIsMobile,
	setUa: setUa
};
module.exports = exports["default"];

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var parseRules = {
	browser: [{
		criteria: "PhantomJS",
		identity: "PhantomJS"
	}, {
		criteria: /Whale/,
		identity: "Whale",
		versionSearch: "Whale"
	}, {
		criteria: /Edge/,
		identity: "Edge",
		versionSearch: "Edge"
	}, {
		criteria: /MSIE|Trident|Windows Phone/,
		identity: "IE",
		versionSearch: "IEMobile|MSIE|rv"
	}, {
		criteria: /MiuiBrowser/,
		identity: "MIUI Browser",
		versionSearch: "MiuiBrowser"
	}, {
		criteria: /SamsungBrowser/,
		identity: "Samsung Internet",
		versionSearch: "SamsungBrowser"
	}, {
		criteria: /SAMSUNG /,
		identity: "Samsung Internet",
		versionSearch: "Version"
	}, {
		criteria: /Chrome|CriOS/,
		identity: "Chrome"
	}, {
		criteria: /Android/,
		identity: "Android Browser",
		versionSearch: "Version"
	}, {
		criteria: /iPhone|iPad/,
		identity: "Safari",
		versionSearch: "Version"
	}, {
		criteria: "Apple",
		identity: "Safari",
		versionSearch: "Version"
	}, {
		criteria: "Firefox",
		identity: "Firefox"
	}],
	os: [{
		criteria: /Windows Phone/,
		identity: "Windows Phone",
		versionSearch: "Windows Phone"
	}, {
		criteria: "Windows 2000",
		identity: "Window",
		versionAlias: "5.0"
	}, {
		criteria: /Windows NT/,
		identity: "Window",
		versionSearch: "Windows NT"
	}, {
		criteria: /iPhone|iPad/,
		identity: "iOS",
		versionSearch: "iPhone OS|CPU OS"
	}, {
		criteria: "Mac",
		versionSearch: "OS X",
		identity: "MAC"
	}, {
		criteria: /Android/,
		identity: "Android"
	}, {
		criteria: /Tizen/,
		identity: "Tizen"
	}, {
		criteria: /Web0S/,
		identity: "WebOS"
	}],

	// Webview check condition
	// ios: If has no version information
	// Android 5.0 && chrome 40+: Presence of "; wv" in userAgent
	// Under android 5.0: Presence of "NAVER" or "Daum" in userAgent
	webview: [{
		criteria: /iPhone|iPad/,
		browserVersionSearch: "Version",
		webviewBrowserVersion: /-1/
	}, {
		criteria: /iPhone|iPad|Android/,
		webviewToken: /NAVER|DAUM|; wv/

	}],
	defaultString: {
		browser: {
			version: "-1",
			name: "unknown"
		},
		os: {
			version: "-1",
			name: "unknown"
		}
	}
};

exports["default"] = parseRules;
module.exports = exports["default"];

/***/ })
/******/ ]);
});

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/* eslint-disable no-new-func */
/* eslint-disable no-nested-ternary */
var win = typeof window !== "undefined" && window.Math === Math ? window : typeof self !== "undefined" && self.Math === Math ? self : Function("return this")();
/* eslint-enable no-nested-ternary */
/* eslint-enable no-new-func */

win.Float32Array = typeof win.Float32Array !== "undefined" ? win.Float32Array : win.Array;

exports.window = win;
var document = exports.document = win.document;
var Float32Array = exports.Float32Array = win.Float32Array;
var getComputedStyle = exports.getComputedStyle = win.getComputedStyle;
var userAgent = exports.userAgent = win.navigator.userAgent;
var SUPPORT_TOUCH = exports.SUPPORT_TOUCH = "ontouchstart" in win;
var SUPPORT_DEVICEMOTION = exports.SUPPORT_DEVICEMOTION = "ondevicemotion" in win;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.4+314e4831
 */

(function (global, factory) {
	 true ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && "function" === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var TRY_CATCH_ERROR = { error: null };

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    TRY_CATCH_ERROR.error = error;
    return TRY_CATCH_ERROR;
  }
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === TRY_CATCH_ERROR) {
      reject(promise, TRY_CATCH_ERROR.error);
      TRY_CATCH_ERROR.error = null;
    } else if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = void 0,
      failed = void 0;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value.error = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (failed) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = getThen(entry);

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        handleMaybeThenable(promise, entry, _then);
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    return promise.then(function (value) {
      return constructor.resolve(callback()).then(function () {
        return value;
      });
    }, function (reason) {
      return constructor.resolve(callback()).then(function () {
        throw reason;
      });
    });
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));



//# sourceMappingURL=es6-promise.map

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(52), __webpack_require__(9)))

/***/ }),
/* 6 */
/***/ (function(module, exports) {

/*
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MathUtil = window.MathUtil || {};

MathUtil.degToRad = Math.PI / 180;
MathUtil.radToDeg = 180 / Math.PI;

// Some minimal math functionality borrowed from THREE.Math and stripped down
// for the purposes of this library.


MathUtil.Vector2 = function ( x, y ) {
  this.x = x || 0;
  this.y = y || 0;
};

MathUtil.Vector2.prototype = {
  constructor: MathUtil.Vector2,

  set: function ( x, y ) {
    this.x = x;
    this.y = y;

    return this;
  },

  copy: function ( v ) {
    this.x = v.x;
    this.y = v.y;

    return this;
  },

  subVectors: function ( a, b ) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;

    return this;
  },
};

MathUtil.Vector3 = function ( x, y, z ) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
};

MathUtil.Vector3.prototype = {
  constructor: MathUtil.Vector3,

  set: function ( x, y, z ) {
    this.x = x;
    this.y = y;
    this.z = z;

    return this;
  },

  copy: function ( v ) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;

    return this;
  },

  length: function () {
    return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
  },

  normalize: function () {
    var scalar = this.length();

    if ( scalar !== 0 ) {
      var invScalar = 1 / scalar;

      this.multiplyScalar(invScalar);
    } else {
      this.x = 0;
      this.y = 0;
      this.z = 0;
    }

    return this;
  },

  multiplyScalar: function ( scalar ) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
  },

  applyQuaternion: function ( q ) {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;

    // calculate quat * vector
    var ix =  qw * x + qy * z - qz * y;
    var iy =  qw * y + qz * x - qx * z;
    var iz =  qw * z + qx * y - qy * x;
    var iw = - qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
    this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
    this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

    return this;
  },

  dot: function ( v ) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  },

  crossVectors: function ( a, b ) {
    var ax = a.x, ay = a.y, az = a.z;
    var bx = b.x, by = b.y, bz = b.z;

    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;

    return this;
  },
};

MathUtil.Quaternion = function ( x, y, z, w ) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = ( w !== undefined ) ? w : 1;
};

MathUtil.Quaternion.prototype = {
  constructor: MathUtil.Quaternion,

  set: function ( x, y, z, w ) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;

    return this;
  },

  copy: function ( quaternion ) {
    this.x = quaternion.x;
    this.y = quaternion.y;
    this.z = quaternion.z;
    this.w = quaternion.w;

    return this;
  },

  setFromEulerXYZ: function( x, y, z ) {
    var c1 = Math.cos( x / 2 );
    var c2 = Math.cos( y / 2 );
    var c3 = Math.cos( z / 2 );
    var s1 = Math.sin( x / 2 );
    var s2 = Math.sin( y / 2 );
    var s3 = Math.sin( z / 2 );

    this.x = s1 * c2 * c3 + c1 * s2 * s3;
    this.y = c1 * s2 * c3 - s1 * c2 * s3;
    this.z = c1 * c2 * s3 + s1 * s2 * c3;
    this.w = c1 * c2 * c3 - s1 * s2 * s3;

    return this;
  },

  setFromEulerYXZ: function( x, y, z ) {
    var c1 = Math.cos( x / 2 );
    var c2 = Math.cos( y / 2 );
    var c3 = Math.cos( z / 2 );
    var s1 = Math.sin( x / 2 );
    var s2 = Math.sin( y / 2 );
    var s3 = Math.sin( z / 2 );

    this.x = s1 * c2 * c3 + c1 * s2 * s3;
    this.y = c1 * s2 * c3 - s1 * c2 * s3;
    this.z = c1 * c2 * s3 - s1 * s2 * c3;
    this.w = c1 * c2 * c3 + s1 * s2 * s3;

    return this;
  },

  setFromAxisAngle: function ( axis, angle ) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
    // assumes axis is normalized

    var halfAngle = angle / 2, s = Math.sin( halfAngle );

    this.x = axis.x * s;
    this.y = axis.y * s;
    this.z = axis.z * s;
    this.w = Math.cos( halfAngle );

    return this;
  },

  multiply: function ( q ) {
    return this.multiplyQuaternions( this, q );
  },

  multiplyQuaternions: function ( a, b ) {
    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

    var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
    var qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;

    this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    return this;
  },

  inverse: function () {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;

    this.normalize();

    return this;
  },

  normalize: function () {
    var l = Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

    if ( l === 0 ) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;
    } else {
      l = 1 / l;

      this.x = this.x * l;
      this.y = this.y * l;
      this.z = this.z * l;
      this.w = this.w * l;
    }

    return this;
  },

  slerp: function ( qb, t ) {
    if ( t === 0 ) return this;
    if ( t === 1 ) return this.copy( qb );

    var x = this.x, y = this.y, z = this.z, w = this.w;

    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;

    if ( cosHalfTheta < 0 ) {
      this.w = - qb.w;
      this.x = - qb.x;
      this.y = - qb.y;
      this.z = - qb.z;

      cosHalfTheta = - cosHalfTheta;
    } else {
      this.copy( qb );
    }

    if ( cosHalfTheta >= 1.0 ) {
      this.w = w;
      this.x = x;
      this.y = y;
      this.z = z;

      return this;
    }

    var halfTheta = Math.acos( cosHalfTheta );
    var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

    if ( Math.abs( sinHalfTheta ) < 0.001 ) {
      this.w = 0.5 * ( w + this.w );
      this.x = 0.5 * ( x + this.x );
      this.y = 0.5 * ( y + this.y );
      this.z = 0.5 * ( z + this.z );

      return this;
    }

    var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
    ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

    this.w = ( w * ratioA + this.w * ratioB );
    this.x = ( x * ratioA + this.x * ratioB );
    this.y = ( y * ratioA + this.y * ratioB );
    this.z = ( z * ratioA + this.z * ratioB );

    return this;
  },

  setFromUnitVectors: function () {
    // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
    // assumes direction vectors vFrom and vTo are normalized

    var v1, r;
    var EPS = 0.000001;

    return function ( vFrom, vTo ) {
      if ( v1 === undefined ) v1 = new MathUtil.Vector3();

      r = vFrom.dot( vTo ) + 1;

      if ( r < EPS ) {
        r = 0;

        if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
          v1.set( - vFrom.y, vFrom.x, 0 );
        } else {
          v1.set( 0, - vFrom.z, vFrom.y );
        }
      } else {
        v1.crossVectors( vFrom, vTo );
      }

      this.x = v1.x;
      this.y = v1.y;
      this.z = v1.z;
      this.w = r;

      this.normalize();

      return this;
    }
  }(),
};

module.exports = MathUtil;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _agent = __webpack_require__(3);

var _agent2 = _interopRequireDefault(_agent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WEBGL_ERROR_CODE = {
	"0": "NO_ERROR",
	"1280": "INVALID_ENUM",
	"1281": "INVALID_VALUE",
	"1282": "INVALID_OPERATION",
	"1285": "OUT_OF_MEMORY",
	"1286": "INVALID_FRAMEBUFFER_OPERATION",
	"37442": "CONTEXT_LOST_WEBGL"
};

var webglAvailability = null;

var WebGLUtils = function () {
	function WebGLUtils() {
		_classCallCheck(this, WebGLUtils);
	}

	WebGLUtils.createShader = function createShader(gl, type, source) {
		var shader = gl.createShader(type);

		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

		if (success) {
			return shader;
		}

		gl.deleteShader(shader);
		return null;
	};

	WebGLUtils.createProgram = function createProgram(gl, vertexShader, fragmentShader) {
		var program = gl.createProgram();

		gl.attachShader(program, vertexShader);
		gl.attachShader(program, fragmentShader);
		gl.linkProgram(program);
		var success = gl.getProgramParameter(program, gl.LINK_STATUS);

		if (success) {
			return program;
		}

		gl.deleteProgram(program);
		return null;
	};

	WebGLUtils.initBuffer = function initBuffer(gl, target /* bind point */, data, itemSize, attr) {
		var buffer = gl.createBuffer();

		gl.bindBuffer(target, buffer);
		gl.bufferData(target, data, gl.STATIC_DRAW);

		if (buffer) {
			buffer.itemSize = itemSize;
			buffer.numItems = data.length / itemSize;
		}

		if (attr !== undefined) {
			gl.enableVertexAttribArray(attr);
			gl.vertexAttribPointer(attr, buffer.itemSize, gl.FLOAT, false, 0, 0);
		}

		return buffer;
	};

	WebGLUtils.bindBufferToAttribute = function bindBufferToAttribute(gl, buffer, attr) {
		if (buffer === null || attr === null) {
			return;
		}

		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.vertexAttribPointer(attr, buffer.itemSize, gl.FLOAT, false, 0, 0);
	};

	WebGLUtils.getWebglContext = function getWebglContext(canvas, userContextAttributes) {
		var webglIdentifiers = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
		var context = null;
		var contextAttributes = _extends({
			preserveDrawingBuffer: false,
			antialias: false
		}, userContextAttributes);

		function onWebglcontextcreationerror(e) {
			return e.statusMessage;
		}

		canvas.addEventListener("webglcontextcreationerror", onWebglcontextcreationerror);

		for (var i = 0; i < webglIdentifiers.length; i++) {
			try {
				context = canvas.getContext(webglIdentifiers[i], contextAttributes);
			} catch (t) {}
			if (context) {
				break;
			}
		}

		canvas.removeEventListener("webglcontextcreationerror", onWebglcontextcreationerror);

		return context;
	};

	WebGLUtils.createTexture = function createTexture(gl, textureTarget) {
		var texture = gl.createTexture();

		gl.bindTexture(textureTarget, texture);
		gl.texParameteri(textureTarget, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(textureTarget, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(textureTarget, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(textureTarget, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.bindTexture(textureTarget, null);

		return texture;
	};

	/**
  * Returns the webgl availability of the current browser.
  * @method WebGLUtils#isWebGLAvailable
  * @retuen {Boolean} isWebGLAvailable
  */


	WebGLUtils.isWebGLAvailable = function isWebGLAvailable() {
		if (webglAvailability === null) {
			var canvas = document.createElement("canvas");
			var webglContext = WebGLUtils.getWebglContext(canvas);

			webglAvailability = !!webglContext;

			// webglContext Resource forced collection
			if (webglContext) {
				var loseContextExtension = webglContext.getExtension("WEBGL_lose_context");

				loseContextExtension && loseContextExtension.loseContext();
			}
		}
		return webglAvailability;
	};

	/**
  * Returns whether webgl is stable in the current browser.
  * @method WebGLUtils#isStableWebGL
  * @retuen {Boolean} isStableWebGL
  */


	WebGLUtils.isStableWebGL = function isStableWebGL() {
		var agentInfo = (0, _agent2["default"])();
		var isStableWebgl = true;

		if (agentInfo.os.name === "android" && parseFloat(agentInfo.os.version) <= 4.3) {
			isStableWebgl = false;
		} else if (agentInfo.os.name === "android" && parseFloat(agentInfo.os.version) === 4.4) {
			if (agentInfo.browser.name !== "chrome") {
				isStableWebgl = false;
			}
		}
		return isStableWebgl;
	};

	WebGLUtils.getErrorNameFromWebGLErrorCode = function getErrorNameFromWebGLErrorCode(code) {
		if (!(code in WEBGL_ERROR_CODE)) {
			return "UNKNOWN_ERROR";
		}

		return WEBGL_ERROR_CODE[code];
	};

	return WebGLUtils;
}();

exports["default"] = WebGLUtils;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var CONTROL_MODE_VR = 1;
var CONTROL_MODE_YAWPITCH = 2;

var TOUCH_DIRECTION_NONE = 1;
var TOUCH_DIRECTION_YAW = 2;
var TOUCH_DIRECTION_PITCH = 4;
var TOUCH_DIRECTION_ALL = TOUCH_DIRECTION_YAW | TOUCH_DIRECTION_PITCH;

/* Const for MovableCoord */
var MC_DECELERATION = 0.0014;
var MC_MAXIMUM_DURATION = 1000;
var MC_BIND_SCALE = [0.20, 0.20];

var MIN_FIELD_OF_VIEW = 20;
var MAX_FIELD_OF_VIEW = 110;
var PAN_SCALE = 320;

// const DELTA_THRESHOLD = 0.015;
// const DELTA_THRESHOLD = 0.09; // Note4
// const DELTA_THRESHOLD = 0.0825;
// const DELTA_THRESHOLD = 0.075;
// const DELTA_THRESHOLD = 0.06;
// const DELTA_THRESHOLD = 0.045;
var DELTA_THRESHOLD = 0.0375; // Note2

var YAW_RANGE_HALF = 180;
var PITCH_RANGE_HALF = 90;
var CIRCULAR_PITCH_RANGE_HALF = 180;
var PINCH_EVENTS = "pinchstart pinchmove pinchend";

var KEYMAP = {
	LEFT_ARROW: 37,
	A: 65,
	UP_ARROW: 38,
	W: 87,
	RIGHT_ARROW: 39,
	D: 68,
	DOWN_ARROW: 40,
	S: 83
};

var GYRO_MODE = {
	NONE: "none",
	YAWPITCH: "yawPitch",
	VR: "VR"
};

exports.GYRO_MODE = GYRO_MODE;
exports.CONTROL_MODE_VR = CONTROL_MODE_VR;
exports.CONTROL_MODE_YAWPITCH = CONTROL_MODE_YAWPITCH;
exports.TOUCH_DIRECTION_NONE = TOUCH_DIRECTION_NONE;
exports.TOUCH_DIRECTION_YAW = TOUCH_DIRECTION_YAW;
exports.TOUCH_DIRECTION_PITCH = TOUCH_DIRECTION_PITCH;
exports.TOUCH_DIRECTION_ALL = TOUCH_DIRECTION_ALL;
exports.MC_DECELERATION = MC_DECELERATION;
exports.MC_MAXIMUM_DURATION = MC_MAXIMUM_DURATION;
exports.MC_BIND_SCALE = MC_BIND_SCALE;
exports.MIN_FIELD_OF_VIEW = MIN_FIELD_OF_VIEW;
exports.MAX_FIELD_OF_VIEW = MAX_FIELD_OF_VIEW;
exports.PAN_SCALE = PAN_SCALE;
exports.DELTA_THRESHOLD = DELTA_THRESHOLD;
exports.YAW_RANGE_HALF = YAW_RANGE_HALF;
exports.PITCH_RANGE_HALF = PITCH_RANGE_HALF;
exports.CIRCULAR_PITCH_RANGE_HALF = CIRCULAR_PITCH_RANGE_HALF;
exports.PINCH_EVENTS = PINCH_EVENTS;
exports.KEYMAP = KEYMAP;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 10 */
/***/ (function(module, exports) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Util = window.Util || {};

Util.MIN_TIMESTEP = 0.001;
Util.MAX_TIMESTEP = 1;

Util.base64 = function(mimeType, base64) {
  return 'data:' + mimeType + ';base64,' + base64;
};

Util.clamp = function(value, min, max) {
  return Math.min(Math.max(min, value), max);
};

Util.lerp = function(a, b, t) {
  return a + ((b - a) * t);
};

/**
 * Light polyfill for `Promise.race`. Returns
 * a promise that resolves when the first promise
 * provided resolves.
 *
 * @param {Array<Promise>} promises
 */
Util.race = function(promises) {
  if (Promise.race) {
    return Promise.race(promises);
  }

  return new Promise(function (resolve, reject) {
    for (var i = 0; i < promises.length; i++) {
      promises[i].then(resolve, reject);
    }
  });
};

Util.isIOS = (function() {
  var isIOS = /iPad|iPhone|iPod/.test(navigator.platform);
  return function() {
    return isIOS;
  };
})();

Util.isWebViewAndroid = (function() {
  var isWebViewAndroid = navigator.userAgent.indexOf('Version') !== -1 &&
      navigator.userAgent.indexOf('Android') !== -1 &&
      navigator.userAgent.indexOf('Chrome') !== -1;
  return function() {
    return isWebViewAndroid;
  };
})();

Util.isSafari = (function() {
  var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  return function() {
    return isSafari;
  };
})();

Util.isFirefoxAndroid = (function() {
  var isFirefoxAndroid = navigator.userAgent.indexOf('Firefox') !== -1 &&
      navigator.userAgent.indexOf('Android') !== -1;
  return function() {
    return isFirefoxAndroid;
  };
})();

Util.isR7 = (function() {
  var isR7 = navigator.userAgent.indexOf('R7 Build') !== -1;
  return function() {
    return isR7;
  };
})();

Util.isLandscapeMode = function() {
  var rtn = (window.orientation == 90 || window.orientation == -90);
  return Util.isR7() ? !rtn : rtn;
};

// Helper method to validate the time steps of sensor timestamps.
Util.isTimestampDeltaValid = function(timestampDeltaS) {
  if (isNaN(timestampDeltaS)) {
    return false;
  }
  if (timestampDeltaS <= Util.MIN_TIMESTEP) {
    return false;
  }
  if (timestampDeltaS > Util.MAX_TIMESTEP) {
    return false;
  }
  return true;
};

Util.getScreenWidth = function() {
  return Math.max(window.screen.width, window.screen.height) *
      window.devicePixelRatio;
};

Util.getScreenHeight = function() {
  return Math.min(window.screen.width, window.screen.height) *
      window.devicePixelRatio;
};

Util.requestFullscreen = function(element) {
  if (Util.isWebViewAndroid()) {
      return false;
  }
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element.webkitRequestFullscreen) {
    element.webkitRequestFullscreen();
  } else if (element.mozRequestFullScreen) {
    element.mozRequestFullScreen();
  } else if (element.msRequestFullscreen) {
    element.msRequestFullscreen();
  } else {
    return false;
  }

  return true;
};

Util.exitFullscreen = function() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen();
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen();
  } else {
    return false;
  }

  return true;
};

Util.getFullscreenElement = function() {
  return document.fullscreenElement ||
      document.webkitFullscreenElement ||
      document.mozFullScreenElement ||
      document.msFullscreenElement;
};

Util.linkProgram = function(gl, vertexSource, fragmentSource, attribLocationMap) {
  // No error checking for brevity.
  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertexShader, vertexSource);
  gl.compileShader(vertexShader);

  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragmentShader, fragmentSource);
  gl.compileShader(fragmentShader);

  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);

  for (var attribName in attribLocationMap)
    gl.bindAttribLocation(program, attribLocationMap[attribName], attribName);

  gl.linkProgram(program);

  gl.deleteShader(vertexShader);
  gl.deleteShader(fragmentShader);

  return program;
};

Util.getProgramUniforms = function(gl, program) {
  var uniforms = {};
  var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  var uniformName = '';
  for (var i = 0; i < uniformCount; i++) {
    var uniformInfo = gl.getActiveUniform(program, i);
    uniformName = uniformInfo.name.replace('[0]', '');
    uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
  }
  return uniforms;
};

Util.orthoMatrix = function (out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right),
      bt = 1 / (bottom - top),
      nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
};

Util.copyArray = function (source, dest) {
  for (var i = 0, n = source.length; i < n; i++) {
    dest[i] = source[i];
  }
};

Util.isMobile = function() {
  var check = false;
  (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true})(navigator.userAgent||navigator.vendor||window.opera);
  return check;
};

Util.extend = function(dest, src) {
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      dest[key] = src[key];
    }
  }

  return dest;
}

Util.safariCssSizeWorkaround = function(canvas) {
  // TODO(smus): Remove this workaround when Safari for iOS is fixed.
  // iOS only workaround (for https://bugs.webkit.org/show_bug.cgi?id=152556).
  //
  // "To the last I grapple with thee;
  //  from hell's heart I stab at thee;
  //  for hate's sake I spit my last breath at thee."
  // -- Moby Dick, by Herman Melville
  if (Util.isIOS()) {
    var width = canvas.style.width;
    var height = canvas.style.height;
    canvas.style.width = (parseInt(width) + 1) + 'px';
    canvas.style.height = (parseInt(height)) + 'px';
    setTimeout(function() {
      canvas.style.width = width;
      canvas.style.height = height;
    }, 100);
  }

  // Debug only.
  window.Util = Util;
  window.canvas = canvas;
};

Util.isDebug = function() {
  return Util.getQueryParameter('debug');
};

Util.getQueryParameter = function(name) {
  var name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
  var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
      results = regex.exec(location.search);
  return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
};

Util.frameDataFromPose = (function() {
  var piOver180 = Math.PI / 180.0;
  var rad45 = Math.PI * 0.25;

  // Borrowed from glMatrix.
  function mat4_perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov ? (fov.upDegrees * piOver180) : rad45),
    downTan = Math.tan(fov ? (fov.downDegrees * piOver180) : rad45),
    leftTan = Math.tan(fov ? (fov.leftDegrees * piOver180) : rad45),
    rightTan = Math.tan(fov ? (fov.rightDegrees * piOver180) : rad45),
    xScale = 2.0 / (leftTan + rightTan),
    yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
  }

  function mat4_fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
  };

  function mat4_translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
      a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
      a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

      out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
      out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
      out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
  };

  function mat4_invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
  };

  var defaultOrientation = new Float32Array([0, 0, 0, 1]);
  var defaultPosition = new Float32Array([0, 0, 0]);

  function updateEyeMatrices(projection, view, pose, parameters, vrDisplay) {
    mat4_perspectiveFromFieldOfView(projection, parameters ? parameters.fieldOfView : null, vrDisplay.depthNear, vrDisplay.depthFar);

    var orientation = pose.orientation || defaultOrientation;
    var position = pose.position || defaultPosition;

    mat4_fromRotationTranslation(view, orientation, position);
    if (parameters)
      mat4_translate(view, view, parameters.offset);
    mat4_invert(view, view);
  }

  return function(frameData, pose, vrDisplay) {
    if (!frameData || !pose)
      return false;

    frameData.pose = pose;
    frameData.timestamp = pose.timestamp;

    updateEyeMatrices(
        frameData.leftProjectionMatrix, frameData.leftViewMatrix,
        pose, vrDisplay.getEyeParameters("left"), vrDisplay);
    updateEyeMatrices(
        frameData.rightProjectionMatrix, frameData.rightViewMatrix,
        pose, vrDisplay.getEyeParameters("right"), vrDisplay);

    return true;
  };
})();

Util.isInsideCrossDomainIFrame = function() {
  var isFramed = (window.self !== window.top);
  var refDomain = Util.getDomainFromUrl(document.referrer);
  var thisDomain = Util.getDomainFromUrl(window.location.href);

  return isFramed && (refDomain !== thisDomain);
};

// From http://stackoverflow.com/a/23945027.
Util.getDomainFromUrl = function(url) {
  var domain;
  // Find & remove protocol (http, ftp, etc.) and get domain.
  if (url.indexOf("://") > -1) {
    domain = url.split('/')[2];
  }
  else {
    domain = url.split('/')[0];
  }

  //find & remove port number
  domain = domain.split(':')[0];

  return domain;
}

module.exports = Util;


/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_11__;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Renderer = function Renderer() {
	_classCallCheck(this, Renderer);
};

exports["default"] = Renderer;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _consts = __webpack_require__(8);

/**
 * Constant value for errors
 * @ko 에러에 대한 상수 값
 * @namespace
 * @name ERROR_TYPE
 * @memberof eg.view360.PanoViewer
 */
var ERROR_TYPE = {
	/**
  * Unsupported device
  * @ko 미지원 기기
  * @name INVALID_DEVICE
  * @memberof eg.view360.PanoViewer.ERROR_TYPE
  * @constant
  * @type {Number}
  * @default 10
  */
	INVALID_DEVICE: 10,
	/**
  * Webgl not support
  * @ko WEBGL 미지원
  * @name NO_WEBGL
  * @memberof eg.view360.PanoViewer.ERROR_TYPE
  * @constant
  * @type {Number}
  * @default 11
  */
	NO_WEBGL: 11,
	/**
  * Failed to load image
  * @ko 이미지 로드 실패
  * @name FAIL_IMAGE_LOAD
  * @memberof eg.view360.PanoViewer.ERROR_TYPE
  * @constant
  * @type {Number}
  * @default 12
  */
	FAIL_IMAGE_LOAD: 12,
	/**
  * Failed to bind texture
  * @ko 텍스쳐 바인딩 실패
  * @name FAIL_BIND_TEXTURE
  * @memberof eg.view360.PanoViewer.ERROR_TYPE
  * @constant
  * @type {Number}
  * @default 13
  */
	FAIL_BIND_TEXTURE: 13,
	/**
  * Only one resource(image or video) should be specified
  * @ko 리소스 지정 오류 (image 혹은 video 중 하나만 지정되어야 함)
  * @name INVALID_RESOURCE
  * @memberof eg.view360.PanoViewer.ERROR_TYPE
  * @constant
  * @type {Number}
  * @default 14
  */
	INVALID_RESOURCE: 14,
	/**
  * WebGL context lost occurred
  * @ko WebGL context lost 발생
  * @name RENDERING_CONTEXT_LOST
  * @memberof eg.view360.PanoViewer.ERROR_TYPE
  * @constant
  * @type {Number}
  * @default 15
  */
	RENDERING_CONTEXT_LOST: 15
};

/**
 * Constant value for events
 * @ko 이벤트에 대한 상수 값
 * @namespace
 * @name EVENTS
 * @memberof eg.view360.PanoViewer
 */
/**
 * Constant value for gyro mode. <br>(Reference {@link https://github.com/naver/egjs-view360/wiki/PanoViewer-3.0-User-Guide})
 * @ko gyro 모드 대한 상수 값. <br>({@link https://github.com/naver/egjs-view360/wiki/PanoViewer-3.0-User-Guide} 참고)
 * @namespace
 * @name GYRO_MODE
 * @memberof eg.view360.PanoViewer
 */
/**
 * Disable gyro
 * @ko gyro 비활성화
 * @name NONE
 * @memberof eg.view360.PanoViewer.GYRO_MODE
 * @constant
 * @type {String}
 * @default "none"
 */
/**
 * YawPitch Mode
 * @ko YawPitch Mode
 * @name YAWPITCH
 * @memberof eg.view360.PanoViewer.GYRO_MODE
 * @constant
 * @type {String}
 * @default "yawPitch"
 */
/**
 * VR Mode
 * @ko VR Mode
 * @name VR
 * @memberof eg.view360.PanoViewer.GYRO_MODE
 * @constant
 * @type {String}
 * @default "VR"
 */
var EVENTS = {
	/**
  * Events that is fired when PanoViewer is ready to show image and handle user interaction.
  * @ko PanoViewer 가 사용자의 인터렉션 및 렌더링이 준비되상태에 발생하는 이벤트
  * @name READY
  * @memberof eg.view360.PanoViewer.EVENTS
  * @constant
  * @type {String}
  * @default ready
  */
	READY: "ready",
	/**
  * Events that is fired when direction or fov is changed.
  * @ko PanoViewer 에서 바라보고 있는 방향이나 FOV(화각)가 변경되었을때 발생하는 이벤트
  * @name VIEW_CHANGE
  * @memberof eg.view360.PanoViewer.EVENTS
  * @constant
  * @type {String}
  * @default viewChange
  */
	VIEW_CHANGE: "viewChange",
	/**
  * Events that is fired when animation which is triggered by inertia is ended.
  * @ko 관성에 의한 애니메이션 동작이 완료되었을때 발생하는 이벤트
  * @name ANIMATION_END
  * @memberof eg.view360.PanoViewer.EVENTS
  * @constant
  * @type {String}
  * @default animationEnd
  */
	ANIMATION_END: "animationEnd",
	/**
  * Events that is fired when error occurs
  * @ko 에러 발생 시 발생하는 이벤트
  * @name ERROR
  * @memberof eg.view360.PanoViewer.EVENTS
  * @constant
  * @type {String}
  * @default error
  */
	ERROR: "error"
};

/**
 * Constant value for projection type
 * @ko 프로젝션 타입 대한 상수 값
 * @namespace
 * @name PROJECTION_TYPE
 * @memberof eg.view360.PanoViewer
 */
var PROJECTION_TYPE = {
	/**
  * Constant value for equirectangular type.
  * @ko equirectangular 에 대한 상수 값.
  * @name EQUIRECTANGULAR
  * @memberof eg.view360.PanoViewer.PROJECTION_TYPE
  * @constant
  * @type {String}
  * @default equirectangular
  */
	EQUIRECTANGULAR: "equirectangular",
	/**
  * Constant value for cubemap type.
  * @ko cubemap 에 대한 상수 값.
  * @name CUBEMAP
  * @memberof eg.view360.PanoViewer.PROJECTION_TYPE
  * @constant
  * @type {String}
  * @default cubemap
  */
	CUBEMAP: "cubemap"
};

module.exports = {
	GYRO_MODE: _consts.GYRO_MODE,
	EVENTS: EVENTS,
	ERROR_TYPE: ERROR_TYPE,
	PROJECTION_TYPE: PROJECTION_TYPE
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class eg.view360.SpriteImage
 * @classdesc A module that displays a single or continuous image of any one of the "sprite images". SpinViewer internally uses SpriteImage to show each frame of the sprite image.
 * @ko 스프라이트 이미지 중 임의의 한 프레임을 단발성 혹은 연속적으로 보여주는 컴포넌트입니다. SpinViewer 는 내부적으로 SpriteImage 를 사용하여 스프라이트 이미지의 각 프레임을 보여줍니다.
 * @extends eg.Component
 *
 * @param {HTMLElement} element The element to show the image <ko>이미지를 보여줄 대상 요소</ko>
 * @param {Object} options The option object<ko>파라미터 객체</ko>
 * @param {String} options.imageUrl The url of the sprite image <ko>스프라이트 이미지의 url</ko>
 * @param {Number} [options.rowCount=1] Number of horizontal frames in the sprite image <ko>스프라이트 이미지의 가로 프레임 갯수</ko>
 * @param {Number} [options.colCount=1] Number of vertical frames in the sprite image <ko>스프라이트 이미지의 세로 프레임 갯수</ko>
 * @param {Number|String} [options.width="auto"] The width of the target element to show the image <ko>이미지를 보여줄 대상 요소의 너비</ko>
 * @param {Number|String} [options.height="auto"] The height of the target element to show the image <ko>이미지를 보여줄 대상 요소의 높이</ko>
 * @param {Boolean} [options.autoHeight=true] Whether to automatically set the height of the image area to match the original image's proportion <ko>원본 이미지 비율에 맞게 이미지 영역의 높이를 자동으로 설정할지 여부</ko>
 * @param {Number[]} [options.colRow=[0, 0]] The column, row coordinates of the first frame of the sprite image (based on 0 index) <ko> 스프라이트 이미지 중 처음 보여줄 프레임의 (column, row) 좌표 (0 index 기반)</ko>
 * @param {Number} [options.frameIndex=0] frameIndex specifies the index of the frame to be displayed in the "Sprite image". The frameIndex order is zero-based and indexed in Z form (left-to-right, top-to-bottom, and newline again from left to right).<br>- colRow is equivalent to frameIndex. However, if colRow is specified at the same time, colRow takes precedence.<ko>스프라이트 이미지 중에서 보여질 프레임의 인덱스를 지정합니다. frameIndex 순서는 0부터 시작하며 Z 형태(왼쪽에서 오른쪽, 위에서 아래, 개행 시 다시 왼쪽 부터)로 인덱싱합니다.<br>- colRow 는 frameIndex 와 동일한 기능을 합니다. 단, colRow 가 동시에 지정된 경우 colRow 가 우선합니다.</ko>
 * @param {Number} [options.scale=1] Spin scale (The larger the spin, the more).<ko>Spin 배율 (클 수록 더 많이 움직임)</ko>
 *
 * @support {"ie": "9+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.3+ (except 3.x)"}
 * @example
 *
 * // Initialize SpriteImage
 *
 * var el = document.getElementById("image-div");
 * var sprites = new eg.view360.SpriteImage(el, {
 * 	imageUrl: "/img/bag360.jpg", // required
 * 	rowCount: 24
 * });
 */
var SpriteImage = function (_Component) {
	_inherits(SpriteImage, _Component);

	function SpriteImage(element, options) {
		_classCallCheck(this, SpriteImage);

		var _this = _possibleConstructorReturn(this, _Component.call(this));

		var opt = options || {};

		_this._el = element;
		_this._rowCount = opt.rowCount || 1;
		_this._colCount = opt.colCount || 1;
		_this._totalCount = _this._rowCount * _this._colCount; // total frames
		_this._width = opt.width || "auto";
		_this._height = opt.height || "auto";
		_this._autoHeight = opt.autoHeight != null ? opt.autoHeight : "true"; // If autoHeight is specified, _height will be overwritten.
		_this._colRow = [0, 0];

		if (opt.colRow) {
			_this._colRow = opt.colRow;
		} else if (opt.frameIndex) {
			_this.setFrameIndex(opt.frameIndex);
		}

		_this._el.style.width = SpriteImage._getSizeString(_this._width);
		_this._el.style.height = SpriteImage._getSizeString(_this._height);

		if (!opt.imageUrl) {
			setTimeout(function () {
				_this.trigger("imageError", {
					imageUrl: opt.imageUrl
				});
			}, 0);
			return _possibleConstructorReturn(_this);
		}

		_this._image = new Image();
		/**
   * Event
   */
		_this._image.onload = function () {
			_this._bg = SpriteImage._createBgDiv(_this._image, _this._rowCount, _this._colCount, _this._autoHeight);
			_this._el.appendChild(_this._bg);
			_this.setColRow(_this._colRow[0], _this._colRow[1]);

			/**
    * Events that occur when component loading is complete
    * @ko 컴포넌트 로딩이 완료되면 발생하는 이벤트
    * @name eg.view360.SpriteImage#load
    * @event
    * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
    * @param {HTMLElement} param.target The target element for which to display the image <ko>이미지를 보여줄 대상 엘리먼트</ko>
    * @param {HTMLElement} param.bgElement Generated background image element <ko>생성된 background 이미지 엘리먼트</ko>
    *
    * @example
    *
    * sprites.on({
    *	"load" : function(evt) {
    *		console.log("load event fired - e.target", e.target, "e.bgElement", e.bgElement);
    *	}
    * });
    */
			_this.trigger("load", {
				target: _this._el,
				bgElement: _this._bg
			});

			if (_this._autoPlayReservedInfo) {
				_this.play(_this._autoPlayReservedInfo);
				_this._autoPlayReservedInfo = null;
			}
		};

		_this._image.onerror = function (e) {
			/**
    * An event that occurs when the image index is changed by the user's left / right panning
    * @ko 사용자의 좌우 Panning 에 의해 이미지 인덱스가 변경되었을때 발생하는 이벤트
    * @name eg.view360.SpriteImage#imageError
    * @event
    * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
    * @param {String} param.imageUrl User-specified image URL <ko>사용자가 지정한 이미지 URL</ko>
    *
    * @example
    *
    * sprites.on({
    *	"imageError" : function(evt) {
    *		// Error handling
    *		console.log(e.imageUrl);
    *	}
    * });
    */
			_this.trigger("imageError", {
				imageUrl: opt.imageUrl
			});
		};

		_this._image.src = opt.imageUrl;
		return _this;
	}

	SpriteImage._createBgDiv = function _createBgDiv(img, rowCount, colCount, autoHeight) {
		var el = document.createElement("div");

		el.style.backgroundImage = "url(" + img.src + ")";
		el.style.backgroundSize = colCount * 100 + "% " + rowCount * 100 + "%";

		var unitWidth = img.width / colCount;
		var unitHeight = img.height / rowCount;

		if (autoHeight) {
			var r = unitHeight / unitWidth;

			el.style.paddingBottom = r * 100 + "%";
		} else {
			el.style.height = "100%";
		}

		return el;
	};

	/**
  * Specifies the frameIndex of the frame to be shown in the sprite image.
  * @ko 스프라이트 이미지 중 보여질 프레임의 frameIndex 값을 지정
  * @method eg.view360.SpriteImage#setFrameIndex
  * @param {Number} frameIndex frame index of a frame<ko>프레임의 인덱스</ko>
  *
  * @example
  *
  * sprites.setFrameIndex(0, 1);// col = 0, row = 1
  */


	SpriteImage.prototype.setFrameIndex = function setFrameIndex(index) {
		var colRow = this.toColRow(index);

		this.setColRow(colRow[0], colRow[1]);
	};

	/**
  * Returns the frameIndex of the frame to be shown in the sprite image.
  * @ko 스프라이트 이미지 중 보여지는 프레임의 index 값을 반환
  * @method eg.view360.SpriteImage#getFrameIndex
  * @return {Number} frame index <ko>frame 인덱스</ko>
  *
  * @example
  *
  * var frameIndex = sprites.getFrameIndex(); // eg. frameIndex = 1
  *
  */


	SpriteImage.prototype.getFrameIndex = function getFrameIndex() {
		return this._colRow[1] * this._colCount + this._colRow[0];
	};

	/**
  * Specifies the col and row values of the frame to be shown in the sprite image.
  * @ko 스프라이트 이미지 중 보여질 프레임의 col, row 값을 지정
  * @method eg.view360.SpriteImage#setColRow
  * @param {Number} col Column number of a frame<ko>프레임의 행값</ko>
  * @param {Number} row Row number of a frame<ko>프레임의 열값</ko>
  *
  * @example
  *
  * sprites.setlColRow(1, 2); // col = 1, row = 2
  */


	SpriteImage.prototype.setColRow = function setColRow(col, row) {
		if (row > this._rowCount - 1 || col > this._colCount - 1) {
			return;
		}

		if (this._bg) {
			this._bg.style.backgroundPosition = -col * 100 + "% " + -row * 100 + "%";
		}

		this._colRow = [col, row];
	};

	/**
  * Returns the col and row values of the frame to be shown in the sprite image.
  * @ko 스프라이트 이미지 중 보여지는 프레임의 col, row 값을환반환
  * @method eg.view360.SpriteImage#gelColRow
  * @return {Number[]} Array containing col, row<ko>col, row 정보를 담는 배열</ko>
  *
  * @example
  *
  * var colRow = sprites.getlColRow();
  * // colRow = [1, 2] - index of col is 1, index of row is 2
  *
  */


	SpriteImage.prototype.getColRow = function getColRow() {
		return this._colRow;
	};

	SpriteImage._getSizeString = function _getSizeString(size) {
		if (typeof size === "number") {
			return size + "px";
		}

		return size;
	};

	/**
  * Stop playing
  * @ko play 되고 있던 프레임 재생을 중지합니다.
  * @method eg.view360.SpriteImage#stop
  *
  * @example
  *
  * viewer.stop();
  *
  */


	SpriteImage.prototype.stop = function stop() {
		if (this._autoPlayTimer) {
			clearInterval(this._autoPlayTimer);
			this._autoPlayTimer = null;
		}
	};

	/**
  * Switches frames sequentially in the 'interval' starting from the currently displayed frame and plays all frames by 'playCount'.
  * @ko 현재 보여지고 있는 프레임을 시작으로 'interval' 간격으로 순차적으로 프레임을 전환하며 모든 프레임을 'playCount' 만큼 재생한다.
  * @method eg.view360.SpriteImage#play
  * @param {Object} param The parameter object<ko>파라미터 객체</ko>
  * @param {Number} [param.interval=1000 / totalFrameCount] Interframe Interval - in milliseconds<ko>프레임간 간격 - 밀리세컨드 단위</ko>
  * @param {Number} [param.playCount=0] PlayCount = 1 in which all frames are reproduced once, and playCount = n in which all frames are repeated n times. playCount = 0 in which all frames are repeated infinitely<ko>모든 프레임을 1회씩 재생한 것이 playCount = 1, 모든 프레임을 n 회 재상한 것이 playCount = n 이 된다. 0 dms 무한반복</ko>
  *
  * @example
  *
  * viewer.play({angle: 16, playCount: 1});
  *
  */


	SpriteImage.prototype.play = function play() {
		var _this2 = this;

		var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { interval: 1000 / this._totalCount, playCount: 0 },
		    interval = _ref.interval,
		    playCount = _ref.playCount;

		if (!this._bg) {
			this._autoPlayReservedInfo = { interval: interval, playCount: playCount };
			return;
		}

		if (this._autoPlayTimer) {
			clearInterval(this._autoPlayTimer);
			this._autoPlayTimer = null;
		}

		var frameIndex = this.getFrameIndex();
		var count = 0;
		var frameCount = 0; // for checking 1 cycle

		this._autoPlayTimer = setInterval(function () {
			frameIndex %= _this2._totalCount;
			var colRow = _this2.toColRow(frameIndex);

			_this2.setColRow(colRow[0], colRow[1]);
			frameIndex++;

			// Done 1 Cycle?
			if (++frameCount === _this2._totalCount) {
				frameCount = 0;
				count++;
			}

			if (playCount > 0 && count === playCount) {
				clearInterval(_this2._autoPlayTimer);
			}
		}, interval);
	};

	SpriteImage.prototype.toColRow = function toColRow(frameIndex) {
		var colCount = this._colCount;
		var rowCount = this._rowCount;

		if (frameIndex < 0) {
			return [0, 0];
		} else if (frameIndex >= this._totalCount) {
			return [colCount - 1, rowCount - 1];
		}

		var col = frameIndex % colCount;
		var row = Math.floor(frameIndex / colCount);

		// console.log(frameIndex, col, row);
		return [col, row];
	};

	return SpriteImage;
}(_component2["default"]);

exports["default"] = SpriteImage;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _browser = __webpack_require__(4);

var _mathUtil = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Singleton
var screenRotationAngleInst = null;
var refCount = 0;

var ScreenRotationAngle = function () {
	function ScreenRotationAngle() {
		_classCallCheck(this, ScreenRotationAngle);

		refCount++;

		if (screenRotationAngleInst) {
			return screenRotationAngleInst;
		}
		/* eslint-disable */
		screenRotationAngleInst = this;
		/* eslint-enable */
		this._onDeviceOrientation = this._onDeviceOrientation.bind(this);
		this._onOrientationChange = this._onOrientationChange.bind(this);

		this._spinR = 0;

		this._screenOrientationAngle = 0;
		_browser.window.addEventListener("deviceorientation", this._onDeviceOrientation);
		_browser.window.addEventListener("orientationchange", this._onOrientationChange);
	}

	ScreenRotationAngle.prototype._onDeviceOrientation = function _onDeviceOrientation(e) {
		if (e.beta === null || e.gamma === null) {
			// (Chrome) deviceorientation is fired with invalid information {alpha=null, beta=null, ...} despite of not dispatching it. We skip it.
			return;
		}

		// Radian
		var betaR = _mathUtil.glMatrix.toRadian(e.beta);
		var gammaR = _mathUtil.glMatrix.toRadian(e.gamma);

		/* spinR range = [-180, 180], left side: 0 ~ -180(deg), right side: 0 ~ 180(deg) */
		this._spinR = Math.atan2(Math.cos(betaR) * Math.sin(gammaR), Math.sin(betaR));
	};

	ScreenRotationAngle.prototype._onOrientationChange = function _onOrientationChange(e) {
		if (_browser.window.screen && _browser.window.screen.orientation && _browser.window.screen.orientation.angle !== undefined) {
			this._screenOrientationAngle = screen.orientation.angle;
		} else if (_browser.window.orientation !== undefined) {
			/* iOS */
			this._screenOrientationAngle = _browser.window.orientation >= 0 ? _browser.window.orientation : 360 + _browser.window.orientation;
		}
	};

	ScreenRotationAngle.prototype.getRadian = function getRadian() {
		// Join with screen orientation
		// this._testVal = this._spinR + ", " + this._screenOrientationAngle + ", " + window.orientation;
		return this._spinR + _mathUtil.glMatrix.toRadian(this._screenOrientationAngle);
	};

	ScreenRotationAngle.prototype.unref = function unref() {
		if (--refCount > 0) {
			return;
		}

		_browser.window.removeEventListener("deviceorientation", this._onDeviceOrientation);
		_browser.window.removeEventListener("orientationchange", this._onOrientationChange);

		this._spinR = 0;
		this._screenOrientationAngle = 0;
		/* eslint-disable */
		screenRotationAngleInst = null;
		/* eslint-enable */
		refCount = 0;
	};

	return ScreenRotationAngle;
}();

exports["default"] = ScreenRotationAngle;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.YawPitchControl = undefined;

var _YawPitchControl = __webpack_require__(35);

var _YawPitchControl2 = _interopRequireDefault(_YawPitchControl);

var _consts = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// Expose DeviceOrientationControls sub module for test purpose
_YawPitchControl2["default"].CONTROL_MODE_VR = _consts.CONTROL_MODE_VR;
_YawPitchControl2["default"].CONTROL_MODE_YAWPITCH = _consts.CONTROL_MODE_YAWPITCH;
_YawPitchControl2["default"].TOUCH_DIRECTION_ALL = _consts.TOUCH_DIRECTION_ALL;
_YawPitchControl2["default"].TOUCH_DIRECTION_YAW = _consts.TOUCH_DIRECTION_YAW;
_YawPitchControl2["default"].TOUCH_DIRECTION_PITCH = _consts.TOUCH_DIRECTION_PITCH;
_YawPitchControl2["default"].TOUCH_DIRECTION_NONE = _consts.TOUCH_DIRECTION_NONE;

// module.exports = YawPitch;
exports.YawPitchControl = _YawPitchControl2["default"];

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

var _agent = __webpack_require__(3);

var _agent2 = _interopRequireDefault(_agent);

var _posePredictor = __webpack_require__(66);

var _posePredictor2 = _interopRequireDefault(_posePredictor);

var _mathUtil = __webpack_require__(6);

var _mathUtil2 = _interopRequireDefault(_mathUtil);

var _util = __webpack_require__(10);

var _util2 = _interopRequireDefault(_util);

var _browser = __webpack_require__(4);

var _mathUtil3 = __webpack_require__(1);

var _DeviceMotion = __webpack_require__(37);

var _DeviceMotion2 = _interopRequireDefault(_DeviceMotion);

var _ComplementaryFilter = __webpack_require__(36);

var _ComplementaryFilter2 = _interopRequireDefault(_ComplementaryFilter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var K_FILTER = 0.98;
var PREDICTION_TIME_S = 0.040;
var agentInfo = (0, _agent2["default"])();

var FusionPoseSensor = function (_Component) {
	_inherits(FusionPoseSensor, _Component);

	function FusionPoseSensor() {
		_classCallCheck(this, FusionPoseSensor);

		var _this = _possibleConstructorReturn(this, _Component.call(this));

		_this.deviceMotion = new _DeviceMotion2["default"]();

		_this.accelerometer = new _mathUtil2["default"].Vector3();
		_this.gyroscope = new _mathUtil2["default"].Vector3();

		_this._onDeviceMotionChange = _this._onDeviceMotionChange.bind(_this);
		_this._onScreenOrientationChange = _this._onScreenOrientationChange.bind(_this);

		_this.filter = new _ComplementaryFilter2["default"](K_FILTER);
		_this.posePredictor = new _posePredictor2["default"](PREDICTION_TIME_S);

		_this.filterToWorldQ = new _mathUtil2["default"].Quaternion();

		_this.isFirefoxAndroid = _util2["default"].isFirefoxAndroid();
		_this.isIOS = _util2["default"].isIOS();

		// Ref https://github.com/immersive-web/cardboard-vr-display/issues/18
		_this.isChromeUsingDegrees = agentInfo.browser.name === "chrome" && parseInt(agentInfo.browser.version, 10) >= 66;

		_this._isEnabled = false;

		// Set the filter to world transform, depending on OS.
		if (_this.isIOS) {
			_this.filterToWorldQ.setFromAxisAngle(new _mathUtil2["default"].Vector3(1, 0, 0), Math.PI / 2);
		} else {
			_this.filterToWorldQ.setFromAxisAngle(new _mathUtil2["default"].Vector3(1, 0, 0), -Math.PI / 2);
		}

		_this.inverseWorldToScreenQ = new _mathUtil2["default"].Quaternion();
		_this.worldToScreenQ = new _mathUtil2["default"].Quaternion();
		_this.originalPoseAdjustQ = new _mathUtil2["default"].Quaternion();
		_this.originalPoseAdjustQ.setFromAxisAngle(new _mathUtil2["default"].Vector3(0, 0, 1), -_browser.window.orientation * Math.PI / 180);

		_this._setScreenTransform();
		// Adjust this filter for being in landscape mode.
		if (_util2["default"].isLandscapeMode()) {
			_this.filterToWorldQ.multiply(_this.inverseWorldToScreenQ);
		}

		// Keep track of a reset transform for resetSensor.
		_this.resetQ = new _mathUtil2["default"].Quaternion();

		_this.deviceMotion.on("devicemotion", _this._onDeviceMotionChange);
		_this.enable();
		return _this;
	}

	FusionPoseSensor.prototype.enable = function enable() {
		if (this.isEnabled()) {
			return;
		}
		this.deviceMotion.enable();
		this._isEnabled = true;
		_browser.window.addEventListener("orientationchange", this._onScreenOrientationChange);
	};

	FusionPoseSensor.prototype.disable = function disable() {
		if (!this.isEnabled()) {
			return;
		}
		this.deviceMotion.disable();
		this._isEnabled = false;
		_browser.window.removeEventListener("orientationchange", this._onScreenOrientationChange);
	};

	FusionPoseSensor.prototype.isEnabled = function isEnabled() {
		return this._isEnabled;
	};

	FusionPoseSensor.prototype.destroy = function destroy() {
		this.disable();
		this.deviceMotion = null;
	};

	FusionPoseSensor.prototype._triggerChange = function _triggerChange() {
		var orientation = this.getOrientation();

		// if orientation is not prepared. don't trigger change event
		if (!orientation) {
			return;
		}

		if (!this._prevOrientation) {
			this._prevOrientation = orientation;
			return;
		}

		if (_mathUtil3.quat.equals(this._prevOrientation, orientation)) {
			return;
		}

		this.trigger("change", { quaternion: orientation });
	};

	FusionPoseSensor.prototype.getOrientation = function getOrientation() {
		var orientation = void 0;

		// Hack around using deviceorientation instead of devicemotion
		if (this.deviceMotion.isWithoutDeviceMotion && this._deviceOrientationQ) {
			this.deviceOrientationFixQ = this.deviceOrientationFixQ || function () {
				var y = new _mathUtil2["default"].Quaternion().setFromAxisAngle(new _mathUtil2["default"].Vector3(0, 1, 0), -this._alpha);

				return y;
			}.bind(this)();

			orientation = this._deviceOrientationQ;
			var out = new _mathUtil2["default"].Quaternion();

			out.copy(orientation);
			out.multiply(this.filterToWorldQ);
			out.multiply(this.resetQ);
			out.multiply(this.worldToScreenQ);
			out.multiplyQuaternions(this.deviceOrientationFixQ, out);

			// return quaternion as glmatrix quaternion object
			var out_ = _mathUtil3.quat.fromValues(out.x, out.y, out.z, out.w);

			return _mathUtil3.quat.normalize(out_, out_);
		} else {
			// Convert from filter space to the the same system used by the
			// deviceorientation event.
			orientation = this.filter.getOrientation();

			if (!orientation) {
				return null;
			}

			var _out = this._convertFusionToPredicted(orientation);

			// return quaternion as glmatrix quaternion object
			var _out_ = _mathUtil3.quat.fromValues(_out.x, _out.y, _out.z, _out.w);

			return _mathUtil3.quat.normalize(_out_, _out_);
		}
	};

	FusionPoseSensor.prototype._convertFusionToPredicted = function _convertFusionToPredicted(orientation) {
		// Predict orientation.
		this.predictedQ = this.posePredictor.getPrediction(orientation, this.gyroscope, this.previousTimestampS);

		// Convert to THREE coordinate system: -Z forward, Y up, X right.
		var out = new _mathUtil2["default"].Quaternion();

		out.copy(this.filterToWorldQ);
		out.multiply(this.resetQ);
		out.multiply(this.predictedQ);
		out.multiply(this.worldToScreenQ);

		return out;
	};

	FusionPoseSensor.prototype._onDeviceMotionChange = function _onDeviceMotionChange(_ref) {
		var inputEvent = _ref.inputEvent;

		var deviceorientation = inputEvent.deviceorientation;
		var deviceMotion = inputEvent;
		var accGravity = deviceMotion.accelerationIncludingGravity;
		var rotRate = deviceMotion.adjustedRotationRate || deviceMotion.rotationRate;
		var timestampS = deviceMotion.timeStamp / 1000;

		if (deviceorientation) {
			if (!this._alpha) {
				this._alpha = deviceorientation.alpha;
			}
			this._deviceOrientationQ = this._deviceOrientationQ || new _mathUtil2["default"].Quaternion();
			this._deviceOrientationQ.setFromEulerYXZ(deviceorientation.beta, deviceorientation.alpha, deviceorientation.gamma);

			this._triggerChange();
		} else {
			// Firefox Android timeStamp returns one thousandth of a millisecond.
			if (this.isFirefoxAndroid) {
				timestampS /= 1000;
			}

			this.accelerometer.set(-accGravity.x, -accGravity.y, -accGravity.z);
			this.gyroscope.set(rotRate.alpha, rotRate.beta, rotRate.gamma);

			// Browsers on iOS, Firefox/Android, and Chrome m66/Android `rotationRate`
			// is reported in degrees, so we first convert to radians.
			if (this.isIOS || this.isFirefoxAndroid || this.isChromeUsingDegrees) {
				this.gyroscope.multiplyScalar(Math.PI / 180);
			}

			this.filter.addAccelMeasurement(this.accelerometer, timestampS);
			this.filter.addGyroMeasurement(this.gyroscope, timestampS);

			this._triggerChange();

			this.previousTimestampS = timestampS;
		}
	};

	FusionPoseSensor.prototype._onScreenOrientationChange = function _onScreenOrientationChange(screenOrientation) {
		this._setScreenTransform(_browser.window.orientation);
	};

	FusionPoseSensor.prototype._setScreenTransform = function _setScreenTransform() {
		this.worldToScreenQ.set(0, 0, 0, 1);
		switch (_browser.window.orientation) {
			case 0:
				break;
			case 90:
				this.worldToScreenQ.setFromAxisAngle(new _mathUtil2["default"].Vector3(0, 0, 1), 90 / -180 * Math.PI);
				break;
			case -90:
				this.worldToScreenQ.setFromAxisAngle(new _mathUtil2["default"].Vector3(0, 0, 1), -90 / -180 * Math.PI);
				break;
			case 180:
				this.worldToScreenQ.setFromAxisAngle(new _mathUtil2["default"].Vector3(0, 0, 1), 180 / -180 * Math.PI);
				break;
			default:
				break;
		}
		this.inverseWorldToScreenQ.copy(this.worldToScreenQ);
		this.inverseWorldToScreenQ.inverse();
	};

	return FusionPoseSensor;
}(_component2["default"]);

exports["default"] = FusionPoseSensor;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var util = {};

function toAxis(source, offset) {
	return offset.reduce(function (acc, v, i) {
		if (source[i]) {
			acc[source[i]] = v;
		}
		return acc;
	}, {});
}

util.toAxis = toAxis;

exports["default"] = util;
exports.toAxis = toAxis;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];

var alphaIndex = {};
var charIndex = {};

createIndexes(alphaIndex, charIndex);

/**
 * @constructor
 */
function Html5Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1) === 'x' ?
                parseInt(entity.substr(2).toLowerCase(), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.decode = function(str) {
    return new Html5Entities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var charInfo = charIndex[str.charCodeAt(i)];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        result += str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encode = function(str) {
    return new Html5Entities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var charInfo = charIndex[c];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonUTF = function(str) {
    return new Html5Entities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonASCII = function(str) {
    return new Html5Entities().encodeNonASCII(str);
 };

/**
 * @param {Object} alphaIndex Passed by reference.
 * @param {Object} charIndex Passed by reference.
 */
function createIndexes(alphaIndex, charIndex) {
    var i = ENTITIES.length;
    var _results = [];
    while (i--) {
        var e = ENTITIES[i];
        var alpha = e[0];
        var chars = e[1];
        var chr = chars[0];
        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo;
        if (addChar) {
            charInfo = charIndex[chr] = charIndex[chr] || {};
        }
        if (chars[1]) {
            var chr2 = chars[1];
            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
            _results.push(addChar && (charInfo[chr2] = alpha));
        } else {
            alphaIndex[alpha] = String.fromCharCode(chr);
            _results.push(addChar && (charInfo[''] = alpha));
        }
    }
}

module.exports = Html5Entities;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.VERSION = exports.SpriteImage = exports.SpinViewer = exports.PanoViewer = exports.YawPitchControl = undefined;

var _YawPitchControl = __webpack_require__(16);

var _PanoViewer = __webpack_require__(31);

var _SpinViewer = __webpack_require__(33);

var VERSION = "3.0.0-rc";

exports.YawPitchControl = _YawPitchControl.YawPitchControl;
exports.PanoViewer = _PanoViewer.PanoViewer;
exports.SpinViewer = _SpinViewer.SpinViewer;
exports.SpriteImage = _SpinViewer.SpriteImage;
exports.VERSION = VERSION;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__resourceQuery) {

/* global __resourceQuery WorkerGlobalScope self */
/* eslint prefer-destructuring: off */

var url = __webpack_require__(59);
var stripAnsi = __webpack_require__(58);
var log = __webpack_require__(51).getLogger('webpack-dev-server');
var socket = __webpack_require__(62);
var overlay = __webpack_require__(61);

function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute('src');
  }
  // Fall back to getting all scripts in the document.
  var scriptElements = document.scripts || [];
  var currentScript = scriptElements[scriptElements.length - 1];
  if (currentScript) {
    return currentScript.getAttribute('src');
  }
  // Fail as there was no script to use.
  throw new Error('[WDS] Failed to get current script source.');
}

var urlParts = void 0;
var hotReload = true;
if (typeof window !== 'undefined') {
  var qs = window.location.search.toLowerCase();
  hotReload = qs.indexOf('hotreload=false') === -1;
}
if (true) {
  // If this bundle is inlined, use the resource query to get the correct url.
  urlParts = url.parse(__resourceQuery.substr(1));
} else {
  // Else, get the url from the <script> this file was called with.
  var scriptHost = getCurrentScriptSource();
  // eslint-disable-next-line no-useless-escape
  scriptHost = scriptHost.replace(/\/[^\/]+$/, '');
  urlParts = url.parse(scriptHost || '/', false, true);
}

if (!urlParts.port || urlParts.port === '0') {
  urlParts.port = self.location.port;
}

var _hot = false;
var initial = true;
var currentHash = '';
var useWarningOverlay = false;
var useErrorOverlay = false;
var useProgress = false;

var INFO = 'info';
var WARNING = 'warning';
var ERROR = 'error';
var NONE = 'none';

// Set the default log level
log.setDefaultLevel(INFO);

// Send messages to the outside, so plugins can consume it.
function sendMsg(type, data) {
  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: 'webpack' + type,
      data: data
    }, '*');
  }
}

var onSocketMsg = {
  hot: function hot() {
    _hot = true;
    log.info('[WDS] Hot Module Replacement enabled.');
  },
  invalid: function invalid() {
    log.info('[WDS] App updated. Recompiling...');
    // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.
    if (useWarningOverlay || useErrorOverlay) overlay.clear();
    sendMsg('Invalid');
  },
  hash: function hash(_hash) {
    currentHash = _hash;
  },

  'still-ok': function stillOk() {
    log.info('[WDS] Nothing changed.');
    if (useWarningOverlay || useErrorOverlay) overlay.clear();
    sendMsg('StillOk');
  },
  'log-level': function logLevel(level) {
    var hotCtx = __webpack_require__(68);
    if (hotCtx.keys().indexOf('./log') !== -1) {
      hotCtx('./log').setLogLevel(level);
    }
    switch (level) {
      case INFO:
      case ERROR:
        log.setLevel(level);
        break;
      case WARNING:
        // loglevel's warning name is different from webpack's
        log.setLevel('warn');
        break;
      case NONE:
        log.disableAll();
        break;
      default:
        log.error('[WDS] Unknown clientLogLevel \'' + level + '\'');
    }
  },
  overlay: function overlay(value) {
    if (typeof document !== 'undefined') {
      if (typeof value === 'boolean') {
        useWarningOverlay = false;
        useErrorOverlay = value;
      } else if (value) {
        useWarningOverlay = value.warnings;
        useErrorOverlay = value.errors;
      }
    }
  },
  progress: function progress(_progress) {
    if (typeof document !== 'undefined') {
      useProgress = _progress;
    }
  },

  'progress-update': function progressUpdate(data) {
    if (useProgress) log.info('[WDS] ' + data.percent + '% - ' + data.msg + '.');
  },
  ok: function ok() {
    sendMsg('Ok');
    if (useWarningOverlay || useErrorOverlay) overlay.clear();
    if (initial) return initial = false; // eslint-disable-line no-return-assign
    reloadApp();
  },

  'content-changed': function contentChanged() {
    log.info('[WDS] Content base changed. Reloading...');
    self.location.reload();
  },
  warnings: function warnings(_warnings) {
    log.warn('[WDS] Warnings while compiling.');
    var strippedWarnings = _warnings.map(function (warning) {
      return stripAnsi(warning);
    });
    sendMsg('Warnings', strippedWarnings);
    for (var i = 0; i < strippedWarnings.length; i++) {
      log.warn(strippedWarnings[i]);
    }
    if (useWarningOverlay) overlay.showMessage(_warnings);

    if (initial) return initial = false; // eslint-disable-line no-return-assign
    reloadApp();
  },
  errors: function errors(_errors) {
    log.error('[WDS] Errors while compiling. Reload prevented.');
    var strippedErrors = _errors.map(function (error) {
      return stripAnsi(error);
    });
    sendMsg('Errors', strippedErrors);
    for (var i = 0; i < strippedErrors.length; i++) {
      log.error(strippedErrors[i]);
    }
    if (useErrorOverlay) overlay.showMessage(_errors);
  },
  error: function error(_error) {
    log.error(_error);
  },
  close: function close() {
    log.error('[WDS] Disconnected!');
    sendMsg('Close');
  }
};

var hostname = urlParts.hostname;
var protocol = urlParts.protocol;

// check ipv4 and ipv6 `all hostname`
if (hostname === '0.0.0.0' || hostname === '::') {
  // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384
  // eslint-disable-next-line no-bitwise
  if (self.location.hostname && !!~self.location.protocol.indexOf('http')) {
    hostname = self.location.hostname;
  }
}

// `hostname` can be empty when the script path is relative. In that case, specifying
// a protocol would result in an invalid URL.
// When https is used in the app, secure websockets are always necessary
// because the browser doesn't accept non-secure websockets.
if (hostname && (self.location.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {
  protocol = self.location.protocol;
}

var socketUrl = url.format({
  protocol: protocol,
  auth: urlParts.auth,
  hostname: hostname,
  port: urlParts.port,
  pathname: urlParts.path == null || urlParts.path === '/' ? '/sockjs-node' : urlParts.path
});

socket(socketUrl, onSocketMsg);

var isUnloading = false;
self.addEventListener('beforeunload', function () {
  isUnloading = true;
});

function reloadApp() {
  if (isUnloading || !hotReload) {
    return;
  }
  if (_hot) {
    log.info('[WDS] App hot update...');
    // eslint-disable-next-line global-require
    var hotEmitter = __webpack_require__(64);
    hotEmitter.emit('webpackHotUpdate', currentHash);
    if (typeof self !== 'undefined' && self.window) {
      // broadcast update to window
      self.postMessage('webpackHotUpdate' + currentHash, '*');
    }
  } else {
    var rootWindow = self;
    // use parent window for reload (in case we're in an iframe with no valid src)
    var intervalId = self.setInterval(function () {
      if (rootWindow.location.protocol !== 'about:') {
        // reload immediately if protocol is valid
        applyReload(rootWindow, intervalId);
      } else {
        rootWindow = rootWindow.parent;
        if (rootWindow.parent === rootWindow) {
          // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
          applyReload(rootWindow, intervalId);
        }
      }
    });
  }

  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    log.info('[WDS] App updated. Reloading...');
    rootWindow.location.reload();
  }
}
/* WEBPACK VAR INJECTION */}.call(exports, "?http://localhost:8080"))

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Promise = typeof Promise === 'undefined' ? __webpack_require__(5).Promise : Promise;

var STATUS = {
	"NONE": 0,
	"LOADING": 1,
	"LOADED": 2,
	"ERROR": 3
};

var EVENT = {
	"READYSTATECHANGE": "readystatechange"
};

var ImageLoader = function (_Component) {
	_inherits(ImageLoader, _Component);

	function ImageLoader(image) {
		_classCallCheck(this, ImageLoader);

		var _this = _possibleConstructorReturn(this, _Component.call(this));
		// Super constructor


		_this._image = null;
		_this._onceHandlers = [];
		_this._loadStatus = STATUS.NONE;

		image && _this.set(image);
		return _this;
	}

	ImageLoader.prototype.get = function get() {
		var _this2 = this;

		return new _Promise(function (res, rej) {
			if (!_this2._image) {
				rej("ImageLoader: image is not defiend");
			} else if (_this2._loadStatus === STATUS.LOADED) {
				res(_this2.getElement());
			} else if (_this2._loadStatus === STATUS.LOADING) {
				/* Check isMaybeLoaded() first because there may have
    	posibilities that image already loaded before get is called.
    	for example calling get on external image onload callback.*/
				if (ImageLoader.isMaybeLoaded(_this2._image)) {
					_this2._loadStatus = STATUS.LOADED;
					res(_this2.getElement());
				} else {
					_this2.on(EVENT.READYSTATECHANGE, function (e) {
						if (e.type === STATUS.LOADED) {
							res(_this2.getElement());
						} else {
							rej("ImageLoader: failed to load images.");
						}
					});
				}
			} else {
				rej("ImageLoader: failed to load images");
			}
		});
	};

	/**
  * @param image img element or img url or array of img element or array of img url
  */


	ImageLoader.prototype.set = function set(image) {
		var _this3 = this;

		this._loadStatus = STATUS.LOADING;

		this._image = ImageLoader.createElement(image);

		if (ImageLoader.isMaybeLoaded(this._image)) {
			this._loadStatus = STATUS.LOADED;
			return;
		}

		this.onceLoaded(this._image, function () {
			_this3._loadStatus = STATUS.LOADED;
			_this3.trigger(EVENT.READYSTATECHANGE, {
				type: STATUS.LOADED
			});
		}, function () {
			_this3._loadStatus = STATUS.ERROR;
			_this3.trigger(EVENT.READYSTATECHANGE, {
				type: STATUS.ERROR
			});
		});
	};

	ImageLoader.createElement = function createElement(image) {
		var images = image instanceof Array ? image : [image];

		return images.map(function (img) {
			var _img = img;

			if (typeof img === "string") {
				_img = new Image();
				_img.crossOrigin = "anonymous";
				_img.src = img;
			}
			return _img;
		});
	};

	ImageLoader.prototype.getElement = function getElement() {
		return this._image.length === 1 ? this._image[0] : this._image;
	};

	ImageLoader.isMaybeLoaded = function isMaybeLoaded(image) {
		return image instanceof Image ? image.complete && image.naturalWidth !== 0 : !image.some(function (img) {
			return !img.complete || img.naturalWidth === 0;
		});
	};

	ImageLoader.prototype.onceLoaded = function onceLoaded(target, onload, onerror) {
		var _this4 = this;

		var targets = target instanceof Array ? target : [target];
		var targetsNotLoaded = targets.filter(function (img) {
			return !ImageLoader.isMaybeLoaded(img);
		});
		var loadPromises = targetsNotLoaded.map(function (img) {
			return new _Promise(function (res, rej) {
				_this4._once(img, "load", function () {
					return res(img);
				});
				_this4._once(img, "error", function () {
					return rej(img);
				});
			});
		});

		_Promise.all(loadPromises).then(function (result) {
			return onload(targets.length === 1 ? targets[0] : targets);
		}, function (reason) {
			return onerror(reason);
		});
	};

	ImageLoader.prototype._once = function _once(target, type, listener) {
		var fn = function fn(event) {
			target.removeEventListener(type, fn);
			listener(event);
		};

		target.addEventListener(type, fn);
		this._onceHandlers.push({ target: target, type: type, fn: fn });
	};

	ImageLoader.prototype.getStatus = function getStatus() {
		return this._loadStatus;
	};

	ImageLoader.prototype.destroy = function destroy() {
		this._onceHandlers.forEach(function (handler) {
			handler.target.removeEventListener(handler.type, handler.fn);
		});
		this._onceHandlers = [];
		this._image.src = "";
		this._image = null;
		this._loadStatus = STATUS.NONE;
	};

	return ImageLoader;
}(_component2["default"]);

exports["default"] = ImageLoader;


ImageLoader.STATUS = STATUS;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

var _ImageLoader = __webpack_require__(22);

var _ImageLoader2 = _interopRequireDefault(_ImageLoader);

var _VideoLoader = __webpack_require__(24);

var _VideoLoader2 = _interopRequireDefault(_VideoLoader);

var _WebGLUtils = __webpack_require__(7);

var _WebGLUtils2 = _interopRequireDefault(_WebGLUtils);

var _CubeRenderer = __webpack_require__(27);

var _CubeRenderer2 = _interopRequireDefault(_CubeRenderer);

var _SphereRenderer = __webpack_require__(28);

var _SphereRenderer2 = _interopRequireDefault(_SphereRenderer);

var _mathUtil = __webpack_require__(1);

var _browser = __webpack_require__(25);

var _consts = __webpack_require__(13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Promise = typeof Promise === 'undefined' ? __webpack_require__(5).Promise : Promise;

var ImageType = _consts.PROJECTION_TYPE;

var DEVICE_PIXEL_RATIO = _browser.devicePixelRatio || 1;

// DEVICE_PIXEL_RATIO 가 2를 초과하는 경우는 리소스 낭비이므로 2로 맞춘다.
if (DEVICE_PIXEL_RATIO > 2) {
	DEVICE_PIXEL_RATIO = 2;
}

// define custom events name
/**
 * TODO: how to manage events/errortype with PanoViewer
 *
 * I think renderer events should be seperated from viewer events although it has same name.
 */
var EVENTS = {
	BIND_TEXTURE: "bindTexture",
	IMAGE_LOADED: "imageLoaded",
	ERROR: "error",
	RENDERING_CONTEXT_LOST: "renderingContextLost",
	RENDERING_CONTEXT_RESTORE: "renderingContextRestore"
};

var ERROR_TYPE = {
	INVALID_DEVICE: 10,
	NO_WEBGL: 11,
	FAIL_IMAGE_LOAD: 12
};

var PanoImageRenderer = function (_Component) {
	_inherits(PanoImageRenderer, _Component);

	function PanoImageRenderer(image, width, height, isVideo, sphericalConfig, renderingContextAttributes) {
		_classCallCheck(this, PanoImageRenderer);

		var _this = _possibleConstructorReturn(this, _Component.call(this));
		// Super constructor


		_this.sphericalConfig = sphericalConfig;
		_this.fieldOfView = sphericalConfig.fieldOfView;

		_this.width = width;
		_this.height = height;

		_this._lastQuaternion = null;
		_this._lastYaw = null;
		_this._lastPitch = null;
		_this._lastFieldOfView = null;

		_this.pMatrix = _mathUtil.mat4.create();
		_this.mvMatrix = _mathUtil.mat4.create();

		// initialzie pMatrix
		_mathUtil.mat4.perspective(_this.pMatrix, _mathUtil.glMatrix.toRadian(_this.fieldOfView), width / height, 0.1, 100);

		_this.textureCoordBuffer = null;
		_this.vertexBuffer = null;
		_this.indexBuffer = null;
		_this.canvas = _this._initCanvas(width, height);
		_this._renderingContextAttributes = renderingContextAttributes;
		_this._image = null;
		_this._imageConfig = null;
		_this._imageIsReady = false;
		_this._shouldForceDraw = false;
		_this._keepUpdate = false; // Flag to specify 'continuous update' on video even when still.

		_this._onContentLoad = _this._onContentLoad.bind(_this);
		_this._onContentError = _this._onContentError.bind(_this);

		if (image) {
			_this.setImage({
				image: image,
				imageType: sphericalConfig.imageType,
				isVideo: isVideo,
				cubemapConfig: sphericalConfig.cubemapConfig
			});
		}
		return _this;
	}

	PanoImageRenderer.prototype.getContent = function getContent() {
		return this._image;
	};

	PanoImageRenderer.prototype.setImage = function setImage(_ref) {
		var image = _ref.image,
		    imageType = _ref.imageType,
		    _ref$isVideo = _ref.isVideo,
		    isVideo = _ref$isVideo === undefined ? false : _ref$isVideo,
		    cubemapConfig = _ref.cubemapConfig;

		this._imageIsReady = false;
		this._isVideo = isVideo;
		this._imageConfig = _extends({
			order: "RLUDBF",
			tileConfig: {
				flipHirozontal: false,
				rotation: 0
			}
		}, cubemapConfig);
		this._setImageType(imageType);

		if (this._contentLoader) {
			this._contentLoader.destroy();
		}

		if (isVideo) {
			this._contentLoader = new _VideoLoader2["default"]();
			this._keepUpdate = true;
		} else {
			this._contentLoader = new _ImageLoader2["default"]();
			this._keepUpdate = false;
		}

		// img element or img url
		this._contentLoader.set(image);

		// 이미지의 사이즈를 캐시한다.
		// image is reference for content in contentLoader, so it may be not valid if contentLoader is destroyed.
		this._image = this._contentLoader.getElement();

		return this._contentLoader.get().then(this._onContentLoad, this._onContentError)["catch"](function (e) {
			return setTimeout(function () {
				throw e;
			});
		}); // Prevent exceptions from being isolated in promise chain.
	};

	PanoImageRenderer.prototype._setImageType = function _setImageType(imageType) {
		if (!imageType || this._imageType === imageType) {
			return;
		}

		this._imageType = imageType;
		this._isCubeMap = imageType === ImageType.CUBEMAP;
		this._renderer = this._isCubeMap ? _CubeRenderer2["default"] : _SphereRenderer2["default"];
		this._initWebGL();
	};

	PanoImageRenderer.prototype._initCanvas = function _initCanvas(width, height) {
		var canvas = document.createElement("canvas");

		canvas.width = width;
		canvas.height = height;
		canvas.style.bottom = 0;
		canvas.style.left = 0;
		canvas.style.right = 0;
		canvas.style.top = 0;
		canvas.style.margin = "auto";
		canvas.style.maxHeight = "100%";
		canvas.style.maxWidth = "100%";
		canvas.style.outline = "none";
		canvas.style.position = "absolute";

		this._onWebglcontextlost = this._onWebglcontextlost.bind(this);
		this._onWebglcontextrestored = this._onWebglcontextrestored.bind(this);

		canvas.addEventListener("webglcontextlost", this._onWebglcontextlost);
		canvas.addEventListener("webglcontextrestored", this._onWebglcontextrestored);

		return canvas;
	};

	PanoImageRenderer.prototype._onContentError = function _onContentError(error) {
		this._imageIsReady = false;
		this._image = null;
		this.trigger(EVENTS.ERROR, {
			type: ERROR_TYPE.FAIL_IMAGE_LOAD,
			message: "failed to load image"
		});

		return false;
	};

	PanoImageRenderer.prototype._triggerContentLoad = function _triggerContentLoad() {
		this.trigger(EVENTS.IMAGE_LOADED, {
			content: this._image,
			isVideo: this._isVideo,
			projectionType: this._imageType
		});
	};

	PanoImageRenderer.prototype._onContentLoad = function _onContentLoad(image) {
		this._imageIsReady = true;

		this._triggerContentLoad();
		return true;
	};

	PanoImageRenderer.prototype.isImageLoaded = function isImageLoaded() {
		return !!this._image && this._imageIsReady && (!this._isVideo || this._image.readyState >= 2 /* HAVE_CURRENT_DATA */);
	};

	PanoImageRenderer.prototype.bindTexture = function bindTexture() {
		var _this2 = this;

		return new _Promise(function (res, rej) {
			if (!_this2._contentLoader) {
				rej("ImageLoader is not initialized");
				return;
			}

			_this2._contentLoader.get().then(function () {
				return _this2._bindTexture();
			}, rej).then(res);
		});
	};

	// 부모 엘리먼트에 canvas 를 붙임


	PanoImageRenderer.prototype.attachTo = function attachTo(parentElement) {
		this.detach();
		parentElement.appendChild(this.canvas);
	};

	PanoImageRenderer.prototype.forceContextLoss = function forceContextLoss() {
		if (this.hasRenderingContext()) {
			var loseContextExtension = this.context.getExtension("WEBGL_lose_context");

			if (loseContextExtension) {
				loseContextExtension.loseContext();
			}
		}
	};

	// 부모 엘리먼트에서 canvas 를 제거


	PanoImageRenderer.prototype.detach = function detach() {
		if (this.canvas.parentElement) {
			this.canvas.parentElement.removeChild(this.canvas);
		}
	};

	PanoImageRenderer.prototype.destroy = function destroy() {
		if (this._contentLoader) {
			this._contentLoader.destroy();
		}

		this.detach();
		this.forceContextLoss();

		this.off();

		this.canvas.removeEventListener("webglcontextlost", this._onWebglcontextlost);
		this.canvas.removeEventListener("webglcontextrestored", this._onWebglcontextrestored);
	};

	PanoImageRenderer.prototype.hasRenderingContext = function hasRenderingContext() {
		if (!(this.context && !this.context.isContextLost())) {
			return false;
		} else if (this.context && !this.context.getProgramParameter(this.shaderProgram, this.context.LINK_STATUS)) {
			return false;
		}
		return true;
	};

	PanoImageRenderer.prototype._onWebglcontextlost = function _onWebglcontextlost(e) {
		e.preventDefault();
		this.trigger(EVENTS.RENDERING_CONTEXT_LOST);
	};

	PanoImageRenderer.prototype._onWebglcontextrestored = function _onWebglcontextrestored(e) {
		this._initWebGL();
		this.trigger(EVENTS.RENDERING_CONTEXT_RESTORE);
	};

	PanoImageRenderer.prototype.updateFieldOfView = function updateFieldOfView(fieldOfView) {
		this.fieldOfView = fieldOfView;
		this._updateViewport();
	};

	PanoImageRenderer.prototype.updateViewportDimensions = function updateViewportDimensions(width, height) {
		var viewPortChanged = false;

		this.width = width;
		this.height = height;

		var w = width * DEVICE_PIXEL_RATIO;
		var h = height * DEVICE_PIXEL_RATIO;

		if (w !== this.canvas.width) {
			this.canvas.width = w;
			viewPortChanged = true;
		}

		if (h !== this.canvas.height) {
			this.canvas.height = h;
			viewPortChanged = true;
		}

		if (!viewPortChanged) {
			return;
		}

		this._updateViewport();
		this._shouldForceDraw = true;
	};

	PanoImageRenderer.prototype._updateViewport = function _updateViewport() {
		_mathUtil.mat4.perspective(this.pMatrix, _mathUtil.glMatrix.toRadian(this.fieldOfView), this.canvas.width / this.canvas.height, 0.1, 100);

		this.context.viewport(0, 0, this.context.drawingBufferWidth, this.context.drawingBufferHeight);
	};

	PanoImageRenderer.prototype._initWebGL = function _initWebGL() {
		// TODO: Following code does need to be executed only if width/height, cubicStrip property is changed.
		try {
			this._initRenderingContext();
			this.updateViewportDimensions(this.width, this.height);

			if (this.shaderProgram) {
				this.context.deleteProgram(this.shaderProgram);
			}

			this.shaderProgram = this._initShaderProgram(this.context);
			if (!this.shaderProgram) {
				throw new Error("Failed to intialize shaders: " + _WebGLUtils2["default"].getErrorNameFromWebGLErrorCode(this.context.getError()));
			}

			// Buffers for shader
			this._initBuffers();
		} catch (e) {
			this.trigger(EVENTS.ERROR, {
				type: ERROR_TYPE.NO_WEBGL,
				message: "no webgl support"
			});
			this.destroy();
			return;
		}
		// 캔버스를 투명으로 채운다.
		this.context.clearColor(0, 0, 0, 0);
		var textureTarget = this._isCubeMap ? this.context.TEXTURE_CUBE_MAP : this.context.TEXTURE_2D;

		if (this.texture) {
			this.context.deleteTexture(this.texture);
		}

		this.texture = _WebGLUtils2["default"].createTexture(this.context, textureTarget);
	};

	PanoImageRenderer.prototype._initRenderingContext = function _initRenderingContext() {
		if (this.hasRenderingContext()) {
			return;
		}

		if (!window.WebGLRenderingContext) {
			throw new Error("WebGLRenderingContext not available.");
		}

		this.context = _WebGLUtils2["default"].getWebglContext(this.canvas, this._renderingContextAttributes);

		if (!this.context) {
			throw new Error("Failed to acquire 3D rendering context");
		}
	};

	PanoImageRenderer.prototype._initShaderProgram = function _initShaderProgram(gl) {
		var vertexShaderSource = this._renderer.getVertexShaderSource();
		var vertexShader = _WebGLUtils2["default"].createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);

		if (!vertexShader) {
			return false;
		}

		var fragmentShaderSource = this._renderer.getFragmentShaderSource();
		var fragmentShader = _WebGLUtils2["default"].createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

		if (!fragmentShader) {
			return false;
		}

		var shaderProgram = _WebGLUtils2["default"].createProgram(gl, vertexShader, fragmentShader);

		if (!shaderProgram) {
			return null;
		}

		gl.useProgram(shaderProgram);
		shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
		gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
		shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
		shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
		shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
		shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
		gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

		// clear buffer
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
		// Use TEXTURE0
		gl.uniform1i(shaderProgram.samplerUniform, 0);

		return shaderProgram;
	};

	PanoImageRenderer.prototype._initBuffers = function _initBuffers() {
		var vertexPositionData = this._renderer.getVertexPositionData();
		var indexData = this._renderer.getIndexData();
		var textureCoordData = this._renderer.getTextureCoordData(this._imageConfig);
		var gl = this.context;

		this.vertexBuffer = _WebGLUtils2["default"].initBuffer(gl, gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), 3, this.shaderProgram.vertexPositionAttribute);

		this.indexBuffer = _WebGLUtils2["default"].initBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), 1);

		this.textureCoordBuffer = _WebGLUtils2["default"].initBuffer(gl, gl.ARRAY_BUFFER, new Float32Array(textureCoordData), this._isCubeMap ? 3 : 2, this.shaderProgram.textureCoordAttribute);
	};

	PanoImageRenderer.prototype._bindTexture = function _bindTexture() {
		this._renderer.bindTexture(this.context, this.texture, this._image, this._imageConfig);
		this._shouldForceDraw = true;

		this.trigger(EVENTS.BIND_TEXTURE);
	};

	PanoImageRenderer.prototype._updateTexture = function _updateTexture() {
		this._renderer.updateTexture(this.context, this._image, this._imageConfig);
	};

	PanoImageRenderer.prototype.keepUpdate = function keepUpdate(doUpdate) {
		if (doUpdate && this.isImageLoaded() === false) {
			// Force to draw a frame after image is loaded on render()
			this._shouldForceDraw = true;
		}

		this._keepUpdate = doUpdate;
	};

	PanoImageRenderer.prototype.renderWithQuaternion = function renderWithQuaternion(quaternion, fieldOfView) {
		if (!this.isImageLoaded()) {
			return;
		}

		if (this._keepUpdate === false && this._lastQuaternion && _mathUtil.quat.exactEquals(this._lastQuaternion, quaternion) && this.fieldOfView && this.fieldOfView === fieldOfView && this._shouldForceDraw === false) {
			return;
		}

		// updatefieldOfView only if fieldOfView is changed.
		if (fieldOfView !== undefined && fieldOfView !== this.fieldOfView) {
			this.updateFieldOfView(fieldOfView);
		}

		var outQ = void 0;

		if (!this._isCubeMap) {
			// TODO: Remove this yaw revision by correcting shader
			outQ = _mathUtil.quat.rotateY(_mathUtil.quat.create(), quaternion, _mathUtil.glMatrix.toRadian(90));
		} else {
			outQ = quaternion;
		}

		this.mvMatrix = _mathUtil.mat4.fromQuat(_mathUtil.mat4.create(), outQ);

		this._draw();

		this._lastQuaternion = _mathUtil.quat.clone(quaternion);
		if (this._shouldForceDraw) {
			this._shouldForceDraw = false;
		}
	};

	PanoImageRenderer.prototype.render = function render(yaw, pitch, fieldOfView) {
		if (!this.isImageLoaded()) {
			return;
		}

		if (this._keepUpdate === false && this._lastYaw !== null && this._lastYaw === yaw && this._lastPitch !== null && this._lastPitch === pitch && this.fieldOfView && this.fieldOfView === fieldOfView && this._shouldForceDraw === false) {
			return;
		}

		// fieldOfView 가 존재하면서 기존의 값과 다를 경우에만 업데이트 호출
		if (fieldOfView !== undefined && fieldOfView !== this.fieldOfView) {
			this.updateFieldOfView(fieldOfView);
		}

		_mathUtil.mat4.identity(this.mvMatrix);
		_mathUtil.mat4.rotateX(this.mvMatrix, this.mvMatrix, -_mathUtil.glMatrix.toRadian(pitch));
		_mathUtil.mat4.rotateY(this.mvMatrix, this.mvMatrix, -_mathUtil.glMatrix.toRadian(yaw - (this._isCubeMap ? 0 : 90)));

		this._draw();

		this._lastYaw = yaw;
		this._lastPitch = pitch;
		if (this._shouldForceDraw) {
			this._shouldForceDraw = false;
		}
	};

	PanoImageRenderer.prototype._draw = function _draw() {
		var gl = this.context;

		gl.uniformMatrix4fv(this.shaderProgram.pMatrixUniform, false, this.pMatrix);
		gl.uniformMatrix4fv(this.shaderProgram.mvMatrixUniform, false, this.mvMatrix);

		if (this._isVideo && this._keepUpdate) {
			this._updateTexture();
		}

		if (this.indexBuffer) {
			gl.drawElements(gl.TRIANGLES, this.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		}
	};

	return PanoImageRenderer;
}(_component2["default"]);

exports["default"] = PanoImageRenderer;


PanoImageRenderer.EVENTS = EVENTS;
PanoImageRenderer.ERROR_TYPE = ERROR_TYPE;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _Promise = typeof Promise === 'undefined' ? __webpack_require__(5).Promise : Promise;

// import Agent from "@egjs/agent";

/* Ref https://www.w3schools.com/tags/av_prop_readystate.asp */
var READY_STATUS = {
	HAVE_NOTHING: 0, // no information whether or not the audio/video is ready
	HAVE_METADATA: 1, // HAVE_METADATA - metadata for the audio/video is ready
	HAVE_CURRENT_DATA: 2, // data for the current playback position is available, but not enough data to play next frame/millisecond
	HAVE_FUTURE_DATA: 3, // data for the current and at least the next frame is available
	HAVE_ENOUGH_DATA: 4, // enough data available to start playing
	// below is custom status for failed to load status
	LOADING_FAILED: -1
};

var READYSTATECHANGE_EVENT_NAME = {};

READYSTATECHANGE_EVENT_NAME[READY_STATUS.HAVE_METADATA] = "loadedmetadata";
READYSTATECHANGE_EVENT_NAME[READY_STATUS.HAVE_CURRENT_DATA] = "loadeddata";
READYSTATECHANGE_EVENT_NAME[READY_STATUS.HAVE_FUTURE_DATA] = "canplay";
READYSTATECHANGE_EVENT_NAME[READY_STATUS.HAVE_ENOUGH_DATA] = "canplaythrough";

var VideoLoader = function () {
	function VideoLoader(video) {
		_classCallCheck(this, VideoLoader);

		this._handlers = [];
		this._sourceCount = 0;

		// on iOS safari, 'loadeddata' will not triggered unless the user hits play,
		// so used 'loadedmetadata' instead.
		this._thresholdReadyState = READY_STATUS.HAVE_METADATA;
		this._thresholdEventName = READYSTATECHANGE_EVENT_NAME[this._thresholdReadyState];

		this._loadStatus = video && video.readyState || READY_STATUS.HAVE_NOTHING;

		this._onerror = this._onerror.bind(this);

		video && this.set(video);
	}

	VideoLoader.prototype._onerror = function _onerror() {
		this._errorCount++;
		if (this._errorCount >= this._sourceCount) {
			this._loadStatus = READY_STATUS.LOADING_FAILED;
			this._detachErrorHandler(this._onerror);
		}
	};

	/**
  *
  * @param {Object | String} video Object or String containing Video Source URL<ko>비디오 URL 정보를 담고 있는 문자열이나 객체 {type, src}</ko>
  */


	VideoLoader.prototype._appendSourceElement = function _appendSourceElement(videoUrl) {
		var videoSrc = void 0;
		var videoType = void 0;

		if ((typeof videoUrl === "undefined" ? "undefined" : _typeof(videoUrl)) === "object") {
			videoSrc = videoUrl.src;
			videoType = videoUrl.type;
		} else if (typeof videoUrl === "string") {
			videoSrc = videoUrl;
		}

		if (!videoSrc) {
			return false;
		}

		var sourceElement = document.createElement("source");

		sourceElement.src = videoSrc;
		videoType && (sourceElement.type = videoType);

		this._video.appendChild(sourceElement);
		return true;
	};

	VideoLoader.prototype.set = function set(video) {
		var _this = this;

		this._reset(); // reset resources.

		if (!video) {
			return;
		}

		if (video instanceof HTMLVideoElement) {
			// video tag
			this._video = video;
		} else if (typeof video === "string" || (typeof video === "undefined" ? "undefined" : _typeof(video)) === "object") {
			// url
			this._video = document.createElement("video");
			this._video.setAttribute("crossorigin", "anonymous");
			this._video.setAttribute("webkit-playsinline", "");
			this._video.setAttribute("playsinline", "");

			if (video instanceof Array) {
				video.forEach(function (v) {
					return _this._appendSourceElement(v);
				});
			} else {
				this._appendSourceElement(video);
			}

			this._sourceCount = this._video.querySelectorAll("source").length;

			if (this._sourceCount > 0) {
				if (this._video.readyState < this._thresholdReadyState) {
					this._video.load();
					// attach loading error listener
					this._attachErrorHandler(this._onerror);
				}
			} else {
				this._video = null;
			}
		}
	};

	VideoLoader.prototype._attachErrorHandler = function _attachErrorHandler(handler) {
		this._video.addEventListener("error", handler);
		this._sources = this._video.querySelectorAll("source");
		[].forEach.call(this._sources, function (source) {
			source.addEventListener("error", handler);
		});
	};

	VideoLoader.prototype._detachErrorHandler = function _detachErrorHandler(handler) {
		this._video.removeEventListener("error", handler);
		[].forEach.call(this._sources, function (source) {
			source.removeEventListener("error", handler);
		});
	};

	VideoLoader.prototype.get = function get() {
		var _this2 = this;

		return new _Promise(function (res, rej) {
			if (!_this2._video) {
				rej("VideoLoader: video is undefined");
			} else if (_this2._loadStatus === READY_STATUS.LOADING_FAILED) {
				rej("VideoLoader: video source is invalid");
			} else if (_this2._video.readyState >= _this2._thresholdReadyState) {
				res(_this2._video);
			} else {
				// check errorCnt and reject
				var rejector = function rejector() {
					if (_this2._loadStatus === READY_STATUS.LOADING_FAILED) {
						_this2._detachErrorHandler(rejector);
						rej("VideoLoader: video source is invalid");
					}
				};

				_this2._attachErrorHandler(rejector);
				_this2._once(_this2._thresholdEventName, function () {
					return res(_this2._video);
				});
			}
		});
	};

	VideoLoader.prototype.getElement = function getElement() {
		return this._video;
	};

	VideoLoader.prototype.destroy = function destroy() {
		this._reset();
	};

	VideoLoader.prototype._reset = function _reset() {
		var _this3 = this;

		this._handlers.forEach(function (handler) {
			_this3._video.removeEventListener(handler.type, handler.fn);
		});
		this._handlers = [];
		this._video = null;

		this._sourceCount = 0;
		this._errorCount = 0;
	};

	VideoLoader.prototype._once = function _once(type, listener) {
		var target = this._video;

		var fn = function fn(event) {
			target.removeEventListener(type, fn);
			listener(event);
		};

		/* By useCapture mode enabled, you can capture the error event being fired on source(child)*/
		target.addEventListener(type, fn, true);
		this._handlers.push({ type: type, fn: fn });
	};

	return VideoLoader;
}();

exports["default"] = VideoLoader;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var userAgent = exports.userAgent = window.navigator.userAgent;
var devicePixelRatio = exports.devicePixelRatio = window.devicePixelRatio;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.WebGLUtils = exports.PanoImageRenderer = undefined;

var _PanoImageRenderer = __webpack_require__(23);

var _PanoImageRenderer2 = _interopRequireDefault(_PanoImageRenderer);

var _WebGLUtils = __webpack_require__(7);

var _WebGLUtils2 = _interopRequireDefault(_WebGLUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

exports.PanoImageRenderer = _PanoImageRenderer2["default"];
exports.WebGLUtils = _WebGLUtils2["default"];

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _agent = __webpack_require__(3);

var _agent2 = _interopRequireDefault(_agent);

var _Renderer2 = __webpack_require__(12);

var _Renderer3 = _interopRequireDefault(_Renderer2);

var _mathUtil = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CubeRenderer = function (_Renderer) {
	_inherits(CubeRenderer, _Renderer);

	function CubeRenderer() {
		_classCallCheck(this, CubeRenderer);

		return _possibleConstructorReturn(this, _Renderer.apply(this, arguments));
	}

	CubeRenderer.getVertexPositionData = function getVertexPositionData() {
		CubeRenderer._VERTEX_POSITION_DATA = CubeRenderer._VERTEX_POSITION_DATA !== null ? CubeRenderer._VERTEX_POSITION_DATA : [
		// back
		1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1,

		// front
		-1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1,

		// top
		-1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1,

		// bottom
		1, -1, -1, -1, -1, -1, -1, -1, 1, 1, -1, 1,

		// right
		1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, -1,

		// left
		-1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1];

		return CubeRenderer._VERTEX_POSITION_DATA;
	};

	CubeRenderer.getIndexData = function getIndexData() {
		if (CubeRenderer._INDEX_DATA) {
			return CubeRenderer._INDEX_DATA;
		}

		var indexData = [];
		var vertexPositionData = CubeRenderer.getVertexPositionData();

		for (var i = 0; i < vertexPositionData.length / 3; i += 4) {
			indexData.push(i, i + 2, i + 1, i, i + 3, i + 2);
		}

		CubeRenderer._INDEX_DATA = indexData;
		return indexData;
	};

	CubeRenderer.extractTileConfig = function extractTileConfig(imageConfig) {
		var tileConfig = Array.isArray(imageConfig.tileConfig) ? imageConfig.tileConfig : Array.apply(undefined, Array(6)).map(function () {
			return imageConfig.tileConfig;
		});

		tileConfig = tileConfig.map(function (config) {
			return _extends({
				flipHorizontal: false,
				rotation: 0
			}, config);
		});

		return tileConfig;
	};

	CubeRenderer.extractOrder = function extractOrder(imageConfig) {
		return imageConfig.order || "RLUDBF";
	};

	CubeRenderer.getTextureCoordData = function getTextureCoordData(imageConfig) {
		var vertexOrder = "BFUDRL";
		var order = CubeRenderer.extractOrder(imageConfig);
		var base = CubeRenderer.getVertexPositionData();
		var tileConfig = CubeRenderer.extractTileConfig(imageConfig);
		var elemSize = 3;
		var vertexPerTile = 4;
		var textureCoordData = vertexOrder.split("").map(function (face) {
			return tileConfig[order.indexOf(face)];
		}).map(function (config, i) {
			var rotation = parseInt(config.rotation / 90, 10);
			var ordermap_ = config.flipHorizontal ? [0, 1, 2, 3] : [1, 0, 3, 2];

			for (var r = 0; r < Math.abs(rotation); r++) {
				if (config.flipHorizontal && rotation > 0 || !config.flipHorizontal && rotation < 0) {
					ordermap_.push(ordermap_.shift());
				} else {
					ordermap_.unshift(ordermap_.pop());
				}
			}

			var elemPerTile = elemSize * vertexPerTile;
			var tileVertex = base.slice(i * elemPerTile, i * elemPerTile + elemPerTile);
			var tileTemp = [];

			for (var j = 0; j < vertexPerTile; j++) {
				tileTemp[ordermap_[j]] = tileVertex.splice(0, elemSize);
			}
			return tileTemp;
		}).join().split(",").map(function (v) {
			return parseInt(v, 10);
		});

		return textureCoordData;
	};

	CubeRenderer.getVertexShaderSource = function getVertexShaderSource() {
		return "\n\t\t\tattribute vec3 aVertexPosition;\n\t\t\tattribute vec3 aTextureCoord;\n\t\t\tuniform mat4 uMVMatrix;\n\t\t\tuniform mat4 uPMatrix;\n\t\t\tvarying highp vec3 vVertexDirectionVector;\n\t\t\tvoid main(void) {\n\t\t\t\tgl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n\t\t\t\tvVertexDirectionVector = aTextureCoord;\n\t\t\t}";
	};

	CubeRenderer.getFragmentShaderSource = function getFragmentShaderSource() {
		return "\n\t\t\tvarying highp vec3 vVertexDirectionVector;\n\t\t\tuniform samplerCube uSampler;\n\t\t\tvoid main(void) {\n\t\t\t\tgl_FragColor = textureCube(uSampler, vVertexDirectionVector);\n\t\t\t}";
	};

	CubeRenderer.updateTexture = function updateTexture(gl, image, imageConfig) {
		var baseOrder = "RLUDBF";
		var order = CubeRenderer.extractOrder(imageConfig);
		var orderMap = {};

		order.split("").forEach(function (v, i) {
			orderMap[v] = i;
		});

		try {
			if (image instanceof Array) {
				for (var surfaceIdx = 0; surfaceIdx < 6; surfaceIdx++) {
					var tileIdx = orderMap[baseOrder[surfaceIdx]];

					gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + surfaceIdx, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image[tileIdx]);
				}
			} else {
				var maxCubeMapTextureSize = CubeRenderer.getMaxCubeMapTextureSize(gl, image);

				for (var _surfaceIdx = 0; _surfaceIdx < 6; _surfaceIdx++) {
					var _tileIdx = orderMap[baseOrder[_surfaceIdx]];
					var tile = CubeRenderer.extractTileFromImage(image, _tileIdx, maxCubeMapTextureSize);

					gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _surfaceIdx, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tile);
				}
			}
		} catch (e) {}
	};

	CubeRenderer.bindTexture = function bindTexture(gl, texture, image, imageConfig) {
		gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
		CubeRenderer.updateTexture(gl, image, imageConfig);
	};

	CubeRenderer._getDimension = function _getDimension(pixelSource) {
		var width = pixelSource.naturalWidth || pixelSource.videoWidth;
		var height = pixelSource.naturalHeight || pixelSource.videoHeight;

		return { width: width, height: height };
	};

	CubeRenderer.getSourceTileSize = function getSourceTileSize(image) {
		var _getDimension2 = this._getDimension(image),
		    width = _getDimension2.width,
		    height = _getDimension2.height;

		var aspectRatio = width / height;
		var inputTextureSize = void 0;

		if (aspectRatio === 1 / 6) {
			inputTextureSize = width;
		} else if (aspectRatio === 6) {
			inputTextureSize = height;
		} else if (aspectRatio === 2 / 3) {
			inputTextureSize = width / 2;
		} else {
			inputTextureSize = width / 3;
		}
		return inputTextureSize;
	};

	CubeRenderer.extractTileFromImage = function extractTileFromImage(image, tileIdx, outputTextureSize) {
		var _getDimension3 = this._getDimension(image),
		    width = _getDimension3.width;

		var inputTextureSize = CubeRenderer.getSourceTileSize(image);

		var canvas = document.createElement("canvas");

		canvas.width = outputTextureSize;
		canvas.height = outputTextureSize;
		var context = canvas.getContext("2d");
		var tilePerRow = width / inputTextureSize;

		var x = inputTextureSize * tileIdx % (inputTextureSize * tilePerRow);
		var y = parseInt(tileIdx / tilePerRow, 10) * inputTextureSize;

		context.drawImage(image, x, y, inputTextureSize, inputTextureSize, 0, 0, outputTextureSize, outputTextureSize);
		return canvas;
	};

	CubeRenderer.getMaxCubeMapTextureSize = function getMaxCubeMapTextureSize(gl, image) {
		var agent = (0, _agent2["default"])();
		var maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
		var _imageWidth = CubeRenderer.getSourceTileSize(image);

		if (agent.browser.name === "ie" && parseInt(agent.browser.version, 10) === 11) {
			if (!_mathUtil.util.isPowerOfTwo(_imageWidth)) {
				for (var i = 1; i < maxCubeMapTextureSize; i *= 2) {
					if (i < _imageWidth) {
						continue;
					} else {
						_imageWidth = i;
						break;
					}
				}
			}
		}
		// ios 9 의 경우 텍스쳐 최대사이즈는 1024 이다.
		if (agent.os.name === "ios" && parseInt(agent.os.version, 10) === 9) {
			_imageWidth = 1024;
		}
		// ios 8 의 경우 텍스쳐 최대사이즈는 512 이다.
		if (agent.os.name === "ios" && parseInt(agent.os.version, 10) === 8) {
			_imageWidth = 512;
		}
		// maxCubeMapTextureSize 보다는 작고, imageWidth 보다 큰 2의 승수 중 가장 작은 수
		return Math.min(maxCubeMapTextureSize, _imageWidth);
	};

	return CubeRenderer;
}(_Renderer3["default"]);

exports["default"] = CubeRenderer;


CubeRenderer._VERTEX_POSITION_DATA = null;
CubeRenderer._INDEX_DATA = null;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _agent = __webpack_require__(3);

var _agent2 = _interopRequireDefault(_agent);

var _Renderer2 = __webpack_require__(12);

var _Renderer3 = _interopRequireDefault(_Renderer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var agent = (0, _agent2["default"])();
var isIE11 = agent.browser.name === "ie" && agent.browser.version === "11.0";
var pixelCanvas = void 0;
var pixelContext = void 0;

var SphereRenderer = function (_Renderer) {
	_inherits(SphereRenderer, _Renderer);

	function SphereRenderer() {
		_classCallCheck(this, SphereRenderer);

		return _possibleConstructorReturn(this, _Renderer.apply(this, arguments));
	}

	SphereRenderer.getVertexPositionData = function getVertexPositionData() {
		return SphereRenderer._VERTEX_POSITION_DATA;
	};

	SphereRenderer.getIndexData = function getIndexData() {
		return SphereRenderer._INDEX_DATA;
	};

	SphereRenderer.getTextureCoordData = function getTextureCoordData() {
		return SphereRenderer._TEXTURE_COORD_DATA;
	};

	SphereRenderer.getVertexShaderSource = function getVertexShaderSource() {
		return "\n\t\t\tattribute vec3 aVertexPosition;\n\t\t\tattribute vec2 aTextureCoord;\n\t\t\tuniform mat4 uMVMatrix;\n\t\t\tuniform mat4 uPMatrix;\n\t\t\tvarying highp vec2 vTextureCoord;\n\t\t\tvoid main(void) {\n\t\t\t\tgl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n\t\t\t\tvTextureCoord = aTextureCoord;\n\t\t\t}";
	};

	SphereRenderer.getFragmentShaderSource = function getFragmentShaderSource() {
		return "\n\t\t\tvarying highp vec2 vTextureCoord;\n\t\t\tuniform sampler2D uSampler;\n\t\t\tvoid main(void) {\n\t\t\t\tgl_FragColor = texture2D(\n\t\t\t\t\tuSampler,\n\t\t\t\t\tvec2(vTextureCoord.s, vTextureCoord.t)\n\t\t\t\t);\n\t\t\t}";
	};

	SphereRenderer._getPixelSource = function _getPixelSource(image) {
		if (!pixelCanvas) {
			return image;
		}

		var _getDimension2 = this._getDimension(image),
		    width = _getDimension2.width,
		    height = _getDimension2.height;

		if (pixelCanvas.width !== width) {
			pixelCanvas.width = width;
		}

		if (pixelCanvas.height !== height) {
			pixelCanvas.height = height;
		}

		pixelContext.drawImage(image, 0, 0);

		return pixelCanvas;
	};

	SphereRenderer._getDimension = function _getDimension(pixelSource) {
		var width = pixelSource.naturalWidth || pixelSource.videoWidth;
		var height = pixelSource.naturalHeight || pixelSource.videoHeight;

		return { width: width, height: height };
	};

	SphereRenderer.updateTexture = function updateTexture(gl, image) {
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._getPixelSource(image));
	};

	SphereRenderer.bindTexture = function bindTexture(gl, texture, image) {
		// Make sure image isn't too big
		var _getDimension3 = this._getDimension(image),
		    width = _getDimension3.width,
		    height = _getDimension3.height;

		var size = Math.max(width, height);
		var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);

		if (size > maxSize) {
			/* eslint-disable no-console */
			console.warn("Image width(" + width + ") exceeds device limit(" + maxSize + "))");
			/* eslint-enable no-console */
			return;
		}

		if (isIE11 && image instanceof HTMLVideoElement) {
			pixelCanvas = document.createElement("canvas");
			pixelCanvas.width = width;
			pixelCanvas.height = height;
			pixelContext = pixelCanvas.getContext("2d");
		}

		gl.activeTexture(gl.TEXTURE0);
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		gl.bindTexture(gl.TEXTURE_2D, texture);

		SphereRenderer.updateTexture(gl, image);
	};

	SphereRenderer._initData = function _initData() {
		var latitudeBands = 60;
		var longitudeBands = 60;
		var radius = 2;

		var textureCoordData = [];
		var vertexPositionData = [];
		var indexData = [];
		var latIdx = void 0;
		var lngIdx = void 0;

		for (latIdx = 0; latIdx <= latitudeBands; latIdx++) {
			var theta = (latIdx / latitudeBands - 0.5) * Math.PI;
			var sinTheta = Math.sin(theta);
			var cosTheta = Math.cos(theta);

			for (lngIdx = 0; lngIdx <= longitudeBands; lngIdx++) {
				var phi = (lngIdx / longitudeBands - 0.5) * 2 * Math.PI;
				var sinPhi = Math.sin(phi);
				var cosPhi = Math.cos(phi);
				var x = cosPhi * cosTheta;
				var y = sinTheta;
				var z = sinPhi * cosTheta;
				var u = lngIdx / longitudeBands;
				var v = latIdx / latitudeBands;

				textureCoordData.push(u, v);
				vertexPositionData.push(radius * x, radius * y, radius * z);

				if (lngIdx !== longitudeBands && latIdx !== latitudeBands) {
					var a = latIdx * (longitudeBands + 1) + lngIdx;
					var b = a + longitudeBands + 1;

					indexData.push(a, b, a + 1, b, b + 1, a + 1);
				}
			}
		}

		SphereRenderer._VERTEX_POSITION_DATA = vertexPositionData;
		SphereRenderer._TEXTURE_COORD_DATA = textureCoordData;
		SphereRenderer._INDEX_DATA = indexData;
	};

	return SphereRenderer;
}(_Renderer3["default"]);

exports["default"] = SphereRenderer;


SphereRenderer._VERTEX_POSITION_DATA = null;
SphereRenderer._TEXTURE_COORD_DATA = null;
SphereRenderer._INDEX_DATA = null;

SphereRenderer._initData();

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

var _browser = __webpack_require__(30);

var _YawPitchControl = __webpack_require__(16);

var _PanoImageRenderer = __webpack_require__(26);

var _WebGLUtils = __webpack_require__(7);

var _WebGLUtils2 = _interopRequireDefault(_WebGLUtils);

var _consts = __webpack_require__(13);

var _mathUtil = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Promise = typeof Promise === 'undefined' ? __webpack_require__(5).Promise : Promise;

var PanoViewer = function (_Component) {
	_inherits(PanoViewer, _Component);

	/**
  * @classdesc 360 media viewer
  * @ko 360 미디어 뷰어
  * @class
  * @name eg.view360.PanoViewer
  * @extends eg.Component
  *
  * @param {HTMLElement} container The container element for the renderer. <ko>렌더러의 컨테이너 엘리먼트</ko>
  * @param {Object} config
  *
  * @param {String|Image} config.image Input image url or element (Use only image property or video property)<ko>입력 이미지 URL 혹은 엘리먼트(image 와 video 둘 중 하나만 설정)</ko>
  * @param {String|HTMLVideoElement} config.video Input video url or element(Use only image property or video property)<ko>입력 비디오 URL 혹은 엘리먼트(image 와 video 둘 중 하나만 설정)</ko>
  * @param {String} [config.projectionType=equirectangular] The type of projection: equirectangular, cubemap <br/>{@link eg.view360.PanoViewer.PROJECTION_TYPE}<ko>Projection 유형 : equirectangular, cubemap <br/>{@link eg.view360.PanoViewer.PROJECTION_TYPE}</ko>
  * @param {Object} config.cubemapConfig config cubemap projection layout. <ko>cubemap projection type 의 레이아웃을 설정한다.</ko>
  * @param {Number} [config.width=width of container] the viewer's width. (in px) <ko>뷰어의 너비 (px 단위)</ko>
  * @param {Number} [config.height=height of container] the viewer's height.(in px) <ko>뷰어의 높이 (px 단위)</ko>
  *
  * @param {Number} [config.yaw=0] Initial Yaw of camera (in degree) <ko>카메라의 초기 Yaw (degree 단위)</ko>
  * @param {Number} [config.pitch=0] Initial Pitch of camera (in degree) <ko>카메라의 초기 Pitch (degree 단위)</ko>
  * @param {Number} [config.fov=65] Initial vertical field of view of camera (in degree) <ko>카메라의 초기 수직 field of view (degree 단위)</ko>
  * @param {Boolean} [config.showPolePoint=false] If false, the pole is not displayed inside the viewport <ko>false 인 경우, 극점은 뷰포트 내부에 표시되지 않습니다</ko>
  * @param {Boolean} [config.useZoom=true] When true, enables zoom with the wheel and Pinch gesture <ko>true 일 때 휠 및 집기 제스춰로 확대 / 축소 할 수 있습니다.</ko>
  * @param {Boolean} [config.useKeyboard=true] When true, enables the keyboard move key control: awsd, arrow keys <ko>true 이면 키보드 이동 키 컨트롤을 활성화합니다: awsd, 화살표 키</ko>
  * @param {String} [config.gyroMode=yawPitch] Enables control through device motion. ("none", "yawPitch", "VR") <br/>{@link eg.view360.PanoViewer.GYRO_MODE} <ko>디바이스 움직임을 통한 컨트롤을 활성화 합니다. ("none", "yawPitch", "VR") <br/>{@link eg.view360.PanoViewer.GYRO_MODE} </ko>
  * @param {Array} [config.yawRange=[-180, 180]] Range of controllable Yaw values <ko>제어 가능한 Yaw 값의 범위</ko>
  * @param {Array} [config.pitchRange=[-90, 90]] Range of controllable Pitch values <ko>제어 가능한 Pitch 값의 범위</ko>
  * @param {Array} [config.fovRange=[30, 110]] Range of controllable vertical field of view values <ko>제어 가능한 수직 field of view 값의 범위</ko>
  * @param {Number} [config.touchDirection= {@link eg.view360.PanoViewer.TOUCH_DIRECTION.ALL}(6)] Direction of touch that can be controlled by user <br/>{@link eg.view360.PanoViewer.TOUCH_DIRECTION}<ko>사용자가 터치로 조작 가능한 방향 <br/>{@link eg.view360.PanoViewer.TOUCH_DIRECTION}</ko>
  *
  * @example
  *
  * // create PanoViewer with option
  * var PanoViewer = eg.view360.PanoViewer;
  * // Area where the image will be displayed(HTMLElement)
  * var container = document.getElementById("myPanoViewer");
  *
  * var panoViewer = new PanoViewer(container, {
  *     // If projectionType is not specified, the default is "equirectangular".
  *     // Specifies an image of the "equirectangular" type.
  *     image: "/path/to/image/image.jpg"
  *});
  */
	function PanoViewer(container) {
		var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		_classCallCheck(this, PanoViewer);

		// Raises the error event if webgl is not supported.
		var _this = _possibleConstructorReturn(this, _Component.call(this));

		if (!_WebGLUtils2["default"].isWebGLAvailable()) {
			var _ret;

			setTimeout(function () {
				_this.trigger(_consts.EVENTS.ERROR, {
					type: _consts.ERROR_TYPE.NO_WEBGL,
					message: "no webgl support"
				});
			}, 0);
			return _ret = _this, _possibleConstructorReturn(_this, _ret);
		}

		if (!_WebGLUtils2["default"].isStableWebGL()) {
			var _ret2;

			setTimeout(function () {
				_this.trigger(_consts.EVENTS.ERROR, {
					type: _consts.ERROR_TYPE.INVALID_DEVICE,
					message: "blacklisted browser"
				});
			}, 0);

			return _ret2 = _this, _possibleConstructorReturn(_this, _ret2);
		}

		if (!!options.image && !!options.video) {
			var _ret3;

			setTimeout(function () {
				_this.trigger(_consts.EVENTS.ERROR, {
					type: _consts.ERROR_TYPE.INVALID_RESOURCE,
					message: "Specifying multi resouces(both image and video) is not valid."
				});
			}, 0);
			return _ret3 = _this, _possibleConstructorReturn(_this, _ret3);
		}

		_this._container = container;
		_this._image = options.image || options.video;
		_this._isVideo = !!options.video;
		_this._projectionType = options.projectionType || _consts.PROJECTION_TYPE.EQUIRECTANGULAR;
		_this._cubemapConfig = _extends({
			order: "RLUDBF",
			tileConfig: {
				flipHirozontal: false,
				rotation: 0
			}
		}, options.cubemapConfig);

		// If the width and height are not provided, will use the size of the container.
		_this._width = options.width || parseInt(window.getComputedStyle(container).width, 10);
		_this._height = options.height || parseInt(window.getComputedStyle(container).height, 10);

		_this._yaw = options.yaw || 0;
		_this._pitch = options.pitch || 0;
		_this._fov = options.fov || 65;

		_this._gyroMode = options.gyroMode || _consts.GYRO_MODE.YAWPITCH;
		_this._quaternion = null;

		_this._aspectRatio = _this._width / _this._height;
		var fovRange = options.fovRange || [30, 110];
		var touchDirection = PanoViewer._isValidTouchDirection(options.touchDirection) ? options.touchDirection : _YawPitchControl.YawPitchControl.TOUCH_DIRECTION_ALL;
		var yawPitchConfig = _extends(options, {
			element: container,
			yaw: _this._yaw,
			pitch: _this._pitch,
			fov: _this._fov,
			gyroMode: _this._gyroMode,
			fovRange: fovRange,
			aspectRatio: _this._aspectRatio,
			touchDirection: touchDirection
		});

		_this._isReady = false;

		_this._initYawPitchControl(yawPitchConfig);
		_this._initRenderer(_this._yaw, _this._pitch, _this._fov, _this._projectionType, _this._cubemapConfig);
		return _this;
	}

	/**
 	* Get the video element that the viewer is currently playing. You can use this for playback.
 	* @ko 뷰어가 현재 사용 중인 비디오 요소를 얻습니다. 이 요소를 이용해 비디오의 컨트롤을 할 수 있습니다.
 	* @method eg.view360.PanoViewer#getVideo
 	* @return {HTMLVideoElement} HTMLVideoElement<ko>HTMLVideoElement</ko>
 	* @example
 	* var videoTag = panoViewer.getVideo();
 	* videoTag.play(); // play video!
 	*/


	PanoViewer.prototype.getVideo = function getVideo() {
		if (!this._isVideo) {
			return null;
		}

		return this._photoSphereRenderer.getContent();
	};

	/**
  * Set the video information to be used by the viewer.
  * @ko 뷰어가 사용할 이미지 정보를 설정합니다.
  * @method eg.view360.PanoViewer#setVideo
  * @param {String|HTMLVideoElement|Object} video Input video url or element or config object<ko>입력 비디오 URL 혹은 엘리먼트 혹은 설정객체를 활용(image 와 video 둘 중 하나만 설정)</ko>
  * @param {Object} param
  * @param {String} [param.projectionType={@link eg.view360.PanoViewer.PROJECTION_TYPE.EQUIRECTANGULAR}("equirectangular")] Projection Type<ko>프로젝션 타입</ko>
  * @param {Object} param.cubemapConfig config cubemap projection layout. <ko>cubemap projection type 의 레이아웃 설정</ko>
  *
  * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer 인스턴스</ko>
  * @example
  * panoViewer.setVideo("/path/to/video/video.mp4", {
  *     projectionType: eg.view360.PanoViewer.PROJECTION_TYPE.EQUIRECTANGULAR
  * });
  */


	PanoViewer.prototype.setVideo = function setVideo(video) {
		var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		if (video) {
			this.setImage(video, {
				projectionType: param.projectionType,
				isVideo: true,
				cubemapConfig: param.cubemapConfig
			});
		}

		return this;
	};

	/**
  * Get the image information that the viewer is currently using.
  * @ko 뷰어가 현재 사용하고있는 이미지 정보를 얻습니다.
  * @method eg.view360.PanoViewer#getImage
  * @return {Image} Image Object<ko>이미지 객체</ko>
  * @example
  * var imageObj = panoViewer.getImage();
  */


	PanoViewer.prototype.getImage = function getImage() {
		if (this._isVideo) {
			return null;
		}

		return this._photoSphereRenderer.getContent();
	};

	/**
  * Set the image information to be used by the viewer.
  * @ko 뷰어가 사용할 이미지 정보를 설정합니다.
  * @method eg.view360.PanoViewer#setImage
  * @param {String|Image|Object} image Input image url or element or config object<ko>입력 이미지 URL 혹은 엘리먼트 혹은 설정객체를 활용(image 와 video 둘 중 하나만 설정한다.)</ko>
  * @param {Object} param Additional information<ko>이미지 추가 정보</ko>
  * @param {String} [param.projectionType="equirectangular"] Projection Type<ko>프로젝션 타입</ko>
  * @param {Object} param.cubemapConfig config cubemap projection layout. <ko>cubemap projection type 레이아웃</ko>
  *
  * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer 인스턴스</ko>
  * @example
  * panoViewer.setImage("/path/to/image/image.png", {
  *     projectionType: eg.view360.PanoViewer.PROJECTION_TYPE.CUBEMAP
  * });
  */


	PanoViewer.prototype.setImage = function setImage(image) {
		var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		var cubemapConfig = _extends({
			order: "RLUDBF",
			tileConfig: {
				flipHirozontal: false,
				rotation: 0
			}
		}, param.cubemapConfig);
		var isVideo = !!param.isVideo;

		if (this._image && this._isVideo !== isVideo) {
			/* eslint-disable no-console */
			console.warn("Currently not supporting to change content type(Image <--> Video)");
			/* eslint-enable no-console */
			return this;
		}

		if (image) {
			this._image = image;
			this._isVideo = isVideo;
			this._projectionType = param.projectionType || _consts.PROJECTION_TYPE.EQUIRECTANGULAR;
			this._cubemapConfig = cubemapConfig;

			this._deactivate();
			this._initRenderer(this._yaw, this._pitch, this._fov, this._projectionType, this._cubemapConfig);
		}

		return this;
	};

	/**
  * Set whether the renderer always updates the texture and renders.
  * @ko 렌더러가 항상 텍스쳐를 갱신하고 화면을 렌더링 할지 여부를 설정할 수 있습니다.
  *
  * @method eg.view360.PanoViewer#keepUpdate
  * @param {Boolean} doUpdate When true viewer will always update texture and render, when false viewer will not update texture and render only camera config is changed.<ko>true면 항상 텍스쳐를 갱신하고 화면을 그리는 반면, false면 텍스쳐 갱신은 하지 않으며, 카메라 요소에 변화가 있을 때에만 화면을 그립니다.</ko>
  * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer 인스턴스</ko>
  */


	PanoViewer.prototype.keepUpdate = function keepUpdate(doUpdate) {
		this._photoSphereRenderer.keepUpdate(doUpdate);
		return this;
	};

	/**
  * Get projection type (equirectangular/cube)
  * @ko 프로젝션 타입(Equirectangular 혹은 Cube)을 반환합니다.
  *
  * @method eg.view360.PanoViewer#getProjectionType
  * @return {String} {@link eg.view360.PanoViewer.PROJECTION_TYPE}
  */


	PanoViewer.prototype.getProjectionType = function getProjectionType() {
		return this._projectionType;
	};

	PanoViewer.prototype._initRenderer = function _initRenderer(yaw, pitch, fov, projectionType, cubemapConfig) {
		var _this2 = this;

		this._photoSphereRenderer = new _PanoImageRenderer.PanoImageRenderer(this._image, this._width, this._height, this._isVideo, {
			initialYaw: yaw,
			initialPitch: pitch,
			fieldOfView: fov,
			imageType: projectionType,
			cubemapConfig: cubemapConfig
		});

		this._bindRendererHandler();

		this._photoSphereRenderer.bindTexture().then(function () {
			return _this2._activate();
		}, function () {
			_this2._triggerEvent(_consts.EVENTS.ERROR, {
				type: _consts.ERROR_TYPE.FAIL_BIND_TEXTURE,
				message: "failed to bind texture"
			});
		});
	};

	PanoViewer.prototype._bindRendererHandler = function _bindRendererHandler() {
		var _this3 = this;

		this._photoSphereRenderer.on(_PanoImageRenderer.PanoImageRenderer.EVENTS.ERROR, function (e) {
			_this3.trigger(_consts.EVENTS.ERROR, e);
		});

		this._photoSphereRenderer.on(_PanoImageRenderer.PanoImageRenderer.EVENTS.RENDERING_CONTEXT_LOST, function (e) {
			_this3._deactivate();
			_this3.trigger(_consts.EVENTS.ERROR, {
				type: _consts.ERROR_TYPE.RENDERING_CONTEXT_LOST,
				message: "webgl rendering context lost"
			});
		});
	};

	PanoViewer.prototype._initYawPitchControl = function _initYawPitchControl(yawPitchConfig) {
		var _this4 = this;

		this._yawPitchControl = new _YawPitchControl.YawPitchControl(yawPitchConfig);

		this._yawPitchControl.on(_consts.EVENTS.ANIMATION_END, function (e) {
			_this4._triggerEvent(_consts.EVENTS.ANIMATION_END, e);
		});

		this._yawPitchControl.on("change", function (e) {
			_this4._yaw = e.yaw;
			_this4._pitch = e.pitch;
			_this4._fov = e.fov;
			_this4._quaternion = e.quaternion;

			_this4._triggerEvent(_consts.EVENTS.VIEW_CHANGE, e);
		});
	};

	PanoViewer.prototype._triggerEvent = function _triggerEvent(name, param) {
		var evt = param || {};

		/**
   * Events that is fired when error occurs
   * @ko 에러 발생 시 발생하는 이벤트
   * @name eg.view360.PanoViewer#error
   * @event
   * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
   * @param {Number} param.type Error type
   * 		10: INVALID_DEVICE: Unsupported device
   * 		11: NO_WEBGL: Webgl not support
   * 		12, FAIL_IMAGE_LOAD: Failed to load image
   * 		13: FAIL_BIND_TEXTURE: Failed to bind texture
   * 		14: INVALID_RESOURCE: Only one resource(image or video) should be specified
   * 		15: RENDERING_CONTEXT_LOST: WebGL context lost occurred
   * <ko>에러 종류
   * 		10: INVALID_DEVICE: 미지원 기기
   * 		11: NO_WEBGL: WEBGL 미지원
   * 		12, FAIL_IMAGE_LOAD: 이미지 로드 실패
   * 		13: FAIL_BIND_TEXTURE: 텍스쳐 바인딩 실패
   * 		14: INVALID_RESOURCE: 리소스 지정 오류 (image 혹은 video 중 하나만 지정되어야 함)
   * 		15: RENDERING_CONTEXT_LOST: WebGL context lost 발생
   * </ko>
   * @param {String} param.message Error message <ko>에러 메시지</ko>
   * @see {@link eg.view360.PanoViewer.ERROR_TYPE}
   * @example
   *
   * viwer.on({
   *	"error" : function(evt) {
   *		// evt.type === 13
   *		// evt.message === "failed to bind texture"
   * });
   *
   * // constant can be used
   * viwer.on({
   *	eg.view360.PanoViewer.EVENTS.ERROR : function(evt) {
   *		// evt.type === eg.view360.PanoViewer.ERROR_TYPE.FAIL_BIND_TEXTURE
   *		// evt.message === "failed to bind texture"
   * });
   */

		/**
   * Events that is fired when PanoViewer is ready to go.
   * @ko PanoViewer 가 준비된 상태에 발생하는 이벤트
   * @name eg.view360.PanoViewer#ready
   * @event
   *
   * @example
   *
   * viwer.on({
   *	"ready" : function(evt) {
   *		// PanoViewer is ready to show image and handle user interaction.
   * });
   */

		/**
   * Events that is fired when direction or fov is changed.
   * @ko PanoViewer 에서 바라보고 있는 방향이나 FOV(화각)가 변경되었을때 발생하는 이벤트
   * @name eg.view360.PanoViewer#viewChange
   * @event
   * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
   * @param {Number} param.yaw yaw<ko>yaw</ko>
   * @param {Number} param.pitch pitch <ko>pitch</ko>
   * @param {Number} param.fov Field of view (fov) <ko>화각</ko>
   * @example
   *
   * viwer.on({
   *	"viewChange" : function(evt) {
   *		//evt.yaw, evt.pitch, evt.fov is available.
   * });
   */

		/**
   * Events that is fired when animation which is triggered by inertia is ended.
   * @ko 관성에 의한 애니메이션 동작이 완료되었을때 발생하는 이벤트
   * @name eg.view360.PanoViewer#animationEnd
   * @event
   * @example
   *
   * viwer.on({
   *	"animationEnd" : function(evt) {
   *		// animation is ended.
   * });
   */
		return this.trigger(name, evt);
	};

	/**
  * When set true, enables zoom with the wheel or pinch gesture. However, in the case of touch, pinch works only when the touchDirection setting is {@link eg.view360.PanoViewer.TOUCH_DIRECTION.ALL}.
  * @ko true 로 설정 시 휠 혹은 집기 동작으로 확대/축소 할 수 있습니다. false 설정 시 확대/축소 기능을 비활성화 합니다. 단, 터치인 경우 touchDirection 설정이 {@link eg.view360.PanoViewer.TOUCH_DIRECTION.ALL} 인 경우에만 pinch 가 동작합니다.
  * @method eg.view360.PanoViewer#setUseZoom
  * @param {Boolean} useZoom
  * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer 인스턴스</ko>
  */


	PanoViewer.prototype.setUseZoom = function setUseZoom(useZoom) {
		typeof useZoom !== "boolean" && this._yawPitchControl.option("useZoom", useZoom);

		return this;
	};

	/**
  * When true, enables the keyboard move key control: awsd, arrow keys
  * @ko true이면 키보드 이동 키 컨트롤을 활성화합니다. (awsd, 화살표 키)
  * @method eg.view360.PanoViewer#setUseKeyboard
  * @param {Boolean} useKeyboard
  * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer 인스턴스</ko>
  */


	PanoViewer.prototype.setUseKeyboard = function setUseKeyboard(useKeyboard) {
		this._yawPitchControl.option("useKeyboard", useKeyboard);
		return this;
	};

	/**
  * Enables control through device motion. ("none", "yawPitch", "VR")
  * @ko 디바이스 움직임을 통한 컨트롤을 활성화 합니다. ("none", "yawPitch", "VR")
  * @method eg.view360.PanoViewer#setGyroMode
  * @param {String} gyroMode {@link eg.view360.PanoViewer.GYRO_MODE}
  * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer 인스턴스</ko>
  * @example
  * panoViewer.setGyroMode("yawPitch");
  * //equivalent
  * panoViewer.setGyroMode(eg.view360.PanoViewer.GYRO_MODE.YAWPITCH);
  */


	PanoViewer.prototype.setGyroMode = function setGyroMode(gyroMode) {
		this._yawPitchControl.option("gyroMode", gyroMode);
		return this;
	};

	/**
  * Set the range of controllable FOV values
  * @ko 제어 가능한 FOV 구간을 설정합니다.
  * @method eg.view360.PanoViewer#setFovRange
  * @param {Array} range
  * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer 인스턴스</ko>
  * @example
  * panoViewer.setFovRange([50, 90]);
  */


	PanoViewer.prototype.setFovRange = function setFovRange(range) {
		this._yawPitchControl.option("fovRange", range);
		return this;
	};

	/**
  * Getting the range of controllable FOV values
  * @ko 제어 가능한 FOV 구간을 반환합니다.
  * @method eg.view360.PanoViewer#getFovRange
  * @return {Array}
  * @example
  * var range = panoViewer.getFovRange(); //[50, 90]
  */


	PanoViewer.prototype.getFovRange = function getFovRange() {
		return this._yawPitchControl.option("fovRange");
	};

	/**
  * Update size of canvas element by it's container element's or specified size. If size is not specified, the size of the container area is obtained and updated to that size.
  * @ko 캔버스 엘리먼트의 크기를 컨테이너 엘리먼트의 크기나 지정된 크기로 업데이트합니다. 만약 size 가 지정되지 않으면 컨테이너 영역의 크기를 얻어와 해당 크기로 갱신합니다.
  * @method eg.view360.PanoViewer#updateViewportDimensions
  * @param {Object} [size]
  * @param {Number} [size.width=width of container]
  * @param {Number} [size.height=height of container]
  * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer 인스턴스</ko>
  */


	PanoViewer.prototype.updateViewportDimensions = function updateViewportDimensions(size) {
		if (!this._isReady) {
			return this;
		}
		this._width = size && size.width || parseInt(window.getComputedStyle(this._container).width, 10);
		this._height = size && size.height || parseInt(window.getComputedStyle(this._container).height, 10);
		this._aspectRatio = this._width / this._height;
		this._photoSphereRenderer.updateViewportDimensions(this._width, this._height);
		this._yawPitchControl.option("aspectRatio", this._aspectRatio);

		this.lookAt({}, 0);
		return this;
	};

	/**
  * Get the current field of view(FOV)
  * @ko 현재 field of view(FOV) 값을 반환합니다.
  * @method eg.view360.PanoViewer#getFov
  * @return {Number}
  */


	PanoViewer.prototype.getFov = function getFov() {
		return this._fov;
	};

	/**
  * Get the horizontal field of view in degree
  */


	PanoViewer.prototype._getHFov = function _getHFov() {
		return _mathUtil.glMatrix.toDegree(2 * Math.atan(this._aspectRatio * Math.tan(_mathUtil.glMatrix.toRadian(this._fov) / 2)));
	};

	/**
  * Get current yaw value
  * @ko 현재 yaw 값을 반환합니다.
  * @method eg.view360.PanoViewer#getYaw
  * @return {Number}
  */


	PanoViewer.prototype.getYaw = function getYaw() {
		return this._yaw;
	};

	/**
  * Get current pitch value
  * @ko 현재 pitch 값을 반환합니다.
  * @method eg.view360.PanoViewer#getPitch
  * @return {Number}
  */


	PanoViewer.prototype.getPitch = function getPitch() {
		return this._pitch;
	};

	/**
  * Get the range of controllable Yaw values
  * @ko 컨트롤 가능한 Yaw 구간을 반환합니다.
  * @method eg.view360.PanoViewer#getYawRange
  * @return {Array}
  */


	PanoViewer.prototype.getYawRange = function getYawRange() {
		return this._yawPitchControl.option("yawRange");
	};

	/**
  * Get the range of controllable Pitch values
  * @ko 컨트롤 가능한 Pitch 구간을 가져옵니다.
  * @method eg.view360.PanoViewer#getPitchRange
  * @return {Array}
  */


	PanoViewer.prototype.getPitchRange = function getPitchRange() {
		return this._yawPitchControl.option("pitchRange");
	};

	/**
  * Set the range of controllable yaw
  * @ko 컨트롤 가능한 Yaw 구간을 반환합니다.
  * @method eg.view360.PanoViewer#setYawRange
  * @param {Array} range
  * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer 인스턴스</ko>
  * @example
  * panoViewer.setYawRange([-90, 90]);
  */


	PanoViewer.prototype.setYawRange = function setYawRange(yawRange) {
		this._yawPitchControl.option("yawRange", yawRange);
		return this;
	};

	/**
  * Set the range of controllable Pitch values
  * @ko 컨트롤 가능한 Pitch 구간을 설정합니다.
  * @method eg.view360.PanoViewer#setPitchRange
  * @param {Array} range
  * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer 인스턴스</ko>
  * @example
  * panoViewer.setPitchRange([-40, 40]);
  */


	PanoViewer.prototype.setPitchRange = function setPitchRange(pitchRange) {
		this._yawPitchControl.option("pitchRange", pitchRange);
		return this;
	};

	/**
  * Specifies whether to display the pole by limiting the pitch range. If it is true, pole point can be displayed. If it is false, it is not displayed.
  * @ko pitch 범위를 제한하여 극점을 표시할지를 지정합니다. true 인 경우 극점까지 표현할 수 있으며 false 인 경우 극점까지 표시하지 않습니다.
  * @method eg.view360.PanoViewer#setShowPolePoint
  * @param {Boolean} showPolePoint
  * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer 인스턴스</ko>
  */


	PanoViewer.prototype.setShowPolePoint = function setShowPolePoint(showPolePoint) {
		this._yawPitchControl.option("showPolePoint", showPolePoint);
		return this;
	};

	/**
  * Set a new view by setting camera configuration. Any parameters not specified remain the same.
  * @ko 카메라 설정을 지정하여 화면을 갱신합니다. 지정되지 않은 매개 변수는 동일하게 유지됩니다.
  * @method eg.view360.PanoViewer#lookAt
  * @param {Object} orientation
  * @param {Number} orientation.yaw Target yaw in degree <ko>목표 yaw (degree 단위)</ko>
  * @param {Number} orientation.pitch Target pitch in degree <ko>목표 pitch (degree 단위)</ko>
  * @param {Number} orientation.fov Target vertical fov in degree <ko>목표 수직 fov (degree 단위)</ko>
  * @param {Number} duration Animation duration in milliseconds <ko>애니메이션 시간 (밀리 초)</ko>
  * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer 인스턴스</ko>
  * @example
  * // Change the yaw angle (absolute angle) to 30 degrees for one second.
  * panoViewer.lookAt({yaw: 30}, 1000);
  */


	PanoViewer.prototype.lookAt = function lookAt(orientation, duration) {
		if (!this._isReady) {
			return this;
		}

		var yaw = orientation.yaw !== undefined ? orientation.yaw : this._yaw;
		var pitch = orientation.pitch !== undefined ? orientation.pitch : this._pitch;
		var pitchRange = this._yawPitchControl.option("pitchRange");
		var verticalAngleOfImage = pitchRange[1] - pitchRange[0];
		var fov = orientation.fov !== undefined ? orientation.fov : this._fov;

		if (verticalAngleOfImage < fov) {
			fov = verticalAngleOfImage;
		}

		this._yawPitchControl.lookAt({ yaw: yaw, pitch: pitch, fov: fov }, duration);

		if (duration === 0) {
			this._photoSphereRenderer.render(yaw, pitch, fov);
		}
		return this;
	};

	PanoViewer.prototype._activate = function _activate() {
		this._photoSphereRenderer.attachTo(this._container);
		this._yawPitchControl.enable();

		this.updateViewportDimensions();

		this._isReady = true;
		this._triggerEvent(_consts.EVENTS.READY);
		this._startRender();
	};

	/**
  * Register the callback on the raf to call _renderLoop every frame.
  */


	PanoViewer.prototype._startRender = function _startRender() {
		this._renderLoop = this._renderLoop.bind(this);
		this._rafId = window.requestAnimationFrame(this._renderLoop);
	};

	PanoViewer.prototype._renderLoop = function _renderLoop() {
		if (this._photoSphereRenderer) {
			if (this._quaternion) {
				this._photoSphereRenderer.renderWithQuaternion(this._quaternion, this._fov);
			} else {
				this._photoSphereRenderer.render(this._yaw, this._pitch, this._fov);
			}
		}
		this._rafId = window.requestAnimationFrame(this._renderLoop);
	};

	PanoViewer.prototype._stopRender = function _stopRender() {
		if (this._rafId) {
			window.cancelAnimationFrame(this._rafId);
			delete this._rafId;
		}
	};

	/**
  * Destroy webgl context and block user interaction and stop rendering
  */


	PanoViewer.prototype._deactivate = function _deactivate() {
		if (this._photoSphereRenderer) {
			this._photoSphereRenderer.destroy();
			this._photoSphereRenderer = null;
		}

		if (this._isReady) {
			this._yawPitchControl.disable();
			this._stopRender();
			this._isReady = false;
		}
	};

	PanoViewer._isValidTouchDirection = function _isValidTouchDirection(direction) {
		return direction === PanoViewer.TOUCH_DIRECTION.NONE || direction === PanoViewer.TOUCH_DIRECTION.YAW || direction === PanoViewer.TOUCH_DIRECTION.PITCH || direction === PanoViewer.TOUCH_DIRECTION.ALL;
	};

	/**
  * Set touch direction by which user can control.
  * @ko 사용자가 조작가능한 터치 방향을 지정합니다.
  * @method eg.view360.PanoViewer#setTouchDirection
  * @param {Number} direction of the touch. {@link eg.view360.PanoViewer.TOUCH_DIRECTION}<ko>컨트롤 가능한 방향 {@link eg.view360.PanoViewer.TOUCH_DIRECTION}</ko>
  * @return {eg.view360.PanoViewer} PanoViewer instance
  * @example
  *
  * panoViewer = new PanoViewer(el);
  * // Limit the touch direction to the yaw direction only.
  * panoViewer.setTouchDirection(eg.view360.PanoViewer.TOUCH_DIRECTION.YAW);
  */


	PanoViewer.prototype.setTouchDirection = function setTouchDirection(direction) {
		if (PanoViewer._isValidTouchDirection(direction)) {
			this._yawPitchControl.option("touchDirection", direction);
		}

		return this;
	};

	/**
  * Returns touch direction by which user can control
  * @ko 사용자가 조작가능한 터치 방향을 반환한다.
  * @method eg.view360.PanoViewer#getTouchDirection
  * @return {Number} direction of the touch. {@link eg.view360.PanoViewer.TOUCH_DIRECTION}<ko>컨트롤 가능한 방향 {@link eg.view360.PanoViewer.TOUCH_DIRECTION}</ko>
  * @example
  *
  * panoViewer = new PanoViewer(el);
  * // Returns the current touch direction.
  * var dir = panoViewer.getTouchDirection();
  */


	PanoViewer.prototype.getTouchDirection = function getTouchDirection() {
		return this._yawPitchControl.option("touchDirection");
	};

	/**
  * Destroy viewer. Remove all registered event listeners and remove viewer canvas.
  * @ko 뷰어 인스턴스를 해제합니다. 모든 등록된 이벤트리스너를 제거하고 뷰어 캔버스를 삭제합니다.
  * @method eg.view360.PanoViewer#destroy
  * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer 인스턴스</ko>
  */


	PanoViewer.prototype.destroy = function destroy() {
		this._deactivate();

		if (this._yawPitchControl) {
			this._yawPitchControl.destroy();
			this._yawPitchControl = null;
		}

		return this;
	};

	/**
  * Check whether the current environment supports the WebGL
  * @ko 현재 브라우저 환경이 WebGL 을 지원하는지 여부를 확인합니다.
  * @function isWebGLAvailable
  * @memberof eg.view360.PanoViewer
  * @return {Boolean} WebGL support <ko>WebGL 지원여부</ko>
  * @static
  */


	PanoViewer.isWebGLAvailable = function isWebGLAvailable() {
		return _WebGLUtils2["default"].isWebGLAvailable();
	};

	/**
  * Check whether the current environment supports the gyro sensor.
  * @ko 현재 브라우저 환경이 자이로 센서를 지원하는지 여부를 확인합니다.
  * @function isGyroSensorAvailable
  * @memberof eg.view360.PanoViewer
  * @param {Function} callback Function to take the gyro sensor availability as argument <ko>자이로 센서를 지원하는지 여부를 인자로 받는 함수</ko>
  * @static
  */


	PanoViewer.isGyroSensorAvailable = function isGyroSensorAvailable(callback) {
		if (!_browser.DeviceMotionEvent) {
			callback && callback(false);
			return;
		}

		var onDeviceMotionChange = void 0;

		function checkGyro() {
			return new _Promise(function (res, rej) {
				onDeviceMotionChange = function onDeviceMotionChange(deviceMotion) {
					var isGyroSensorAvailable = !(deviceMotion.rotationRate.alpha == null);

					res(isGyroSensorAvailable);
				};

				window.addEventListener("devicemotion", onDeviceMotionChange);
			});
		}

		function timeout() {
			return new _Promise(function (res, rej) {
				setTimeout(function () {
					return res(false);
				}, 1000);
			});
		}

		_Promise.race([checkGyro(), timeout()]).then(function (isGyroSensorAvailable) {
			window.removeEventListener("devicemotion", onDeviceMotionChange);

			callback && callback(isGyroSensorAvailable);

			PanoViewer.isGyroSensorAvailable = function (fb) {
				fb && fb(isGyroSensorAvailable);
				return isGyroSensorAvailable;
			};
		});
	};

	return PanoViewer;
}(_component2["default"]);

exports["default"] = PanoViewer;


PanoViewer.ERROR_TYPE = _consts.ERROR_TYPE;
PanoViewer.EVENTS = _consts.EVENTS;
PanoViewer.PROJECTION_TYPE = _consts.PROJECTION_TYPE;
PanoViewer.GYRO_MODE = _consts.GYRO_MODE;
// It should be deprecated!
PanoViewer.ProjectionType = _consts.PROJECTION_TYPE;
/**
 * Constant value for touch directions
 * @ko 터치 방향에 대한 상수 값.
 * @namespace
 * @name TOUCH_DIRECTION
 * @memberof eg.view360.PanoViewer
 */
PanoViewer.TOUCH_DIRECTION = {
	/**
  * Constant value for none direction.
  * @ko none 방향에 대한 상수 값.
  * @name NONE
  * @memberof eg.view360.PanoViewer.TOUCH_DIRECTION
  * @constant
  * @type {Number}
  * @default 1
  */
	NONE: _YawPitchControl.YawPitchControl.TOUCH_DIRECTION_NONE,
	/**
  * Constant value for horizontal(yaw) direction.
  * @ko horizontal(yaw) 방향에 대한 상수 값.
  * @name YAW
  * @memberof eg.view360.PanoViewer.TOUCH_DIRECTION
  * @constant
  * @type {Number}
  * @default 6
  */
	YAW: _YawPitchControl.YawPitchControl.TOUCH_DIRECTION_YAW,
	/**
  * Constant value for vertical direction.
  * @ko vertical(pitch) 방향에 대한 상수 값.
  * @name PITCH
  * @memberof eg.view360.PanoViewer.TOUCH_DIRECTION
  * @constant
  * @type {Number}
  * @default 24
  */
	PITCH: _YawPitchControl.YawPitchControl.TOUCH_DIRECTION_PITCH,
	/**
  * Constant value for all direction.
  * @ko all 방향에 대한 상수 값.
  * @name ALL
  * @memberof eg.view360.PanoViewer.TOUCH_DIRECTION
  * @constant
  * @type {Number}
  * @default 30
  */
	ALL: _YawPitchControl.YawPitchControl.TOUCH_DIRECTION_ALL
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var win = window;

exports.window = win;
var DeviceMotionEvent = exports.DeviceMotionEvent = win.DeviceMotionEvent;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.VERSION = exports.PanoViewer = undefined;

var _PanoViewer = __webpack_require__(29);

var _PanoViewer2 = _interopRequireDefault(_PanoViewer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var VERSION = "3.0.0-rc";

exports.PanoViewer = _PanoViewer2["default"];
exports.VERSION = VERSION;


_PanoViewer2["default"].VERSION = VERSION;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

var _axes = __webpack_require__(11);

var _axes2 = _interopRequireDefault(_axes);

var _SpriteImage = __webpack_require__(14);

var _SpriteImage2 = _interopRequireDefault(_SpriteImage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DEFAULT_PAN_SCALE = 0.21;

/**
 * @class eg.view360.SpinViewer
 * @classdesc A module used to displays each image sequentially according to the direction of the user's touch movement (left / right) of the sprite image that is collected by rotating the object.
 * @ko 물체 주위를 회전하여 촬영한 이미지들을 모은 스프라이트 이미지를 사용자의 터치 이동 방향(좌 / 우) 에 따라 각 이미지들을 순차적으로 보여주는 컴포넌트입니다.
 * @extends eg.Component
 *
 * @param {HTMLElement} element The element to show the image <ko>이미지를 보여줄 대상 요소</ko>
 * @param {Object} options The option object<ko>파라미터 객체</ko>
 * @param {String} options.imageUrl The url of the sprite image <ko>스프라이트 이미지의 url</ko>
 * @param {Number} [options.rowCount=1] Number of horizontal frames in the sprite image <ko>스프라이트 이미지의 가로 프레임 갯수</ko>
 * @param {Number} [options.colCount=1] Number of vertical frames in the sprite image <ko>스프라이트 이미지의 세로 프레임 갯수</ko>
 * @param {Number|String} [options.width="auto"] The width of the target element to show the image <ko>이미지를 보여줄 대상 요소의 너비</ko>
 * @param {Number|String} [options.height="auto"] The height of the target element to show the image <ko>이미지를 보여줄 대상 요소의 높이</ko>
 * @param {Boolean} [options.autoHeight=true] Whether to automatically set the height of the image area to match the original image's proportion <ko>원본 이미지 비율에 맞게 이미지 영역의 높이를 자동으로 설정할지 여부</ko>
 * @param {Number[]} [options.colRow=[0, 0]] The column, row coordinates of the first frame of the sprite image (based on 0 index) <ko> 스프라이트 이미지 중 처음 보여줄 프레임의 (column, row) 좌표 (0 index 기반)</ko>
 * @param {Number} [options.scale=1] Spin scale (The larger the spin, the more).<ko>Spin 배율 (클 수록 더 많이 움직임)</ko>
 * @support {"ie": "9+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.3+ (except 3.x)"}
 * @example
 *
 * // Initialize SpinViewer
 * var el = document.getElementById("product-360");
 * var viewer = new eg.view360.SpinViewer(el, {
 * 	imageUrl: "/img/bag360.jpg", // required
 * 	rowCount: 24 //required
 * });
 */

var SpinViewer = function (_Component) {
	_inherits(SpinViewer, _Component);

	function SpinViewer(element, options) {
		_classCallCheck(this, SpinViewer);

		var _this = _possibleConstructorReturn(this, _Component.call(this));

		_this._el = element;

		var opt = _extends({}, options);
		var colCount = opt.colCount || 1;
		var rowCount = opt.rowCount || 1;

		_this._scale = opt.scale || 1;
		_this._panScale = _this._scale * DEFAULT_PAN_SCALE;

		_this._frameCount = colCount * rowCount;

		// Init SpriteImage
		_this._sprites = new _SpriteImage2["default"](element, opt).on({
			"load": function load(evt) {
				/**
     * Events that occur when component loading is complete
     * @ko 컴포넌트 로딩이 완료되면 발생하는 이벤트
     * @name eg.view360.SpinViewer#load
     * @event
     * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @param {HTMLElement} param.target The target element for which to display the image <ko>이미지를 보여줄 대상 엘리먼트</ko>
     * @param {HTMLElement} param.bgElement Generated background image element <ko>생성된 background 이미지 엘리먼트</ko>
     *
     * @example
     *
     * viwer.on({
     *	"load" : function(evt) {
     *		this.spinBy({angle: 360, duration: 300});
     *	}
     * });
     */
				_this.trigger("load", evt);
			},
			"imageError": function imageError(evt) {
				/**
     * An event that occurs when the image index is changed by the user's left / right panning
     * @ko 사용자의 좌우 Panning 에 의해 이미지 인덱스가 변경되었을때 발생하는 이벤트
     * @name eg.view360.SpinViewer#imageError
     * @event
     * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @param {String} param.imageUrl User-specified image URL <ko>사용자가 지정한 이미지 URL</ko>
     *
     * @example
     *
     * viewer.on({
     *	"imageError" : function(evt) {
     *		// Error handling
     *		console.log(e.imageUrl);
     *	}
     * });
     */
				_this.trigger("imageError", {
					imageUrl: evt.imageUrl
				});
			}
		});

		// Init Axes
		_this._panInput = new _axes.PanInput(_this._el, {
			scale: [_this._panScale, _this._panScale]
		});
		_this._axes = new _axes2["default"]({
			angle: {
				range: [0, 359],
				circular: true
			}
		}).on({
			"change": function change(evt) {
				var curr = Math.floor(evt.pos.angle / (360 / _this._frameCount));
				var frameIndex = _this._frameCount - curr - 1;

				_this._sprites.setFrameIndex(frameIndex);

				/**
     * An event that occurs when the image index is changed by the user's left / right panning
     * @ko 사용자의 좌우 Panning 에 의해 이미지 인덱스가 변경되었을때 발생하는 이벤트
     * @name eg.view360.SpinViewer#change
     * @event
     * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @param {Number[]} param.colRow Column, row of the frame in the sprite image <ko>스프라이트 이미지 내 프레임의 column, row</ko>
     * @param {Number} param.frameIndex Index value that is sequentially appended in Z direction based on col and row.<ko>col, row 를 기반으로 Z 방향으로 순차적으로 붙여지는 index 값</ko>
     * @param {Number} param.angle The angle that is currently internally held at an angle between 0 and 359. (not a real product angle) <ko>0 ~ 359 범위의 각도로 현재 내부적으로 유지하고 있는 각도 (실제 이미지의 각도가 아님)</ko>
     *
     * @example
     *
     * viwer.on({
     *	"change" : function(evt) {
     *		console.log(event.frameIndex, event.colRow, event.angle);   // event.colRow = [0, 4] event.frameIndex = 4, event = 30
     *	}
     * });
     */
				_this.trigger("change", {
					frameIndex: frameIndex,
					colRow: _this._sprites.getColRow(),
					angle: evt.pos.angle
				});
			},
			"animationEnd": function animationEnd(evt) {
				/**
     * This event is fired when animation ends.
     * @ko 에니메이션이 끝났을 때 발생하는 이벤트
     * @name eg.view360.SpinViewer#animationEnd
     * @event
     * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @param {Boolean} param.isTrusted true if an event was generated by the user action, or false if it was caused by a script or API call<ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
     *
     * @example
     *
     * viwer.on({
     *	"animationEnd" : function(evt) {
     *		// evt.isTrusted === true or false
     *	}
     * });
     */
				_this.trigger("animationEnd", {
					isTrusted: evt.isTrusted
				});
			}
		});

		_this._axes.connect("angle", _this._panInput);
		return _this;
	}

	/**
  * Set spin scale
  * @ko scale 을 조정할 수 있는 함수
  * @method eg.view360.SpinViewer#setScale
  * @param {Number} scale Rotation multiples at spin, the larger the rotation<ko>Spin 시 회전 배수값, 커질 수록 더 많이 회전</ko>
  *
  * @return {Object} Instance of SpinViewer <ko>SpinViewer 인스턴스</ko>
  *
  * @example
  *
  * viewer.setScale(2);// It moves twice as much.
  */


	SpinViewer.prototype.setScale = function setScale(scale) {
		if (isNaN(scale) || scale < 0) {
			return this;
		}

		this._scale = scale;
		this._panScale = scale * DEFAULT_PAN_SCALE;
		this._panInput.options.scale = [this._panScale, this._panScale];

		return this;
	};

	/**
  * Get spin scale
  * @ko scale 값을 반환한다.
  * @method eg.view360.SpinViewer#getScale
  *
  * @return {Number} Rotation multiples at spin, the larger the rotation<ko>Spin 시 회전 배수값, 커질 수록 더 많이 회전</ko>
  *
  * @example
  *
  * viewer.getScale();// It returns number
  */


	SpinViewer.prototype.getScale = function getScale() {
		return this._scale;
	};

	/**
  * It gives the effect of rotating for a certain duration by the specified angle based on the current rotation angle.
  * @ko 현재 회전 각도를 기준으로 지정된 각도(angle)만큼 일정 시간동안(duration) 회전하는 효과를 준다.
  * @method eg.view360.SpinViewer#spinBy
  *
  * @param {Number} [angle = 0] angle<ko>상대적 회전 각도</ko>
  * @param {Object} param The parameter object<ko>파라미터 객체</ko>
  * @param {Number} [param.duration = 0] duration<ko>회전할 시간 - 밀리세컨드 단위</ko>
  *
  * @return {Object} Instance of SpinViewer <ko>SpinViewer 인스턴스</ko>
  *
  * @example
  *
  * viewer.spinBy(720, {duration: 500});
  */


	SpinViewer.prototype.spinBy = function spinBy() {
		var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
		var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { duration: 0 };

		this._axes.setBy({ angle: angle }, param.duration);
		return this;
	};

	/**
  * It gives the effect of rotating for a certain duration (duration) by the specified angle (angle).
  * @ko 지정된 각도(angle)만큼 일정 시간동안(duration) 회전하는 효과를 준다.
  * @method eg.view360.SpinViewer#spinTo
  *
  * @param {Number} [angle = 0] angle<ko>회전 각도</ko>
  * @param {Object} param The parameter object<ko>파라미터 객체</ko>
  * @param {Number} [param.duration = 0] duration<ko>회전할 시간 - 밀리세컨드 단위</ko>
  *
  * @return {Object} Instance of SpinViewer <ko>SpinViewer 인스턴스</ko>
  *
  * @example
  *
  * viewer.spinTo(30, {duration:100});
  */


	SpinViewer.prototype.spinTo = function spinTo() {
		var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
		var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { duration: 0 };

		this._axes.setTo({ angle: angle }, param.duration);
		return this;
	};

	/**
  * Returns current angles
  * @ko 지정된 각도(angle)만큼 일정 시간동안(duration) 회전하는 효과를 준다.
  *
  * @return {Number} Current angle <ko>현재 각도</ko>
  */


	SpinViewer.prototype.getAngle = function getAngle() {
		return this._axes.get().angle || 0;
	};

	return SpinViewer;
}(_component2["default"]);

exports["default"] = SpinViewer;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.VERSION = exports.SpriteImage = exports.SpinViewer = undefined;

var _SpinViewer = __webpack_require__(32);

var _SpinViewer2 = _interopRequireDefault(_SpinViewer);

var _SpriteImage = __webpack_require__(14);

var _SpriteImage2 = _interopRequireDefault(_SpriteImage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var VERSION = "3.0.0-rc";

exports.SpinViewer = _SpinViewer2["default"];
exports.SpriteImage = _SpriteImage2["default"];
exports.VERSION = VERSION;


_SpinViewer2["default"].VERSION = VERSION;
_SpriteImage2["default"].VERSION = VERSION;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

var _FusionPoseSensor = __webpack_require__(17);

var _FusionPoseSensor2 = _interopRequireDefault(_FusionPoseSensor);

var _ScreenRotationAngle = __webpack_require__(15);

var _ScreenRotationAngle2 = _interopRequireDefault(_ScreenRotationAngle);

var _mathUtil = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ORIGIN_VECTOR = _mathUtil.vec3.fromValues(0, 0, 0);
var X_AXIS_VECTOR = _mathUtil.vec3.fromValues(1, 0, 0);
var Y_AXIS_VECTOR = _mathUtil.vec3.fromValues(0, 1, 0);

var DeviceQuaternion = function (_Component) {
	_inherits(DeviceQuaternion, _Component);

	function DeviceQuaternion() {
		_classCallCheck(this, DeviceQuaternion);

		var _this = _possibleConstructorReturn(this, _Component.call(this));

		_this._screenRotationAngle = new _ScreenRotationAngle2["default"]();
		_this._fusionPoseSensor = new _FusionPoseSensor2["default"]();
		_this._quaternion = _mathUtil.quat.create();

		_this._fusionPoseSensor.enable();
		_this._fusionPoseSensor.on("change", function (e) {
			_this._quaternion = e.quaternion;

			_this.trigger("change", { isTrusted: true });
		});
		return _this;
	}

	DeviceQuaternion.prototype.getCombinedQuaternion = function getCombinedQuaternion(yaw, pitch) {
		var deviceR = this._screenRotationAngle.getRadian();

		// rotate x-axis around z-axis about screen rotation angle.
		var pitchAxis = _mathUtil.vec3.rotateZ(_mathUtil.vec3.create(), X_AXIS_VECTOR, ORIGIN_VECTOR, deviceR);
		var yawQ = _mathUtil.quat.setAxisAngle(_mathUtil.quat.create(), Y_AXIS_VECTOR, _mathUtil.glMatrix.toRadian(-yaw));
		// rotate quaternion around new x-axis about pitch angle.
		var pitchQ = _mathUtil.quat.setAxisAngle(_mathUtil.quat.create(), pitchAxis, _mathUtil.glMatrix.toRadian(-pitch));
		var conj = _mathUtil.quat.conjugate(_mathUtil.quat.create(), this._quaternion);
		// Multiply pitch quaternion -> device quaternion -> yaw quaternion
		var outQ = _mathUtil.quat.multiply(_mathUtil.quat.create(), pitchQ, conj);

		_mathUtil.quat.multiply(outQ, outQ, yawQ);
		return outQ;
	};

	DeviceQuaternion.prototype.destroy = function destroy() {
		// detach all event handler
		this.off();

		if (this._fusionPoseSensor) {
			this._fusionPoseSensor.off();
			this._fusionPoseSensor.destroy();
			this._fusionPoseSensor = null;
		}

		if (this._screenRotationAngle) {
			this._screenRotationAngle.unref();
			this._screenRotationAngle = null;
		}
	};

	return DeviceQuaternion;
}(_component2["default"]);

exports["default"] = DeviceQuaternion;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

var _axes = __webpack_require__(11);

var _axes2 = _interopRequireDefault(_axes);

var _browser = __webpack_require__(4);

var _WheelInput = __webpack_require__(40);

var _WheelInput2 = _interopRequireDefault(_WheelInput);

var _TiltMotionInput = __webpack_require__(39);

var _TiltMotionInput2 = _interopRequireDefault(_TiltMotionInput);

var _RotationPanInput = __webpack_require__(38);

var _RotationPanInput2 = _interopRequireDefault(_RotationPanInput);

var _DeviceQuaternion = __webpack_require__(34);

var _DeviceQuaternion2 = _interopRequireDefault(_DeviceQuaternion);

var _mathUtil = __webpack_require__(1);

var _consts = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DEFAULT_YAW_RANGE = [-_consts.YAW_RANGE_HALF, _consts.YAW_RANGE_HALF];
var DEFAULT_PITCH_RANGE = [-_consts.PITCH_RANGE_HALF, _consts.PITCH_RANGE_HALF];
var CIRCULAR_PITCH_RANGE = [-_consts.CIRCULAR_PITCH_RANGE_HALF, _consts.CIRCULAR_PITCH_RANGE_HALF];
/**
 * A module used to provide coordinate based on yaw/pitch orientation. This module receives user touch action, keyboard, mouse and device orientation(if it exists) as input, then combines them and converts it to yaw/pitch coordinates.
 *
 * @alias eg.YawPitchControl
 * @extends eg.Component
 *
 * @support {"ie": "10+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.3+ (except 3.x)"}
 */
var YawPitchControl = function (_Component) {
	_inherits(YawPitchControl, _Component);

	/**
  * @param {Object} options The option object of the eg.YawPitch module
  * @param {Element}[options.element=null] element A base element for the eg.YawPitch module
  * @param {Number} [options.yaw=0] initial yaw (degree)
  * @param {Number} [options.pitch=0] initial pitch (degree)
  * @param {Number} [options.fov=65] initial field of view (degree)
  * @param {Boolean} [optiosn.showPolePoint=true] Indicates whether pole is shown
  * @param {Boolean} [options.useZoom=true] Indicates whether zoom is available
  * @param {Boolean} [options.useKeyboard=true] Indicates whether keyboard is enabled
  * @param {String} [config.gyroMode=yawPitch] Enables control through device motion.
  * @param {Number} [options.touchDirection=TOUCH_DIRECTION_ALL] Direction of the touch movement (TOUCH_DIRECTION_ALL: all,  TOUCH_DIRECTION_YAW: horizontal, TOUCH_DIRECTION_PITCH: vertical, TOUCH_DIRECTION_NONE: no move)
  * @param {Array} [options.yawRange=[-180, 180] Range of visible yaw
  * @param {Array} [options.pitchRange=[-90, 90] Range of visible pitch
  * @param {Array} [options.fovRange=[30, 110] Range of FOV
  * @param {Number} [options.aspectRatio=1] Aspect Ratio
  */
	function YawPitchControl(options) {
		_classCallCheck(this, YawPitchControl);

		var _this = _possibleConstructorReturn(this, _Component.call(this));

		var opt = _extends({
			element: null,
			yaw: 0,
			pitch: 0,
			fov: 65,
			showPolePoint: false,
			useZoom: true,
			useKeyboard: true,
			gyroMode: _consts.GYRO_MODE.YAWPITCH,
			touchDirection: _consts.TOUCH_DIRECTION_ALL,
			yawRange: DEFAULT_YAW_RANGE,
			pitchRange: DEFAULT_PITCH_RANGE,
			fovRange: [30, 110],
			aspectRatio: 1 /* TODO: Need Mandatory? */
		}, options);

		_this._element = opt.element;
		_this._initialFov = opt.fov;
		_this._enabled = false;
		_this._isAnimating = false;
		_this._deviceQuaternion = null;

		_this._initAxes(opt);
		_this.option(opt);
		return _this;
	}

	YawPitchControl.prototype._initAxes = function _initAxes(opt) {
		var _this2 = this;

		var yRange = this._updateYawRange(opt.yawRange, opt.fov, opt.aspectRatio);
		var pRange = this._updatePitchRange(opt.pitchRange, opt.fov, opt.showPolePoint);
		var useRotation = opt.gyroMode === _consts.GYRO_MODE.VR;

		this.axesPanInput = new _RotationPanInput2["default"](this._element, { useRotation: useRotation });
		this.axesWheelInput = new _WheelInput2["default"](this._element, { scale: 4 });
		this.axesTiltMotionInput = null;
		this.axesPinchInput = _browser.SUPPORT_TOUCH ? new _axes.PinchInput(this._element, { scale: -1 }) : null;
		this.axesMoveKeyInput = new _axes.MoveKeyInput(this._element, { scale: [-6, 6] });

		this.axes = new _axes2["default"]({
			yaw: {
				range: yRange,
				circular: YawPitchControl.isCircular(yRange),
				bounce: [0, 0]
			},
			pitch: {
				range: pRange,
				circular: YawPitchControl.isCircular(pRange),
				bounce: [0, 0]
			},
			fov: {
				range: opt.fovRange,
				circular: [false, false],
				bounce: [0, 0]
			}
		}, {
			deceleration: _consts.MC_DECELERATION,
			maximumDuration: _consts.MC_MAXIMUM_DURATION
		}, {
			yaw: opt.yaw,
			pitch: opt.pitch,
			fov: opt.fov
		}).on({
			hold: function hold(evt) {
				_this2.trigger("hold", { isTrusted: evt.isTrusted });
			},
			change: function change(evt) {
				if (evt.delta.fov !== 0) {
					_this2._setPanScale(evt.pos.fov);
					_this2._updateControlScale(evt);
				}
				_this2._triggerChange(evt);
			},
			release: function release(evt) {
				_this2._triggerChange(evt);
			},
			animationStart: function animationStart(evt) {},
			animationEnd: function animationEnd(evt) {
				_this2.trigger("animationEnd", { isTrusted: evt.isTrusted });
			}
		});
	};

	YawPitchControl.prototype._setPanScale = function _setPanScale(fov) {
		var areaHeight = parseInt((0, _browser.getComputedStyle)(this._element).height, 10);
		var scale = _consts.MC_BIND_SCALE[0] * fov / this._initialFov * _consts.PAN_SCALE / areaHeight;

		this.axesPanInput.options.scale = [scale, scale];
		this.axes.options.deceleration = _consts.MC_DECELERATION * fov / _consts.MAX_FIELD_OF_VIEW;
	};

	/*
  * Override component's option method
  * to call method for updating values which is affected by option change.
  *
  * @param {*} args
  */


	YawPitchControl.prototype.option = function option() {
		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		var argLen = args.length;

		// Getter
		if (argLen === 0) {
			return this._getOptions();
		} else if (argLen === 1 && typeof args[0] === "string") {
			return this._getOptions(args[0]);
		}

		// Setter
		var beforeOptions = _extends({}, this.options);
		var newOptions = {};
		var changedKeyList = []; // TODO: if value is not changed, then do not push on changedKeyList.

		if (argLen === 1) {
			changedKeyList = Object.keys(args[0]);
			newOptions = _extends({}, args[0]);
		} else if (argLen >= 2) {
			changedKeyList.push(args[0]);
			newOptions[args[0]] = args[1];
		}

		this._setOptions(this._getValidatedOptions(newOptions));
		this._applyOptions(changedKeyList, beforeOptions);
		return this;
	};

	YawPitchControl.prototype._getValidatedOptions = function _getValidatedOptions(newOptions) {
		if (newOptions.yawRange) {
			newOptions.yawRange = this._getValidYawRange(newOptions.yawRange, newOptions.fov, newOptions.aspectRatio);
		}
		if (newOptions.pitchRange) {
			newOptions.pitchRange = this._getValidPitchRange(newOptions.pitchRange, newOptions.fov);
		}
		return newOptions;
	};

	YawPitchControl.prototype._getOptions = function _getOptions(key) {
		var value = void 0;

		if (typeof key === "string") {
			value = this.options[key];
		} else if (arguments.length === 0) {
			value = this.options;
		}
		return value;
	};

	YawPitchControl.prototype._setOptions = function _setOptions(options) {
		for (var key in options) {
			this.options[key] = options[key];
		}
	};

	YawPitchControl.prototype._applyOptions = function _applyOptions(keys, prevOptions) {
		// If one of below is changed, call updateControlScale()
		if (keys.some(function (key) {
			return key === "showPolePoint" || key === "fov" || key === "aspectRatio" || key === "yawRange" || key === "pitchRange";
		})) {
			this._updateControlScale();
		}

		if (keys.some(function (key) {
			return key === "fovRange";
		})) {
			var fovRange = this.options.fovRange;
			var prevFov = this.axes.get().fov;
			var nextFov = this.axes.get().fov;

			_mathUtil.vec2.copy(this.axes.axis.fov.range, fovRange);

			if (nextFov < fovRange[0]) {
				nextFov = fovRange[0];
			} else if (prevFov > fovRange[1]) {
				nextFov = fovRange[1];
			}

			if (prevFov !== nextFov) {
				this.axes.setTo({
					fov: nextFov
				}, 0);
				this._updateControlScale();
			}
		}

		if (keys.some(function (key) {
			return key === "gyroMode";
		}) && _browser.SUPPORT_DEVICEMOTION) {
			var isVR = this.options.gyroMode === _consts.GYRO_MODE.VR;
			var isYawPitch = this.options.gyroMode === _consts.GYRO_MODE.YAWPITCH;

			// Disconnect first
			if (this.axesTiltMotionInput) {
				this.axes.disconnect(this.axesTiltMotionInput);
				this.axesTiltMotionInput.destroy();
				this.axesTiltMotionInput = null;
			}

			if (this._deviceQuaternion) {
				this._deviceQuaternion.destroy();
				this._deviceQuaternion = null;
			}

			if (isVR) {
				this._initDeviceQuaternion();
			} else if (isYawPitch) {
				this.axesTiltMotionInput = new _TiltMotionInput2["default"](this._element);
				this.axes.connect(["yaw", "pitch"], this.axesTiltMotionInput);
			}

			this.axesPanInput.setUseRotation(isVR);
		}

		if (keys.some(function (key) {
			return key === "useKeyboard";
		})) {
			var useKeyboard = this.options.useKeyboard;

			if (useKeyboard) {
				this.axes.connect(["yaw", "pitch"], this.axesMoveKeyInput);
			} else {
				this.axes.disconnect(this.axesMoveKeyInput);
			}
		}

		if (keys.some(function (key) {
			return key === "useZoom";
		})) {
			var useZoom = this.options.useZoom;

			// Disconnect first
			this.axes.disconnect(this.axesWheelInput);
			if (useZoom) {
				this.axes.connect(["fov"], this.axesWheelInput);
			}
		}

		this._togglePinchInputByOption(this.options.touchDirection, this.options.useZoom);

		if (keys.some(function (key) {
			return key === "touchDirection";
		})) {
			this._enabled && this._enableTouch(this.options.touchDirection);
		}
	};

	YawPitchControl.prototype._togglePinchInputByOption = function _togglePinchInputByOption(touchDirection, useZoom) {
		if (this.axesPinchInput) {
			// disconnect first
			this.axes.disconnect(this.axesPinchInput);

			// If the touchDirection option is not ALL, pinchInput should be disconnected to make use of a native scroll.
			if (useZoom && touchDirection === _consts.TOUCH_DIRECTION_ALL &&
			// TODO: Get rid of using private property of axes instance.
			this.axes._inputs.indexOf(this.axesPinchInput) === -1) {
				this.axes.connect(["fov"], this.axesPinchInput);
			}
		}
	};

	YawPitchControl.prototype._enableTouch = function _enableTouch(direction) {
		// Disconnect first
		this.axesPanInput && this.axes.disconnect(this.axesPanInput);

		var yawEnabled = direction & _consts.TOUCH_DIRECTION_YAW ? "yaw" : null;
		var pitchEnabled = direction & _consts.TOUCH_DIRECTION_PITCH ? "pitch" : null;

		this.axes.connect([yawEnabled, pitchEnabled], this.axesPanInput);
	};

	YawPitchControl.prototype._initDeviceQuaternion = function _initDeviceQuaternion() {
		var _this3 = this;

		this._deviceQuaternion = new _DeviceQuaternion2["default"]();
		this._deviceQuaternion.on("change", function (e) {
			_this3._triggerChange(e);
		});
	};

	YawPitchControl.prototype._getValidYawRange = function _getValidYawRange(newYawRange, newFov, newAspectRatio) {
		var ratio = YawPitchControl.adjustAspectRatio(newAspectRatio || this.options.aspectRatio || 1);
		var fov = newFov || this.axes.get().fov;
		var horizontalFov = fov * ratio;
		var isValid = newYawRange[1] - newYawRange[0] >= horizontalFov;

		if (isValid) {
			return newYawRange;
		} else {
			return this.options.yawRange || DEFAULT_YAW_RANGE;
		}
	};

	YawPitchControl.prototype._getValidPitchRange = function _getValidPitchRange(newPitchRange, newFov) {
		var fov = newFov || this.axes.get().fov;
		var isValid = newPitchRange[1] - newPitchRange[0] >= fov;

		if (isValid) {
			return newPitchRange;
		} else {
			return this.options.pitchRange || DEFAULT_PITCH_RANGE;
		}
	};

	YawPitchControl.isCircular = function isCircular(range) {
		return range[1] - range[0] < 360 ? [false, false] : [true, true];
	};

	/**
  * Update yaw/pitch min/max by 5 factor
  *
  * 1. showPolePoint
  * 2. fov
  * 3. yawRange
  * 4. pitchRange
  * 5. aspectRatio
  *
  * If one of above is changed, call this function
  */


	YawPitchControl.prototype._updateControlScale = function _updateControlScale(changeEvt) {
		var opt = this.options;
		var fov = this.axes.get().fov;

		var pRange = this._updatePitchRange(opt.pitchRange, fov, opt.showPolePoint);
		var yRange = this._updateYawRange(opt.yawRange, fov, opt.aspectRatio);

		// TODO: If not changed!?
		var pos = this.axes.get();
		var y = pos.yaw;
		var p = pos.pitch;

		_mathUtil.vec2.copy(this.axes.axis.yaw.range, yRange);
		_mathUtil.vec2.copy(this.axes.axis.pitch.range, pRange);
		this.axes.axis.yaw.circular = YawPitchControl.isCircular(yRange);
		this.axes.axis.pitch.circular = YawPitchControl.isCircular(pRange);

		/**
   * update yaw/pitch by it's range.
   */
		if (y < yRange[0]) {
			y = yRange[0];
		} else if (y > yRange[1]) {
			y = yRange[1];
		}

		if (p < pRange[0]) {
			p = pRange[0];
		} else if (p > pRange[1]) {
			p = pRange[1];
		}

		if (changeEvt) {
			changeEvt.set({
				yaw: y,
				pitch: p
			});
		}

		this.axes.setTo({
			yaw: y,
			pitch: p
		}, 0);

		return this;
	};

	YawPitchControl.prototype._updatePitchRange = function _updatePitchRange(pitchRange, fov, showPolePoint) {
		if (this.options.gyroMode === _consts.GYRO_MODE.VR) {
			// Circular pitch on VR
			return CIRCULAR_PITCH_RANGE;
		}

		var verticalAngle = pitchRange[1] - pitchRange[0];
		var halfFov = fov / 2;
		var isPanorama = verticalAngle < 180;

		if (showPolePoint && !isPanorama) {
			// Use full pinch range
			return pitchRange.map(function (v) {
				return +v.toFixed(5);
			});
		}

		// Round value as movableCood do.
		return [pitchRange[0] + halfFov, pitchRange[1] - halfFov].map(function (v) {
			return +v.toFixed(5);
		});
	};

	YawPitchControl.prototype._updateYawRange = function _updateYawRange(yawRange, fov, aspectRatio) {
		if (this.options.gyroMode === _consts.GYRO_MODE.VR) {
			return DEFAULT_YAW_RANGE;
		}

		var horizontalAngle = yawRange[1] - yawRange[0];

		/**
   * Full 360 Mode
   */
		if (horizontalAngle >= 360) {
			// Don't limit yaw range on Full 360 mode.
			return yawRange.map(function (v) {
				return +v.toFixed(5);
			});
		}

		/**
   * Panorama mode
   */
		var MAGIC_NUMBER = 1;
		var ratio = YawPitchControl.adjustAspectRatio(aspectRatio);
		var halfHorizontalFov = fov / 2 * ratio;

		// TODO: Magic Number Fix!
		if (horizontalAngle > 290) {
			MAGIC_NUMBER = 0.794; // horizontalAngle = 286;
		} else if (horizontalAngle > 125) {
			MAGIC_NUMBER = 0.98; // horizontalAngle *= 0.98;
		}

		// Round value as movableCood do.
		return [yawRange[0] * MAGIC_NUMBER + halfHorizontalFov, yawRange[1] * MAGIC_NUMBER - halfHorizontalFov].map(function (v) {
			return +v.toFixed(5);
		});
	};

	YawPitchControl.prototype._triggerChange = function _triggerChange(evt) {
		var pos = this.axes.get();
		var opt = this.options;
		var event = {
			targetElement: opt.element,
			isTrusted: evt.isTrusted
		};

		event.yaw = pos.yaw;
		event.pitch = pos.pitch;
		event.fov = pos.fov;

		if (opt.gyroMode === _consts.GYRO_MODE.VR && this._deviceQuaternion) {
			event.quaternion = this._deviceQuaternion.getCombinedQuaternion(pos.yaw, pos.pitch);
		}
		this.trigger("change", event);
	};

	// TODO: makes constant to be logic


	YawPitchControl.adjustAspectRatio = function adjustAspectRatio(input) {
		var inputRange = [0.520, 0.540, 0.563, 0.570, 0.584, 0.590, 0.609, 0.670, 0.702, 0.720, 0.760, 0.780, 0.820, 0.920, 0.970, 1.00, 1.07, 1.14, 1.19, 1.25, 1.32, 1.38, 1.40, 1.43, 1.53, 1.62, 1.76, 1.77, 1.86, 1.96, 2.26, 2.30, 2.60, 3.00, 5.00, 6.00];
		var outputRange = [0.510, 0.540, 0.606, 0.560, 0.628, 0.630, 0.647, 0.710, 0.736, 0.757, 0.780, 0.770, 0.800, 0.890, 0.975, 1.00, 1.07, 1.10, 1.15, 1.18, 1.22, 1.27, 1.30, 1.33, 1.39, 1.45, 1.54, 1.55, 1.58, 1.62, 1.72, 1.82, 1.92, 2.00, 2.24, 2.30];

		var rangeIdx = -1;

		for (var i = 0; i < inputRange.length - 1; i++) {
			if (inputRange[i] <= input && inputRange[i + 1] >= input) {
				rangeIdx = i;
				break;
			}
		}

		if (rangeIdx === -1) {
			if (inputRange[0] > input) {
				return outputRange[0];
			} else {
				return outputRange[outputRange[0].length - 1];
			}
		}

		var inputA = inputRange[rangeIdx];
		var inputB = inputRange[rangeIdx + 1];
		var outputA = outputRange[rangeIdx];
		var outputB = outputRange[rangeIdx + 1];

		return YawPitchControl.lerp(outputA, outputB, (input - inputA) / (inputB - inputA));
	};

	YawPitchControl.lerp = function lerp(a, b, fraction) {
		return a + fraction * (b - a);
	};

	/**
  * Enable YawPitch functionality
  *
  * @method eg.YawPitch#enable
  */


	YawPitchControl.prototype.enable = function enable() {
		if (this._enabled) {
			return this;
		}

		this._enabled = true;

		// touchDirection is decided by parameter is valid string (Ref. Axes.connect)
		this._applyOptions(Object.keys(this.options), this.options);

		this._setPanScale(this.getFov());

		return this;
	};

	/**
  * Disable YawPitch functionality
  *
  * @method eg.YawPitch#disable
  */


	YawPitchControl.prototype.disable = function disable(persistOrientation) {
		if (!this._enabled) {
			return this;
		}

		// TODO: Check peristOrientation is needed!
		if (!persistOrientation) {
			this._resetOrientation();
		}
		this.axes.disconnect();
		this._enabled = false;
		return this;
	};

	YawPitchControl.prototype._resetOrientation = function _resetOrientation() {
		var opt = this.options;

		this.axes.setTo({
			yaw: opt.yaw,
			pitch: opt.pitch,
			fov: opt.fov
		}, 0);

		return this;
	};

	/**
  * Set one or more of yaw, pitch, fov
  *
  * @param {Object} coordinate yaw, pitch, fov
  * @param {Number} duration Animation duration. if it is above 0 then it's animated.
  */


	YawPitchControl.prototype.lookAt = function lookAt(_ref, duration) {
		var yaw = _ref.yaw,
		    pitch = _ref.pitch,
		    fov = _ref.fov;

		var pos = this.axes.get();

		var y = yaw === undefined ? 0 : yaw - pos.yaw;
		var p = pitch === undefined ? 0 : pitch - pos.pitch;
		var f = fov === undefined ? 0 : fov - pos.fov;

		this.axes.setBy({
			yaw: y,
			pitch: p,
			fov: f
		}, duration);
	};

	YawPitchControl.prototype.get = function get() {
		return this.axes.get();
	};

	YawPitchControl.prototype.getYaw = function getYaw() {
		return this.axes.get().yaw;
	};

	YawPitchControl.prototype.getPitch = function getPitch() {
		return this.axes.get().pitch;
	};

	YawPitchControl.prototype.getFov = function getFov() {
		return this.axes.get().fov;
	};

	/**
  * Destroys objects
  */


	YawPitchControl.prototype.destroy = function destroy() {
		this.axes && this.axes.destroy();
		this.axisPanInput && this.axisPanInput.destroy();
		this.axesWheelInput && this.axesWheelInput.destroy();
		this.axesTiltMotionInput && this.axesTiltMotionInput.destroy();
		this.axesDeviceOrientationInput && this.axesDeviceOrientationInput.destroy();
		this.axesPinchInput && this.axesPinchInput.destroy();
		this.axesMoveKeyInput && this.axesMoveKeyInput.destroy();
		this._deviceQuaternion && this._deviceQuaternion.destroy();
	};

	return YawPitchControl;
}(_component2["default"]);

YawPitchControl.VERSION = "3.0.0-rc";
exports["default"] = YawPitchControl;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _mathUtil = __webpack_require__(6);

var _mathUtil2 = _interopRequireDefault(_mathUtil);

var _complementaryFilter = __webpack_require__(65);

var _complementaryFilter2 = _interopRequireDefault(_complementaryFilter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

_complementaryFilter2["default"].prototype.run_ = function () {
	if (!this.isOrientationInitialized) {
		this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
		this.previousFilterQ.copy(this.accelQ);
		this.isOrientationInitialized = true;
		return;
	}

	var deltaT = this.currentGyroMeasurement.timestampS - this.previousGyroMeasurement.timestampS;

	// Convert gyro rotation vector to a quaternion delta.
	var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);

	this.gyroIntegralQ.multiply(gyroDeltaQ);

	// filter_1 = K * (filter_0 + gyro * dT) + (1 - K) * accel.
	this.filterQ.copy(this.previousFilterQ);
	this.filterQ.multiply(gyroDeltaQ);

	// Calculate the delta between the current estimated gravity and the real
	// gravity vector from accelerometer.
	var invFilterQ = new _mathUtil2["default"].Quaternion();

	invFilterQ.copy(this.filterQ);
	invFilterQ.inverse();

	this.estimatedGravity.set(0, 0, -1);
	this.estimatedGravity.applyQuaternion(invFilterQ);
	this.estimatedGravity.normalize();

	this.measuredGravity.copy(this.currentAccelMeasurement.sample);
	this.measuredGravity.normalize();

	// Compare estimated gravity with measured gravity, get the delta quaternion
	// between the two.
	var deltaQ = new _mathUtil2["default"].Quaternion();

	deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
	deltaQ.inverse();

	// Calculate the SLERP target: current orientation plus the measured-estimated
	// quaternion delta.
	var targetQ = new _mathUtil2["default"].Quaternion();

	targetQ.copy(this.filterQ);
	targetQ.multiply(deltaQ);

	// SLERP factor: 0 is pure gyro, 1 is pure accel.
	this.filterQ.slerp(targetQ, 1 - this.kFilter);

	this.previousFilterQ.copy(this.filterQ);

	if (!this.isFilterQuaternionInitialized) {
		this.isFilterQuaternionInitialized = true;
	}
};

_complementaryFilter2["default"].prototype.getOrientation = function () {
	if (this.isFilterQuaternionInitialized) {
		return this.filterQ;
	} else {
		return null;
	}
};

exports["default"] = _complementaryFilter2["default"];

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

var _agent = __webpack_require__(3);

var _agent2 = _interopRequireDefault(_agent);

var _mathUtil = __webpack_require__(1);

var _browser = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var STILLNESS_THRESHOLD = 200; // millisecond

/**
 * In Chrome m65, `devicemotion` events are broken but subsequently fixed
 * in 65.0.3325.148. Since many browsers use Chromium, ensure that
 * we scope this detection by branch and build numbers to provide
 * a proper fallback.
 * https://github.com/immersive-web/webvr-polyfill/issues/307
 */
var isChromeWithoutDeviceMotion = function isChromeWithoutDeviceMotion() {
	var value = false;
	var agentInfo = (0, _agent2["default"])();
	var browserVersion = agentInfo.browser.version;

	if (agentInfo.browser.name === "chrome" && parseInt(browserVersion, 10) === 65) {
		var versionToken = browserVersion.split(".");
		var branch = versionToken[2];
		var build = versionToken[3];

		value = parseInt(branch, 10) === 3325 && parseInt(build, 10) < 148;
	}
	return value;
};

var DeviceMotion = function (_Component) {
	_inherits(DeviceMotion, _Component);

	function DeviceMotion() {
		_classCallCheck(this, DeviceMotion);

		var _this = _possibleConstructorReturn(this, _Component.call(this));

		_this._onDeviceMotion = _this._onDeviceMotion.bind(_this);
		_this._onDeviceOrientation = _this._onDeviceOrientation.bind(_this);
		_this._onChromeWithoutDeviceMotion = _this._onChromeWithoutDeviceMotion.bind(_this);

		_this.isWithoutDeviceMotion = isChromeWithoutDeviceMotion();
		_this.isAndroid = (0, _agent2["default"])().os.name === "android";

		_this.stillGyroVec = _mathUtil.vec3.create();
		_this.rawGyroVec = _mathUtil.vec3.create();
		_this.adjustedGyroVec = _mathUtil.vec3.create();

		_this._timer = null;

		_this.lastDevicemotionTimestamp = 0;
		_this._isEnabled = false;
		_this.enable();
		return _this;
	}

	DeviceMotion.prototype._onChromeWithoutDeviceMotion = function _onChromeWithoutDeviceMotion(e) {
		var alpha = e.alpha,
		    beta = e.beta,
		    gamma = e.gamma;

		// There is deviceorientation event trigged with empty values
		// on Headless Chrome.

		if (alpha === null) {
			return;
		}

		// convert to radian
		alpha = (alpha || 0) * Math.PI / 180;
		beta = (beta || 0) * Math.PI / 180;
		gamma = (gamma || 0) * Math.PI / 180;

		this.trigger("devicemotion", {
			inputEvent: {
				deviceorientation: {
					alpha: alpha,
					beta: beta,
					gamma: -gamma
				}
			}
		});
	};

	DeviceMotion.prototype._onDeviceOrientation = function _onDeviceOrientation() {
		var _this2 = this;

		this._timer && clearTimeout(this._timer);
		this._timer = setTimeout(function () {
			if (new Date().getTime() - _this2.lastDevicemotionTimestamp < STILLNESS_THRESHOLD) {
				_mathUtil.vec3.copy(_this2.stillGyroVec, _this2.rawGyroVec);
			}
		}, STILLNESS_THRESHOLD);
	};

	DeviceMotion.prototype._onDeviceMotion = function _onDeviceMotion(e) {
		// desktop chrome triggers devicemotion event with empthy sensor values.
		// Those events should ignored.
		var isGyroSensorAvailable = !(e.rotationRate.alpha == null);
		var isGravitySensorAvailable = !(e.accelerationIncludingGravity.x == null);

		if (e.interval === 0 || !(isGyroSensorAvailable && isGravitySensorAvailable)) {
			return;
		}

		var devicemotionEvent = _extends({}, e);

		devicemotionEvent.interval = e.interval;
		devicemotionEvent.timeStamp = e.timeStamp;
		devicemotionEvent.type = e.type;
		devicemotionEvent.rotationRate = {
			alpha: e.rotationRate.alpha,
			beta: e.rotationRate.beta,
			gamma: e.rotationRate.gamma
		};
		devicemotionEvent.accelerationIncludingGravity = {
			x: e.accelerationIncludingGravity.x,
			y: e.accelerationIncludingGravity.y,
			z: e.accelerationIncludingGravity.z
		};
		devicemotionEvent.acceleration = {
			x: e.acceleration.x,
			y: e.acceleration.y,
			z: e.acceleration.z
		};

		if (this.isAndroid) {
			_mathUtil.vec3.set(this.rawGyroVec, e.rotationRate.alpha || 0, e.rotationRate.beta || 0, e.rotationRate.gamma || 0);
			_mathUtil.vec3.subtract(this.adjustedGyroVec, this.rawGyroVec, this.stillGyroVec);
			this.lastDevicemotionTimestamp = new Date().getTime();

			devicemotionEvent.adjustedRotationRate = {
				alpha: this.adjustedGyroVec[0],
				beta: this.adjustedGyroVec[1],
				gamma: this.adjustedGyroVec[2] };
		}

		this.trigger("devicemotion", {
			inputEvent: devicemotionEvent
		});
	};

	DeviceMotion.prototype.enable = function enable() {
		if (this.isAndroid) {
			_browser.window.addEventListener("deviceorientation", this._onDeviceOrientation);
		}
		if (this.isWithoutDeviceMotion) {
			_browser.window.addEventListener("deviceorientation", this._onChromeWithoutDeviceMotion);
		} else {
			_browser.window.addEventListener("devicemotion", this._onDeviceMotion);
		}
		this._isEnabled = true;
	};

	DeviceMotion.prototype.disable = function disable() {
		_browser.window.removeEventListener("deviceorientation", this._onDeviceOrientation);
		_browser.window.removeEventListener("deviceorientation", this._onChromeWithoutDeviceMotion);
		_browser.window.removeEventListener("devicemotion", this._onDeviceMotion);
		this._isEnabled = false;
	};

	return DeviceMotion;
}(_component2["default"]);

exports["default"] = DeviceMotion;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _axes = __webpack_require__(11);

var _axes2 = _interopRequireDefault(_axes);

var _ScreenRotationAngle = __webpack_require__(15);

var _ScreenRotationAngle2 = _interopRequireDefault(_ScreenRotationAngle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * RotationPanInput is extension of PanInput to compensate coordinates by screen rotation angle.
 *
 * The reason for using this function is that in VR mode,
 * the roll angle is adjusted in the direction opposite to the screen rotation angle.
 *
 * Therefore, the angle that the user touches and moves does not match the angle at which the actual object should move.
 * @extends PanInput
 */
var RotationPanInput = function (_PanInput) {
	_inherits(RotationPanInput, _PanInput);

	/**
  * Constructor
  *
  * @private
  * @param {HTMLElement} el target element
  * @param {Object} [options] The option object
  * @param {Boolean} [options.useRotation]  Whether to use rotation(or VR)
  */
	function RotationPanInput(el, options) {
		_classCallCheck(this, RotationPanInput);

		var _this = _possibleConstructorReturn(this, _PanInput.call(this, el, options));

		_this._useRotation = false;
		_this._screenRotationAngle = null;

		_this.setUseRotation(!!(options && options.useRotation));

		_this._userDirection = _axes2["default"].DIRECTION_ALL;
		return _this;
	}

	RotationPanInput.prototype.setUseRotation = function setUseRotation(useRotation) {
		this._useRotation = useRotation;

		if (this._screenRotationAngle) {
			this._screenRotationAngle.unref();
			this._screenRotationAngle = null;
		}

		if (this._useRotation) {
			this._screenRotationAngle = new _ScreenRotationAngle2["default"]();
		}
	};

	RotationPanInput.prototype.connect = function connect(observer) {
		// User intetened direction
		this._userDirection = this._direction;

		// In VR Mode, Use ALL direction if direction is not none
		// Because horizontal and vertical is changed dynamically by screen rotation.
		// this._direction is used to initialize hammerjs
		if (this._useRotation && this._direction & _axes2["default"].DIRECTION_ALL) {
			this._direction = _axes2["default"].DIRECTION_ALL;
		}

		_PanInput.prototype.connect.call(this, observer);
	};

	RotationPanInput.prototype.getOffset = function getOffset(properties, useDirection) {
		if (this._useRotation === false) {
			return _PanInput.prototype.getOffset.call(this, properties, useDirection);
		}

		var offset = _PanInput.prototype.getOffset.call(this, properties, [true, true]);
		var newOffset = [0, 0];
		var theta = this._screenRotationAngle.getRadian();
		var cosTheta = Math.cos(theta);
		var sinTheta = Math.sin(theta);

		newOffset[0] = offset[0] * cosTheta - offset[1] * sinTheta;
		newOffset[1] = offset[1] * cosTheta + offset[0] * sinTheta;

		// Use only user allowed direction.
		if (!(this._userDirection & _axes2["default"].DIRECTION_HORIZONTAL)) {
			newOffset[0] = 0;
		} else if (!(this._userDirection & _axes2["default"].DIRECTION_VERTICAL)) {
			newOffset[1] = 0;
		}

		return newOffset;
	};

	RotationPanInput.prototype.destroy = function destroy() {
		if (this._useRotation) {
			this._screenRotationAngle && this._screenRotationAngle.unref();
		}

		_PanInput.prototype.destroy.call(this);
	};

	return RotationPanInput;
}(_axes.PanInput);

/**
 * Override getDirectionByAngle to return DIRECTION_ALL
 * Ref: https://github.com/naver/egjs-axes/issues/99
 *
 * But we obey axes's rule. If axes's rule is problem, let's apply following code.
 */
// PanInput.getDirectionByAngle = function (angle, thresholdAngle) {
// 	return DIRECTION_ALL;
// };


exports["default"] = RotationPanInput;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

var _utils = __webpack_require__(18);

var _FusionPoseSensor = __webpack_require__(17);

var _FusionPoseSensor2 = _interopRequireDefault(_FusionPoseSensor);

var _mathUtil = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function getDeltaYaw(prvQ, curQ) {
	var yawDeltaByYaw = _mathUtil.util.getRotationDelta(prvQ, curQ, _mathUtil.ROTATE_CONSTANT.YAW_DELTA_BY_YAW);
	var yawDeltaByRoll = _mathUtil.util.getRotationDelta(prvQ, curQ, _mathUtil.ROTATE_CONSTANT.YAW_DELTA_BY_ROLL) * Math.sin(_mathUtil.util.extractPitchFromQuat(curQ));

	return yawDeltaByRoll + yawDeltaByYaw;
}

function getDeltaPitch(prvQ, curQ) {
	var pitchDelta = _mathUtil.util.getRotationDelta(prvQ, curQ, _mathUtil.ROTATE_CONSTANT.PITCH_DELTA);

	return pitchDelta;
}

var TiltMotionInput = function (_Component) {
	_inherits(TiltMotionInput, _Component);

	function TiltMotionInput(el, options) {
		_classCallCheck(this, TiltMotionInput);

		var _this = _possibleConstructorReturn(this, _Component.call(this));

		_this.element = el;

		_this._prevQuaternion = null;
		_this._quaternion = null;

		_this.fusionPoseSensor = null;

		_this.options = _extends({
			scale: 1,
			threshold: 0
		}, options);

		_this._onPoseChange = _this._onPoseChange.bind(_this);
		return _this;
	}

	TiltMotionInput.prototype.mapAxes = function mapAxes(axes) {
		this.axes = axes;
	};

	TiltMotionInput.prototype.connect = function connect(observer) {
		if (this.observer) {
			return this;
		}
		this.observer = observer;
		this.fusionPoseSensor = new _FusionPoseSensor2["default"]();
		this.fusionPoseSensor.enable();
		this._attachEvent();
		return this;
	};

	TiltMotionInput.prototype.disconnect = function disconnect() {
		if (!this.observer) {
			return this;
		}

		this._dettachEvent();
		this.fusionPoseSensor.disable();
		this.fusionPoseSensor.destroy();
		this.fusionPoseSensor = null;
		this.observer = null;
		return this;
	};

	TiltMotionInput.prototype.destroy = function destroy() {
		this.disconnect();
		this.element = null;
		this.options = null;
		this.axes = null;
		this._prevQuaternion = null;
		this._quaternion = null;
	};

	TiltMotionInput.prototype._onPoseChange = function _onPoseChange(event) {
		if (!this._prevQuaternion) {
			this._prevQuaternion = _mathUtil.quat.clone(event.quaternion);
			this._quaternion = _mathUtil.quat.clone(event.quaternion);
			return;
		}

		_mathUtil.quat.copy(this._prevQuaternion, this._quaternion);
		_mathUtil.quat.copy(this._quaternion, event.quaternion);

		this.observer.change(this, event, (0, _utils.toAxis)(this.axes, [getDeltaYaw(this._prevQuaternion, this._quaternion), getDeltaPitch(this._prevQuaternion, this._quaternion)]));
	};

	TiltMotionInput.prototype._attachEvent = function _attachEvent() {
		this.fusionPoseSensor.on("change", this._onPoseChange);
	};

	TiltMotionInput.prototype._dettachEvent = function _dettachEvent() {
		this.fusionPoseSensor.off("change", this._onPoseChange);
	};

	return TiltMotionInput;
}(_component2["default"]);

exports["default"] = TiltMotionInput;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

var _utils = __webpack_require__(18);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WheelInput = function (_Component) {
	_inherits(WheelInput, _Component);

	function WheelInput(el, options) {
		_classCallCheck(this, WheelInput);

		var _this = _possibleConstructorReturn(this, _Component.call(this));

		_this.element = el;

		_this.options = _extends({
			scale: 1,
			threshold: 0
		}, options);

		_this._onWheel = _this._onWheel.bind(_this);
		return _this;
	}

	WheelInput.prototype.mapAxes = function mapAxes(axes) {
		this.axes = axes;
	};

	WheelInput.prototype.connect = function connect(observer) {
		if (this.observer) {
			return this;
		}
		this.observer = observer;
		this._attachEvent();
		return this;
	};

	WheelInput.prototype.disconnect = function disconnect() {
		if (!this.observer) {
			return this;
		}
		this.observer = null;
		this._dettachEvent();
		return this;
	};

	WheelInput.prototype.destroy = function destroy() {
		this.disconnect();
		this.element = null;
		this.options = null;
		this.axes = null;
	};

	WheelInput.prototype._onWheel = function _onWheel(event) {
		event.preventDefault();

		if (event.deltaY === 0) {
			return;
		}

		this.observer.change(this, event, (0, _utils.toAxis)(this.axes, [(event.deltaY < 0 ? -1 : 1) * this.options.scale]));
	};

	WheelInput.prototype._attachEvent = function _attachEvent() {
		this.element.addEventListener("wheel", this._onWheel, false);
	};

	WheelInput.prototype._dettachEvent = function _dettachEvent() {
		this.element.removeEventListener("wheel", this._onWheel, false);
	};

	return WheelInput;
}(_component2["default"]);

exports["default"] = WheelInput;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _common = __webpack_require__(2);

var _common2 = _interopRequireDefault(_common);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
/**
 * Original Code
 * https://github.com/toji/gl-matrix/blob/v2.3.2/src/gl-matrix/mat4.js
 * 4x4 Matrix util
 * modified by egjs
 */
mat4.create = function () {
    var out = new _common2["default"].ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function (out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
mat4.fromQuat = function (out, q) {
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,
        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = 2 * far * near * nf;
    out[15] = 0;
    return out;
};

module.exports = mat4;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _common = __webpack_require__(2);

var _common2 = _interopRequireDefault(_common);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
/**
 * Original Code
 * https://github.com/toji/gl-matrix/blob/v2.3.2/src/gl-matrix/quat.js
 * Quaternion util
 * modified by egjs
 */
quat.create = function () {
    var out = new _common2["default"].ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = function (a) {
    var out = new _common2["default"].ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = function (x, y, z, w) {
    var out = new _common2["default"].ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = function (out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function (out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function (out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3],
        bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5;

    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3],
        bx = Math.sin(rad),
        bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5;

    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3],
        by = Math.sin(rad),
        bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = function (out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x * x + y * y + z * z + w * w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.equals = function (a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    return Math.abs(a0 - b0) <= _common2["default"].EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common2["default"].EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common2["default"].EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common2["default"].EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
};

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

module.exports = quat;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _common = __webpack_require__(2);

var _common2 = _interopRequireDefault(_common);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */
var vec2 = {}; /**
                * Original Code
                * https://github.com/toji/gl-matrix/blob/v2.3.2/src/gl-matrix/vec2.js
                * 2 Dimensional Vector Util
                * modified by egjs
                */


vec2.copy = function (out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
};

module.exports = vec2;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _common = __webpack_require__(2);

var _common2 = _interopRequireDefault(_common);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
/**
 * Original Code
 * https://github.com/toji/gl-matrix/blob/v2.3.2/src/gl-matrix/vec3.js
 * 3 Dimensional Vector Util
 * modified by egjs
 */
vec3.create = function () {
    var out = new _common2["default"].ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function (x, y, z) {
    var out = new _common2["default"].ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

vec3.set = function (out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

vec3.copy = function (out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function (out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function (out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x * x + y * y + z * z);
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function (out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x * x + y * y + z * z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function (out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        bx = b[0],
        by = b[1],
        bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function (out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0],
        y = a[1],
        z = a[2],
        qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3],


    // calculate quat * vec
    ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function (out, a, b, c) {
    var p = [],
        r = [];
    //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];

    //perform rotation
    r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
    r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
    r[2] = p[2];

    //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];

    return out;
};

module.exports = vec3;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
}
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
}
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
}
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
}

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text
  }

  // Cache opened sequence.
  var ansiCodes = []
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
    var ot = _openTags[seq]
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop()
        return '</span>'
      }
      // Open tag.
      ansiCodes.push(seq)
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
    }

    var ct = _closeTags[seq]
    if (ct) {
      // Pop sequence
      ansiCodes.pop()
      return ct
    }
    return ''
  })

  // Make sure tags are closed.
  var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

  return ret
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.')
  }

  var _finalColors = {}
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null
    if (!hex) {
      _finalColors[key] = _defColors[key]
      continue
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex]
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string'
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
      }
      var defHexColor = _defColors[key]
      if (!hex[0]) {
        hex[0] = defHexColor[0]
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]]
        hex.push(defHexColor[1])
      }

      hex = hex.slice(0, 2)
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
    }
    _finalColors[key] = hex
  }
  _setTags(_finalColors)
}

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors)
}

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {}

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () { return _openTags }
  })
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () { return _closeTags }
  })
} else {
  ansiHTML.tags.open = _openTags
  ansiHTML.tags.close = _closeTags
}

function _setTags (colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey

  for (var code in _styles) {
    var color = _styles[code]
    var oriColor = colors[color] || '000'
    _openTags[code] = 'color:#' + oriColor
    code = parseInt(code)
    _openTags[(code + 10).toString()] = 'background:#' + oriColor
  }
}

ansiHTML.reset()


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),
/* 47 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  XmlEntities: __webpack_require__(50),
  Html4Entities: __webpack_require__(49),
  Html5Entities: __webpack_require__(19),
  AllHtmlEntities: __webpack_require__(19)
};


/***/ }),
/* 49 */
/***/ (function(module, exports) {

var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];

var alphaIndex = {};
var numIndex = {};

var i = 0;
var length = HTML_ALPHA.length;
while (i < length) {
    var a = HTML_ALPHA[i];
    var c = HTML_CODES[i];
    alphaIndex[a] = String.fromCharCode(c);
    numIndex[c] = a;
    i++;
}

/**
 * @constructor
 */
function Html4Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1).toLowerCase() === 'x' ?
                parseInt(entity.substr(2), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.decode = function(str) {
    return new Html4Entities().decode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var alpha = numIndex[str.charCodeAt(i)];
        result += alpha ? "&" + alpha + ";" : str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encode = function(str) {
    return new Html4Entities().encode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var cc = str.charCodeAt(i);
        var alpha = numIndex[cc];
        if (alpha) {
            result += "&" + alpha + ";";
        } else if (cc < 32 || cc > 126) {
            result += "&#" + cc + ";";
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonUTF = function(str) {
    return new Html4Entities().encodeNonUTF(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonASCII = function(str) {
    return new Html4Entities().encodeNonASCII(str);
};

module.exports = Html4Entities;


/***/ }),
/* 50 */
/***/ (function(module, exports) {

var ALPHA_INDEX = {
    '&lt': '<',
    '&gt': '>',
    '&quot': '"',
    '&apos': '\'',
    '&amp': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': '\'',
    '&amp;': '&'
};

var CHAR_INDEX = {
    60: 'lt',
    62: 'gt',
    34: 'quot',
    39: 'apos',
    38: 'amp'
};

var CHAR_S_INDEX = {
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;',
    '&': '&amp;'
};

/**
 * @constructor
 */
function XmlEntities() {}

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/<|>|"|'|&/g, function(s) {
        return CHAR_S_INDEX[s];
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encode = function(str) {
    return new XmlEntities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {
        if (s.charAt(1) === '#') {
            var code = s.charAt(2).toLowerCase() === 'x' ?
                parseInt(s.substr(3), 16) :
                parseInt(s.substr(2));

            if (isNaN(code) || code < -32768 || code > 65535) {
                return '';
            }
            return String.fromCharCode(code);
        }
        return ALPHA_INDEX[s] || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.decode = function(str) {
    return new XmlEntities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var alpha = CHAR_INDEX[c];
        if (alpha) {
            result += "&" + alpha + ";";
            i++;
            continue;
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonUTF = function(str) {
    return new XmlEntities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLenght = str.length;
    var result = '';
    var i = 0;
    while (i < strLenght) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonASCII = function(str) {
    return new XmlEntities().encodeNonASCII(str);
 };

module.exports = XmlEntities;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof module === 'object' && module.exports) {
        module.exports = definition();
    } else {
        root.log = definition();
    }
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));


/***/ }),
/* 52 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(63)(module), __webpack_require__(9)))

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(54);
exports.encode = exports.stringify = __webpack_require__(55);


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/* sockjs-client v1.1.4 | http://sockjs.org | MIT license */
(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.SockJS = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
'use strict';

var transportList = require('./transport-list');

module.exports = require('./main')(transportList);

// TODO can't get rid of this until all servers do
if ('_sockjs_onload' in global) {
  setTimeout(global._sockjs_onload, 1);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./main":14,"./transport-list":16}],2:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function CloseEvent() {
  Event.call(this);
  this.initEvent('close', false, false);
  this.wasClean = false;
  this.code = 0;
  this.reason = '';
}

inherits(CloseEvent, Event);

module.exports = CloseEvent;

},{"./event":4,"inherits":57}],3:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventTarget = require('./eventtarget')
  ;

function EventEmitter() {
  EventTarget.call(this);
}

inherits(EventEmitter, EventTarget);

EventEmitter.prototype.removeAllListeners = function(type) {
  if (type) {
    delete this._listeners[type];
  } else {
    this._listeners = {};
  }
};

EventEmitter.prototype.once = function(type, listener) {
  var self = this
    , fired = false;

  function g() {
    self.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  this.on(type, g);
};

EventEmitter.prototype.emit = function() {
  var type = arguments[0];
  var listeners = this._listeners[type];
  if (!listeners) {
    return;
  }
  // equivalent of Array.prototype.slice.call(arguments, 1);
  var l = arguments.length;
  var args = new Array(l - 1);
  for (var ai = 1; ai < l; ai++) {
    args[ai - 1] = arguments[ai];
  }
  for (var i = 0; i < listeners.length; i++) {
    listeners[i].apply(this, args);
  }
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

module.exports.EventEmitter = EventEmitter;

},{"./eventtarget":5,"inherits":57}],4:[function(require,module,exports){
'use strict';

function Event(eventType) {
  this.type = eventType;
}

Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
  this.type = eventType;
  this.bubbles = canBubble;
  this.cancelable = cancelable;
  this.timeStamp = +new Date();
  return this;
};

Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault = function() {};

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

module.exports = Event;

},{}],5:[function(require,module,exports){
'use strict';

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

function EventTarget() {
  this._listeners = {};
}

EventTarget.prototype.addEventListener = function(eventType, listener) {
  if (!(eventType in this._listeners)) {
    this._listeners[eventType] = [];
  }
  var arr = this._listeners[eventType];
  // #4
  if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
    arr = arr.concat([listener]);
  }
  this._listeners[eventType] = arr;
};

EventTarget.prototype.removeEventListener = function(eventType, listener) {
  var arr = this._listeners[eventType];
  if (!arr) {
    return;
  }
  var idx = arr.indexOf(listener);
  if (idx !== -1) {
    if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
    } else {
      delete this._listeners[eventType];
    }
    return;
  }
};

EventTarget.prototype.dispatchEvent = function() {
  var event = arguments[0];
  var t = event.type;
  // equivalent of Array.prototype.slice.call(arguments, 0);
  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
  if (this['on' + t]) {
    this['on' + t].apply(this, args);
  }
  if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
    var listeners = this._listeners[t];
    for (var i = 0; i < listeners.length; i++) {
      listeners[i].apply(this, args);
    }
  }
};

module.exports = EventTarget;

},{}],6:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function TransportMessageEvent(data) {
  Event.call(this);
  this.initEvent('message', false, false);
  this.data = data;
}

inherits(TransportMessageEvent, Event);

module.exports = TransportMessageEvent;

},{"./event":4,"inherits":57}],7:[function(require,module,exports){
'use strict';

var JSON3 = require('json3')
  , iframeUtils = require('./utils/iframe')
  ;

function FacadeJS(transport) {
  this._transport = transport;
  transport.on('message', this._transportMessage.bind(this));
  transport.on('close', this._transportClose.bind(this));
}

FacadeJS.prototype._transportClose = function(code, reason) {
  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
};
FacadeJS.prototype._transportMessage = function(frame) {
  iframeUtils.postMessage('t', frame);
};
FacadeJS.prototype._send = function(data) {
  this._transport.send(data);
};
FacadeJS.prototype._close = function() {
  this._transport.close();
  this._transport.removeAllListeners();
};

module.exports = FacadeJS;

},{"./utils/iframe":47,"json3":58}],8:[function(require,module,exports){
(function (process){
'use strict';

var urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , JSON3 = require('json3')
  , FacadeJS = require('./facade')
  , InfoIframeReceiver = require('./info-iframe-receiver')
  , iframeUtils = require('./utils/iframe')
  , loc = require('./location')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:iframe-bootstrap');
}

module.exports = function(SockJS, availableTransports) {
  var transportMap = {};
  availableTransports.forEach(function(at) {
    if (at.facadeTransport) {
      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
    }
  });

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
  var parentOrigin;

  /* eslint-disable camelcase */
  SockJS.bootstrap_iframe = function() {
    /* eslint-enable camelcase */
    var facade;
    iframeUtils.currentWindowId = loc.hash.slice(1);
    var onMessage = function(e) {
      if (e.source !== parent) {
        return;
      }
      if (typeof parentOrigin === 'undefined') {
        parentOrigin = e.origin;
      }
      if (e.origin !== parentOrigin) {
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = JSON3.parse(e.data);
      } catch (ignored) {
        debug('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
        return;
      }
      switch (iframeMessage.type) {
      case 's':
        var p;
        try {
          p = JSON3.parse(iframeMessage.data);
        } catch (ignored) {
          debug('bad json', iframeMessage.data);
          break;
        }
        var version = p[0];
        var transport = p[1];
        var transUrl = p[2];
        var baseUrl = p[3];
        debug(version, transport, transUrl, baseUrl);
        // change this to semver logic
        if (version !== SockJS.version) {
          throw new Error('Incompatible SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".');
        }

        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
          throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
        }
        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
        break;
      case 'm':
        facade._send(iframeMessage.data);
        break;
      case 'c':
        if (facade) {
          facade._close();
        }
        facade = null;
        break;
      }
    };

    eventUtils.attachEvent('message', onMessage);

    // Start
    iframeUtils.postMessage('s');
  };
};

}).call(this,{ env: {} })

},{"./facade":7,"./info-iframe-receiver":10,"./location":13,"./utils/event":46,"./utils/iframe":47,"./utils/url":52,"debug":55,"json3":58}],9:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , objectUtils = require('./utils/object')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-ajax');
}

function InfoAjax(url, AjaxObject) {
  EventEmitter.call(this);

  var self = this;
  var t0 = +new Date();
  this.xo = new AjaxObject('GET', url);

  this.xo.once('finish', function(status, text) {
    var info, rtt;
    if (status === 200) {
      rtt = (+new Date()) - t0;
      if (text) {
        try {
          info = JSON3.parse(text);
        } catch (e) {
          debug('bad json', text);
        }
      }

      if (!objectUtils.isObject(info)) {
        info = {};
      }
    }
    self.emit('finish', info, rtt);
    self.removeAllListeners();
  });
}

inherits(InfoAjax, EventEmitter);

InfoAjax.prototype.close = function() {
  this.removeAllListeners();
  this.xo.close();
};

module.exports = InfoAjax;

}).call(this,{ env: {} })

},{"./utils/object":49,"debug":55,"events":3,"inherits":57,"json3":58}],10:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , JSON3 = require('json3')
  , XHRLocalObject = require('./transport/sender/xhr-local')
  , InfoAjax = require('./info-ajax')
  ;

function InfoReceiverIframe(transUrl) {
  var self = this;
  EventEmitter.call(this);

  this.ir = new InfoAjax(transUrl, XHRLocalObject);
  this.ir.once('finish', function(info, rtt) {
    self.ir = null;
    self.emit('message', JSON3.stringify([info, rtt]));
  });
}

inherits(InfoReceiverIframe, EventEmitter);

InfoReceiverIframe.transportName = 'iframe-info-receiver';

InfoReceiverIframe.prototype.close = function() {
  if (this.ir) {
    this.ir.close();
    this.ir = null;
  }
  this.removeAllListeners();
};

module.exports = InfoReceiverIframe;

},{"./info-ajax":9,"./transport/sender/xhr-local":37,"events":3,"inherits":57,"json3":58}],11:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , utils = require('./utils/event')
  , IframeTransport = require('./transport/iframe')
  , InfoReceiverIframe = require('./info-iframe-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-iframe');
}

function InfoIframe(baseUrl, url) {
  var self = this;
  EventEmitter.call(this);

  var go = function() {
    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

    ifr.once('message', function(msg) {
      if (msg) {
        var d;
        try {
          d = JSON3.parse(msg);
        } catch (e) {
          debug('bad json', msg);
          self.emit('finish');
          self.close();
          return;
        }

        var info = d[0], rtt = d[1];
        self.emit('finish', info, rtt);
      }
      self.close();
    });

    ifr.once('close', function() {
      self.emit('finish');
      self.close();
    });
  };

  // TODO this seems the same as the 'needBody' from transports
  if (!global.document.body) {
    utils.attachEvent('load', go);
  } else {
    go();
  }
}

inherits(InfoIframe, EventEmitter);

InfoIframe.enabled = function() {
  return IframeTransport.enabled();
};

InfoIframe.prototype.close = function() {
  if (this.ifr) {
    this.ifr.close();
  }
  this.removeAllListeners();
  this.ifr = null;
};

module.exports = InfoIframe;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./info-iframe-receiver":10,"./transport/iframe":22,"./utils/event":46,"debug":55,"events":3,"inherits":57,"json3":58}],12:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , urlUtils = require('./utils/url')
  , XDR = require('./transport/sender/xdr')
  , XHRCors = require('./transport/sender/xhr-cors')
  , XHRLocal = require('./transport/sender/xhr-local')
  , XHRFake = require('./transport/sender/xhr-fake')
  , InfoIframe = require('./info-iframe')
  , InfoAjax = require('./info-ajax')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-receiver');
}

function InfoReceiver(baseUrl, urlInfo) {
  debug(baseUrl);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self.doXhr(baseUrl, urlInfo);
  }, 0);
}

inherits(InfoReceiver, EventEmitter);

// TODO this is currently ignoring the list of available transports and the whitelist

InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
  if (urlInfo.sameOrigin) {
    return new InfoAjax(url, XHRLocal);
  }
  if (XHRCors.enabled) {
    return new InfoAjax(url, XHRCors);
  }
  if (XDR.enabled && urlInfo.sameScheme) {
    return new InfoAjax(url, XDR);
  }
  if (InfoIframe.enabled()) {
    return new InfoIframe(baseUrl, url);
  }
  return new InfoAjax(url, XHRFake);
};

InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
  var self = this
    , url = urlUtils.addPath(baseUrl, '/info')
    ;
  debug('doXhr', url);

  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

  this.timeoutRef = setTimeout(function() {
    debug('timeout');
    self._cleanup(false);
    self.emit('finish');
  }, InfoReceiver.timeout);

  this.xo.once('finish', function(info, rtt) {
    debug('finish', info, rtt);
    self._cleanup(true);
    self.emit('finish', info, rtt);
  });
};

InfoReceiver.prototype._cleanup = function(wasClean) {
  debug('_cleanup');
  clearTimeout(this.timeoutRef);
  this.timeoutRef = null;
  if (!wasClean && this.xo) {
    this.xo.close();
  }
  this.xo = null;
};

InfoReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  this._cleanup(false);
};

InfoReceiver.timeout = 8000;

module.exports = InfoReceiver;

}).call(this,{ env: {} })

},{"./info-ajax":9,"./info-iframe":11,"./transport/sender/xdr":34,"./transport/sender/xhr-cors":35,"./transport/sender/xhr-fake":36,"./transport/sender/xhr-local":37,"./utils/url":52,"debug":55,"events":3,"inherits":57}],13:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.location || {
  origin: 'http://localhost:80'
, protocol: 'http'
, host: 'localhost'
, port: 80
, href: 'http://localhost/'
, hash: ''
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (process,global){
'use strict';

require('./shims');

var URL = require('url-parse')
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , random = require('./utils/random')
  , escape = require('./utils/escape')
  , urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , transport = require('./utils/transport')
  , objectUtils = require('./utils/object')
  , browser = require('./utils/browser')
  , log = require('./utils/log')
  , Event = require('./event/event')
  , EventTarget = require('./event/eventtarget')
  , loc = require('./location')
  , CloseEvent = require('./event/close')
  , TransportMessageEvent = require('./event/trans-message')
  , InfoReceiver = require('./info-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:main');
}

var transports;

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
function SockJS(url, protocols, options) {
  if (!(this instanceof SockJS)) {
    return new SockJS(url, protocols, options);
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
  }
  EventTarget.call(this);

  this.readyState = SockJS.CONNECTING;
  this.extensions = '';
  this.protocol = '';

  // non-standard extension
  options = options || {};
  if (options.protocols_whitelist) {
    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
  }
  this._transportsWhitelist = options.transports;
  this._transportOptions = options.transportOptions || {};

  var sessionId = options.sessionId || 8;
  if (typeof sessionId === 'function') {
    this._generateSessionId = sessionId;
  } else if (typeof sessionId === 'number') {
    this._generateSessionId = function() {
      return random.string(sessionId);
    };
  } else {
    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
  }

  this._server = options.server || random.numberString(1000);

  // Step 1 of WS spec - parse and validate the url. Issue #8
  var parsedUrl = new URL(url);
  if (!parsedUrl.host || !parsedUrl.protocol) {
    throw new SyntaxError("The URL '" + url + "' is invalid");
  } else if (parsedUrl.hash) {
    throw new SyntaxError('The URL must not contain a fragment');
  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
  }

  var secure = parsedUrl.protocol === 'https:';
  // Step 2 - don't allow secure origin with an insecure protocol
  if (loc.protocol === 'https' && !secure) {
    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
  }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
  if (!protocols) {
    protocols = [];
  } else if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  // Step 5 - check protocols argument
  var sortedProtocols = protocols.sort();
  sortedProtocols.forEach(function(proto, i) {
    if (!proto) {
      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
    }
    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
    }
  });

  // Step 6 - convert origin
  var o = urlUtils.getOrigin(loc.href);
  this._origin = o ? o.toLowerCase() : null;

  // remove the trailing slash
  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

  // store the sanitized url
  this.url = parsedUrl.href;
  debug('using url', this.url);

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
  this._urlInfo = {
    nullOrigin: !browser.hasDomain()
  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
  };

  this._ir = new InfoReceiver(this.url, this._urlInfo);
  this._ir.once('finish', this._receiveInfo.bind(this));
}

inherits(SockJS, EventTarget);

function userSetCode(code) {
  return code === 1000 || (code >= 3000 && code <= 4999);
}

SockJS.prototype.close = function(code, reason) {
  // Step 1
  if (code && !userSetCode(code)) {
    throw new Error('InvalidAccessError: Invalid code');
  }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
  if (reason && reason.length > 123) {
    throw new SyntaxError('reason argument has an invalid length');
  }

  // Step 3.1
  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
    return;
  }

  // TODO look at docs to determine how to set this
  var wasClean = true;
  this._close(code || 1000, reason || 'Normal closure', wasClean);
};

SockJS.prototype.send = function(data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
  if (typeof data !== 'string') {
    data = '' + data;
  }
  if (this.readyState === SockJS.CONNECTING) {
    throw new Error('InvalidStateError: The connection has not been established yet');
  }
  if (this.readyState !== SockJS.OPEN) {
    return;
  }
  this._transport.send(escape.quote(data));
};

SockJS.version = require('./version');

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._receiveInfo = function(info, rtt) {
  debug('_receiveInfo', rtt);
  this._ir = null;
  if (!info) {
    this._close(1002, 'Cannot connect to server');
    return;
  }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
  this._rto = this.countRTO(rtt);
  // allow server to override url used for the actual transport
  this._transUrl = info.base_url ? info.base_url : this.url;
  info = objectUtils.extend(info, this._urlInfo);
  debug('info', info);
  // determine list of desired and supported transports
  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
  this._transports = enabledTransports.main;
  debug(this._transports.length + ' enabled transports');

  this._connect();
};

SockJS.prototype._connect = function() {
  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
    debug('attempt', Transport.transportName);
    if (Transport.needBody) {
      if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
        debug('waiting for body');
        this._transports.unshift(Transport);
        eventUtils.attachEvent('load', this._connect.bind(this));
        return;
      }
    }

    // calculate timeout based on RTO and round trips. Default to 5s
    var timeoutMs = (this._rto * Transport.roundTrips) || 5000;
    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
    debug('using timeout', timeoutMs);

    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
    var options = this._transportOptions[Transport.transportName];
    debug('transport url', transportUrl);
    var transportObj = new Transport(transportUrl, this._transUrl, options);
    transportObj.on('message', this._transportMessage.bind(this));
    transportObj.once('close', this._transportClose.bind(this));
    transportObj.transportName = Transport.transportName;
    this._transport = transportObj;

    return;
  }
  this._close(2000, 'All transports failed', false);
};

SockJS.prototype._transportTimeout = function() {
  debug('_transportTimeout');
  if (this.readyState === SockJS.CONNECTING) {
    this._transportClose(2007, 'Transport timed out');
  }
};

SockJS.prototype._transportMessage = function(msg) {
  debug('_transportMessage', msg);
  var self = this
    , type = msg.slice(0, 1)
    , content = msg.slice(1)
    , payload
    ;

  // first check for messages that don't need a payload
  switch (type) {
    case 'o':
      this._open();
      return;
    case 'h':
      this.dispatchEvent(new Event('heartbeat'));
      debug('heartbeat', this.transport);
      return;
  }

  if (content) {
    try {
      payload = JSON3.parse(content);
    } catch (e) {
      debug('bad json', content);
    }
  }

  if (typeof payload === 'undefined') {
    debug('empty payload', content);
    return;
  }

  switch (type) {
    case 'a':
      if (Array.isArray(payload)) {
        payload.forEach(function(p) {
          debug('message', self.transport, p);
          self.dispatchEvent(new TransportMessageEvent(p));
        });
      }
      break;
    case 'm':
      debug('message', this.transport, payload);
      this.dispatchEvent(new TransportMessageEvent(payload));
      break;
    case 'c':
      if (Array.isArray(payload) && payload.length === 2) {
        this._close(payload[0], payload[1], true);
      }
      break;
  }
};

SockJS.prototype._transportClose = function(code, reason) {
  debug('_transportClose', this.transport, code, reason);
  if (this._transport) {
    this._transport.removeAllListeners();
    this._transport = null;
    this.transport = null;
  }

  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
    this._connect();
    return;
  }

  this._close(code, reason);
};

SockJS.prototype._open = function() {
  debug('_open', this._transport.transportName, this.readyState);
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transportTimeoutId) {
      clearTimeout(this._transportTimeoutId);
      this._transportTimeoutId = null;
    }
    this.readyState = SockJS.OPEN;
    this.transport = this._transport.transportName;
    this.dispatchEvent(new Event('open'));
    debug('connected', this.transport);
  } else {
    // The server might have been restarted, and lost track of our
    // connection.
    this._close(1006, 'Server lost session');
  }
};

SockJS.prototype._close = function(code, reason, wasClean) {
  debug('_close', this.transport, code, reason, wasClean, this.readyState);
  var forceFail = false;

  if (this._ir) {
    forceFail = true;
    this._ir.close();
    this._ir = null;
  }
  if (this._transport) {
    this._transport.close();
    this._transport = null;
    this.transport = null;
  }

  if (this.readyState === SockJS.CLOSED) {
    throw new Error('InvalidStateError: SockJS has already been closed');
  }

  this.readyState = SockJS.CLOSING;
  setTimeout(function() {
    this.readyState = SockJS.CLOSED;

    if (forceFail) {
      this.dispatchEvent(new Event('error'));
    }

    var e = new CloseEvent('close');
    e.wasClean = wasClean || false;
    e.code = code || 1000;
    e.reason = reason;

    this.dispatchEvent(e);
    this.onmessage = this.onclose = this.onerror = null;
    debug('disconnected');
  }.bind(this), 0);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
SockJS.prototype.countRTO = function(rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
  if (rtt > 100) {
    return 4 * rtt; // rto > 400msec
  }
  return 300 + rtt; // 300msec < rto <= 400msec
};

module.exports = function(availableTransports) {
  transports = transport(availableTransports);
  require('./iframe-bootstrap')(SockJS, availableTransports);
  return SockJS;
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./event/close":2,"./event/event":4,"./event/eventtarget":5,"./event/trans-message":6,"./iframe-bootstrap":8,"./info-receiver":12,"./location":13,"./shims":15,"./utils/browser":44,"./utils/escape":45,"./utils/event":46,"./utils/log":48,"./utils/object":49,"./utils/random":50,"./utils/transport":51,"./utils/url":52,"./version":53,"debug":55,"inherits":57,"json3":58,"url-parse":61}],15:[function(require,module,exports){
/* eslint-disable */
/* jscs: disable */
'use strict';

// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);

},{}],16:[function(require,module,exports){
'use strict';

module.exports = [
  // streaming transports
  require('./transport/websocket')
, require('./transport/xhr-streaming')
, require('./transport/xdr-streaming')
, require('./transport/eventsource')
, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))

  // polling transports
, require('./transport/htmlfile')
, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))
, require('./transport/xhr-polling')
, require('./transport/xdr-polling')
, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))
, require('./transport/jsonp-polling')
];

},{"./transport/eventsource":20,"./transport/htmlfile":21,"./transport/jsonp-polling":23,"./transport/lib/iframe-wrap":26,"./transport/websocket":38,"./transport/xdr-polling":39,"./transport/xdr-streaming":40,"./transport/xhr-polling":41,"./transport/xhr-streaming":42}],17:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('../../utils/event')
  , urlUtils = require('../../utils/url')
  , XHR = global.XMLHttpRequest
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:browser:xhr');
}

function AbstractXHRObject(method, url, payload, opts) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function () {
    self._start(method, url, payload, opts);
  }, 0);
}

inherits(AbstractXHRObject, EventEmitter);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
  var self = this;

  try {
    this.xhr = new XHR();
  } catch (x) {
    // intentionally empty
  }

  if (!this.xhr) {
    debug('no xhr');
    this.emit('finish', 0, 'no xhr support');
    this._cleanup();
    return;
  }

  // several browsers cache POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload cleanup');
    self._cleanup(true);
  });
  try {
    this.xhr.open(method, url, true);
    if (this.timeout && 'timeout' in this.xhr) {
      this.xhr.timeout = this.timeout;
      this.xhr.ontimeout = function() {
        debug('xhr timeout');
        self.emit('finish', 0, '');
        self._cleanup(false);
      };
    }
  } catch (e) {
    debug('exception', e);
    // IE raises an exception on wrong port.
    this.emit('finish', 0, '');
    this._cleanup(false);
    return;
  }

  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
    debug('withCredentials');
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

    this.xhr.withCredentials = 'true';
  }
  if (opts && opts.headers) {
    for (var key in opts.headers) {
      this.xhr.setRequestHeader(key, opts.headers[key]);
    }
  }

  this.xhr.onreadystatechange = function() {
    if (self.xhr) {
      var x = self.xhr;
      var text, status;
      debug('readyState', x.readyState);
      switch (x.readyState) {
      case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
        try {
          status = x.status;
          text = x.responseText;
        } catch (e) {
          // intentionally empty
        }
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }

        // IE does return readystate == 3 for 404 answers.
        if (status === 200 && text && text.length > 0) {
          debug('chunk');
          self.emit('chunk', status, text);
        }
        break;
      case 4:
        status = x.status;
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
        if (status === 12005 || status === 12029) {
          status = 0;
        }

        debug('finish', status, x.responseText);
        self.emit('finish', status, x.responseText);
        self._cleanup(false);
        break;
      }
    }
  };

  try {
    self.xhr.send(payload);
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
};

AbstractXHRObject.prototype._cleanup = function(abort) {
  debug('cleanup');
  if (!this.xhr) {
    return;
  }
  this.removeAllListeners();
  utils.unloadDel(this.unloadRef);

  // IE needs this field to be a function
  this.xhr.onreadystatechange = function() {};
  if (this.xhr.ontimeout) {
    this.xhr.ontimeout = null;
  }

  if (abort) {
    try {
      this.xhr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

AbstractXHRObject.enabled = !!XHR;
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (!AbstractXHRObject.enabled && (axo in global)) {
  debug('overriding xmlhttprequest');
  XHR = function() {
    try {
      return new global[axo]('Microsoft.XMLHTTP');
    } catch (e) {
      return null;
    }
  };
  AbstractXHRObject.enabled = !!new XHR();
}

var cors = false;
try {
  cors = 'withCredentials' in new XHR();
} catch (ignored) {
  // intentionally empty
}

AbstractXHRObject.supportsCORS = cors;

module.exports = AbstractXHRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],18:[function(require,module,exports){
(function (global){
module.exports = global.EventSource;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
(function (global){
'use strict';

var Driver = global.WebSocket || global.MozWebSocket;
if (Driver) {
	module.exports = function WebSocketBrowserDriver(url) {
		return new Driver(url);
	};
} else {
	module.exports = undefined;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , EventSourceReceiver = require('./receiver/eventsource')
  , XHRCorsObject = require('./sender/xhr-cors')
  , EventSourceDriver = require('eventsource')
  ;

function EventSourceTransport(transUrl) {
  if (!EventSourceTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
}

inherits(EventSourceTransport, AjaxBasedTransport);

EventSourceTransport.enabled = function() {
  return !!EventSourceDriver;
};

EventSourceTransport.transportName = 'eventsource';
EventSourceTransport.roundTrips = 2;

module.exports = EventSourceTransport;

},{"./lib/ajax-based":24,"./receiver/eventsource":29,"./sender/xhr-cors":35,"eventsource":18,"inherits":57}],21:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , HtmlfileReceiver = require('./receiver/htmlfile')
  , XHRLocalObject = require('./sender/xhr-local')
  , AjaxBasedTransport = require('./lib/ajax-based')
  ;

function HtmlFileTransport(transUrl) {
  if (!HtmlfileReceiver.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
}

inherits(HtmlFileTransport, AjaxBasedTransport);

HtmlFileTransport.enabled = function(info) {
  return HtmlfileReceiver.enabled && info.sameOrigin;
};

HtmlFileTransport.transportName = 'htmlfile';
HtmlFileTransport.roundTrips = 2;

module.exports = HtmlFileTransport;

},{"./lib/ajax-based":24,"./receiver/htmlfile":30,"./sender/xhr-local":37,"inherits":57}],22:[function(require,module,exports){
(function (process){
'use strict';

// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var inherits = require('inherits')
  , JSON3 = require('json3')
  , EventEmitter = require('events').EventEmitter
  , version = require('../version')
  , urlUtils = require('../utils/url')
  , iframeUtils = require('../utils/iframe')
  , eventUtils = require('../utils/event')
  , random = require('../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:transport:iframe');
}

function IframeTransport(transport, transUrl, baseUrl) {
  if (!IframeTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  EventEmitter.call(this);

  var self = this;
  this.origin = urlUtils.getOrigin(baseUrl);
  this.baseUrl = baseUrl;
  this.transUrl = transUrl;
  this.transport = transport;
  this.windowId = random.string(8);

  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
  debug(transport, transUrl, iframeUrl);

  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
    debug('err callback');
    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
    self.close();
  });

  this.onmessageCallback = this._message.bind(this);
  eventUtils.attachEvent('message', this.onmessageCallback);
}

inherits(IframeTransport, EventEmitter);

IframeTransport.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.iframeObj) {
    eventUtils.detachEvent('message', this.onmessageCallback);
    try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
      this.postMessage('c');
    } catch (x) {
      // intentionally empty
    }
    this.iframeObj.cleanup();
    this.iframeObj = null;
    this.onmessageCallback = this.iframeObj = null;
  }
};

IframeTransport.prototype._message = function(e) {
  debug('message', e.data);
  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
    debug('not same origin', e.origin, this.origin);
    return;
  }

  var iframeMessage;
  try {
    iframeMessage = JSON3.parse(e.data);
  } catch (ignored) {
    debug('bad json', e.data);
    return;
  }

  if (iframeMessage.windowId !== this.windowId) {
    debug('mismatched window id', iframeMessage.windowId, this.windowId);
    return;
  }

  switch (iframeMessage.type) {
  case 's':
    this.iframeObj.loaded();
    // window global dependency
    this.postMessage('s', JSON3.stringify([
      version
    , this.transport
    , this.transUrl
    , this.baseUrl
    ]));
    break;
  case 't':
    this.emit('message', iframeMessage.data);
    break;
  case 'c':
    var cdata;
    try {
      cdata = JSON3.parse(iframeMessage.data);
    } catch (ignored) {
      debug('bad json', iframeMessage.data);
      return;
    }
    this.emit('close', cdata[0], cdata[1]);
    this.close();
    break;
  }
};

IframeTransport.prototype.postMessage = function(type, data) {
  debug('postMessage', type, data);
  this.iframeObj.post(JSON3.stringify({
    windowId: this.windowId
  , type: type
  , data: data || ''
  }), this.origin);
};

IframeTransport.prototype.send = function(message) {
  debug('send', message);
  this.postMessage('m', message);
};

IframeTransport.enabled = function() {
  return iframeUtils.iframeEnabled;
};

IframeTransport.transportName = 'iframe';
IframeTransport.roundTrips = 2;

module.exports = IframeTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/iframe":47,"../utils/random":50,"../utils/url":52,"../version":53,"debug":55,"events":3,"inherits":57,"json3":58}],23:[function(require,module,exports){
(function (global){
'use strict';

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = require('inherits')
  , SenderReceiver = require('./lib/sender-receiver')
  , JsonpReceiver = require('./receiver/jsonp')
  , jsonpSender = require('./sender/jsonp')
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/sender-receiver":28,"./receiver/jsonp":31,"./sender/jsonp":33,"inherits":57}],24:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , SenderReceiver = require('./sender-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:ajax-based');
}

function createAjaxSender(AjaxObject) {
  return function(url, payload, callback) {
    debug('create ajax sender', url, payload);
    var opt = {};
    if (typeof payload === 'string') {
      opt.headers = {'Content-type': 'text/plain'};
    }
    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
    xo.once('finish', function(status) {
      debug('finish', status);
      xo = null;

      if (status !== 200 && status !== 204) {
        return callback(new Error('http status ' + status));
      }
      callback();
    });
    return function() {
      debug('abort');
      xo.close();
      xo = null;

      var err = new Error('Aborted');
      err.code = 1000;
      callback(err);
    };
  };
}

function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
}

inherits(AjaxBasedTransport, SenderReceiver);

module.exports = AjaxBasedTransport;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./sender-receiver":28,"debug":55,"inherits":57}],25:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self.close();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.close = function() {
  debug('close');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],26:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , IframeTransport = require('../iframe')
  , objectUtils = require('../../utils/object')
  ;

module.exports = function(transport) {

  function IframeWrapTransport(transUrl, baseUrl) {
    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
  }

  inherits(IframeWrapTransport, IframeTransport);

  IframeWrapTransport.enabled = function(url, info) {
    if (!global.document) {
      return false;
    }

    var iframeInfo = objectUtils.extend({}, info);
    iframeInfo.sameOrigin = true;
    return transport.enabled(iframeInfo) && IframeTransport.enabled();
  };

  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
  IframeWrapTransport.needBody = true;
  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

  IframeWrapTransport.facadeTransport = transport;

  return IframeWrapTransport;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/object":49,"../iframe":22,"inherits":57}],27:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],28:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , BufferedSender = require('./buffered-sender')
  , Polling = require('./polling')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender-receiver');
}

function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
  debug(pollUrl);
  var self = this;
  BufferedSender.call(this, transUrl, senderFunc);

  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
  this.poll.on('message', function(msg) {
    debug('poll message', msg);
    self.emit('message', msg);
  });
  this.poll.once('close', function(code, reason) {
    debug('poll close', code, reason);
    self.poll = null;
    self.emit('close', code, reason);
    self.close();
  });
}

inherits(SenderReceiver, BufferedSender);

SenderReceiver.prototype.close = function() {
  BufferedSender.prototype.close.call(this);
  debug('close');
  this.removeAllListeners();
  if (this.poll) {
    this.poll.abort();
    this.poll = null;
  }
};

module.exports = SenderReceiver;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./buffered-sender":25,"./polling":27,"debug":55,"inherits":57}],29:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , EventSourceDriver = require('eventsource')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"eventsource":18,"inherits":57}],30:[function(require,module,exports){
(function (process,global){
'use strict';

var inherits = require('inherits')
  , iframeUtils = require('../../utils/iframe')
  , urlUtils = require('../../utils/url')
  , EventEmitter = require('events').EventEmitter
  , random = require('../../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {
    // intentionally empty
  }
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],31:[function(require,module,exports){
(function (process,global){
'use strict';

var utils = require('../../utils/iframe')
  , random = require('../../utils/random')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {
          // intentionally empty
        }
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {
        // intentionally empty
      }
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],32:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:xhr');
}

function XhrReceiver(url, AjaxObject) {
  debug(url);
  EventEmitter.call(this);
  var self = this;

  this.bufferPosition = 0;

  this.xo = new AjaxObject('POST', url, null);
  this.xo.on('chunk', this._chunkHandler.bind(this));
  this.xo.once('finish', function(status, text) {
    debug('finish', status, text);
    self._chunkHandler(status, text);
    self.xo = null;
    var reason = status === 200 ? 'network' : 'permanent';
    debug('close', reason);
    self.emit('close', null, reason);
    self._cleanup();
  });
}

inherits(XhrReceiver, EventEmitter);

XhrReceiver.prototype._chunkHandler = function(status, text) {
  debug('_chunkHandler', status);
  if (status !== 200 || !text) {
    return;
  }

  for (var idx = -1; ; this.bufferPosition += idx + 1) {
    var buf = text.slice(this.bufferPosition);
    idx = buf.indexOf('\n');
    if (idx === -1) {
      break;
    }
    var msg = buf.slice(0, idx);
    if (msg) {
      debug('message', msg);
      this.emit('message', msg);
    }
  }
};

XhrReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

XhrReceiver.prototype.abort = function() {
  debug('abort');
  if (this.xo) {
    this.xo.close();
    debug('close');
    this.emit('close', null, 'user');
    this.xo = null;
  }
  this._cleanup();
};

module.exports = XhrReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],33:[function(require,module,exports){
(function (process,global){
'use strict';

var random = require('../../utils/random')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/random":50,"../../utils/url":52,"debug":55}],34:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , eventUtils = require('../../utils/event')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:xdr');
}

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

function XDRObject(method, url, payload) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self._start(method, url, payload);
  }, 0);
}

inherits(XDRObject, EventEmitter);

XDRObject.prototype._start = function(method, url, payload) {
  debug('_start');
  var self = this;
  var xdr = new global.XDomainRequest();
  // IE caches even POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  xdr.onerror = function() {
    debug('onerror');
    self._error();
  };
  xdr.ontimeout = function() {
    debug('ontimeout');
    self._error();
  };
  xdr.onprogress = function() {
    debug('progress', xdr.responseText);
    self.emit('chunk', 200, xdr.responseText);
  };
  xdr.onload = function() {
    debug('load');
    self.emit('finish', 200, xdr.responseText);
    self._cleanup(false);
  };
  this.xdr = xdr;
  this.unloadRef = eventUtils.unloadAdd(function() {
    self._cleanup(true);
  });
  try {
    // Fails with AccessDenied if port number is bogus
    this.xdr.open(method, url);
    if (this.timeout) {
      this.xdr.timeout = this.timeout;
    }
    this.xdr.send(payload);
  } catch (x) {
    this._error();
  }
};

XDRObject.prototype._error = function() {
  this.emit('finish', 0, '');
  this._cleanup(false);
};

XDRObject.prototype._cleanup = function(abort) {
  debug('cleanup', abort);
  if (!this.xdr) {
    return;
  }
  this.removeAllListeners();
  eventUtils.unloadDel(this.unloadRef);

  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
  if (abort) {
    try {
      this.xdr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xdr = null;
};

XDRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

// IE 8/9 if the request target uses the same scheme - #79
XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

module.exports = XDRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],35:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRCorsObject(method, url, payload, opts) {
  XhrDriver.call(this, method, url, payload, opts);
}

inherits(XHRCorsObject, XhrDriver);

XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

module.exports = XHRCorsObject;

},{"../driver/xhr":17,"inherits":57}],36:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;

},{"events":3,"inherits":57}],37:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRLocalObject(method, url, payload /*, opts */) {
  XhrDriver.call(this, method, url, payload, {
    noCredentials: true
  });
}

inherits(XHRLocalObject, XhrDriver);

XHRLocalObject.enabled = XhrDriver.enabled;

module.exports = XHRLocalObject;

},{"../driver/xhr":17,"inherits":57}],38:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('../utils/event')
  , urlUtils = require('../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , WebsocketDriver = require('./driver/websocket')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:websocket');
}

function WebSocketTransport(transUrl, ignore, options) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url, [], options);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  var ws = this.ws;
  this._cleanup();
  if (ws) {
    ws.close();
  }
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/url":52,"./driver/websocket":19,"debug":55,"events":3,"inherits":57}],39:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XdrStreamingTransport = require('./xdr-streaming')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"./xdr-streaming":40,"inherits":57}],40:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

function XdrStreamingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
}

inherits(XdrStreamingTransport, AjaxBasedTransport);

XdrStreamingTransport.enabled = function(info) {
  if (info.cookie_needed || info.nullOrigin) {
    return false;
  }
  return XDRObject.enabled && info.sameScheme;
};

XdrStreamingTransport.transportName = 'xdr-streaming';
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrStreamingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"inherits":57}],41:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  ;

function XhrPollingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
}

inherits(XhrPollingTransport, AjaxBasedTransport);

XhrPollingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }

  if (XHRLocalObject.enabled && info.sameOrigin) {
    return true;
  }
  return XHRCorsObject.enabled;
};

XhrPollingTransport.transportName = 'xhr-polling';
XhrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XhrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],42:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  , browser = require('../utils/browser')
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../utils/browser":44,"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],43:[function(require,module,exports){
(function (global){
'use strict';

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],44:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  isOpera: function() {
    return global.navigator &&
      /opera/i.test(global.navigator.userAgent);
  }

, isKonqueror: function() {
    return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent);
  }

  // #187 wrap document.domain in try/catch because of WP8 from file:///
, hasDomain: function () {
    // non-browser client always has a domain
    if (!global.document) {
      return true;
    }

    try {
      return !!global.document.domain;
    } catch (e) {
      return false;
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],45:[function(require,module,exports){
'use strict';

var JSON3 = require('json3');

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
// eslint-disable-next-line no-control-regex
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON3.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};

},{"json3":58}],46:[function(require,module,exports){
(function (global){
'use strict';

var random = require('./random');

var onUnload = {}
  , afterUnload = false
    // detect google chrome packaged apps because they don't allow the 'unload' event
  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
  ;

module.exports = {
  attachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.addEventListener(event, listener, false);
    } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
      global.document.attachEvent('on' + event, listener);
      // I get 'window' for ie8.
      global.attachEvent('on' + event, listener);
    }
  }

, detachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.removeEventListener(event, listener, false);
    } else if (global.document && global.detachEvent) {
      global.document.detachEvent('on' + event, listener);
      global.detachEvent('on' + event, listener);
    }
  }

, unloadAdd: function(listener) {
    if (isChromePackagedApp) {
      return null;
    }

    var ref = random.string(8);
    onUnload[ref] = listener;
    if (afterUnload) {
      setTimeout(this.triggerUnloadCallbacks, 0);
    }
    return ref;
  }

, unloadDel: function(ref) {
    if (ref in onUnload) {
      delete onUnload[ref];
    }
  }

, triggerUnloadCallbacks: function() {
    for (var ref in onUnload) {
      onUnload[ref]();
      delete onUnload[ref];
    }
  }
};

var unloadTriggered = function() {
  if (afterUnload) {
    return;
  }
  afterUnload = true;
  module.exports.triggerUnloadCallbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
if (!isChromePackagedApp) {
  module.exports.attachEvent('unload', unloadTriggered);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./random":50}],47:[function(require,module,exports){
(function (process,global){
'use strict';

var eventUtils = require('./event')
  , JSON3 = require('json3')
  , browser = require('./browser')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:iframe');
}

module.exports = {
  WPrefix: '_jp'
, currentWindowId: null

, polluteGlobalNamespace: function() {
    if (!(module.exports.WPrefix in global)) {
      global[module.exports.WPrefix] = {};
    }
  }

, postMessage: function(type, data) {
    if (global.parent !== global) {
      global.parent.postMessage(JSON3.stringify({
        windowId: module.exports.currentWindowId
      , type: type
      , data: data || ''
      }), '*');
    } else {
      debug('Cannot postMessage, no parent window.', type, data);
    }
  }

, createIframe: function(iframeUrl, errorCallback) {
    var iframe = global.document.createElement('iframe');
    var tref, unloadRef;
    var unattach = function() {
      debug('unattach');
      clearTimeout(tref);
      // Explorer had problems with that.
      try {
        iframe.onload = null;
      } catch (x) {
        // intentionally empty
      }
      iframe.onerror = null;
    };
    var cleanup = function() {
      debug('cleanup');
      if (iframe) {
        unattach();
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
        setTimeout(function() {
          if (iframe) {
            iframe.parentNode.removeChild(iframe);
          }
          iframe = null;
        }, 0);
        eventUtils.unloadDel(unloadRef);
      }
    };
    var onerror = function(err) {
      debug('onerror', err);
      if (iframe) {
        cleanup();
        errorCallback(err);
      }
    };
    var post = function(msg, origin) {
      debug('post', msg, origin);
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {
        // intentionally empty
      }
    };

    iframe.src = iframeUrl;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function() {
      onerror('onerror');
    };
    iframe.onload = function() {
      debug('onload');
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
      clearTimeout(tref);
      tref = setTimeout(function() {
        onerror('onload timeout');
      }, 2000);
    };
    global.document.body.appendChild(iframe);
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }

/* eslint no-undef: "off", new-cap: "off" */
, createHtmlfile: function(iframeUrl, errorCallback) {
    var axo = ['Active'].concat('Object').join('X');
    var doc = new global[axo]('htmlfile');
    var tref, unloadRef;
    var iframe;
    var unattach = function() {
      clearTimeout(tref);
      iframe.onerror = null;
    };
    var cleanup = function() {
      if (doc) {
        unattach();
        eventUtils.unloadDel(unloadRef);
        iframe.parentNode.removeChild(iframe);
        iframe = doc = null;
        CollectGarbage();
      }
    };
    var onerror = function(r) {
      debug('onerror', r);
      if (doc) {
        cleanup();
        errorCallback(r);
      }
    };
    var post = function(msg, origin) {
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {
        // intentionally empty
      }
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframeUrl;
    iframe.onerror = function() {
      onerror('onerror');
    };
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }
};

module.exports.iframeEnabled = false;
if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror());
}

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./browser":44,"./event":46,"debug":55,"json3":58}],48:[function(require,module,exports){
(function (global){
'use strict';

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists;

  try {
    levelExists = global.console && global.console[level] && global.console[level].apply;
  } catch(e) {
    // do nothing
  }

  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
'use strict';

module.exports = {
  isObject: function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

, extend: function(obj) {
    if (!this.isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  }
};

},{}],50:[function(require,module,exports){
'use strict';

/* global crypto:true */
var crypto = require('crypto');

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
module.exports = {
  string: function(length) {
    var max = _randomStringChars.length;
    var bytes = crypto.randomBytes(length);
    var ret = [];
    for (var i = 0; i < length; i++) {
      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
    }
    return ret.join('');
  }

, number: function(max) {
    return Math.floor(Math.random() * max);
  }

, numberString: function(max) {
    var t = ('' + (max - 1)).length;
    var p = new Array(t + 1).join('0');
    return (p + this.number(max)).slice(-t);
  }
};

},{"crypto":43}],51:[function(require,module,exports){
(function (process){
'use strict';

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

}).call(this,{ env: {} })

},{"debug":55}],52:[function(require,module,exports){
(function (process){
'use strict';

var URL = require('url-parse');

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:url');
}

module.exports = {
  getOrigin: function(url) {
    if (!url) {
      return null;
    }

    var p = new URL(url);
    if (p.protocol === 'file:') {
      return null;
    }

    var port = p.port;
    if (!port) {
      port = (p.protocol === 'https:') ? '443' : '80';
    }

    return p.protocol + '//' + p.hostname + ':' + port;
  }

, isOriginEqual: function(a, b) {
    var res = this.getOrigin(a) === this.getOrigin(b);
    debug('same', a, b, res);
    return res;
  }

, isSchemeEqual: function(a, b) {
    return (a.split(':')[0] === b.split(':')[0]);
  }

, addPath: function (url, path) {
    var qs = url.split('?');
    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
  }

, addQuery: function (url, q) {
    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
  }
};

}).call(this,{ env: {} })

},{"debug":55,"url-parse":61}],53:[function(require,module,exports){
module.exports = '1.1.4';

},{}],54:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000
var m = s * 60
var h = m * 60
var d = h * 24
var y = d * 365.25

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {}
  var type = typeof val
  if (type === 'string' && val.length > 0) {
    return parse(val)
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ?
			fmtLong(val) :
			fmtShort(val)
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
}

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str)
  if (str.length > 10000) {
    return
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
  if (!match) {
    return
  }
  var n = parseFloat(match[1])
  var type = (match[2] || 'ms').toLowerCase()
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y
    case 'days':
    case 'day':
    case 'd':
      return n * d
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n
    default:
      return undefined
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd'
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h'
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm'
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's'
  }
  return ms + 'ms'
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms'
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name
  }
  return Math.ceil(ms / n) + ' ' + name + 's'
}

},{}],55:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,{ env: {} })

},{"./debug":56}],56:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":54}],57:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],58:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  //
  // Little nifty parsing hack, leverage the fact that RegExp.exec increments
  // the lastIndex property so we can continue executing this loop until we've
  // parsed all results.
  //
  for (;
    part = parser.exec(query);
    result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])
  );

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],60:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],61:[function(require,module,exports){
'use strict';

var required = require('requires-port')
  , lolcation = require('./lolcation')
  , qs = require('querystringify')
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @api private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @api private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} location Location defaults for relative paths.
 * @param {Boolean|Function} parser Parser for the query string.
 * @api public
 */
function URL(address, location, parser) {
  if (!(this instanceof URL)) {
    return new URL(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[2] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];
    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL}
 * @api public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
      url.pathname = value.length && value.charAt(0) !== '/' ? '/' + value : value;

      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
};

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String}
 * @api public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

URL.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
URL.extractProtocol = extractProtocol;
URL.location = lolcation;
URL.qs = qs;

module.exports = URL;

},{"./lolcation":62,"querystringify":59,"requires-port":60}],62:[function(require,module,exports){
(function (global){
'use strict';

var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 }
  , URL;

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @api public
 */
module.exports = function lolcation(loc) {
  loc = loc || global.location || {};
  URL = URL || require('./');

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new URL(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new URL(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./":61}]},{},[1])(1)
});


//# sourceMappingURL=sockjs.js.map

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ansiRegex = __webpack_require__(46)();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(53);
var util = __webpack_require__(60);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(56);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).

var ansiHTML = __webpack_require__(45);
var Entities = __webpack_require__(48).AllHtmlEntities;

var entities = new Entities();

var colors = {
  reset: ['transparent', 'transparent'],
  black: '181818',
  red: 'E36049',
  green: 'B3CB74',
  yellow: 'FFD080',
  blue: '7CAFC2',
  magenta: '7FACCA',
  cyan: 'C3C2EF',
  lightgrey: 'EBE7E3',
  darkgrey: '6D7891'
};
ansiHTML.setColors(colors);

function createOverlayIframe(onIframeLoad) {
  var iframe = document.createElement('iframe');
  iframe.id = 'webpack-dev-server-client-overlay';
  iframe.src = 'about:blank';
  iframe.style.position = 'fixed';
  iframe.style.left = 0;
  iframe.style.top = 0;
  iframe.style.right = 0;
  iframe.style.bottom = 0;
  iframe.style.width = '100vw';
  iframe.style.height = '100vh';
  iframe.style.border = 'none';
  iframe.style.zIndex = 9999999999;
  iframe.onload = onIframeLoad;
  return iframe;
}

function addOverlayDivTo(iframe) {
  var div = iframe.contentDocument.createElement('div');
  div.id = 'webpack-dev-server-client-overlay-div';
  div.style.position = 'fixed';
  div.style.boxSizing = 'border-box';
  div.style.left = 0;
  div.style.top = 0;
  div.style.right = 0;
  div.style.bottom = 0;
  div.style.width = '100vw';
  div.style.height = '100vh';
  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
  div.style.color = '#E8E8E8';
  div.style.fontFamily = 'Menlo, Consolas, monospace';
  div.style.fontSize = 'large';
  div.style.padding = '2rem';
  div.style.lineHeight = '1.2';
  div.style.whiteSpace = 'pre-wrap';
  div.style.overflow = 'auto';
  iframe.contentDocument.body.appendChild(div);
  return div;
}

var overlayIframe = null;
var overlayDiv = null;
var lastOnOverlayDivReady = null;

function ensureOverlayDivExists(onOverlayDivReady) {
  if (overlayDiv) {
    // Everything is ready, call the callback right away.
    onOverlayDivReady(overlayDiv);
    return;
  }

  // Creating an iframe may be asynchronous so we'll schedule the callback.
  // In case of multiple calls, last callback wins.
  lastOnOverlayDivReady = onOverlayDivReady;

  if (overlayIframe) {
    // We're already creating it.
    return;
  }

  // Create iframe and, when it is ready, a div inside it.
  overlayIframe = createOverlayIframe(function () {
    overlayDiv = addOverlayDivTo(overlayIframe);
    // Now we can talk!
    lastOnOverlayDivReady(overlayDiv);
  });

  // Zalgo alert: onIframeLoad() will be called either synchronously
  // or asynchronously depending on the browser.
  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.
  document.body.appendChild(overlayIframe);
}

function showMessageOverlay(message) {
  ensureOverlayDivExists(function (div) {
    // Make it look similar to our terminal.
    div.innerHTML = '<span style="color: #' + colors.red + '">Failed to compile.</span><br><br>' + ansiHTML(entities.encode(message));
  });
}

function destroyErrorOverlay() {
  if (!overlayDiv) {
    // It is not there in the first place.
    return;
  }

  // Clean up and reset internal state.
  document.body.removeChild(overlayIframe);
  overlayDiv = null;
  overlayIframe = null;
  lastOnOverlayDivReady = null;
}

// Successful compilation.
exports.clear = function handleSuccess() {
  destroyErrorOverlay();
};

// Compilation with errors (e.g. syntax error or missing modules).
exports.showMessage = function handleMessage(messages) {
  showMessageOverlay(messages[0]);
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SockJS = __webpack_require__(57);

var retries = 0;
var sock = null;

var socket = function initSocket(url, handlers) {
  sock = new SockJS(url);

  sock.onopen = function onopen() {
    retries = 0;
  };

  sock.onclose = function onclose() {
    if (retries === 0) {
      handlers.close();
    }

    // Try to reconnect.
    sock = null;

    // After 10 retries stop trying, to prevent logspam.
    if (retries <= 10) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-mixed-operators, no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;

      setTimeout(function () {
        socket(url, handlers);
      }, retryInMs);
    }
  };

  sock.onmessage = function onmessage(e) {
    // This assumes that all data sent via the websocket is JSON.
    var msg = JSON.parse(e.data);
    if (handlers[msg.type]) {
      handlers[msg.type](msg.data);
    }
  };
};

module.exports = socket;

/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var EventEmitter = __webpack_require__(47);
module.exports = new EventEmitter();


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var SensorSample = __webpack_require__(67);
var MathUtil = __webpack_require__(6);
var Util = __webpack_require__(10);

/**
 * An implementation of a simple complementary filter, which fuses gyroscope and
 * accelerometer data from the 'devicemotion' event.
 *
 * Accelerometer data is very noisy, but stable over the long term.
 * Gyroscope data is smooth, but tends to drift over the long term.
 *
 * This fusion is relatively simple:
 * 1. Get orientation estimates from accelerometer by applying a low-pass filter
 *    on that data.
 * 2. Get orientation estimates from gyroscope by integrating over time.
 * 3. Combine the two estimates, weighing (1) in the long term, but (2) for the
 *    short term.
 */
function ComplementaryFilter(kFilter) {
  this.kFilter = kFilter;

  // Raw sensor measurements.
  this.currentAccelMeasurement = new SensorSample();
  this.currentGyroMeasurement = new SensorSample();
  this.previousGyroMeasurement = new SensorSample();

  // Set default look direction to be in the correct direction.
  if (Util.isIOS()) {
    this.filterQ = new MathUtil.Quaternion(-1, 0, 0, 1);
  } else {
    this.filterQ = new MathUtil.Quaternion(1, 0, 0, 1);
  }
  this.previousFilterQ = new MathUtil.Quaternion();
  this.previousFilterQ.copy(this.filterQ);

  // Orientation based on the accelerometer.
  this.accelQ = new MathUtil.Quaternion();
  // Whether or not the orientation has been initialized.
  this.isOrientationInitialized = false;
  // Running estimate of gravity based on the current orientation.
  this.estimatedGravity = new MathUtil.Vector3();
  // Measured gravity based on accelerometer.
  this.measuredGravity = new MathUtil.Vector3();

  // Debug only quaternion of gyro-based orientation.
  this.gyroIntegralQ = new MathUtil.Quaternion();
}

ComplementaryFilter.prototype.addAccelMeasurement = function(vector, timestampS) {
  this.currentAccelMeasurement.set(vector, timestampS);
};

ComplementaryFilter.prototype.addGyroMeasurement = function(vector, timestampS) {
  this.currentGyroMeasurement.set(vector, timestampS);

  var deltaT = timestampS - this.previousGyroMeasurement.timestampS;
  if (Util.isTimestampDeltaValid(deltaT)) {
    this.run_();
  }

  this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
};

ComplementaryFilter.prototype.run_ = function() {

  if (!this.isOrientationInitialized) {
    this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
    this.previousFilterQ.copy(this.accelQ);
    this.isOrientationInitialized = true;
    return;
  }

  var deltaT = this.currentGyroMeasurement.timestampS -
      this.previousGyroMeasurement.timestampS;

  // Convert gyro rotation vector to a quaternion delta.
  var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
  this.gyroIntegralQ.multiply(gyroDeltaQ);

  // filter_1 = K * (filter_0 + gyro * dT) + (1 - K) * accel.
  this.filterQ.copy(this.previousFilterQ);
  this.filterQ.multiply(gyroDeltaQ);

  // Calculate the delta between the current estimated gravity and the real
  // gravity vector from accelerometer.
  var invFilterQ = new MathUtil.Quaternion();
  invFilterQ.copy(this.filterQ);
  invFilterQ.inverse();

  this.estimatedGravity.set(0, 0, -1);
  this.estimatedGravity.applyQuaternion(invFilterQ);
  this.estimatedGravity.normalize();

  this.measuredGravity.copy(this.currentAccelMeasurement.sample);
  this.measuredGravity.normalize();

  // Compare estimated gravity with measured gravity, get the delta quaternion
  // between the two.
  var deltaQ = new MathUtil.Quaternion();
  deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
  deltaQ.inverse();

  if (Util.isDebug()) {
    console.log('Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)',
                MathUtil.radToDeg * Util.getQuaternionAngle(deltaQ),
                (this.estimatedGravity.x).toFixed(1),
                (this.estimatedGravity.y).toFixed(1),
                (this.estimatedGravity.z).toFixed(1),
                (this.measuredGravity.x).toFixed(1),
                (this.measuredGravity.y).toFixed(1),
                (this.measuredGravity.z).toFixed(1));
  }

  // Calculate the SLERP target: current orientation plus the measured-estimated
  // quaternion delta.
  var targetQ = new MathUtil.Quaternion();
  targetQ.copy(this.filterQ);
  targetQ.multiply(deltaQ);

  // SLERP factor: 0 is pure gyro, 1 is pure accel.
  this.filterQ.slerp(targetQ, 1 - this.kFilter);

  this.previousFilterQ.copy(this.filterQ);
};

ComplementaryFilter.prototype.getOrientation = function() {
  return this.filterQ;
};

ComplementaryFilter.prototype.accelToQuaternion_ = function(accel) {
  var normAccel = new MathUtil.Vector3();
  normAccel.copy(accel);
  normAccel.normalize();
  var quat = new MathUtil.Quaternion();
  quat.setFromUnitVectors(new MathUtil.Vector3(0, 0, -1), normAccel);
  quat.inverse();
  return quat;
};

ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function(gyro, dt) {
  // Extract axis and angle from the gyroscope data.
  var quat = new MathUtil.Quaternion();
  var axis = new MathUtil.Vector3();
  axis.copy(gyro);
  axis.normalize();
  quat.setFromAxisAngle(axis, gyro.length() * dt);
  return quat;
};


module.exports = ComplementaryFilter;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MathUtil = __webpack_require__(6);
var Util = __webpack_require__(10);

/**
 * Given an orientation and the gyroscope data, predicts the future orientation
 * of the head. This makes rendering appear faster.
 *
 * Also see: http://msl.cs.uiuc.edu/~lavalle/papers/LavYerKatAnt14.pdf
 *
 * @param {Number} predictionTimeS time from head movement to the appearance of
 * the corresponding image.
 */
function PosePredictor(predictionTimeS) {
  this.predictionTimeS = predictionTimeS;

  // The quaternion corresponding to the previous state.
  this.previousQ = new MathUtil.Quaternion();
  // Previous time a prediction occurred.
  this.previousTimestampS = null;

  // The delta quaternion that adjusts the current pose.
  this.deltaQ = new MathUtil.Quaternion();
  // The output quaternion.
  this.outQ = new MathUtil.Quaternion();
}

PosePredictor.prototype.getPrediction = function(currentQ, gyro, timestampS) {
  if (!this.previousTimestampS) {
    this.previousQ.copy(currentQ);
    this.previousTimestampS = timestampS;
    return currentQ;
  }

  // Calculate axis and angle based on gyroscope rotation rate data.
  var axis = new MathUtil.Vector3();
  axis.copy(gyro);
  axis.normalize();

  var angularSpeed = gyro.length();

  // If we're rotating slowly, don't do prediction.
  if (angularSpeed < MathUtil.degToRad * 20) {
    if (Util.isDebug()) {
      console.log('Moving slowly, at %s deg/s: no prediction',
                  (MathUtil.radToDeg * angularSpeed).toFixed(1));
    }
    this.outQ.copy(currentQ);
    this.previousQ.copy(currentQ);
    return this.outQ;
  }

  // Get the predicted angle based on the time delta and latency.
  var deltaT = timestampS - this.previousTimestampS;
  var predictAngle = angularSpeed * this.predictionTimeS;

  this.deltaQ.setFromAxisAngle(axis, predictAngle);
  this.outQ.copy(this.previousQ);
  this.outQ.multiply(this.deltaQ);

  this.previousQ.copy(currentQ);
  this.previousTimestampS = timestampS;

  return this.outQ;
};


module.exports = PosePredictor;


/***/ }),
/* 67 */
/***/ (function(module, exports) {

function SensorSample(sample, timestampS) {
  this.set(sample, timestampS);
};

SensorSample.prototype.set = function(sample, timestampS) {
  this.sample = sample;
  this.timestampS = timestampS;
};

SensorSample.prototype.copy = function(sensorSample) {
  this.set(sensorSample.sample, sensorSample.timestampS);
};

module.exports = SensorSample;


/***/ }),
/* 68 */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	throw new Error("Cannot find module '" + req + "'.");
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = 68;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(21);
module.exports = __webpack_require__(20);


/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBlNzgyNjQ0ZmIwZjE4M2IxYjdiZCIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcIkBlZ2pzL2NvbXBvbmVudFwiLFwiY29tbW9uanMyXCI6XCJAZWdqcy9jb21wb25lbnRcIixcImFtZFwiOlwiQGVnanMvY29tcG9uZW50XCIsXCJyb290XCI6W1wiZWdcIixcIkNvbXBvbmVudFwiXX0iLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL21hdGgtdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvbWF0aFV0aWwvY29tbW9uLmpzIiwid2VicGFjazovLy8uL34vQGVnanMvYWdlbnQvZGlzdC9hZ2VudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvWWF3UGl0Y2hDb250cm9sL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vd2VidnItcG9seWZpbGwvc3JjL21hdGgtdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvUGFub0ltYWdlUmVuZGVyZXIvV2ViR0xVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvWWF3UGl0Y2hDb250cm9sL2NvbnN0cy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vd2VidnItcG9seWZpbGwvc3JjL3V0aWwuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJAZWdqcy9heGVzXCIsXCJjb21tb25qczJcIjpcIkBlZ2pzL2F4ZXNcIixcImFtZFwiOlwiQGVnanMvYXhlc1wiLFwicm9vdFwiOltcImVnXCIsXCJBeGVzXCJdfSIsIndlYnBhY2s6Ly8vLi9zcmMvUGFub0ltYWdlUmVuZGVyZXIvcmVuZGVyZXIvUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1Bhbm9WaWV3ZXIvY29uc3RzLmpzIiwid2VicGFjazovLy8uL3NyYy9TcGluVmlld2VyL1Nwcml0ZUltYWdlLmpzIiwid2VicGFjazovLy8uL3NyYy9ZYXdQaXRjaENvbnRyb2wvU2NyZWVuUm90YXRpb25BbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvWWF3UGl0Y2hDb250cm9sL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ZYXdQaXRjaENvbnRyb2wvaW5wdXQvRnVzaW9uUG9zZVNlbnNvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvWWF3UGl0Y2hDb250cm9sL3V0aWxzLmpzIiwid2VicGFjazovLy8uL34vaHRtbC1lbnRpdGllcy9saWIvaHRtbDUtZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQ/NWU2OSIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50Iiwid2VicGFjazovLy8uL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9JbWFnZUxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvUGFub0ltYWdlUmVuZGVyZXIvUGFub0ltYWdlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1Bhbm9JbWFnZVJlbmRlcmVyL1ZpZGVvTG9hZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9icm93c2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvUGFub0ltYWdlUmVuZGVyZXIvcmVuZGVyZXIvQ3ViZVJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9yZW5kZXJlci9TcGhlcmVSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvUGFub1ZpZXdlci9QYW5vVmlld2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9QYW5vVmlld2VyL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1Bhbm9WaWV3ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NwaW5WaWV3ZXIvU3BpblZpZXdlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU3BpblZpZXdlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvWWF3UGl0Y2hDb250cm9sL0RldmljZVF1YXRlcm5pb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1lhd1BpdGNoQ29udHJvbC9ZYXdQaXRjaENvbnRyb2wuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1lhd1BpdGNoQ29udHJvbC9pbnB1dC9Db21wbGVtZW50YXJ5RmlsdGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9ZYXdQaXRjaENvbnRyb2wvaW5wdXQvRGV2aWNlTW90aW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9ZYXdQaXRjaENvbnRyb2wvaW5wdXQvUm90YXRpb25QYW5JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvWWF3UGl0Y2hDb250cm9sL2lucHV0L1RpbHRNb3Rpb25JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvWWF3UGl0Y2hDb250cm9sL2lucHV0L1doZWVsSW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL21hdGhVdGlsL21hdDQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL21hdGhVdGlsL3F1YXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL21hdGhVdGlsL3ZlYzIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL21hdGhVdGlsL3ZlYzMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbnNpLWh0bWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbnNpLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2h0bWwtZW50aXRpZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9odG1sLWVudGl0aWVzL2xpYi9odG1sNC1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2h0bWwtZW50aXRpZXMvbGliL3htbC1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8uL34vcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2Rpc3Qvc29ja2pzLmpzIiwid2VicGFjazovLy8uL34vc3RyaXAtYW5zaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vLy4vfi91cmwvdXRpbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L292ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9zb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9lbWl0dGVyLmpzIiwid2VicGFjazovLy8uL34vd2VidnItcG9seWZpbGwvc3JjL3NlbnNvci1mdXNpb24vY29tcGxlbWVudGFyeS1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi93ZWJ2ci1wb2x5ZmlsbC9zcmMvc2Vuc29yLWZ1c2lvbi9wb3NlLXByZWRpY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3dlYnZyLXBvbHlmaWxsL3NyYy9zZW5zb3ItZnVzaW9uL3NlbnNvci1zYW1wbGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9ob3Qgbm9ucmVjdXJzaXZlIF5cXC5cXC9sb2ckIl0sIm5hbWVzIjpbInF1YXRUb1ZlYzMiLCJxdWF0ZXJuaW9uIiwiYmFzZVYiLCJmcm9tVmFsdWVzIiwidHJhbnNmb3JtUXVhdCIsInV0aWwiLCJpc1Bvd2VyT2ZUd28iLCJuIiwiZXh0cmFjdFBpdGNoRnJvbVF1YXQiLCJNYXRoIiwiYXRhbjIiLCJzcXJ0IiwicG93IiwiUk9UQVRFX0NPTlNUQU5UIiwiUElUQ0hfREVMVEEiLCJZQVdfREVMVEFfQllfUk9MTCIsIllBV19ERUxUQV9CWV9ZQVciLCJ0YXJnZXRBeGlzIiwibWVzaFBvaW50IiwiZ2V0Um90YXRpb25EZWx0YSIsInByZXZRIiwiY3VyUSIsInJvdGF0ZUtpbmQiLCJwcmV2UXVhdGVybmlvbiIsImNsb25lIiwiY3VyUXVhdGVybmlvbiIsIm5vcm1hbGl6ZSIsInByZXZQb2ludCIsImN1clBvaW50Iiwicm90YXRlRGlzdGFuY2UiLCJkb3QiLCJjcm9zcyIsImNyZWF0ZSIsInJvdGF0ZURpcmVjdGlvbiIsIm1lc2hQb2ludDIiLCJtZXNoUG9pbnQzIiwidmVjVSIsInZlY1YiLCJ2ZWNOIiwiY29lZmZpY2llbnRBIiwiY29lZmZpY2llbnRCIiwiY29lZmZpY2llbnRDIiwiZGlzdGFuY2UiLCJhYnMiLCJwcm9qZWN0ZWRQcmV2UG9pbnQiLCJzdWJ0cmFjdCIsInNjYWxlIiwidHJpZ29ub21ldHJpY1JhdGlvIiwibGVuZ3RoIiwidGhldGEiLCJhY29zIiwiY3Jvc3NWZWMiLCJ0aGV0YURpcmVjdGlvbiIsImRlbHRhUmFkaWFuIiwidG9EZWdyZWUiLCJnbE1hdHJpeCIsIm1hdDQiLCJxdWF0IiwidmVjMiIsInZlYzMiLCJBUlJBWV9UWVBFIiwiRmxvYXQzMkFycmF5IiwiQXJyYXkiLCJkZWdyZWUiLCJQSSIsInRvUmFkaWFuIiwiYSIsIkVQU0lMT04iLCJtb2R1bGUiLCJleHBvcnRzIiwid2luIiwid2luZG93Iiwic2VsZiIsIkZ1bmN0aW9uIiwiZG9jdW1lbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwidXNlckFnZW50IiwibmF2aWdhdG9yIiwiU1VQUE9SVF9UT1VDSCIsIlNVUFBPUlRfREVWSUNFTU9USU9OIiwiV0VCR0xfRVJST1JfQ09ERSIsIndlYmdsQXZhaWxhYmlsaXR5IiwiV2ViR0xVdGlscyIsImNyZWF0ZVNoYWRlciIsImdsIiwidHlwZSIsInNvdXJjZSIsInNoYWRlciIsInNoYWRlclNvdXJjZSIsImNvbXBpbGVTaGFkZXIiLCJzdWNjZXNzIiwiZ2V0U2hhZGVyUGFyYW1ldGVyIiwiQ09NUElMRV9TVEFUVVMiLCJkZWxldGVTaGFkZXIiLCJjcmVhdGVQcm9ncmFtIiwidmVydGV4U2hhZGVyIiwiZnJhZ21lbnRTaGFkZXIiLCJwcm9ncmFtIiwiYXR0YWNoU2hhZGVyIiwibGlua1Byb2dyYW0iLCJnZXRQcm9ncmFtUGFyYW1ldGVyIiwiTElOS19TVEFUVVMiLCJkZWxldGVQcm9ncmFtIiwiaW5pdEJ1ZmZlciIsInRhcmdldCIsImRhdGEiLCJpdGVtU2l6ZSIsImF0dHIiLCJidWZmZXIiLCJjcmVhdGVCdWZmZXIiLCJiaW5kQnVmZmVyIiwiYnVmZmVyRGF0YSIsIlNUQVRJQ19EUkFXIiwibnVtSXRlbXMiLCJ1bmRlZmluZWQiLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsInZlcnRleEF0dHJpYlBvaW50ZXIiLCJGTE9BVCIsImJpbmRCdWZmZXJUb0F0dHJpYnV0ZSIsIkFSUkFZX0JVRkZFUiIsImdldFdlYmdsQ29udGV4dCIsImNhbnZhcyIsInVzZXJDb250ZXh0QXR0cmlidXRlcyIsIndlYmdsSWRlbnRpZmllcnMiLCJjb250ZXh0IiwiY29udGV4dEF0dHJpYnV0ZXMiLCJwcmVzZXJ2ZURyYXdpbmdCdWZmZXIiLCJhbnRpYWxpYXMiLCJvbldlYmdsY29udGV4dGNyZWF0aW9uZXJyb3IiLCJlIiwic3RhdHVzTWVzc2FnZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJpIiwiZ2V0Q29udGV4dCIsInQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY3JlYXRlVGV4dHVyZSIsInRleHR1cmVUYXJnZXQiLCJ0ZXh0dXJlIiwiYmluZFRleHR1cmUiLCJ0ZXhQYXJhbWV0ZXJpIiwiVEVYVFVSRV9NQUdfRklMVEVSIiwiTElORUFSIiwiVEVYVFVSRV9NSU5fRklMVEVSIiwiVEVYVFVSRV9XUkFQX1MiLCJDTEFNUF9UT19FREdFIiwiVEVYVFVSRV9XUkFQX1QiLCJpc1dlYkdMQXZhaWxhYmxlIiwiY3JlYXRlRWxlbWVudCIsIndlYmdsQ29udGV4dCIsImxvc2VDb250ZXh0RXh0ZW5zaW9uIiwiZ2V0RXh0ZW5zaW9uIiwibG9zZUNvbnRleHQiLCJpc1N0YWJsZVdlYkdMIiwiYWdlbnRJbmZvIiwiaXNTdGFibGVXZWJnbCIsIm9zIiwibmFtZSIsInBhcnNlRmxvYXQiLCJ2ZXJzaW9uIiwiYnJvd3NlciIsImdldEVycm9yTmFtZUZyb21XZWJHTEVycm9yQ29kZSIsImNvZGUiLCJDT05UUk9MX01PREVfVlIiLCJDT05UUk9MX01PREVfWUFXUElUQ0giLCJUT1VDSF9ESVJFQ1RJT05fTk9ORSIsIlRPVUNIX0RJUkVDVElPTl9ZQVciLCJUT1VDSF9ESVJFQ1RJT05fUElUQ0giLCJUT1VDSF9ESVJFQ1RJT05fQUxMIiwiTUNfREVDRUxFUkFUSU9OIiwiTUNfTUFYSU1VTV9EVVJBVElPTiIsIk1DX0JJTkRfU0NBTEUiLCJNSU5fRklFTERfT0ZfVklFVyIsIk1BWF9GSUVMRF9PRl9WSUVXIiwiUEFOX1NDQUxFIiwiREVMVEFfVEhSRVNIT0xEIiwiWUFXX1JBTkdFX0hBTEYiLCJQSVRDSF9SQU5HRV9IQUxGIiwiQ0lSQ1VMQVJfUElUQ0hfUkFOR0VfSEFMRiIsIlBJTkNIX0VWRU5UUyIsIktFWU1BUCIsIkxFRlRfQVJST1ciLCJBIiwiVVBfQVJST1ciLCJXIiwiUklHSFRfQVJST1ciLCJEIiwiRE9XTl9BUlJPVyIsIlMiLCJHWVJPX01PREUiLCJOT05FIiwiWUFXUElUQ0giLCJWUiIsIlJlbmRlcmVyIiwiRVJST1JfVFlQRSIsIklOVkFMSURfREVWSUNFIiwiTk9fV0VCR0wiLCJGQUlMX0lNQUdFX0xPQUQiLCJGQUlMX0JJTkRfVEVYVFVSRSIsIklOVkFMSURfUkVTT1VSQ0UiLCJSRU5ERVJJTkdfQ09OVEVYVF9MT1NUIiwiRVZFTlRTIiwiUkVBRFkiLCJWSUVXX0NIQU5HRSIsIkFOSU1BVElPTl9FTkQiLCJFUlJPUiIsIlBST0pFQ1RJT05fVFlQRSIsIkVRVUlSRUNUQU5HVUxBUiIsIkNVQkVNQVAiLCJTcHJpdGVJbWFnZSIsImVsZW1lbnQiLCJvcHRpb25zIiwib3B0IiwiX2VsIiwiX3Jvd0NvdW50Iiwicm93Q291bnQiLCJfY29sQ291bnQiLCJjb2xDb3VudCIsIl90b3RhbENvdW50IiwiX3dpZHRoIiwid2lkdGgiLCJfaGVpZ2h0IiwiaGVpZ2h0IiwiX2F1dG9IZWlnaHQiLCJhdXRvSGVpZ2h0IiwiX2NvbFJvdyIsImNvbFJvdyIsImZyYW1lSW5kZXgiLCJzZXRGcmFtZUluZGV4Iiwic3R5bGUiLCJfZ2V0U2l6ZVN0cmluZyIsImltYWdlVXJsIiwic2V0VGltZW91dCIsInRyaWdnZXIiLCJfaW1hZ2UiLCJJbWFnZSIsIm9ubG9hZCIsIl9iZyIsIl9jcmVhdGVCZ0RpdiIsImFwcGVuZENoaWxkIiwic2V0Q29sUm93IiwiYmdFbGVtZW50IiwiX2F1dG9QbGF5UmVzZXJ2ZWRJbmZvIiwicGxheSIsIm9uZXJyb3IiLCJzcmMiLCJpbWciLCJlbCIsImJhY2tncm91bmRJbWFnZSIsImJhY2tncm91bmRTaXplIiwidW5pdFdpZHRoIiwidW5pdEhlaWdodCIsInIiLCJwYWRkaW5nQm90dG9tIiwiaW5kZXgiLCJ0b0NvbFJvdyIsImdldEZyYW1lSW5kZXgiLCJjb2wiLCJyb3ciLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJnZXRDb2xSb3ciLCJzaXplIiwic3RvcCIsIl9hdXRvUGxheVRpbWVyIiwiY2xlYXJJbnRlcnZhbCIsImludGVydmFsIiwicGxheUNvdW50IiwiY291bnQiLCJmcmFtZUNvdW50Iiwic2V0SW50ZXJ2YWwiLCJmbG9vciIsInNjcmVlblJvdGF0aW9uQW5nbGVJbnN0IiwicmVmQ291bnQiLCJTY3JlZW5Sb3RhdGlvbkFuZ2xlIiwiX29uRGV2aWNlT3JpZW50YXRpb24iLCJiaW5kIiwiX29uT3JpZW50YXRpb25DaGFuZ2UiLCJfc3BpblIiLCJfc2NyZWVuT3JpZW50YXRpb25BbmdsZSIsImJldGEiLCJnYW1tYSIsImJldGFSIiwiZ2FtbWFSIiwiY29zIiwic2luIiwic2NyZWVuIiwib3JpZW50YXRpb24iLCJhbmdsZSIsImdldFJhZGlhbiIsInVucmVmIiwiWWF3UGl0Y2hDb250cm9sIiwiS19GSUxURVIiLCJQUkVESUNUSU9OX1RJTUVfUyIsIkZ1c2lvblBvc2VTZW5zb3IiLCJkZXZpY2VNb3Rpb24iLCJhY2NlbGVyb21ldGVyIiwiVmVjdG9yMyIsImd5cm9zY29wZSIsIl9vbkRldmljZU1vdGlvbkNoYW5nZSIsIl9vblNjcmVlbk9yaWVudGF0aW9uQ2hhbmdlIiwiZmlsdGVyIiwicG9zZVByZWRpY3RvciIsImZpbHRlclRvV29ybGRRIiwiUXVhdGVybmlvbiIsImlzRmlyZWZveEFuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lVXNpbmdEZWdyZWVzIiwicGFyc2VJbnQiLCJfaXNFbmFibGVkIiwic2V0RnJvbUF4aXNBbmdsZSIsImludmVyc2VXb3JsZFRvU2NyZWVuUSIsIndvcmxkVG9TY3JlZW5RIiwib3JpZ2luYWxQb3NlQWRqdXN0USIsIl9zZXRTY3JlZW5UcmFuc2Zvcm0iLCJpc0xhbmRzY2FwZU1vZGUiLCJtdWx0aXBseSIsInJlc2V0USIsIm9uIiwiZW5hYmxlIiwiaXNFbmFibGVkIiwiZGlzYWJsZSIsImRlc3Ryb3kiLCJfdHJpZ2dlckNoYW5nZSIsImdldE9yaWVudGF0aW9uIiwiX3ByZXZPcmllbnRhdGlvbiIsImVxdWFscyIsImlzV2l0aG91dERldmljZU1vdGlvbiIsIl9kZXZpY2VPcmllbnRhdGlvblEiLCJkZXZpY2VPcmllbnRhdGlvbkZpeFEiLCJ5IiwiX2FscGhhIiwib3V0IiwiY29weSIsIm11bHRpcGx5UXVhdGVybmlvbnMiLCJvdXRfIiwieCIsInoiLCJ3IiwiX2NvbnZlcnRGdXNpb25Ub1ByZWRpY3RlZCIsInByZWRpY3RlZFEiLCJnZXRQcmVkaWN0aW9uIiwicHJldmlvdXNUaW1lc3RhbXBTIiwiaW5wdXRFdmVudCIsImRldmljZW9yaWVudGF0aW9uIiwiYWNjR3Jhdml0eSIsImFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkiLCJyb3RSYXRlIiwiYWRqdXN0ZWRSb3RhdGlvblJhdGUiLCJyb3RhdGlvblJhdGUiLCJ0aW1lc3RhbXBTIiwidGltZVN0YW1wIiwiYWxwaGEiLCJzZXRGcm9tRXVsZXJZWFoiLCJzZXQiLCJtdWx0aXBseVNjYWxhciIsImFkZEFjY2VsTWVhc3VyZW1lbnQiLCJhZGRHeXJvTWVhc3VyZW1lbnQiLCJzY3JlZW5PcmllbnRhdGlvbiIsImludmVyc2UiLCJ0b0F4aXMiLCJvZmZzZXQiLCJyZWR1Y2UiLCJhY2MiLCJ2IiwiVkVSU0lPTiIsIlBhbm9WaWV3ZXIiLCJTcGluVmlld2VyIiwiU1RBVFVTIiwiRVZFTlQiLCJJbWFnZUxvYWRlciIsImltYWdlIiwiX29uY2VIYW5kbGVycyIsIl9sb2FkU3RhdHVzIiwiZ2V0IiwicmVzIiwicmVqIiwiTE9BREVEIiwiZ2V0RWxlbWVudCIsIkxPQURJTkciLCJpc01heWJlTG9hZGVkIiwiUkVBRFlTVEFURUNIQU5HRSIsIm9uY2VMb2FkZWQiLCJpbWFnZXMiLCJtYXAiLCJfaW1nIiwiY3Jvc3NPcmlnaW4iLCJjb21wbGV0ZSIsIm5hdHVyYWxXaWR0aCIsInNvbWUiLCJ0YXJnZXRzIiwidGFyZ2V0c05vdExvYWRlZCIsImxvYWRQcm9taXNlcyIsIl9vbmNlIiwiYWxsIiwidGhlbiIsInJlYXNvbiIsImxpc3RlbmVyIiwiZm4iLCJldmVudCIsInB1c2giLCJnZXRTdGF0dXMiLCJmb3JFYWNoIiwiaGFuZGxlciIsIkltYWdlVHlwZSIsIkRFVklDRV9QSVhFTF9SQVRJTyIsIkJJTkRfVEVYVFVSRSIsIklNQUdFX0xPQURFRCIsIlJFTkRFUklOR19DT05URVhUX1JFU1RPUkUiLCJQYW5vSW1hZ2VSZW5kZXJlciIsImlzVmlkZW8iLCJzcGhlcmljYWxDb25maWciLCJyZW5kZXJpbmdDb250ZXh0QXR0cmlidXRlcyIsImZpZWxkT2ZWaWV3IiwiX2xhc3RRdWF0ZXJuaW9uIiwiX2xhc3RZYXciLCJfbGFzdFBpdGNoIiwiX2xhc3RGaWVsZE9mVmlldyIsInBNYXRyaXgiLCJtdk1hdHJpeCIsInBlcnNwZWN0aXZlIiwidGV4dHVyZUNvb3JkQnVmZmVyIiwidmVydGV4QnVmZmVyIiwiaW5kZXhCdWZmZXIiLCJfaW5pdENhbnZhcyIsIl9yZW5kZXJpbmdDb250ZXh0QXR0cmlidXRlcyIsIl9pbWFnZUNvbmZpZyIsIl9pbWFnZUlzUmVhZHkiLCJfc2hvdWxkRm9yY2VEcmF3IiwiX2tlZXBVcGRhdGUiLCJfb25Db250ZW50TG9hZCIsIl9vbkNvbnRlbnRFcnJvciIsInNldEltYWdlIiwiaW1hZ2VUeXBlIiwiY3ViZW1hcENvbmZpZyIsImdldENvbnRlbnQiLCJfaXNWaWRlbyIsIm9yZGVyIiwidGlsZUNvbmZpZyIsImZsaXBIaXJvem9udGFsIiwicm90YXRpb24iLCJfc2V0SW1hZ2VUeXBlIiwiX2NvbnRlbnRMb2FkZXIiLCJfaW1hZ2VUeXBlIiwiX2lzQ3ViZU1hcCIsIl9yZW5kZXJlciIsIl9pbml0V2ViR0wiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJtYXJnaW4iLCJtYXhIZWlnaHQiLCJtYXhXaWR0aCIsIm91dGxpbmUiLCJwb3NpdGlvbiIsIl9vbldlYmdsY29udGV4dGxvc3QiLCJfb25XZWJnbGNvbnRleHRyZXN0b3JlZCIsImVycm9yIiwibWVzc2FnZSIsIl90cmlnZ2VyQ29udGVudExvYWQiLCJjb250ZW50IiwicHJvamVjdGlvblR5cGUiLCJpc0ltYWdlTG9hZGVkIiwicmVhZHlTdGF0ZSIsIl9iaW5kVGV4dHVyZSIsImF0dGFjaFRvIiwicGFyZW50RWxlbWVudCIsImRldGFjaCIsImZvcmNlQ29udGV4dExvc3MiLCJoYXNSZW5kZXJpbmdDb250ZXh0IiwicmVtb3ZlQ2hpbGQiLCJvZmYiLCJpc0NvbnRleHRMb3N0Iiwic2hhZGVyUHJvZ3JhbSIsInByZXZlbnREZWZhdWx0IiwidXBkYXRlRmllbGRPZlZpZXciLCJfdXBkYXRlVmlld3BvcnQiLCJ1cGRhdGVWaWV3cG9ydERpbWVuc2lvbnMiLCJ2aWV3UG9ydENoYW5nZWQiLCJoIiwidmlld3BvcnQiLCJkcmF3aW5nQnVmZmVyV2lkdGgiLCJkcmF3aW5nQnVmZmVySGVpZ2h0IiwiX2luaXRSZW5kZXJpbmdDb250ZXh0IiwiX2luaXRTaGFkZXJQcm9ncmFtIiwiRXJyb3IiLCJnZXRFcnJvciIsIl9pbml0QnVmZmVycyIsImNsZWFyQ29sb3IiLCJURVhUVVJFX0NVQkVfTUFQIiwiVEVYVFVSRV8yRCIsImRlbGV0ZVRleHR1cmUiLCJXZWJHTFJlbmRlcmluZ0NvbnRleHQiLCJ2ZXJ0ZXhTaGFkZXJTb3VyY2UiLCJnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UiLCJWRVJURVhfU0hBREVSIiwiZnJhZ21lbnRTaGFkZXJTb3VyY2UiLCJnZXRGcmFnbWVudFNoYWRlclNvdXJjZSIsIkZSQUdNRU5UX1NIQURFUiIsInVzZVByb2dyYW0iLCJ2ZXJ0ZXhQb3NpdGlvbkF0dHJpYnV0ZSIsImdldEF0dHJpYkxvY2F0aW9uIiwicE1hdHJpeFVuaWZvcm0iLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJtdk1hdHJpeFVuaWZvcm0iLCJzYW1wbGVyVW5pZm9ybSIsInRleHR1cmVDb29yZEF0dHJpYnV0ZSIsImNsZWFyIiwiQ09MT1JfQlVGRkVSX0JJVCIsIkRFUFRIX0JVRkZFUl9CSVQiLCJTVEVOQ0lMX0JVRkZFUl9CSVQiLCJ1bmlmb3JtMWkiLCJ2ZXJ0ZXhQb3NpdGlvbkRhdGEiLCJnZXRWZXJ0ZXhQb3NpdGlvbkRhdGEiLCJpbmRleERhdGEiLCJnZXRJbmRleERhdGEiLCJ0ZXh0dXJlQ29vcmREYXRhIiwiZ2V0VGV4dHVyZUNvb3JkRGF0YSIsIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwiVWludDE2QXJyYXkiLCJfdXBkYXRlVGV4dHVyZSIsInVwZGF0ZVRleHR1cmUiLCJrZWVwVXBkYXRlIiwiZG9VcGRhdGUiLCJyZW5kZXJXaXRoUXVhdGVybmlvbiIsImV4YWN0RXF1YWxzIiwib3V0USIsInJvdGF0ZVkiLCJmcm9tUXVhdCIsIl9kcmF3IiwicmVuZGVyIiwieWF3IiwicGl0Y2giLCJpZGVudGl0eSIsInJvdGF0ZVgiLCJ1bmlmb3JtTWF0cml4NGZ2IiwiZHJhd0VsZW1lbnRzIiwiVFJJQU5HTEVTIiwiVU5TSUdORURfU0hPUlQiLCJSRUFEWV9TVEFUVVMiLCJIQVZFX05PVEhJTkciLCJIQVZFX01FVEFEQVRBIiwiSEFWRV9DVVJSRU5UX0RBVEEiLCJIQVZFX0ZVVFVSRV9EQVRBIiwiSEFWRV9FTk9VR0hfREFUQSIsIkxPQURJTkdfRkFJTEVEIiwiUkVBRFlTVEFURUNIQU5HRV9FVkVOVF9OQU1FIiwiVmlkZW9Mb2FkZXIiLCJ2aWRlbyIsIl9oYW5kbGVycyIsIl9zb3VyY2VDb3VudCIsIl90aHJlc2hvbGRSZWFkeVN0YXRlIiwiX3RocmVzaG9sZEV2ZW50TmFtZSIsIl9vbmVycm9yIiwiX2Vycm9yQ291bnQiLCJfZGV0YWNoRXJyb3JIYW5kbGVyIiwiX2FwcGVuZFNvdXJjZUVsZW1lbnQiLCJ2aWRlb1VybCIsInZpZGVvU3JjIiwidmlkZW9UeXBlIiwic291cmNlRWxlbWVudCIsIl92aWRlbyIsIl9yZXNldCIsIkhUTUxWaWRlb0VsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJxdWVyeVNlbGVjdG9yQWxsIiwibG9hZCIsIl9hdHRhY2hFcnJvckhhbmRsZXIiLCJfc291cmNlcyIsImNhbGwiLCJyZWplY3RvciIsImRldmljZVBpeGVsUmF0aW8iLCJDdWJlUmVuZGVyZXIiLCJfVkVSVEVYX1BPU0lUSU9OX0RBVEEiLCJfSU5ERVhfREFUQSIsImV4dHJhY3RUaWxlQ29uZmlnIiwiaW1hZ2VDb25maWciLCJpc0FycmF5IiwiZmxpcEhvcml6b250YWwiLCJjb25maWciLCJleHRyYWN0T3JkZXIiLCJ2ZXJ0ZXhPcmRlciIsImJhc2UiLCJlbGVtU2l6ZSIsInZlcnRleFBlclRpbGUiLCJzcGxpdCIsImluZGV4T2YiLCJmYWNlIiwib3JkZXJtYXBfIiwic2hpZnQiLCJ1bnNoaWZ0IiwicG9wIiwiZWxlbVBlclRpbGUiLCJ0aWxlVmVydGV4Iiwic2xpY2UiLCJ0aWxlVGVtcCIsImoiLCJzcGxpY2UiLCJqb2luIiwiYmFzZU9yZGVyIiwib3JkZXJNYXAiLCJzdXJmYWNlSWR4IiwidGlsZUlkeCIsInRleEltYWdlMkQiLCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1giLCJSR0JBIiwiVU5TSUdORURfQllURSIsIm1heEN1YmVNYXBUZXh0dXJlU2l6ZSIsImdldE1heEN1YmVNYXBUZXh0dXJlU2l6ZSIsInRpbGUiLCJleHRyYWN0VGlsZUZyb21JbWFnZSIsIl9nZXREaW1lbnNpb24iLCJwaXhlbFNvdXJjZSIsInZpZGVvV2lkdGgiLCJuYXR1cmFsSGVpZ2h0IiwidmlkZW9IZWlnaHQiLCJnZXRTb3VyY2VUaWxlU2l6ZSIsImFzcGVjdFJhdGlvIiwiaW5wdXRUZXh0dXJlU2l6ZSIsIm91dHB1dFRleHR1cmVTaXplIiwidGlsZVBlclJvdyIsImRyYXdJbWFnZSIsImFnZW50IiwiZ2V0UGFyYW1ldGVyIiwiTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSIsIl9pbWFnZVdpZHRoIiwibWluIiwiaXNJRTExIiwicGl4ZWxDYW52YXMiLCJwaXhlbENvbnRleHQiLCJTcGhlcmVSZW5kZXJlciIsIl9URVhUVVJFX0NPT1JEX0RBVEEiLCJfZ2V0UGl4ZWxTb3VyY2UiLCJtYXgiLCJtYXhTaXplIiwiTUFYX1RFWFRVUkVfU0laRSIsImNvbnNvbGUiLCJ3YXJuIiwiYWN0aXZlVGV4dHVyZSIsIlRFWFRVUkUwIiwicGl4ZWxTdG9yZWkiLCJVTlBBQ0tfRkxJUF9ZX1dFQkdMIiwiX2luaXREYXRhIiwibGF0aXR1ZGVCYW5kcyIsImxvbmdpdHVkZUJhbmRzIiwicmFkaXVzIiwibGF0SWR4IiwibG5nSWR4Iiwic2luVGhldGEiLCJjb3NUaGV0YSIsInBoaSIsInNpblBoaSIsImNvc1BoaSIsInUiLCJiIiwiY29udGFpbmVyIiwiX2NvbnRhaW5lciIsIl9wcm9qZWN0aW9uVHlwZSIsIl9jdWJlbWFwQ29uZmlnIiwiX3lhdyIsIl9waXRjaCIsIl9mb3YiLCJmb3YiLCJfZ3lyb01vZGUiLCJneXJvTW9kZSIsIl9xdWF0ZXJuaW9uIiwiX2FzcGVjdFJhdGlvIiwiZm92UmFuZ2UiLCJ0b3VjaERpcmVjdGlvbiIsIl9pc1ZhbGlkVG91Y2hEaXJlY3Rpb24iLCJ5YXdQaXRjaENvbmZpZyIsIl9pc1JlYWR5IiwiX2luaXRZYXdQaXRjaENvbnRyb2wiLCJfaW5pdFJlbmRlcmVyIiwiZ2V0VmlkZW8iLCJfcGhvdG9TcGhlcmVSZW5kZXJlciIsInNldFZpZGVvIiwicGFyYW0iLCJnZXRJbWFnZSIsIl9kZWFjdGl2YXRlIiwiZ2V0UHJvamVjdGlvblR5cGUiLCJpbml0aWFsWWF3IiwiaW5pdGlhbFBpdGNoIiwiX2JpbmRSZW5kZXJlckhhbmRsZXIiLCJfYWN0aXZhdGUiLCJfdHJpZ2dlckV2ZW50IiwiX3lhd1BpdGNoQ29udHJvbCIsImV2dCIsInNldFVzZVpvb20iLCJ1c2Vab29tIiwib3B0aW9uIiwic2V0VXNlS2V5Ym9hcmQiLCJ1c2VLZXlib2FyZCIsInNldEd5cm9Nb2RlIiwic2V0Rm92UmFuZ2UiLCJyYW5nZSIsImdldEZvdlJhbmdlIiwibG9va0F0IiwiZ2V0Rm92IiwiX2dldEhGb3YiLCJhdGFuIiwidGFuIiwiZ2V0WWF3IiwiZ2V0UGl0Y2giLCJnZXRZYXdSYW5nZSIsImdldFBpdGNoUmFuZ2UiLCJzZXRZYXdSYW5nZSIsInlhd1JhbmdlIiwic2V0UGl0Y2hSYW5nZSIsInBpdGNoUmFuZ2UiLCJzZXRTaG93UG9sZVBvaW50Iiwic2hvd1BvbGVQb2ludCIsImR1cmF0aW9uIiwidmVydGljYWxBbmdsZU9mSW1hZ2UiLCJfc3RhcnRSZW5kZXIiLCJfcmVuZGVyTG9vcCIsIl9yYWZJZCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIl9zdG9wUmVuZGVyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJkaXJlY3Rpb24iLCJUT1VDSF9ESVJFQ1RJT04iLCJZQVciLCJQSVRDSCIsIkFMTCIsInNldFRvdWNoRGlyZWN0aW9uIiwiZ2V0VG91Y2hEaXJlY3Rpb24iLCJpc0d5cm9TZW5zb3JBdmFpbGFibGUiLCJjYWxsYmFjayIsIm9uRGV2aWNlTW90aW9uQ2hhbmdlIiwiY2hlY2tHeXJvIiwidGltZW91dCIsInJhY2UiLCJmYiIsIlByb2plY3Rpb25UeXBlIiwiRGV2aWNlTW90aW9uRXZlbnQiLCJERUZBVUxUX1BBTl9TQ0FMRSIsIl9zY2FsZSIsIl9wYW5TY2FsZSIsIl9mcmFtZUNvdW50IiwiX3Nwcml0ZXMiLCJfcGFuSW5wdXQiLCJfYXhlcyIsImNpcmN1bGFyIiwiY3VyciIsInBvcyIsImlzVHJ1c3RlZCIsImNvbm5lY3QiLCJzZXRTY2FsZSIsImlzTmFOIiwiZ2V0U2NhbGUiLCJzcGluQnkiLCJzZXRCeSIsInNwaW5UbyIsInNldFRvIiwiZ2V0QW5nbGUiLCJPUklHSU5fVkVDVE9SIiwiWF9BWElTX1ZFQ1RPUiIsIllfQVhJU19WRUNUT1IiLCJEZXZpY2VRdWF0ZXJuaW9uIiwiX3NjcmVlblJvdGF0aW9uQW5nbGUiLCJfZnVzaW9uUG9zZVNlbnNvciIsImdldENvbWJpbmVkUXVhdGVybmlvbiIsImRldmljZVIiLCJwaXRjaEF4aXMiLCJyb3RhdGVaIiwieWF3USIsInNldEF4aXNBbmdsZSIsInBpdGNoUSIsImNvbmoiLCJjb25qdWdhdGUiLCJERUZBVUxUX1lBV19SQU5HRSIsIkRFRkFVTFRfUElUQ0hfUkFOR0UiLCJDSVJDVUxBUl9QSVRDSF9SQU5HRSIsIl9lbGVtZW50IiwiX2luaXRpYWxGb3YiLCJfZW5hYmxlZCIsIl9pc0FuaW1hdGluZyIsIl9kZXZpY2VRdWF0ZXJuaW9uIiwiX2luaXRBeGVzIiwieVJhbmdlIiwiX3VwZGF0ZVlhd1JhbmdlIiwicFJhbmdlIiwiX3VwZGF0ZVBpdGNoUmFuZ2UiLCJ1c2VSb3RhdGlvbiIsImF4ZXNQYW5JbnB1dCIsImF4ZXNXaGVlbElucHV0IiwiYXhlc1RpbHRNb3Rpb25JbnB1dCIsImF4ZXNQaW5jaElucHV0IiwiYXhlc01vdmVLZXlJbnB1dCIsImF4ZXMiLCJpc0NpcmN1bGFyIiwiYm91bmNlIiwiZGVjZWxlcmF0aW9uIiwibWF4aW11bUR1cmF0aW9uIiwiaG9sZCIsImNoYW5nZSIsImRlbHRhIiwiX3NldFBhblNjYWxlIiwiX3VwZGF0ZUNvbnRyb2xTY2FsZSIsInJlbGVhc2UiLCJhbmltYXRpb25TdGFydCIsImFuaW1hdGlvbkVuZCIsImFyZWFIZWlnaHQiLCJhcmdzIiwiYXJnTGVuIiwiX2dldE9wdGlvbnMiLCJiZWZvcmVPcHRpb25zIiwibmV3T3B0aW9ucyIsImNoYW5nZWRLZXlMaXN0IiwiT2JqZWN0Iiwia2V5cyIsIl9zZXRPcHRpb25zIiwiX2dldFZhbGlkYXRlZE9wdGlvbnMiLCJfYXBwbHlPcHRpb25zIiwiX2dldFZhbGlkWWF3UmFuZ2UiLCJfZ2V0VmFsaWRQaXRjaFJhbmdlIiwia2V5IiwidmFsdWUiLCJhcmd1bWVudHMiLCJwcmV2T3B0aW9ucyIsInByZXZGb3YiLCJuZXh0Rm92IiwiYXhpcyIsImlzVlIiLCJpc1lhd1BpdGNoIiwiZGlzY29ubmVjdCIsIl9pbml0RGV2aWNlUXVhdGVybmlvbiIsInNldFVzZVJvdGF0aW9uIiwiX3RvZ2dsZVBpbmNoSW5wdXRCeU9wdGlvbiIsIl9lbmFibGVUb3VjaCIsIl9pbnB1dHMiLCJ5YXdFbmFibGVkIiwicGl0Y2hFbmFibGVkIiwibmV3WWF3UmFuZ2UiLCJuZXdGb3YiLCJuZXdBc3BlY3RSYXRpbyIsInJhdGlvIiwiYWRqdXN0QXNwZWN0UmF0aW8iLCJob3Jpem9udGFsRm92IiwiaXNWYWxpZCIsIm5ld1BpdGNoUmFuZ2UiLCJjaGFuZ2VFdnQiLCJwIiwidmVydGljYWxBbmdsZSIsImhhbGZGb3YiLCJpc1Bhbm9yYW1hIiwidG9GaXhlZCIsImhvcml6b250YWxBbmdsZSIsIk1BR0lDX05VTUJFUiIsImhhbGZIb3Jpem9udGFsRm92IiwidGFyZ2V0RWxlbWVudCIsImlucHV0IiwiaW5wdXRSYW5nZSIsIm91dHB1dFJhbmdlIiwicmFuZ2VJZHgiLCJpbnB1dEEiLCJpbnB1dEIiLCJvdXRwdXRBIiwib3V0cHV0QiIsImxlcnAiLCJmcmFjdGlvbiIsInBlcnNpc3RPcmllbnRhdGlvbiIsIl9yZXNldE9yaWVudGF0aW9uIiwiZiIsImF4aXNQYW5JbnB1dCIsImF4ZXNEZXZpY2VPcmllbnRhdGlvbklucHV0IiwicHJvdG90eXBlIiwicnVuXyIsImlzT3JpZW50YXRpb25Jbml0aWFsaXplZCIsImFjY2VsUSIsImFjY2VsVG9RdWF0ZXJuaW9uXyIsImN1cnJlbnRBY2NlbE1lYXN1cmVtZW50Iiwic2FtcGxlIiwicHJldmlvdXNGaWx0ZXJRIiwiZGVsdGFUIiwiY3VycmVudEd5cm9NZWFzdXJlbWVudCIsInByZXZpb3VzR3lyb01lYXN1cmVtZW50IiwiZ3lyb0RlbHRhUSIsImd5cm9Ub1F1YXRlcm5pb25EZWx0YV8iLCJneXJvSW50ZWdyYWxRIiwiZmlsdGVyUSIsImludkZpbHRlclEiLCJlc3RpbWF0ZWRHcmF2aXR5IiwiYXBwbHlRdWF0ZXJuaW9uIiwibWVhc3VyZWRHcmF2aXR5IiwiZGVsdGFRIiwic2V0RnJvbVVuaXRWZWN0b3JzIiwidGFyZ2V0USIsInNsZXJwIiwia0ZpbHRlciIsImlzRmlsdGVyUXVhdGVybmlvbkluaXRpYWxpemVkIiwiU1RJTExORVNTX1RIUkVTSE9MRCIsImlzQ2hyb21lV2l0aG91dERldmljZU1vdGlvbiIsImJyb3dzZXJWZXJzaW9uIiwidmVyc2lvblRva2VuIiwiYnJhbmNoIiwiYnVpbGQiLCJEZXZpY2VNb3Rpb24iLCJfb25EZXZpY2VNb3Rpb24iLCJfb25DaHJvbWVXaXRob3V0RGV2aWNlTW90aW9uIiwiaXNBbmRyb2lkIiwic3RpbGxHeXJvVmVjIiwicmF3R3lyb1ZlYyIsImFkanVzdGVkR3lyb1ZlYyIsIl90aW1lciIsImxhc3REZXZpY2Vtb3Rpb25UaW1lc3RhbXAiLCJjbGVhclRpbWVvdXQiLCJEYXRlIiwiZ2V0VGltZSIsImlzR3Jhdml0eVNlbnNvckF2YWlsYWJsZSIsImRldmljZW1vdGlvbkV2ZW50IiwiYWNjZWxlcmF0aW9uIiwiUm90YXRpb25QYW5JbnB1dCIsIl91c2VSb3RhdGlvbiIsIl91c2VyRGlyZWN0aW9uIiwiRElSRUNUSU9OX0FMTCIsIm9ic2VydmVyIiwiX2RpcmVjdGlvbiIsImdldE9mZnNldCIsInByb3BlcnRpZXMiLCJ1c2VEaXJlY3Rpb24iLCJuZXdPZmZzZXQiLCJESVJFQ1RJT05fSE9SSVpPTlRBTCIsIkRJUkVDVElPTl9WRVJUSUNBTCIsImdldERlbHRhWWF3IiwicHJ2USIsInlhd0RlbHRhQnlZYXciLCJ5YXdEZWx0YUJ5Um9sbCIsImdldERlbHRhUGl0Y2giLCJwaXRjaERlbHRhIiwiVGlsdE1vdGlvbklucHV0IiwiX3ByZXZRdWF0ZXJuaW9uIiwiZnVzaW9uUG9zZVNlbnNvciIsInRocmVzaG9sZCIsIl9vblBvc2VDaGFuZ2UiLCJtYXBBeGVzIiwiX2F0dGFjaEV2ZW50IiwiX2RldHRhY2hFdmVudCIsIldoZWVsSW5wdXQiLCJfb25XaGVlbCIsImRlbHRhWSIsInJhZCIsInMiLCJjIiwiYTEwIiwiYTExIiwiYTEyIiwiYTEzIiwiYTIwIiwiYTIxIiwiYTIyIiwiYTIzIiwiYTAwIiwiYTAxIiwiYTAyIiwiYTAzIiwicSIsIngyIiwieTIiLCJ6MiIsInh4IiwieXgiLCJ5eSIsInp4IiwienkiLCJ6eiIsInd4Iiwid3kiLCJ3eiIsImZvdnkiLCJhc3BlY3QiLCJuZWFyIiwiZmFyIiwibmYiLCJheCIsImF5IiwiYXoiLCJhdyIsImJ4IiwiYnkiLCJieiIsImJ3IiwibGVuIiwiYTAiLCJhMSIsImEyIiwiYTMiLCJiMCIsImIxIiwiYjIiLCJiMyIsInF4IiwicXkiLCJxeiIsInF3IiwiaXgiLCJpeSIsIml6IiwiaXciXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlGQUF5RjtBQUN6RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLDZCQUE2Qjs7QUFFN0IsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBLENBQUMsRTs7Ozs7Ozs7OztBQ2hkRDtBQUNBO0FBQ0EsSUFBTWUsTUFBTSxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxPQUFPOUQsSUFBUCxLQUFnQkEsSUFBakQsR0FBd0Q4RCxNQUF4RCxHQUFpRSxPQUFPQyxJQUFQLEtBQWdCLFdBQWhCLElBQStCQSxLQUFLL0QsSUFBTCxLQUFjQSxJQUE3QyxHQUFvRCtELElBQXBELEdBQTJEQyxTQUFTLGFBQVQsR0FBeEk7QUFDQTtBQUNBOztBQUVBSCxJQUFJVCxZQUFKLEdBQW9CLE9BQU9TLElBQUlULFlBQVgsS0FBNEIsV0FBN0IsR0FBNENTLElBQUlULFlBQWhELEdBQStEUyxJQUFJUixLQUF0Rjs7UUFFZVMsTSxHQUFQRCxHO0FBQ0QsSUFBTUksOEJBQVdKLElBQUlJLFFBQXJCO0FBQ0EsSUFBTWIsc0NBQWVTLElBQUlULFlBQXpCO0FBQ0EsSUFBTWMsOENBQW1CTCxJQUFJSyxnQkFBN0I7QUFDQSxJQUFNQyxnQ0FBWU4sSUFBSU8sU0FBSixDQUFjRCxTQUFoQztBQUNBLElBQU1FLHdDQUFnQixrQkFBa0JSLEdBQXhDO0FBQ0EsSUFBTVMsc0RBQXVCLG9CQUFvQlQsR0FBakQsQzs7Ozs7O0FDZFA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjs7QUFFaEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxJQUFJO0FBQ2Q7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiw2Q0FBNkM7QUFDaEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEIsVUFBVSxPQUFPO0FBQ2pCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxJQUFJO0FBQ2Q7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkIsVUFBVSxTQUFTO0FBQ25CO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBLFdBQVc7QUFDWDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQixLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLGFBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQ7Ozs7Ozs7O0FDMXBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0gsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7O0FDelBEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7Ozs7Ozs7c0RDdkx0QztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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SixDQUFDLEVBQUUsc0hBQXNIO0FBQ3pIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsd05BQXdOO0FBQzNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxHQUFHO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrREFBa0QsV0FBVztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSwwUUFBMFE7QUFDN1E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUscURBQXFEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSx5R0FBeUc7QUFDNUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBCQUEwQixxREFBcUQsbUJBQW1CLFdBQVc7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLGtJQUFrSTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsb0NBQW9DO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLHdEQUF3RDtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxDQUFDLEVBQUUsV0FBVztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsRUFBRSxjQUFjO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9EQUFvRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxFQUFFLFFBQVEsRUFBRSxHQUFHO0FBQ2hCLENBQUM7OztBQUdEOzs7Ozs7Ozs7QUNwbUxBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLEtBQUs7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzdEJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7OztBQzdIQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0I7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNyQkE7QUFDQTs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7Ozs7OztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7Ozs7O0FDaEZBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0EsNEIiLCJmaWxlIjoidmlldzM2MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIkBlZ2pzL2NvbXBvbmVudFwiKSwgcmVxdWlyZShcIkBlZ2pzL2F4ZXNcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJ2aWV3MzYwXCIsIFtcIkBlZ2pzL2NvbXBvbmVudFwiLCBcIkBlZ2pzL2F4ZXNcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1widmlldzM2MFwiXSA9IGZhY3RvcnkocmVxdWlyZShcIkBlZ2pzL2NvbXBvbmVudFwiKSwgcmVxdWlyZShcIkBlZ2pzL2F4ZXNcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImVnXCJdID0gcm9vdFtcImVnXCJdIHx8IHt9LCByb290W1wiZWdcIl1bXCJ2aWV3MzYwXCJdID0gZmFjdG9yeShyb290W1wiZWdcIl1bXCJDb21wb25lbnRcIl0sIHJvb3RbXCJlZ1wiXVtcIkF4ZXNcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTFfXykge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDY5KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBlNzgyNjQ0ZmIwZjE4M2IxYjdiZCIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcIkBlZ2pzL2NvbXBvbmVudFwiLFwiY29tbW9uanMyXCI6XCJAZWdqcy9jb21wb25lbnRcIixcImFtZFwiOlwiQGVnanMvY29tcG9uZW50XCIsXCJyb290XCI6W1wiZWdcIixcIkNvbXBvbmVudFwiXX1cbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBPcmlnaW5hbCBDb2RlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdG9qaS9nbC1tYXRyaXgvYmxvYi92Mi4zLjIvc3JjL2dsLW1hdHJpeC5qc1xuICogTWF0aCBVdGlsXG4gKiBtb2RpZmllZCBieSBlZ2pzXG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBnbC1tYXRyaXggLSBIaWdoIHBlcmZvcm1hbmNlIG1hdHJpeCBhbmQgdmVjdG9yIG9wZXJhdGlvbnNcbiAqIEBhdXRob3IgQnJhbmRvbiBKb25lc1xuICogQGF1dGhvciBDb2xpbiBNYWNLZW56aWUgSVZcbiAqIEB2ZXJzaW9uIDIuMy4yXG4gKi9cblxuLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuLy8gU29tZSBtaW5pbWFsIG1hdGggZnVuY3Rpb25hbGl0eSBib3Jyb3dlZCBmcm9tIGdsLU1hdHJpeCBhbmQgc3RyaXBwZWQgZG93blxuLy8gZm9yIHRoZSBwdXJwb3NlcyBvZiB0aGlzIGxpYnJhcnkuXG5cbmltcG9ydCBnbE1hdHJpeCBmcm9tIFwiLi9tYXRoVXRpbC9jb21tb24uanNcIjtcbmltcG9ydCB2ZWMzIGZyb20gXCIuL21hdGhVdGlsL3ZlYzMuanNcIjtcbmltcG9ydCB2ZWMyIGZyb20gXCIuL21hdGhVdGlsL3ZlYzIuanNcIjtcbmltcG9ydCBxdWF0IGZyb20gXCIuL21hdGhVdGlsL3F1YXQuanNcIjtcbmltcG9ydCBtYXQ0IGZyb20gXCIuL21hdGhVdGlsL21hdDQuanNcIjtcblxuZnVuY3Rpb24gcXVhdFRvVmVjMyhxdWF0ZXJuaW9uKSB7XG5cdGNvbnN0IGJhc2VWID0gdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDEpO1xuXG5cdHZlYzMudHJhbnNmb3JtUXVhdChiYXNlViwgYmFzZVYsIHF1YXRlcm5pb24pO1xuXHRyZXR1cm4gYmFzZVY7XG59XG5cbmNvbnN0IHV0aWwgPSB7fTtcblxudXRpbC5pc1Bvd2VyT2ZUd28gPSBmdW5jdGlvbihuKSB7XG5cdHJldHVybiBuICYmIChuICYgKG4gLSAxKSkgPT09IDA7XG59O1xuXG51dGlsLmV4dHJhY3RQaXRjaEZyb21RdWF0ID0gZnVuY3Rpb24ocXVhdGVybmlvbikge1xuXHRjb25zdCBiYXNlViA9IHF1YXRUb1ZlYzMocXVhdGVybmlvbik7XG5cblx0cmV0dXJuIC0xICogTWF0aC5hdGFuMihcblx0XHRiYXNlVlsxXSxcblx0XHRNYXRoLnNxcnQoTWF0aC5wb3coYmFzZVZbMF0sIDIpICsgTWF0aC5wb3coYmFzZVZbMl0sIDIpKSk7XG59O1xuXG4vLyBpbXBsZW1lbnQgcmVmZXJlbmNlXG4vLyB0aGUgZ2VuZXJhbCBlcXVhdGlvbiBvZiBhIHBsYW5lIDogaHR0cDovL3d3dy5naXNkZXZlbG9wZXIuY28ua3IvZW50cnkv7Y+J66m07J2YLeqzteyLnVxuLy8gY2FsY3VsYXRpbmcgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9ycyA6IGh0dHA6Ly9kYXJrcGdtci50aXN0b3J5LmNvbS8xMjFcbmNvbnN0IFJPVEFURV9DT05TVEFOVCA9IHtcblx0UElUQ0hfREVMVEE6IDEsXG5cdFlBV19ERUxUQV9CWV9ST0xMOiAyLFxuXHRZQVdfREVMVEFfQllfWUFXOiAzLFxufTtcblxuUk9UQVRFX0NPTlNUQU5UW1JPVEFURV9DT05TVEFOVC5QSVRDSF9ERUxUQV0gPSB7XG5cdHRhcmdldEF4aXM6IFswLCAxLCAwXSxcblx0bWVzaFBvaW50OiBbMCwgMCwgMV0sXG59O1xuUk9UQVRFX0NPTlNUQU5UW1JPVEFURV9DT05TVEFOVC5ZQVdfREVMVEFfQllfUk9MTF0gPSB7XG5cdHRhcmdldEF4aXM6IFswLCAxLCAwXSxcblx0bWVzaFBvaW50OiBbMSwgMCwgMF0sXG59O1xuUk9UQVRFX0NPTlNUQU5UW1JPVEFURV9DT05TVEFOVC5ZQVdfREVMVEFfQllfWUFXXSA9IHtcblx0dGFyZ2V0QXhpczogWzEsIDAsIDBdLFxuXHRtZXNoUG9pbnQ6IFswLCAwLCAxXSxcbn07XG5cbmZ1bmN0aW9uIGdldFJvdGF0aW9uRGVsdGEocHJldlEsIGN1clEsIHJvdGF0ZUtpbmQpIHtcblx0Y29uc3QgdGFyZ2V0QXhpcyA9IHZlYzMuZnJvbVZhbHVlcyhcblx0XHRST1RBVEVfQ09OU1RBTlRbcm90YXRlS2luZF0udGFyZ2V0QXhpc1swXSxcblx0XHRST1RBVEVfQ09OU1RBTlRbcm90YXRlS2luZF0udGFyZ2V0QXhpc1sxXSxcblx0XHRST1RBVEVfQ09OU1RBTlRbcm90YXRlS2luZF0udGFyZ2V0QXhpc1syXVxuXHQpO1xuXHRjb25zdCBtZXNoUG9pbnQgPSBST1RBVEVfQ09OU1RBTlRbcm90YXRlS2luZF0ubWVzaFBvaW50O1xuXG5cdGNvbnN0IHByZXZRdWF0ZXJuaW9uID0gcXVhdC5jbG9uZShwcmV2USk7XG5cdGNvbnN0IGN1clF1YXRlcm5pb24gPSBxdWF0LmNsb25lKGN1clEpO1xuXG5cdHF1YXQubm9ybWFsaXplKHByZXZRdWF0ZXJuaW9uLCBwcmV2UXVhdGVybmlvbik7XG5cdHF1YXQubm9ybWFsaXplKGN1clF1YXRlcm5pb24sIGN1clF1YXRlcm5pb24pO1xuXG5cdGxldCBwcmV2UG9pbnQgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMSk7XG5cdGxldCBjdXJQb2ludCA9IHZlYzMuZnJvbVZhbHVlcygwLCAwLCAxKTtcblxuXHR2ZWMzLnRyYW5zZm9ybVF1YXQocHJldlBvaW50LCBwcmV2UG9pbnQsIHByZXZRdWF0ZXJuaW9uKTtcblx0dmVjMy50cmFuc2Zvcm1RdWF0KGN1clBvaW50LCBjdXJQb2ludCwgY3VyUXVhdGVybmlvbik7XG5cdHZlYzMudHJhbnNmb3JtUXVhdCh0YXJnZXRBeGlzLCB0YXJnZXRBeGlzLCBjdXJRdWF0ZXJuaW9uKTtcblxuXHRjb25zdCByb3RhdGVEaXN0YW5jZSA9IHZlYzMuZG90KHRhcmdldEF4aXMsIHZlYzMuY3Jvc3ModmVjMy5jcmVhdGUoKSwgcHJldlBvaW50LCBjdXJQb2ludCkpO1xuXHRjb25zdCByb3RhdGVEaXJlY3Rpb24gPSByb3RhdGVEaXN0YW5jZSA+IDAgPyAxIDogLTE7XG5cblx0Ly8gd2hlbiBjb3VudGVyIGNsb2NrIHdpc2UsIHVzZSB2ZWMzLmZyb21WYWx1ZXMoMCwxLDApXG5cdC8vIHdoZW4gY2xvY2sgd2lzZSwgdXNlIHZlYzMuZnJvbVZhbHVlcygwLC0xLDApXG5cdC8vIGNvbnN0IG1lc2hQb2ludDEgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMCk7XG5cdGNvbnN0IG1lc2hQb2ludDIgPSB2ZWMzLmZyb21WYWx1ZXMobWVzaFBvaW50WzBdLCBtZXNoUG9pbnRbMV0sIG1lc2hQb2ludFsyXSk7XG5cblx0bGV0IG1lc2hQb2ludDM7XG5cblx0aWYgKHJvdGF0ZUtpbmQgIT09IFJPVEFURV9DT05TVEFOVC5ZQVdfREVMVEFfQllfWUFXKSB7XG5cdFx0bWVzaFBvaW50MyA9IHZlYzMuZnJvbVZhbHVlcygwLCByb3RhdGVEaXJlY3Rpb24sIDApO1xuXHR9IGVsc2Uge1xuXHRcdG1lc2hQb2ludDMgPSB2ZWMzLmZyb21WYWx1ZXMocm90YXRlRGlyZWN0aW9uLCAwLCAwKTtcblx0fVxuXG5cdHZlYzMudHJhbnNmb3JtUXVhdChtZXNoUG9pbnQyLCBtZXNoUG9pbnQyLCBjdXJRdWF0ZXJuaW9uKTtcblx0dmVjMy50cmFuc2Zvcm1RdWF0KG1lc2hQb2ludDMsIG1lc2hQb2ludDMsIGN1clF1YXRlcm5pb24pO1xuXG5cdGNvbnN0IHZlY1UgPSBtZXNoUG9pbnQyO1xuXHRjb25zdCB2ZWNWID0gbWVzaFBvaW50Mztcblx0Y29uc3QgdmVjTiA9IHZlYzMuY3JlYXRlKCk7XG5cblx0dmVjMy5jcm9zcyh2ZWNOLCB2ZWNVLCB2ZWNWKTtcblx0dmVjMy5ub3JtYWxpemUodmVjTiwgdmVjTik7XG5cblx0Y29uc3QgY29lZmZpY2llbnRBID0gdmVjTlswXTtcblx0Y29uc3QgY29lZmZpY2llbnRCID0gdmVjTlsxXTtcblx0Y29uc3QgY29lZmZpY2llbnRDID0gdmVjTlsyXTtcbi8vXHRjb25zdCBjb2VmZmljaWVudEQgPSAtMSAqIHZlYzMuZG90KHZlY04sIG1lc2hQb2ludDEpO1xuXG5cdC8vIGEgcG9pbnQgb24gdGhlIHBsYW5lXG5cdGN1clBvaW50ID0gdmVjMy5mcm9tVmFsdWVzKG1lc2hQb2ludFswXSwgbWVzaFBvaW50WzFdLCBtZXNoUG9pbnRbMl0pO1xuXHR2ZWMzLnRyYW5zZm9ybVF1YXQoY3VyUG9pbnQsIGN1clBvaW50LCBjdXJRdWF0ZXJuaW9uKTtcblxuXHQvLyBhIHBvaW50IHNob3VsZCBwcm9qZWN0IG9uIHRoZSBwbGFuZVxuXHRwcmV2UG9pbnQgPSB2ZWMzLmZyb21WYWx1ZXMobWVzaFBvaW50WzBdLCBtZXNoUG9pbnRbMV0sIG1lc2hQb2ludFsyXSk7XG5cdHZlYzMudHJhbnNmb3JtUXVhdChwcmV2UG9pbnQsIHByZXZQb2ludCwgcHJldlF1YXRlcm5pb24pO1xuXG5cdC8vIGRpc3RhbmNlIGJldHdlZW4gcHJldlBvaW50IGFuZCB0aGUgcGxhbmVcblx0bGV0IGRpc3RhbmNlID0gTWF0aC5hYnMoXG5cdFx0cHJldlBvaW50WzBdICogY29lZmZpY2llbnRBICtcblx0XHRwcmV2UG9pbnRbMV0gKiBjb2VmZmljaWVudEIgK1xuXHRcdHByZXZQb2ludFsyXSAqIGNvZWZmaWNpZW50Q1xuXHQpO1xuXG5cdGNvbnN0IHByb2plY3RlZFByZXZQb2ludCA9IHZlYzMuY3JlYXRlKCk7XG5cblx0dmVjMy5zdWJ0cmFjdChwcm9qZWN0ZWRQcmV2UG9pbnQsIHByZXZQb2ludCwgdmVjMy5zY2FsZSh2ZWMzLmNyZWF0ZSgpLCB2ZWNOLCBkaXN0YW5jZSkpO1xuXG5cdGxldCB0cmlnb25vbWV0cmljUmF0aW8gPVxuXHRcdChwcm9qZWN0ZWRQcmV2UG9pbnRbMF0gKiBjdXJQb2ludFswXSArXG5cdFx0cHJvamVjdGVkUHJldlBvaW50WzFdICogY3VyUG9pbnRbMV0gK1xuXHRcdHByb2plY3RlZFByZXZQb2ludFsyXSAqIGN1clBvaW50WzJdKSAvXG5cdFx0KHZlYzMubGVuZ3RoKHByb2plY3RlZFByZXZQb2ludCkgKiB2ZWMzLmxlbmd0aChjdXJQb2ludCkpO1xuXG5cdC8vIGRlZmVuc2l2ZSBibG9ja1xuXHRpZiAodHJpZ29ub21ldHJpY1JhdGlvID4gMSkge1xuXHRcdHRyaWdvbm9tZXRyaWNSYXRpbyA9IDE7XG5cdH1cblxuXHRjb25zdCB0aGV0YSA9IE1hdGguYWNvcyh0cmlnb25vbWV0cmljUmF0aW8pO1xuXG5cdGNvbnN0IGNyb3NzVmVjID0gdmVjMy5jcm9zcyh2ZWMzLmNyZWF0ZSgpLCBjdXJQb2ludCwgcHJvamVjdGVkUHJldlBvaW50KTtcblxuXHRkaXN0YW5jZSA9XG5cdFx0Y29lZmZpY2llbnRBICogY3Jvc3NWZWNbMF0gK1xuXHRcdGNvZWZmaWNpZW50QiAqIGNyb3NzVmVjWzFdICtcblx0XHRjb2VmZmljaWVudEMgKiBjcm9zc1ZlY1syXTtcblxuXHRsZXQgdGhldGFEaXJlY3Rpb247XG5cblx0aWYgKHJvdGF0ZUtpbmQgIT09IFJPVEFURV9DT05TVEFOVC5ZQVdfREVMVEFfQllfWUFXKSB7XG5cdFx0dGhldGFEaXJlY3Rpb24gPSBkaXN0YW5jZSA+IDAgPyAxIDogLTE7XG5cdH0gZWxzZSB7XG5cdFx0dGhldGFEaXJlY3Rpb24gPSBkaXN0YW5jZSA8IDAgPyAxIDogLTE7XG5cdH1cblxuXHRjb25zdCBkZWx0YVJhZGlhbiA9IHRoZXRhICogdGhldGFEaXJlY3Rpb24gKiByb3RhdGVEaXJlY3Rpb247XG5cblx0cmV0dXJuIGdsTWF0cml4LnRvRGVncmVlKGRlbHRhUmFkaWFuKTtcbn1cblxudXRpbC5nZXRSb3RhdGlvbkRlbHRhID0gZ2V0Um90YXRpb25EZWx0YTtcblxuZXhwb3J0IHtcblx0dXRpbCxcblx0Z2xNYXRyaXgsXG5cdG1hdDQsXG5cdHF1YXQsXG5cdHZlYzIsXG5cdHZlYzMsXG5cdFJPVEFURV9DT05TVEFOVCxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvbWF0aC11dGlsLmpzIiwiLyoqXG4gKiBPcmlnaW5hbCBDb2RlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdG9qaS9nbC1tYXRyaXgvYmxvYi92Mi4zLjIvc3JjL2dsLW1hdHJpeC9jb21tb24uanNcbiAqIENvbW1vbiB1dGlsaXRpZXNcbiAqIG1vZGlmaWVkIGJ5IGVnanNcbiAqL1xudmFyIGdsTWF0cml4ID0ge307XG5cbmdsTWF0cml4LkFSUkFZX1RZUEUgPSAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5cbnZhciBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xuXG5nbE1hdHJpeC50b1JhZGlhbiA9IGZ1bmN0aW9uKGEpe1xuICAgICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cblxuZ2xNYXRyaXgudG9EZWdyZWUgPSBmdW5jdGlvbihhKXtcbiAgICAgcmV0dXJuIGEgLyBkZWdyZWU7XG59XG5cbi8vIGdsTWF0cml4LkVQU0lMT04gPSAwLjAwMDAwMTtcbmdsTWF0cml4LkVQU0lMT04gPSAwLjAwMDE7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xNYXRyaXg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvbWF0aFV0aWwvY29tbW9uLmpzIiwiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgTkFWRVIgQ29ycC5cclxuICogQGVnanMvYWdlbnQgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICogXHJcbiAqIEBlZ2pzL2FnZW50IEphdmFTY3JpcHQgbGlicmFyeVxyXG4gKiBcclxuICogXHJcbiAqIEB2ZXJzaW9uIDIuMS4yXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImFnZW50XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImVnXCJdID0gcm9vdFtcImVnXCJdIHx8IHt9LCByb290W1wiZWdcIl1bXCJhZ2VudFwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9hZ2VudCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfYWdlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWdlbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxubW9kdWxlLmV4cG9ydHMgPSBfYWdlbnQyW1wiZGVmYXVsdFwiXTsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29weXJpZ2h0IChjKSBOQVZFUiBDb3JwLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGVnanMtYWdlbnQgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9icm93c2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9QYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX1BhcnNlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QYXJzZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyoqXG4gKiBAbmFtZXNwYWNlIGVnXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0cyBicm93c2VyIGFuZCBvcGVyYXRpbmcgc3lzdGVtIGluZm9ybWF0aW9uIGZyb20gdGhlIHVzZXIgYWdlbnQgc3RyaW5nLlxuICogQGtvIOycoOyggCDsl5DsnbTsoITtirgg66y47J6Q7Je07JeQ7IScIOu4jOudvOyasOyggOyZgCDsmrTsmIHssrTsoJwg7KCV67O066W8IOy2lOy2nO2VnOuLpC5cbiAqIEBmdW5jdGlvbiBlZyNhZ2VudFxuICogQHBhcmFtIHtTdHJpbmd9IFt1c2VyQWdlbnQ9bmF2aWdhdG9yLnVzZXJBZ2VudF0gdXNlciBhZ2VudCBzdHJpbmcgdG8gcGFyc2UgPGtvPu2MjOyLse2VoCDsnKDsoIDsl5DsnbTsoITtirgg66y47J6Q7Je0PC9rbz5cbiAqIEByZXR1cm4ge09iamVjdH0gYWdlbnRJbmZvXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFnZW50SW5mby5vcyBvcyBPcGVyYXRpbmcgc3lzdGVtIGluZm9ybWF0aW9uIDxrbz7smrTsmIHssrTsoJwg7KCV67O0PC9rbz5cbiAqIEByZXR1cm4ge1N0cmluZ30gYWdlbnRJbmZvLm9zLm5hbWUgT3BlcmF0aW5nIHN5c3RlbSBuYW1lIChhbmRyb2lkLCBpb3MsIHdpbmRvdywgbWFjLCB1bmtub3duKSA8a28+7Jq07JiB7LK07KCcIOydtOumhCAoYW5kcm9pZCwgaW9zLCB3aW5kb3csIG1hYywgdW5rbm93bik8L2tvPlxuICogQHJldHVybiB7U3RyaW5nfSBhZ2VudEluZm8ub3MudmVyc2lvbiBPcGVyYXRpbmcgc3lzdGVtIHZlcnNpb24gPGtvPuyatOyYgeyytOygnCDrsoTsoIQ8L2tvPlxuICogQHJldHVybiB7U3RyaW5nfSBhZ2VudEluZm8uYnJvd3NlciBCcm93c2VyIGluZm9ybWF0aW9uIDxrbz7ruIzrnbzsmrDsoIAg7KCV67O0PC9rbz5cbiAqIEByZXR1cm4ge1N0cmluZ30gYWdlbnRJbmZvLmJyb3dzZXIubmFtZSBCcm93c2VyIG5hbWUgKHNhZmFyaSwgY2hyb21lLCBzYnJvd3NlciwgaWUsIGZpcmVmb3gsIHVua25vd24pIDxrbz7ruIzrnbzsmrDsoIAg7J2066aEIChzYWZhcmksIGNocm9tZSwgc2Jyb3dzZXIsIGllLCBmaXJlZm94LCB1bmtub3duKTwva28+XG4gKiBAcmV0dXJuIHtTdHJpbmd9IGFnZW50SW5mby5icm93c2VyLnZlcnNpb24gQnJvd3NlciB2ZXJzaW9uIDxrbz7ruIzrnbzsmrDsoIAg67KE7KCEIDwva28+XG4gKiBAcmV0dXJuIHtCb29sZWFufSBhZ2VudEluZm8uYnJvd3Nlci53ZWJ2aWV3IEluZGljYXRlcyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIGluYXBwPGtvPuybueu3sCDruIzrnbzsmrDsoIAg7Jes67aAPC9rbz5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGFnZW50SW5mby5pc01vYmlsZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBmb3IgbW9iaWxlPGtvPuuqqOuwlOydvCDruIzrnbzsmrDsoIAg7Jes67aAPC9rbz5cbiAqL1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE5BVkVSIENvcnAuXG4gKiBlZ2pzLWFnZW50IHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gYWdlbnQoKSB7XG4gIHZhciB1YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogX2Jyb3dzZXIubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBfUGFyc2VyMltcImRlZmF1bHRcIl0uc2V0VWEodWEpO1xuXG4gIHZhciBhZ2VudEluZm8gPSB7XG4gICAgb3M6IF9QYXJzZXIyW1wiZGVmYXVsdFwiXS5nZXRPcygpLFxuICAgIGJyb3dzZXI6IF9QYXJzZXIyW1wiZGVmYXVsdFwiXS5nZXRCcm93c2VyKCksXG4gICAgaXNNb2JpbGU6IF9QYXJzZXIyW1wiZGVmYXVsdFwiXS5nZXRJc01vYmlsZSgpXG4gIH07XG5cbiAgYWdlbnRJbmZvLmJyb3dzZXIubmFtZSA9IGFnZW50SW5mby5icm93c2VyLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgYWdlbnRJbmZvLm9zLm5hbWUgPSBhZ2VudEluZm8ub3MubmFtZS50b0xvd2VyQ2FzZSgpO1xuICBhZ2VudEluZm8ub3MudmVyc2lvbiA9IGFnZW50SW5mby5vcy52ZXJzaW9uLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKGFnZW50SW5mby5vcy5uYW1lID09PSBcImlvc1wiICYmIGFnZW50SW5mby5icm93c2VyLndlYnZpZXcpIHtcbiAgICBhZ2VudEluZm8uYnJvd3Nlci52ZXJzaW9uID0gXCItMVwiO1xuICB9XG5cbiAgcmV0dXJuIGFnZW50SW5mbztcbn1cbmFnZW50LlZFUlNJT04gPSBcIjIuMS4yXCI7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGFnZW50O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgfHwge307XG5cbnZhciBSZWdFeHAgPSBleHBvcnRzLlJlZ0V4cCA9IHdpbi5SZWdFeHA7XG52YXIgbmF2aWdhdG9yID0gZXhwb3J0cy5uYXZpZ2F0b3IgPSB3aW4ubmF2aWdhdG9yO1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9wYXJzZVJ1bGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9wYXJzZVJ1bGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcnNlUnVsZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIFVBID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBzZXRVYSh1YSkge1xuXHRVQSA9IHVhO1xufVxuXG5mdW5jdGlvbiBpc01hdGNoZWQoYmFzZSwgdGFyZ2V0KSB7XG5cdHJldHVybiB0YXJnZXQgJiYgdGFyZ2V0LnRlc3QgPyAhIXRhcmdldC50ZXN0KGJhc2UpIDogYmFzZS5pbmRleE9mKHRhcmdldCkgPiAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0SWRlbnRpdHlTdHJpbmdGcm9tQXJyYXkocnVsZXMsIGRlZmF1bHRTdHJpbmdzKSB7XG5cdHZhciBtYXRjaGVkUnVsZSA9IHJ1bGVzLmZpbHRlcihmdW5jdGlvbiAocnVsZSkge1xuXHRcdHJldHVybiBpc01hdGNoZWQoVUEsIHJ1bGUuY3JpdGVyaWEpO1xuXHR9KVswXTtcblxuXHRyZXR1cm4gbWF0Y2hlZFJ1bGUgJiYgbWF0Y2hlZFJ1bGUuaWRlbnRpdHkgfHwgZGVmYXVsdFN0cmluZ3MubmFtZTtcbn1cblxuZnVuY3Rpb24gZ2V0UnVsZShydWxlcywgdGFyZ2V0SWRlbnRpdHkpIHtcblx0cmV0dXJuIHJ1bGVzLmZpbHRlcihmdW5jdGlvbiAocnVsZSkge1xuXHRcdHZhciBjcml0ZXJpYSA9IHJ1bGUuY3JpdGVyaWE7XG5cdFx0dmFyIGlkZW50aXR5TWF0Y2hlZCA9IG5ldyBSZWdFeHAocnVsZS5pZGVudGl0eSwgXCJpXCIpLnRlc3QodGFyZ2V0SWRlbnRpdHkpO1xuXG5cdFx0aWYgKGNyaXRlcmlhID8gaWRlbnRpdHlNYXRjaGVkICYmIGlzTWF0Y2hlZChVQSwgY3JpdGVyaWEpIDogaWRlbnRpdHlNYXRjaGVkKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSlbMF07XG59XG5cbmZ1bmN0aW9uIGdldEJyb3dzZXJOYW1lKCkge1xuXHRyZXR1cm4gZ2V0SWRlbnRpdHlTdHJpbmdGcm9tQXJyYXkoX3BhcnNlUnVsZXMyW1wiZGVmYXVsdFwiXS5icm93c2VyLCBfcGFyc2VSdWxlczJbXCJkZWZhdWx0XCJdLmRlZmF1bHRTdHJpbmcuYnJvd3Nlcik7XG59XG5cbmZ1bmN0aW9uIGdldEJyb3dzZXJSdWxlKGJyb3dzZXJOYW1lKSB7XG5cdHZhciBydWxlID0gZ2V0UnVsZShfcGFyc2VSdWxlczJbXCJkZWZhdWx0XCJdLmJyb3dzZXIsIGJyb3dzZXJOYW1lKTtcblxuXHRpZiAoIXJ1bGUpIHtcblx0XHRydWxlID0ge1xuXHRcdFx0Y3JpdGVyaWE6IGJyb3dzZXJOYW1lLFxuXHRcdFx0dmVyc2lvblNlYXJjaDogYnJvd3Nlck5hbWUsXG5cdFx0XHRpZGVudGl0eTogYnJvd3Nlck5hbWVcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHJ1bGU7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RCcm93c2VyVmVyc2lvbih2ZXJzaW9uVG9rZW4sIHVhKSB7XG5cdHZhciBicm93c2VyVmVyc2lvbiA9IF9wYXJzZVJ1bGVzMltcImRlZmF1bHRcIl0uZGVmYXVsdFN0cmluZy5icm93c2VyLnZlcnNpb247XG5cdHZhciB2ZXJzaW9uUmVnZXhSZXN1bHQgPSBuZXcgUmVnRXhwKFwiKFwiICsgdmVyc2lvblRva2VuICsgXCIpXCIsIFwiaVwiKS5leGVjKHVhKTtcblxuXHRpZiAoIXZlcnNpb25SZWdleFJlc3VsdCkge1xuXHRcdHJldHVybiBicm93c2VyVmVyc2lvbjtcblx0fVxuXG5cdHZhciB2ZXJzaW9uVG9rZW5JbmRleCA9IHZlcnNpb25SZWdleFJlc3VsdC5pbmRleDtcblx0dmFyIHZlclRrbiA9IHZlcnNpb25SZWdleFJlc3VsdFswXTtcblxuXHRpZiAodmVyc2lvblRva2VuSW5kZXggPiAtMSkge1xuXHRcdHZhciB2ZXJzaW9uSW5kZXggPSB2ZXJzaW9uVG9rZW5JbmRleCArIHZlclRrbi5sZW5ndGggKyAxO1xuXG5cdFx0YnJvd3NlclZlcnNpb24gPSB1YS5zdWJzdHJpbmcodmVyc2lvbkluZGV4KS5zcGxpdChcIiBcIilbMF0ucmVwbGFjZSgvXy9nLCBcIi5cIikucmVwbGFjZSgvO3xcXCkvZywgXCJcIik7XG5cdH1cblx0cmV0dXJuIGJyb3dzZXJWZXJzaW9uO1xufVxuXG5mdW5jdGlvbiBnZXRCcm93c2VyVmVyc2lvbihicm93c2VyTmFtZSkge1xuXHRpZiAoIWJyb3dzZXJOYW1lKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIGNvbnNvbGUubG9nKGJyb3dzZXJSdWxlKTtcblx0Ly8gY29uc3QgdmVyc2lvblRva2VuID0gYnJvd3NlclJ1bGUgPyBicm93c2VyUnVsZS52ZXJzaW9uU2VhcmNoIDogYnJvd3Nlck5hbWU7XG5cdHZhciBicm93c2VyUnVsZSA9IGdldEJyb3dzZXJSdWxlKGJyb3dzZXJOYW1lKTtcblx0dmFyIHZlcnNpb25Ub2tlbiA9IGJyb3dzZXJSdWxlLnZlcnNpb25TZWFyY2ggfHwgYnJvd3Nlck5hbWU7XG5cdHZhciBicm93c2VyVmVyc2lvbiA9IGV4dHJhY3RCcm93c2VyVmVyc2lvbih2ZXJzaW9uVG9rZW4sIFVBKTtcblxuXHRyZXR1cm4gYnJvd3NlclZlcnNpb247XG59XG5cbmZ1bmN0aW9uIGlzV2VidmlldygpIHtcblx0dmFyIHdlYnZpZXdSdWxlcyA9IF9wYXJzZVJ1bGVzMltcImRlZmF1bHRcIl0ud2Vidmlldztcblx0dmFyIGJyb3dzZXJWZXJzaW9uID0gdm9pZCAwO1xuXG5cdHJldHVybiB3ZWJ2aWV3UnVsZXMuZmlsdGVyKGZ1bmN0aW9uIChydWxlKSB7XG5cdFx0cmV0dXJuIGlzTWF0Y2hlZChVQSwgcnVsZS5jcml0ZXJpYSk7XG5cdH0pLnNvbWUoZnVuY3Rpb24gKHJ1bGUpIHtcblx0XHRicm93c2VyVmVyc2lvbiA9IGV4dHJhY3RCcm93c2VyVmVyc2lvbihydWxlLmJyb3dzZXJWZXJzaW9uU2VhcmNoLCBVQSk7XG5cdFx0aWYgKGlzTWF0Y2hlZChVQSwgcnVsZS53ZWJ2aWV3VG9rZW4pIHx8IGlzTWF0Y2hlZChicm93c2VyVmVyc2lvbiwgcnVsZS53ZWJ2aWV3QnJvd3NlclZlcnNpb24pKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIGdldE9TUnVsZShvc05hbWUpIHtcblx0cmV0dXJuIGdldFJ1bGUoX3BhcnNlUnVsZXMyW1wiZGVmYXVsdFwiXS5vcywgb3NOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3NOYW1lKCkge1xuXHRyZXR1cm4gZ2V0SWRlbnRpdHlTdHJpbmdGcm9tQXJyYXkoX3BhcnNlUnVsZXMyW1wiZGVmYXVsdFwiXS5vcywgX3BhcnNlUnVsZXMyW1wiZGVmYXVsdFwiXS5kZWZhdWx0U3RyaW5nLm9zKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3NWZXJzaW9uKG9zTmFtZSkge1xuXHR2YXIgb3NSdWxlID0gZ2V0T1NSdWxlKG9zTmFtZSkgfHwge307XG5cdHZhciBkZWZhdWx0T1NWZXJzaW9uID0gX3BhcnNlUnVsZXMyW1wiZGVmYXVsdFwiXS5kZWZhdWx0U3RyaW5nLm9zLnZlcnNpb247XG5cdHZhciBvc1ZlcnNpb24gPSB2b2lkIDA7XG5cblx0aWYgKCFvc05hbWUpIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cdGlmIChvc1J1bGUudmVyc2lvbkFsaWFzKSB7XG5cdFx0cmV0dXJuIG9zUnVsZS52ZXJzaW9uQWxpYXM7XG5cdH1cblx0dmFyIG9zVmVyc2lvblRva2VuID0gb3NSdWxlLnZlcnNpb25TZWFyY2ggfHwgb3NOYW1lO1xuXHR2YXIgb3NWZXJzaW9uUmVnZXggPSBuZXcgUmVnRXhwKFwiKFwiICsgb3NWZXJzaW9uVG9rZW4gKyBcIilcXFxccyhbXFxcXGRfXFxcXC5dK3xcXFxcZF8wKVwiLCBcImlcIik7XG5cdHZhciBvc1ZlcnNpb25SZWdleFJlc3VsdCA9IG9zVmVyc2lvblJlZ2V4LmV4ZWMoVUEpO1xuXG5cdGlmIChvc1ZlcnNpb25SZWdleFJlc3VsdCkge1xuXHRcdG9zVmVyc2lvbiA9IG9zVmVyc2lvblJlZ2V4LmV4ZWMoVUEpWzJdLnJlcGxhY2UoL18vZywgXCIuXCIpLnJlcGxhY2UoLzt8XFwpL2csIFwiXCIpO1xuXHR9XG5cdHJldHVybiBvc1ZlcnNpb24gfHwgZGVmYXVsdE9TVmVyc2lvbjtcbn1cblxuZnVuY3Rpb24gZ2V0T3MoKSB7XG5cdHZhciBuYW1lID0gZ2V0T3NOYW1lKCk7XG5cdHZhciB2ZXJzaW9uID0gZ2V0T3NWZXJzaW9uKG5hbWUpO1xuXG5cdHJldHVybiB7IG5hbWU6IG5hbWUsIHZlcnNpb246IHZlcnNpb24gfTtcbn1cblxuZnVuY3Rpb24gZ2V0QnJvd3NlcigpIHtcblx0dmFyIG5hbWUgPSBnZXRCcm93c2VyTmFtZSgpO1xuXHR2YXIgdmVyc2lvbiA9IGdldEJyb3dzZXJWZXJzaW9uKG5hbWUpO1xuXG5cdHJldHVybiB7IG5hbWU6IG5hbWUsIHZlcnNpb246IHZlcnNpb24sIHdlYnZpZXc6IGlzV2VidmlldygpIH07XG59XG5cbmZ1bmN0aW9uIGdldElzTW9iaWxlKCkge1xuXHRyZXR1cm4gVUEuaW5kZXhPZihcIk1vYmlcIikgIT09IC0xO1xufVxuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHtcblx0Z2V0T3M6IGdldE9zLFxuXHRnZXRCcm93c2VyOiBnZXRCcm93c2VyLFxuXHRnZXRJc01vYmlsZTogZ2V0SXNNb2JpbGUsXG5cdHNldFVhOiBzZXRVYVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIHBhcnNlUnVsZXMgPSB7XG5cdGJyb3dzZXI6IFt7XG5cdFx0Y3JpdGVyaWE6IFwiUGhhbnRvbUpTXCIsXG5cdFx0aWRlbnRpdHk6IFwiUGhhbnRvbUpTXCJcblx0fSwge1xuXHRcdGNyaXRlcmlhOiAvV2hhbGUvLFxuXHRcdGlkZW50aXR5OiBcIldoYWxlXCIsXG5cdFx0dmVyc2lvblNlYXJjaDogXCJXaGFsZVwiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogL0VkZ2UvLFxuXHRcdGlkZW50aXR5OiBcIkVkZ2VcIixcblx0XHR2ZXJzaW9uU2VhcmNoOiBcIkVkZ2VcIlxuXHR9LCB7XG5cdFx0Y3JpdGVyaWE6IC9NU0lFfFRyaWRlbnR8V2luZG93cyBQaG9uZS8sXG5cdFx0aWRlbnRpdHk6IFwiSUVcIixcblx0XHR2ZXJzaW9uU2VhcmNoOiBcIklFTW9iaWxlfE1TSUV8cnZcIlxuXHR9LCB7XG5cdFx0Y3JpdGVyaWE6IC9NaXVpQnJvd3Nlci8sXG5cdFx0aWRlbnRpdHk6IFwiTUlVSSBCcm93c2VyXCIsXG5cdFx0dmVyc2lvblNlYXJjaDogXCJNaXVpQnJvd3NlclwiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogL1NhbXN1bmdCcm93c2VyLyxcblx0XHRpZGVudGl0eTogXCJTYW1zdW5nIEludGVybmV0XCIsXG5cdFx0dmVyc2lvblNlYXJjaDogXCJTYW1zdW5nQnJvd3NlclwiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogL1NBTVNVTkcgLyxcblx0XHRpZGVudGl0eTogXCJTYW1zdW5nIEludGVybmV0XCIsXG5cdFx0dmVyc2lvblNlYXJjaDogXCJWZXJzaW9uXCJcblx0fSwge1xuXHRcdGNyaXRlcmlhOiAvQ2hyb21lfENyaU9TLyxcblx0XHRpZGVudGl0eTogXCJDaHJvbWVcIlxuXHR9LCB7XG5cdFx0Y3JpdGVyaWE6IC9BbmRyb2lkLyxcblx0XHRpZGVudGl0eTogXCJBbmRyb2lkIEJyb3dzZXJcIixcblx0XHR2ZXJzaW9uU2VhcmNoOiBcIlZlcnNpb25cIlxuXHR9LCB7XG5cdFx0Y3JpdGVyaWE6IC9pUGhvbmV8aVBhZC8sXG5cdFx0aWRlbnRpdHk6IFwiU2FmYXJpXCIsXG5cdFx0dmVyc2lvblNlYXJjaDogXCJWZXJzaW9uXCJcblx0fSwge1xuXHRcdGNyaXRlcmlhOiBcIkFwcGxlXCIsXG5cdFx0aWRlbnRpdHk6IFwiU2FmYXJpXCIsXG5cdFx0dmVyc2lvblNlYXJjaDogXCJWZXJzaW9uXCJcblx0fSwge1xuXHRcdGNyaXRlcmlhOiBcIkZpcmVmb3hcIixcblx0XHRpZGVudGl0eTogXCJGaXJlZm94XCJcblx0fV0sXG5cdG9zOiBbe1xuXHRcdGNyaXRlcmlhOiAvV2luZG93cyBQaG9uZS8sXG5cdFx0aWRlbnRpdHk6IFwiV2luZG93cyBQaG9uZVwiLFxuXHRcdHZlcnNpb25TZWFyY2g6IFwiV2luZG93cyBQaG9uZVwiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogXCJXaW5kb3dzIDIwMDBcIixcblx0XHRpZGVudGl0eTogXCJXaW5kb3dcIixcblx0XHR2ZXJzaW9uQWxpYXM6IFwiNS4wXCJcblx0fSwge1xuXHRcdGNyaXRlcmlhOiAvV2luZG93cyBOVC8sXG5cdFx0aWRlbnRpdHk6IFwiV2luZG93XCIsXG5cdFx0dmVyc2lvblNlYXJjaDogXCJXaW5kb3dzIE5UXCJcblx0fSwge1xuXHRcdGNyaXRlcmlhOiAvaVBob25lfGlQYWQvLFxuXHRcdGlkZW50aXR5OiBcImlPU1wiLFxuXHRcdHZlcnNpb25TZWFyY2g6IFwiaVBob25lIE9TfENQVSBPU1wiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogXCJNYWNcIixcblx0XHR2ZXJzaW9uU2VhcmNoOiBcIk9TIFhcIixcblx0XHRpZGVudGl0eTogXCJNQUNcIlxuXHR9LCB7XG5cdFx0Y3JpdGVyaWE6IC9BbmRyb2lkLyxcblx0XHRpZGVudGl0eTogXCJBbmRyb2lkXCJcblx0fSwge1xuXHRcdGNyaXRlcmlhOiAvVGl6ZW4vLFxuXHRcdGlkZW50aXR5OiBcIlRpemVuXCJcblx0fSwge1xuXHRcdGNyaXRlcmlhOiAvV2ViMFMvLFxuXHRcdGlkZW50aXR5OiBcIldlYk9TXCJcblx0fV0sXG5cblx0Ly8gV2VidmlldyBjaGVjayBjb25kaXRpb25cblx0Ly8gaW9zOiBJZiBoYXMgbm8gdmVyc2lvbiBpbmZvcm1hdGlvblxuXHQvLyBBbmRyb2lkIDUuMCAmJiBjaHJvbWUgNDArOiBQcmVzZW5jZSBvZiBcIjsgd3ZcIiBpbiB1c2VyQWdlbnRcblx0Ly8gVW5kZXIgYW5kcm9pZCA1LjA6IFByZXNlbmNlIG9mIFwiTkFWRVJcIiBvciBcIkRhdW1cIiBpbiB1c2VyQWdlbnRcblx0d2VidmlldzogW3tcblx0XHRjcml0ZXJpYTogL2lQaG9uZXxpUGFkLyxcblx0XHRicm93c2VyVmVyc2lvblNlYXJjaDogXCJWZXJzaW9uXCIsXG5cdFx0d2Vidmlld0Jyb3dzZXJWZXJzaW9uOiAvLTEvXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogL2lQaG9uZXxpUGFkfEFuZHJvaWQvLFxuXHRcdHdlYnZpZXdUb2tlbjogL05BVkVSfERBVU18OyB3di9cblxuXHR9XSxcblx0ZGVmYXVsdFN0cmluZzoge1xuXHRcdGJyb3dzZXI6IHtcblx0XHRcdHZlcnNpb246IFwiLTFcIixcblx0XHRcdG5hbWU6IFwidW5rbm93blwiXG5cdFx0fSxcblx0XHRvczoge1xuXHRcdFx0dmVyc2lvbjogXCItMVwiLFxuXHRcdFx0bmFtZTogXCJ1bmtub3duXCJcblx0XHR9XG5cdH1cbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gcGFyc2VSdWxlcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9AZWdqcy9hZ2VudC9kaXN0L2FnZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1uZXN0ZWQtdGVybmFyeSAqL1xuY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuTWF0aCA9PT0gTWF0aCA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuTWF0aCA9PT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLW5lc3RlZC10ZXJuYXJ5ICovXG4vKiBlc2xpbnQtZW5hYmxlIG5vLW5ldy1mdW5jICovXG5cbndpbi5GbG9hdDMyQXJyYXkgPSAodHlwZW9mIHdpbi5GbG9hdDMyQXJyYXkgIT09IFwidW5kZWZpbmVkXCIpID8gd2luLkZsb2F0MzJBcnJheSA6IHdpbi5BcnJheTtcblxuZXhwb3J0IHt3aW4gYXMgd2luZG93fTtcbmV4cG9ydCBjb25zdCBkb2N1bWVudCA9IHdpbi5kb2N1bWVudDtcbmV4cG9ydCBjb25zdCBGbG9hdDMyQXJyYXkgPSB3aW4uRmxvYXQzMkFycmF5O1xuZXhwb3J0IGNvbnN0IGdldENvbXB1dGVkU3R5bGUgPSB3aW4uZ2V0Q29tcHV0ZWRTdHlsZTtcbmV4cG9ydCBjb25zdCB1c2VyQWdlbnQgPSB3aW4ubmF2aWdhdG9yLnVzZXJBZ2VudDtcbmV4cG9ydCBjb25zdCBTVVBQT1JUX1RPVUNIID0gXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW47XG5leHBvcnQgY29uc3QgU1VQUE9SVF9ERVZJQ0VNT1RJT04gPSBcIm9uZGV2aWNlbW90aW9uXCIgaW4gd2luO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1lhd1BpdGNoQ29udHJvbC9icm93c2VyLmpzIiwiLyohXG4gKiBAb3ZlcnZpZXcgZXM2LXByb21pc2UgLSBhIHRpbnkgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXMvQSsuXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCBZZWh1ZGEgS2F0eiwgVG9tIERhbGUsIFN0ZWZhbiBQZW5uZXIgYW5kIGNvbnRyaWJ1dG9ycyAoQ29udmVyc2lvbiB0byBFUzYgQVBJIGJ5IEpha2UgQXJjaGliYWxkKVxuICogQGxpY2Vuc2UgICBMaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZVxuICogICAgICAgICAgICBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3N0ZWZhbnBlbm5lci9lczYtcHJvbWlzZS9tYXN0ZXIvTElDRU5TRVxuICogQHZlcnNpb24gICB2NC4yLjQrMzE0ZTQ4MzFcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuRVM2UHJvbWlzZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHg7XG4gIHJldHVybiB4ICE9PSBudWxsICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuXG5cbnZhciBfaXNBcnJheSA9IHZvaWQgMDtcbmlmIChBcnJheS5pc0FycmF5KSB7XG4gIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbn0gZWxzZSB7XG4gIF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSA9IF9pc0FycmF5O1xuXG52YXIgbGVuID0gMDtcbnZhciB2ZXJ0eE5leHQgPSB2b2lkIDA7XG52YXIgY3VzdG9tU2NoZWR1bGVyRm4gPSB2b2lkIDA7XG5cbnZhciBhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gIHF1ZXVlW2xlbl0gPSBjYWxsYmFjaztcbiAgcXVldWVbbGVuICsgMV0gPSBhcmc7XG4gIGxlbiArPSAyO1xuICBpZiAobGVuID09PSAyKSB7XG4gICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgIGlmIChjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgY3VzdG9tU2NoZWR1bGVyRm4oZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICBjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG59XG5cbmZ1bmN0aW9uIHNldEFzYXAoYXNhcEZuKSB7XG4gIGFzYXAgPSBhc2FwRm47XG59XG5cbnZhciBicm93c2VyV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG52YXIgYnJvd3Nlckdsb2JhbCA9IGJyb3dzZXJXaW5kb3cgfHwge307XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGlzTm9kZSA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG4vLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxudmFyIGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcblxuLy8gbm9kZVxuZnVuY3Rpb24gdXNlTmV4dFRpY2soKSB7XG4gIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gIH07XG59XG5cbi8vIHZlcnR4XG5mdW5jdGlvbiB1c2VWZXJ0eFRpbWVyKCkge1xuICBpZiAodHlwZW9mIHZlcnR4TmV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmVydHhOZXh0KGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBub2RlLmRhdGEgPSBpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMjtcbiAgfTtcbn1cblxuLy8gd2ViIHdvcmtlclxuZnVuY3Rpb24gdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVNldFRpbWVvdXQoKSB7XG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIGVzNi1wcm9taXNlIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIGdsb2JhbFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWxTZXRUaW1lb3V0KGZsdXNoLCAxKTtcbiAgfTtcbn1cblxudmFyIHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuZnVuY3Rpb24gZmx1c2goKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcbiAgICB2YXIgYXJnID0gcXVldWVbaSArIDFdO1xuXG4gICAgY2FsbGJhY2soYXJnKTtcblxuICAgIHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgIHF1ZXVlW2kgKyAxXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRWZXJ0eCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdmVydHggPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpLnJlcXVpcmUoJ3ZlcnR4Jyk7XG4gICAgdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICByZXR1cm4gdXNlVmVydHhUaW1lcigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbiAgfVxufVxuXG52YXIgc2NoZWR1bGVGbHVzaCA9IHZvaWQgMDtcbi8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG5pZiAoaXNOb2RlKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VOZXh0VGljaygpO1xufSBlbHNlIGlmIChCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xufSBlbHNlIGlmIChpc1dvcmtlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTWVzc2FnZUNoYW5uZWwoKTtcbn0gZWxzZSBpZiAoYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSBhdHRlbXB0VmVydHgoKTtcbn0gZWxzZSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIHBhcmVudCA9IHRoaXM7XG5cbiAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3Iobm9vcCk7XG5cbiAgaWYgKGNoaWxkW1BST01JU0VfSURdID09PSB1bmRlZmluZWQpIHtcbiAgICBtYWtlUHJvbWlzZShjaGlsZCk7XG4gIH1cblxuICB2YXIgX3N0YXRlID0gcGFyZW50Ll9zdGF0ZTtcblxuXG4gIGlmIChfc3RhdGUpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbX3N0YXRlIC0gMV07XG4gICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaW52b2tlQ2FsbGJhY2soX3N0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHBhcmVudC5fcmVzdWx0KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkO1xufVxuXG4vKipcbiAgYFByb21pc2UucmVzb2x2ZWAgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSByZXNvbHZlZCB3aXRoIHRoZVxuICBwYXNzZWQgYHZhbHVlYC4gSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlc29sdmUoMSk7XG4gIH0pO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKDEpO1xuXG4gIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgLy8gdmFsdWUgPT09IDFcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVzb2x2ZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVzb2x2ZWQgd2l0aFxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIGZ1bGZpbGxlZCB3aXRoIHRoZSBnaXZlblxuICBgdmFsdWVgXG4qL1xuZnVuY3Rpb24gcmVzb2x2ZSQxKG9iamVjdCkge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcbiAgcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIFBST01JU0VfSUQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMik7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgUEVORElORyA9IHZvaWQgMDtcbnZhciBGVUxGSUxMRUQgPSAxO1xudmFyIFJFSkVDVEVEID0gMjtcblxudmFyIFRSWV9DQVRDSF9FUlJPUiA9IHsgZXJyb3I6IG51bGwgfTtcblxuZnVuY3Rpb24gc2VsZkZ1bGZpbGxtZW50KCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIllvdSBjYW5ub3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIik7XG59XG5cbmZ1bmN0aW9uIGNhbm5vdFJldHVybk93bigpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGhlbihwcm9taXNlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBlcnJvcjtcbiAgICByZXR1cm4gVFJZX0NBVENIX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRoZW4odGhlbiQkMSwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICB0cnkge1xuICAgIHRoZW4kJDEuY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbiQkMSkge1xuICBhc2FwKGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IHRyeVRoZW4odGhlbiQkMSwgdGhlbmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgIGlmICghc2VhbGVkICYmIGVycm9yKSB7XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9XG4gIH0sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHRoZW5hYmxlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpIHtcbiAgaWYgKG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IgPT09IHByb21pc2UuY29uc3RydWN0b3IgJiYgdGhlbiQkMSA9PT0gdGhlbiAmJiBtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yLnJlc29sdmUgPT09IHJlc29sdmUkMSkge1xuICAgIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0aGVuJCQxID09PSBUUllfQ0FUQ0hfRVJST1IpIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCBUUllfQ0FUQ0hfRVJST1IuZXJyb3IpO1xuICAgICAgVFJZX0NBVENIX0VSUk9SLmVycm9yID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHRoZW4kJDEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odGhlbiQkMSkpIHtcbiAgICAgIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuJCQxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICByZWplY3QocHJvbWlzZSwgc2VsZkZ1bGZpbGxtZW50KCkpO1xuICB9IGVsc2UgaWYgKG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSwgZ2V0VGhlbih2YWx1ZSkpO1xuICB9IGVsc2Uge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICBpZiAocHJvbWlzZS5fb25lcnJvcikge1xuICAgIHByb21pc2UuX29uZXJyb3IocHJvbWlzZS5fcmVzdWx0KTtcbiAgfVxuXG4gIHB1Ymxpc2gocHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvbWlzZS5fcmVzdWx0ID0gdmFsdWU7XG4gIHByb21pc2UuX3N0YXRlID0gRlVMRklMTEVEO1xuXG4gIGlmIChwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggIT09IDApIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHByb21pc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlamVjdChwcm9taXNlLCByZWFzb24pIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHByb21pc2UuX3N0YXRlID0gUkVKRUNURUQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHJlYXNvbjtcblxuICBhc2FwKHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIF9zdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gIHZhciBsZW5ndGggPSBfc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG5cbiAgcGFyZW50Ll9vbmVycm9yID0gbnVsbDtcblxuICBfc3Vic2NyaWJlcnNbbGVuZ3RoXSA9IGNoaWxkO1xuICBfc3Vic2NyaWJlcnNbbGVuZ3RoICsgRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBSRUpFQ1RFRF0gPSBvblJlamVjdGlvbjtcblxuICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICBhc2FwKHB1Ymxpc2gsIHBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaChwcm9taXNlKSB7XG4gIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICB2YXIgc2V0dGxlZCA9IHByb21pc2UuX3N0YXRlO1xuXG4gIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2hpbGQgPSB2b2lkIDAsXG4gICAgICBjYWxsYmFjayA9IHZvaWQgMCxcbiAgICAgIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgIGlmIChjaGlsZCkge1xuICAgICAgaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhkZXRhaWwpO1xuICAgIH1cbiAgfVxuXG4gIHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG59XG5cbmZ1bmN0aW9uIHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FsbGJhY2soZGV0YWlsKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGU7XG4gICAgcmV0dXJuIFRSWV9DQVRDSF9FUlJPUjtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gIHZhciBoYXNDYWxsYmFjayA9IGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgdmFsdWUgPSB2b2lkIDAsXG4gICAgICBlcnJvciA9IHZvaWQgMCxcbiAgICAgIHN1Y2NlZWRlZCA9IHZvaWQgMCxcbiAgICAgIGZhaWxlZCA9IHZvaWQgMDtcblxuICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICB2YWx1ZSA9IHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpO1xuXG4gICAgaWYgKHZhbHVlID09PSBUUllfQ0FUQ0hfRVJST1IpIHtcbiAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICBlcnJvciA9IHZhbHVlLmVycm9yO1xuICAgICAgdmFsdWUuZXJyb3IgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgcmVqZWN0KHByb21pc2UsIGNhbm5vdFJldHVybk93bigpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBkZXRhaWw7XG4gICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIC8vIG5vb3BcbiAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChmYWlsZWQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IFJFSkVDVEVEKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICB0cnkge1xuICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKSB7XG4gICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZWplY3QocHJvbWlzZSwgZSk7XG4gIH1cbn1cblxudmFyIGlkID0gMDtcbmZ1bmN0aW9uIG5leHRJZCgpIHtcbiAgcmV0dXJuIGlkKys7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcm9taXNlKHByb21pc2UpIHtcbiAgcHJvbWlzZVtQUk9NSVNFX0lEXSA9IGlkKys7XG4gIHByb21pc2UuX3N0YXRlID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3N1YnNjcmliZXJzID0gW107XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcigpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcignQXJyYXkgTWV0aG9kcyBtdXN0IGJlIHByb3ZpZGVkIGFuIEFycmF5Jyk7XG59XG5cbnZhciBFbnVtZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbnVtZXJhdG9yKENvbnN0cnVjdG9yLCBpbnB1dCkge1xuICAgIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG5cbiAgICBpZiAoIXRoaXMucHJvbWlzZVtQUk9NSVNFX0lEXSkge1xuICAgICAgbWFrZVByb21pc2UodGhpcy5wcm9taXNlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgdGhpcy5fcmVtYWluaW5nID0gaW5wdXQubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgICAgIHRoaXMuX2VudW1lcmF0ZShpbnB1dCk7XG4gICAgICAgIGlmICh0aGlzLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWplY3QodGhpcy5wcm9taXNlLCB2YWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgfVxuICB9XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uIF9lbnVtZXJhdGUoaW5wdXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgdGhpcy5fc3RhdGUgPT09IFBFTkRJTkcgJiYgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9lYWNoRW50cnkoaW5wdXRbaV0sIGkpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZWFjaEVudHJ5ID0gZnVuY3Rpb24gX2VhY2hFbnRyeShlbnRyeSwgaSkge1xuICAgIHZhciBjID0gdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvcjtcbiAgICB2YXIgcmVzb2x2ZSQkMSA9IGMucmVzb2x2ZTtcblxuXG4gICAgaWYgKHJlc29sdmUkJDEgPT09IHJlc29sdmUkMSkge1xuICAgICAgdmFyIF90aGVuID0gZ2V0VGhlbihlbnRyeSk7XG5cbiAgICAgIGlmIChfdGhlbiA9PT0gdGhlbiAmJiBlbnRyeS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICAgICAgdGhpcy5fc2V0dGxlZEF0KGVudHJ5Ll9zdGF0ZSwgaSwgZW50cnkuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhlbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLl9yZW1haW5pbmctLTtcbiAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gZW50cnk7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IFByb21pc2UkMSkge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBjKG5vb3ApO1xuICAgICAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIGVudHJ5LCBfdGhlbik7XG4gICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChuZXcgYyhmdW5jdGlvbiAocmVzb2x2ZSQkMSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlJCQxKGVudHJ5KTtcbiAgICAgICAgfSksIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZSQkMShlbnRyeSksIGkpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fc2V0dGxlZEF0ID0gZnVuY3Rpb24gX3NldHRsZWRBdChzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcblxuXG4gICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgICB0aGlzLl9yZW1haW5pbmctLTtcblxuICAgICAgaWYgKHN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fd2lsbFNldHRsZUF0ID0gZnVuY3Rpb24gX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKSB7XG4gICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoUkVKRUNURUQsIGksIHJlYXNvbik7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEVudW1lcmF0b3I7XG59KCk7XG5cbi8qKlxuICBgUHJvbWlzZS5hbGxgIGFjY2VwdHMgYW4gYXJyYXkgb2YgcHJvbWlzZXMsIGFuZCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2hcbiAgaXMgZnVsZmlsbGVkIHdpdGggYW4gYXJyYXkgb2YgZnVsZmlsbG1lbnQgdmFsdWVzIGZvciB0aGUgcGFzc2VkIHByb21pc2VzLCBvclxuICByZWplY3RlZCB3aXRoIHRoZSByZWFzb24gb2YgdGhlIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIGJlIHJlamVjdGVkLiBJdCBjYXN0cyBhbGxcbiAgZWxlbWVudHMgb2YgdGhlIHBhc3NlZCBpdGVyYWJsZSB0byBwcm9taXNlcyBhcyBpdCBydW5zIHRoaXMgYWxnb3JpdGhtLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZXNvbHZlKDIpO1xuICBsZXQgcHJvbWlzZTMgPSByZXNvbHZlKDMpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gVGhlIGFycmF5IGhlcmUgd291bGQgYmUgWyAxLCAyLCAzIF07XG4gIH0pO1xuICBgYGBcblxuICBJZiBhbnkgb2YgdGhlIGBwcm9taXNlc2AgZ2l2ZW4gdG8gYGFsbGAgYXJlIHJlamVjdGVkLCB0aGUgZmlyc3QgcHJvbWlzZVxuICB0aGF0IGlzIHJlamVjdGVkIHdpbGwgYmUgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgdG8gdGhlIHJldHVybmVkIHByb21pc2VzJ3NcbiAgcmVqZWN0aW9uIGhhbmRsZXIuIEZvciBleGFtcGxlOlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZWplY3QobmV3IEVycm9yKFwiMlwiKSk7XG4gIGxldCBwcm9taXNlMyA9IHJlamVjdChuZXcgRXJyb3IoXCIzXCIpKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zIGJlY2F1c2UgdGhlcmUgYXJlIHJlamVjdGVkIHByb21pc2VzIVxuICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgIC8vIGVycm9yLm1lc3NhZ2UgPT09IFwiMlwiXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIGFsbFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IGVudHJpZXMgYXJyYXkgb2YgcHJvbWlzZXNcbiAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgbGFiZWxpbmcgdGhlIHByb21pc2UuXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIGFsbCBgcHJvbWlzZXNgIGhhdmUgYmVlblxuICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIGlmIGFueSBvZiB0aGVtIGJlY29tZSByZWplY3RlZC5cbiAgQHN0YXRpY1xuKi9cbmZ1bmN0aW9uIGFsbChlbnRyaWVzKSB7XG4gIHJldHVybiBuZXcgRW51bWVyYXRvcih0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xufVxuXG4vKipcbiAgYFByb21pc2UucmFjZWAgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoIGlzIHNldHRsZWQgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZVxuICBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBzZXR0bGUuXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDInKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyByZXN1bHQgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgaXQgd2FzIHJlc29sdmVkIGJlZm9yZSBwcm9taXNlMVxuICAgIC8vIHdhcyByZXNvbHZlZC5cbiAgfSk7XG4gIGBgYFxuXG4gIGBQcm9taXNlLnJhY2VgIGlzIGRldGVybWluaXN0aWMgaW4gdGhhdCBvbmx5IHRoZSBzdGF0ZSBvZiB0aGUgZmlyc3RcbiAgc2V0dGxlZCBwcm9taXNlIG1hdHRlcnMuIEZvciBleGFtcGxlLCBldmVuIGlmIG90aGVyIHByb21pc2VzIGdpdmVuIHRvIHRoZVxuICBgcHJvbWlzZXNgIGFycmF5IGFyZ3VtZW50IGFyZSByZXNvbHZlZCwgYnV0IHRoZSBmaXJzdCBzZXR0bGVkIHByb21pc2UgaGFzXG4gIGJlY29tZSByZWplY3RlZCBiZWZvcmUgdGhlIG90aGVyIHByb21pc2VzIGJlY2FtZSBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICBwcm9taXNlIHdpbGwgYmVjb21lIHJlamVjdGVkOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3Byb21pc2UgMicpKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVuc1xuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIHByb21pc2UgMiBiZWNhbWUgcmVqZWN0ZWQgYmVmb3JlXG4gICAgLy8gcHJvbWlzZSAxIGJlY2FtZSBmdWxmaWxsZWRcbiAgfSk7XG4gIGBgYFxuXG4gIEFuIGV4YW1wbGUgcmVhbC13b3JsZCB1c2UgY2FzZSBpcyBpbXBsZW1lbnRpbmcgdGltZW91dHM6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBQcm9taXNlLnJhY2UoW2FqYXgoJ2Zvby5qc29uJyksIHRpbWVvdXQoNTAwMCldKVxuICBgYGBcblxuICBAbWV0aG9kIHJhY2VcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlcyB0byBvYnNlcnZlXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHdoaWNoIHNldHRsZXMgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZSBmaXJzdCBwYXNzZWRcbiAgcHJvbWlzZSB0byBzZXR0bGUuXG4qL1xuZnVuY3Rpb24gcmFjZShlbnRyaWVzKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKCFpc0FycmF5KGVudHJpZXMpKSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZWplY3RgIHJldHVybnMgYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIHBhc3NlZCBgcmVhc29uYC5cbiAgSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVqZWN0XG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHJlYXNvbiB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aC5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgZ2l2ZW4gYHJlYXNvbmAuXG4qL1xuZnVuY3Rpb24gcmVqZWN0JDEocmVhc29uKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIG5lZWRzUmVzb2x2ZXIoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbn1cblxuZnVuY3Rpb24gbmVlZHNOZXcoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG59XG5cbi8qKlxuICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsIHdoaWNoXG4gIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlIHJlYXNvblxuICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICBUZXJtaW5vbG9neVxuICAtLS0tLS0tLS0tLVxuXG4gIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cbiAgLSBgdmFsdWVgIGlzIGFueSBsZWdhbCBKYXZhU2NyaXB0IHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkLCBhIHRoZW5hYmxlLCBvciBhIHByb21pc2UpLlxuICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuICAtIGBzZXR0bGVkYCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiBhIHByb21pc2UsIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cblxuICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcbiAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcbiAgcHJvbWlzZSwgdGhlbiB0aGUgb3JpZ2luYWwgcHJvbWlzZSdzIHNldHRsZWQgc3RhdGUgd2lsbCBtYXRjaCB0aGUgdmFsdWUnc1xuICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuICBpdHNlbGYgZnVsZmlsbC5cblxuXG4gIEJhc2ljIFVzYWdlOlxuICAtLS0tLS0tLS0tLS1cblxuICBgYGBqc1xuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vIG9uIHN1Y2Nlc3NcbiAgICByZXNvbHZlKHZhbHVlKTtcblxuICAgIC8vIG9uIGZhaWx1cmVcbiAgICByZWplY3QocmVhc29uKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBBZHZhbmNlZCBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgUHJvbWlzZXMgc2hpbmUgd2hlbiBhYnN0cmFjdGluZyBhd2F5IGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgc3VjaCBhc1xuICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICBgYGBqc1xuICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgYGBganNcbiAgUHJvbWlzZS5hbGwoW1xuICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gIF0pLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcbiAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSk7XG4gIGBgYFxuXG4gIEBjbGFzcyBQcm9taXNlXG4gIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVyXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQGNvbnN0cnVjdG9yXG4qL1xuXG52YXIgUHJvbWlzZSQxID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgdGhpc1tQUk9NSVNFX0lEXSA9IG5leHRJZCgpO1xuICAgIHRoaXMuX3Jlc3VsdCA9IHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgICBpZiAobm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICAgIHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJyAmJiBuZWVkc1Jlc29sdmVyKCk7XG4gICAgICB0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSA/IGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKSA6IG5lZWRzTmV3KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICB3aGljaCByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZVxuICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG4gICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuICB9KTtcbiAgYGBgXG4gICBDaGFpbmluZ1xuICAtLS0tLS0tLVxuICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZpcnN0IHByb21pc2UncyBmdWxmaWxsbWVudFxuICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiB1c2VyLm5hbWU7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgLy8gSWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGB1c2VyTmFtZWAgd2lsbCBiZSB0aGUgdXNlcidzIG5hbWUsIG90aGVyd2lzZSBpdFxuICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuICB9KTtcbiAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gIH0pO1xuICBgYGBcbiAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gIH0pO1xuICBgYGBcbiAgIEFzc2ltaWxhdGlvblxuICAtLS0tLS0tLS0tLS1cbiAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcbiAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICB9KTtcbiAgYGBgXG4gICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gIH0pO1xuICBgYGBcbiAgIFNpbXBsZSBFeGFtcGxlXG4gIC0tLS0tLS0tLS0tLS0tXG4gICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gICBgYGBqYXZhc2NyaXB0XG4gIGxldCByZXN1bHQ7XG4gICB0cnkge1xuICAgIHJlc3VsdCA9IGZpbmRSZXN1bHQoKTtcbiAgICAvLyBzdWNjZXNzXG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgLy8gZmFpbHVyZVxuICB9XG4gIGBgYFxuICAgRXJyYmFjayBFeGFtcGxlXG4gICBgYGBqc1xuICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcbiAgICBpZiAoZXJyKSB7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9XG4gIH0pO1xuICBgYGBcbiAgIFByb21pc2UgRXhhbXBsZTtcbiAgIGBgYGphdmFzY3JpcHRcbiAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBzdWNjZXNzXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gZmFpbHVyZVxuICB9KTtcbiAgYGBgXG4gICBBZHZhbmNlZCBFeGFtcGxlXG4gIC0tLS0tLS0tLS0tLS0tXG4gICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gICBgYGBqYXZhc2NyaXB0XG4gIGxldCBhdXRob3IsIGJvb2tzO1xuICAgdHJ5IHtcbiAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAvLyBzdWNjZXNzXG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgLy8gZmFpbHVyZVxuICB9XG4gIGBgYFxuICAgRXJyYmFjayBFeGFtcGxlXG4gICBgYGBqc1xuICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuICAgfVxuICAgZnVuY3Rpb24gZmFpbHVyZShyZWFzb24pIHtcbiAgIH1cbiAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm91bmRCb29rcyhib29rcyk7XG4gICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgfVxuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kQXV0aG9yKCkuXG4gICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgdGhlbihmdW5jdGlvbihib29rcyl7XG4gICAgICAvLyBmb3VuZCBib29rc1xuICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgIEBtZXRob2QgdGhlblxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZ1bGZpbGxlZFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuICAvKipcbiAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuICBgYGBqc1xuICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICB9XG4gIC8vIHN5bmNocm9ub3VzXG4gIHRyeSB7XG4gIGZpbmRBdXRob3IoKTtcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfVxuICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9KTtcbiAgYGBgXG4gIEBtZXRob2QgY2F0Y2hcbiAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICBgZmluYWxseWAgd2lsbCBiZSBpbnZva2VkIHJlZ2FyZGxlc3Mgb2YgdGhlIHByb21pc2UncyBmYXRlIGp1c3QgYXMgbmF0aXZlXG4gICAgdHJ5L2NhdGNoL2ZpbmFsbHkgYmVoYXZlc1xuICBcbiAgICBTeW5jaHJvbm91cyBleGFtcGxlOlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRBdXRob3IoKSB7XG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQXV0aG9yKCk7XG4gICAgfVxuICBcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZpbmRBdXRob3IoKTsgLy8gc3VjY2VlZCBvciBmYWlsXG4gICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgcmV0dXJuIGZpbmRPdGhlckF1dGhlcigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBhbHdheXMgcnVuc1xuICAgICAgLy8gZG9lc24ndCBhZmZlY3QgdGhlIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgQXN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpe1xuICAgICAgLy8gYXV0aG9yIHdhcyBlaXRoZXIgZm91bmQsIG9yIG5vdFxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIGZpbmFsbHlcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5ID0gZnVuY3Rpb24gX2ZpbmFsbHkoY2FsbGJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHJvbWlzZS5jb25zdHJ1Y3RvcjtcblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBQcm9taXNlO1xufSgpO1xuXG5Qcm9taXNlJDEucHJvdG90eXBlLnRoZW4gPSB0aGVuO1xuUHJvbWlzZSQxLmFsbCA9IGFsbDtcblByb21pc2UkMS5yYWNlID0gcmFjZTtcblByb21pc2UkMS5yZXNvbHZlID0gcmVzb2x2ZSQxO1xuUHJvbWlzZSQxLnJlamVjdCA9IHJlamVjdCQxO1xuUHJvbWlzZSQxLl9zZXRTY2hlZHVsZXIgPSBzZXRTY2hlZHVsZXI7XG5Qcm9taXNlJDEuX3NldEFzYXAgPSBzZXRBc2FwO1xuUHJvbWlzZSQxLl9hc2FwID0gYXNhcDtcblxuLypnbG9iYWwgc2VsZiovXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgdmFyIGxvY2FsID0gdm9pZCAwO1xuXG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsID0gc2VsZjtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgbG9jYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXG4gIGlmIChQKSB7XG4gICAgdmFyIHByb21pc2VUb1N0cmluZyA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2VUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gc2lsZW50bHkgaWdub3JlZFxuICAgIH1cblxuICAgIGlmIChwcm9taXNlVG9TdHJpbmcgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbG9jYWwuUHJvbWlzZSA9IFByb21pc2UkMTtcbn1cblxuLy8gU3RyYW5nZSBjb21wYXQuLlxuUHJvbWlzZSQxLnBvbHlmaWxsID0gcG9seWZpbGw7XG5Qcm9taXNlJDEuUHJvbWlzZSA9IFByb21pc2UkMTtcblxucmV0dXJuIFByb21pc2UkMTtcblxufSkpKTtcblxuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzNi1wcm9taXNlLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIE1hdGhVdGlsID0gd2luZG93Lk1hdGhVdGlsIHx8IHt9O1xuXG5NYXRoVXRpbC5kZWdUb1JhZCA9IE1hdGguUEkgLyAxODA7XG5NYXRoVXRpbC5yYWRUb0RlZyA9IDE4MCAvIE1hdGguUEk7XG5cbi8vIFNvbWUgbWluaW1hbCBtYXRoIGZ1bmN0aW9uYWxpdHkgYm9ycm93ZWQgZnJvbSBUSFJFRS5NYXRoIGFuZCBzdHJpcHBlZCBkb3duXG4vLyBmb3IgdGhlIHB1cnBvc2VzIG9mIHRoaXMgbGlicmFyeS5cblxuXG5NYXRoVXRpbC5WZWN0b3IyID0gZnVuY3Rpb24gKCB4LCB5ICkge1xuICB0aGlzLnggPSB4IHx8IDA7XG4gIHRoaXMueSA9IHkgfHwgMDtcbn07XG5cbk1hdGhVdGlsLlZlY3RvcjIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTWF0aFV0aWwuVmVjdG9yMixcblxuICBzZXQ6IGZ1bmN0aW9uICggeCwgeSApIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG4gICAgdGhpcy54ID0gdi54O1xuICAgIHRoaXMueSA9IHYueTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcbiAgICB0aGlzLnggPSBhLnggLSBiLng7XG4gICAgdGhpcy55ID0gYS55IC0gYi55O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG59O1xuXG5NYXRoVXRpbC5WZWN0b3IzID0gZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuICB0aGlzLnggPSB4IHx8IDA7XG4gIHRoaXMueSA9IHkgfHwgMDtcbiAgdGhpcy56ID0geiB8fCAwO1xufTtcblxuTWF0aFV0aWwuVmVjdG9yMy5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBNYXRoVXRpbC5WZWN0b3IzLFxuXG4gIHNldDogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnogPSB6O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCB2ICkge1xuICAgIHRoaXMueCA9IHYueDtcbiAgICB0aGlzLnkgPSB2Lnk7XG4gICAgdGhpcy56ID0gdi56O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XG4gIH0sXG5cbiAgbm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjYWxhciA9IHRoaXMubGVuZ3RoKCk7XG5cbiAgICBpZiAoIHNjYWxhciAhPT0gMCApIHtcbiAgICAgIHZhciBpbnZTY2FsYXIgPSAxIC8gc2NhbGFyO1xuXG4gICAgICB0aGlzLm11bHRpcGx5U2NhbGFyKGludlNjYWxhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueCA9IDA7XG4gICAgICB0aGlzLnkgPSAwO1xuICAgICAgdGhpcy56ID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG4gICAgdGhpcy54ICo9IHNjYWxhcjtcbiAgICB0aGlzLnkgKj0gc2NhbGFyO1xuICAgIHRoaXMueiAqPSBzY2FsYXI7XG4gIH0sXG5cbiAgYXBwbHlRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHogPSB0aGlzLno7XG5cbiAgICB2YXIgcXggPSBxLng7XG4gICAgdmFyIHF5ID0gcS55O1xuICAgIHZhciBxeiA9IHEuejtcbiAgICB2YXIgcXcgPSBxLnc7XG5cbiAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY3RvclxuICAgIHZhciBpeCA9ICBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG4gICAgdmFyIGl5ID0gIHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcbiAgICB2YXIgaXogPSAgcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICAgIHZhciBpdyA9IC0gcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC0gcXggKyBpeSAqIC0gcXogLSBpeiAqIC0gcXk7XG4gICAgdGhpcy55ID0gaXkgKiBxdyArIGl3ICogLSBxeSArIGl6ICogLSBxeCAtIGl4ICogLSBxejtcbiAgICB0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtIHF6ICsgaXggKiAtIHF5IC0gaXkgKiAtIHF4O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZG90OiBmdW5jdGlvbiAoIHYgKSB7XG4gICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcbiAgfSxcblxuICBjcm9zc1ZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcbiAgICB2YXIgYXggPSBhLngsIGF5ID0gYS55LCBheiA9IGEuejtcbiAgICB2YXIgYnggPSBiLngsIGJ5ID0gYi55LCBieiA9IGIuejtcblxuICAgIHRoaXMueCA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgIHRoaXMueSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICAgIHRoaXMueiA9IGF4ICogYnkgLSBheSAqIGJ4O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG59O1xuXG5NYXRoVXRpbC5RdWF0ZXJuaW9uID0gZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuICB0aGlzLnggPSB4IHx8IDA7XG4gIHRoaXMueSA9IHkgfHwgMDtcbiAgdGhpcy56ID0geiB8fCAwO1xuICB0aGlzLncgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XG59O1xuXG5NYXRoVXRpbC5RdWF0ZXJuaW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IE1hdGhVdGlsLlF1YXRlcm5pb24sXG5cbiAgc2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueiA9IHo7XG4gICAgdGhpcy53ID0gdztcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcbiAgICB0aGlzLnggPSBxdWF0ZXJuaW9uLng7XG4gICAgdGhpcy55ID0gcXVhdGVybmlvbi55O1xuICAgIHRoaXMueiA9IHF1YXRlcm5pb24uejtcbiAgICB0aGlzLncgPSBxdWF0ZXJuaW9uLnc7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzZXRGcm9tRXVsZXJYWVo6IGZ1bmN0aW9uKCB4LCB5LCB6ICkge1xuICAgIHZhciBjMSA9IE1hdGguY29zKCB4IC8gMiApO1xuICAgIHZhciBjMiA9IE1hdGguY29zKCB5IC8gMiApO1xuICAgIHZhciBjMyA9IE1hdGguY29zKCB6IC8gMiApO1xuICAgIHZhciBzMSA9IE1hdGguc2luKCB4IC8gMiApO1xuICAgIHZhciBzMiA9IE1hdGguc2luKCB5IC8gMiApO1xuICAgIHZhciBzMyA9IE1hdGguc2luKCB6IC8gMiApO1xuXG4gICAgdGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgIHRoaXMueSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICB0aGlzLnogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc2V0RnJvbUV1bGVyWVhaOiBmdW5jdGlvbiggeCwgeSwgeiApIHtcbiAgICB2YXIgYzEgPSBNYXRoLmNvcyggeCAvIDIgKTtcbiAgICB2YXIgYzIgPSBNYXRoLmNvcyggeSAvIDIgKTtcbiAgICB2YXIgYzMgPSBNYXRoLmNvcyggeiAvIDIgKTtcbiAgICB2YXIgczEgPSBNYXRoLnNpbiggeCAvIDIgKTtcbiAgICB2YXIgczIgPSBNYXRoLnNpbiggeSAvIDIgKTtcbiAgICB2YXIgczMgPSBNYXRoLnNpbiggeiAvIDIgKTtcblxuICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHNldEZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG4gICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuICAgIC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXG5cbiAgICB2YXIgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLCBzID0gTWF0aC5zaW4oIGhhbGZBbmdsZSApO1xuXG4gICAgdGhpcy54ID0gYXhpcy54ICogcztcbiAgICB0aGlzLnkgPSBheGlzLnkgKiBzO1xuICAgIHRoaXMueiA9IGF4aXMueiAqIHM7XG4gICAgdGhpcy53ID0gTWF0aC5jb3MoIGhhbGZBbmdsZSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgbXVsdGlwbHk6IGZ1bmN0aW9uICggcSApIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XG4gIH0sXG5cbiAgbXVsdGlwbHlRdWF0ZXJuaW9uczogZnVuY3Rpb24gKCBhLCBiICkge1xuICAgIC8vIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9jb2RlL2luZGV4Lmh0bVxuXG4gICAgdmFyIHFheCA9IGEueCwgcWF5ID0gYS55LCBxYXogPSBhLnosIHFhdyA9IGEudztcbiAgICB2YXIgcWJ4ID0gYi54LCBxYnkgPSBiLnksIHFieiA9IGIueiwgcWJ3ID0gYi53O1xuXG4gICAgdGhpcy54ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xuICAgIHRoaXMueSA9IHFheSAqIHFidyArIHFhdyAqIHFieSArIHFheiAqIHFieCAtIHFheCAqIHFiejtcbiAgICB0aGlzLnogPSBxYXogKiBxYncgKyBxYXcgKiBxYnogKyBxYXggKiBxYnkgLSBxYXkgKiBxYng7XG4gICAgdGhpcy53ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgaW52ZXJzZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMueCAqPSAtMTtcbiAgICB0aGlzLnkgKj0gLTE7XG4gICAgdGhpcy56ICo9IC0xO1xuXG4gICAgdGhpcy5ub3JtYWxpemUoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsID0gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncgKTtcblxuICAgIGlmICggbCA9PT0gMCApIHtcbiAgICAgIHRoaXMueCA9IDA7XG4gICAgICB0aGlzLnkgPSAwO1xuICAgICAgdGhpcy56ID0gMDtcbiAgICAgIHRoaXMudyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSAxIC8gbDtcblxuICAgICAgdGhpcy54ID0gdGhpcy54ICogbDtcbiAgICAgIHRoaXMueSA9IHRoaXMueSAqIGw7XG4gICAgICB0aGlzLnogPSB0aGlzLnogKiBsO1xuICAgICAgdGhpcy53ID0gdGhpcy53ICogbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzbGVycDogZnVuY3Rpb24gKCBxYiwgdCApIHtcbiAgICBpZiAoIHQgPT09IDAgKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIHQgPT09IDEgKSByZXR1cm4gdGhpcy5jb3B5KCBxYiApO1xuXG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLnosIHcgPSB0aGlzLnc7XG5cbiAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL3NsZXJwL1xuXG4gICAgdmFyIGNvc0hhbGZUaGV0YSA9IHcgKiBxYi53ICsgeCAqIHFiLnggKyB5ICogcWIueSArIHogKiBxYi56O1xuXG4gICAgaWYgKCBjb3NIYWxmVGhldGEgPCAwICkge1xuICAgICAgdGhpcy53ID0gLSBxYi53O1xuICAgICAgdGhpcy54ID0gLSBxYi54O1xuICAgICAgdGhpcy55ID0gLSBxYi55O1xuICAgICAgdGhpcy56ID0gLSBxYi56O1xuXG4gICAgICBjb3NIYWxmVGhldGEgPSAtIGNvc0hhbGZUaGV0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb3B5KCBxYiApO1xuICAgIH1cblxuICAgIGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcbiAgICAgIHRoaXMudyA9IHc7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHRoaXMueiA9IHo7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBoYWxmVGhldGEgPSBNYXRoLmFjb3MoIGNvc0hhbGZUaGV0YSApO1xuICAgIHZhciBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIDEuMCAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YSApO1xuXG4gICAgaWYgKCBNYXRoLmFicyggc2luSGFsZlRoZXRhICkgPCAwLjAwMSApIHtcbiAgICAgIHRoaXMudyA9IDAuNSAqICggdyArIHRoaXMudyApO1xuICAgICAgdGhpcy54ID0gMC41ICogKCB4ICsgdGhpcy54ICk7XG4gICAgICB0aGlzLnkgPSAwLjUgKiAoIHkgKyB0aGlzLnkgKTtcbiAgICAgIHRoaXMueiA9IDAuNSAqICggeiArIHRoaXMueiApO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxuICAgIHJhdGlvQiA9IE1hdGguc2luKCB0ICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGE7XG5cbiAgICB0aGlzLncgPSAoIHcgKiByYXRpb0EgKyB0aGlzLncgKiByYXRpb0IgKTtcbiAgICB0aGlzLnggPSAoIHggKiByYXRpb0EgKyB0aGlzLnggKiByYXRpb0IgKTtcbiAgICB0aGlzLnkgPSAoIHkgKiByYXRpb0EgKyB0aGlzLnkgKiByYXRpb0IgKTtcbiAgICB0aGlzLnogPSAoIHogKiByYXRpb0EgKyB0aGlzLnogKiByYXRpb0IgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHNldEZyb21Vbml0VmVjdG9yczogZnVuY3Rpb24gKCkge1xuICAgIC8vIGh0dHA6Ly9sb2xlbmdpbmUubmV0L2Jsb2cvMjAxNC8wMi8yNC9xdWF0ZXJuaW9uLWZyb20tdHdvLXZlY3RvcnMtZmluYWxcbiAgICAvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcblxuICAgIHZhciB2MSwgcjtcbiAgICB2YXIgRVBTID0gMC4wMDAwMDE7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCB2RnJvbSwgdlRvICkge1xuICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgTWF0aFV0aWwuVmVjdG9yMygpO1xuXG4gICAgICByID0gdkZyb20uZG90KCB2VG8gKSArIDE7XG5cbiAgICAgIGlmICggciA8IEVQUyApIHtcbiAgICAgICAgciA9IDA7XG5cbiAgICAgICAgaWYgKCBNYXRoLmFicyggdkZyb20ueCApID4gTWF0aC5hYnMoIHZGcm9tLnogKSApIHtcbiAgICAgICAgICB2MS5zZXQoIC0gdkZyb20ueSwgdkZyb20ueCwgMCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHYxLnNldCggMCwgLSB2RnJvbS56LCB2RnJvbS55ICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYxLmNyb3NzVmVjdG9ycyggdkZyb20sIHZUbyApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnggPSB2MS54O1xuICAgICAgdGhpcy55ID0gdjEueTtcbiAgICAgIHRoaXMueiA9IHYxLno7XG4gICAgICB0aGlzLncgPSByO1xuXG4gICAgICB0aGlzLm5vcm1hbGl6ZSgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0oKSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0aFV0aWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vd2VidnItcG9seWZpbGwvc3JjL21hdGgtdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgYWdlbnQgZnJvbSBcIkBlZ2pzL2FnZW50XCI7XG5cbmNvbnN0IFdFQkdMX0VSUk9SX0NPREUgPSB7XG5cdFwiMFwiOiBcIk5PX0VSUk9SXCIsXG5cdFwiMTI4MFwiOiBcIklOVkFMSURfRU5VTVwiLFxuXHRcIjEyODFcIjogXCJJTlZBTElEX1ZBTFVFXCIsXG5cdFwiMTI4MlwiOiBcIklOVkFMSURfT1BFUkFUSU9OXCIsXG5cdFwiMTI4NVwiOiBcIk9VVF9PRl9NRU1PUllcIixcblx0XCIxMjg2XCI6IFwiSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT05cIixcblx0XCIzNzQ0MlwiOiBcIkNPTlRFWFRfTE9TVF9XRUJHTFwiXG59O1xuXG5sZXQgd2ViZ2xBdmFpbGFiaWxpdHkgPSBudWxsO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTFV0aWxzIHtcblx0c3RhdGljIGNyZWF0ZVNoYWRlcihnbCwgdHlwZSwgc291cmNlKSB7XG5cdFx0Y29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuXG5cdFx0Z2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcblx0XHRnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG5cdFx0Y29uc3Qgc3VjY2VzcyA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKTtcblxuXHRcdGlmIChzdWNjZXNzKSB7XG5cdFx0XHRyZXR1cm4gc2hhZGVyO1xuXHRcdH1cblxuXHRcdGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0c3RhdGljIGNyZWF0ZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpIHtcblx0XHRjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG5cdFx0Z2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG5cdFx0Z2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcblx0XHRnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblx0XHRjb25zdCBzdWNjZXNzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyk7XG5cblx0XHRpZiAoc3VjY2Vzcykge1xuXHRcdFx0cmV0dXJuIHByb2dyYW07XG5cdFx0fVxuXG5cdFx0Z2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHN0YXRpYyBpbml0QnVmZmVyKGdsLCB0YXJnZXQgLyogYmluZCBwb2ludCAqLywgZGF0YSwgaXRlbVNpemUsIGF0dHIpIHtcblx0XHRjb25zdCBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdGdsLmJpbmRCdWZmZXIodGFyZ2V0LCBidWZmZXIpO1xuXHRcdGdsLmJ1ZmZlckRhdGEodGFyZ2V0LCBkYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG5cblx0XHRpZiAoYnVmZmVyKSB7XG5cdFx0XHRidWZmZXIuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblx0XHRcdGJ1ZmZlci5udW1JdGVtcyA9IGRhdGEubGVuZ3RoIC8gaXRlbVNpemU7XG5cdFx0fVxuXG5cdFx0aWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0cik7XG5cdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHIsIGJ1ZmZlci5pdGVtU2l6ZSwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYnVmZmVyO1xuXHR9XG5cblx0c3RhdGljIGJpbmRCdWZmZXJUb0F0dHJpYnV0ZShnbCwgYnVmZmVyLCBhdHRyKSB7XG5cdFx0aWYgKGJ1ZmZlciA9PT0gbnVsbCB8fCBhdHRyID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyLCBidWZmZXIuaXRlbVNpemUsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cdH1cblxuXHRzdGF0aWMgZ2V0V2ViZ2xDb250ZXh0KGNhbnZhcywgdXNlckNvbnRleHRBdHRyaWJ1dGVzKSB7XG5cdFx0Y29uc3Qgd2ViZ2xJZGVudGlmaWVycyA9IFtcIndlYmdsXCIsIFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIFwid2Via2l0LTNkXCIsIFwibW96LXdlYmdsXCJdO1xuXHRcdGxldCBjb250ZXh0ID0gbnVsbDtcblx0XHRjb25zdCBjb250ZXh0QXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdFx0cHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcblx0XHRcdGFudGlhbGlhczogZmFsc2Vcblx0XHR9LCB1c2VyQ29udGV4dEF0dHJpYnV0ZXMpO1xuXG5cdFx0ZnVuY3Rpb24gb25XZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yKGUpIHtcblx0XHRcdHJldHVybiBlLnN0YXR1c01lc3NhZ2U7XG5cdFx0fVxuXG5cdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yXCIsIG9uV2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvcik7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHdlYmdsSWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCh3ZWJnbElkZW50aWZpZXJzW2ldLCBjb250ZXh0QXR0cmlidXRlcyk7XG5cdFx0XHR9IGNhdGNoICh0KSB7fVxuXHRcdFx0aWYgKGNvbnRleHQpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yXCIsIG9uV2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvcik7XG5cblx0XHRyZXR1cm4gY29udGV4dDtcblx0fVxuXG5cdHN0YXRpYyBjcmVhdGVUZXh0dXJlKGdsLCB0ZXh0dXJlVGFyZ2V0KSB7XG5cdFx0Y29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblxuXHRcdGdsLmJpbmRUZXh0dXJlKHRleHR1cmVUYXJnZXQsIHRleHR1cmUpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZVRhcmdldCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZVRhcmdldCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZVRhcmdldCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZVRhcmdldCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKHRleHR1cmVUYXJnZXQsIG51bGwpO1xuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgd2ViZ2wgYXZhaWxhYmlsaXR5IG9mIHRoZSBjdXJyZW50IGJyb3dzZXIuXG5cdCAqIEBtZXRob2QgV2ViR0xVdGlscyNpc1dlYkdMQXZhaWxhYmxlXG5cdCAqIEByZXR1ZW4ge0Jvb2xlYW59IGlzV2ViR0xBdmFpbGFibGVcblx0ICovXG5cdHN0YXRpYyBpc1dlYkdMQXZhaWxhYmxlKCkge1xuXHRcdGlmICh3ZWJnbEF2YWlsYWJpbGl0eSA9PT0gbnVsbCkge1xuXHRcdFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblx0XHRcdGNvbnN0IHdlYmdsQ29udGV4dCA9IFdlYkdMVXRpbHMuZ2V0V2ViZ2xDb250ZXh0KGNhbnZhcyk7XG5cblx0XHRcdHdlYmdsQXZhaWxhYmlsaXR5ID0gISF3ZWJnbENvbnRleHQ7XG5cblx0XHRcdC8vIHdlYmdsQ29udGV4dCBSZXNvdXJjZSBmb3JjZWQgY29sbGVjdGlvblxuXHRcdFx0aWYgKHdlYmdsQ29udGV4dCkge1xuXHRcdFx0XHRjb25zdCBsb3NlQ29udGV4dEV4dGVuc2lvbiA9IHdlYmdsQ29udGV4dC5nZXRFeHRlbnNpb24oXCJXRUJHTF9sb3NlX2NvbnRleHRcIik7XG5cblx0XHRcdFx0bG9zZUNvbnRleHRFeHRlbnNpb24gJiYgbG9zZUNvbnRleHRFeHRlbnNpb24ubG9zZUNvbnRleHQoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHdlYmdsQXZhaWxhYmlsaXR5O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciB3ZWJnbCBpcyBzdGFibGUgaW4gdGhlIGN1cnJlbnQgYnJvd3Nlci5cblx0ICogQG1ldGhvZCBXZWJHTFV0aWxzI2lzU3RhYmxlV2ViR0xcblx0ICogQHJldHVlbiB7Qm9vbGVhbn0gaXNTdGFibGVXZWJHTFxuXHQgKi9cblx0c3RhdGljIGlzU3RhYmxlV2ViR0woKSB7XG5cdFx0Y29uc3QgYWdlbnRJbmZvID0gYWdlbnQoKTtcblx0XHRsZXQgaXNTdGFibGVXZWJnbCA9IHRydWU7XG5cblx0XHRpZiAoYWdlbnRJbmZvLm9zLm5hbWUgPT09IFwiYW5kcm9pZFwiICYmIHBhcnNlRmxvYXQoYWdlbnRJbmZvLm9zLnZlcnNpb24pIDw9IDQuMykge1xuXHRcdFx0aXNTdGFibGVXZWJnbCA9IGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoYWdlbnRJbmZvLm9zLm5hbWUgPT09IFwiYW5kcm9pZFwiICYmIHBhcnNlRmxvYXQoYWdlbnRJbmZvLm9zLnZlcnNpb24pID09PSA0LjQpIHtcblx0XHRcdGlmIChhZ2VudEluZm8uYnJvd3Nlci5uYW1lICE9PSBcImNocm9tZVwiKSB7XG5cdFx0XHRcdGlzU3RhYmxlV2ViZ2wgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGlzU3RhYmxlV2ViZ2w7XG5cdH1cblxuXHRzdGF0aWMgZ2V0RXJyb3JOYW1lRnJvbVdlYkdMRXJyb3JDb2RlKGNvZGUpIHtcblx0XHRpZiAoIShjb2RlIGluIFdFQkdMX0VSUk9SX0NPREUpKSB7XG5cdFx0XHRyZXR1cm4gXCJVTktOT1dOX0VSUk9SXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFdFQkdMX0VSUk9SX0NPREVbY29kZV07XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9XZWJHTFV0aWxzLmpzIiwiY29uc3QgQ09OVFJPTF9NT0RFX1ZSID0gMTtcbmNvbnN0IENPTlRST0xfTU9ERV9ZQVdQSVRDSCA9IDI7XG5cbmNvbnN0IFRPVUNIX0RJUkVDVElPTl9OT05FID0gMTtcbmNvbnN0IFRPVUNIX0RJUkVDVElPTl9ZQVcgPSAyO1xuY29uc3QgVE9VQ0hfRElSRUNUSU9OX1BJVENIID0gNDtcbmNvbnN0IFRPVUNIX0RJUkVDVElPTl9BTEwgPSBUT1VDSF9ESVJFQ1RJT05fWUFXIHwgVE9VQ0hfRElSRUNUSU9OX1BJVENIO1xuXG4vKiBDb25zdCBmb3IgTW92YWJsZUNvb3JkICovXG5jb25zdCBNQ19ERUNFTEVSQVRJT04gPSAwLjAwMTQ7XG5jb25zdCBNQ19NQVhJTVVNX0RVUkFUSU9OID0gMTAwMDtcbmNvbnN0IE1DX0JJTkRfU0NBTEUgPSBbMC4yMCwgMC4yMF07XG5cbmNvbnN0IE1JTl9GSUVMRF9PRl9WSUVXID0gMjA7XG5jb25zdCBNQVhfRklFTERfT0ZfVklFVyA9IDExMDtcbmNvbnN0IFBBTl9TQ0FMRSA9IDMyMDtcblxuLy8gY29uc3QgREVMVEFfVEhSRVNIT0xEID0gMC4wMTU7XG4vLyBjb25zdCBERUxUQV9USFJFU0hPTEQgPSAwLjA5OyAvLyBOb3RlNFxuLy8gY29uc3QgREVMVEFfVEhSRVNIT0xEID0gMC4wODI1O1xuLy8gY29uc3QgREVMVEFfVEhSRVNIT0xEID0gMC4wNzU7XG4vLyBjb25zdCBERUxUQV9USFJFU0hPTEQgPSAwLjA2O1xuLy8gY29uc3QgREVMVEFfVEhSRVNIT0xEID0gMC4wNDU7XG5jb25zdCBERUxUQV9USFJFU0hPTEQgPSAwLjAzNzU7IC8vIE5vdGUyXG5cbmNvbnN0IFlBV19SQU5HRV9IQUxGID0gMTgwO1xuY29uc3QgUElUQ0hfUkFOR0VfSEFMRiA9IDkwO1xuY29uc3QgQ0lSQ1VMQVJfUElUQ0hfUkFOR0VfSEFMRiA9IDE4MDtcbmNvbnN0IFBJTkNIX0VWRU5UUyA9IFwicGluY2hzdGFydCBwaW5jaG1vdmUgcGluY2hlbmRcIjtcblxuY29uc3QgS0VZTUFQID0ge1xuXHRMRUZUX0FSUk9XOiAzNyxcblx0QTogNjUsXG5cdFVQX0FSUk9XOiAzOCxcblx0VzogODcsXG5cdFJJR0hUX0FSUk9XOiAzOSxcblx0RDogNjgsXG5cdERPV05fQVJST1c6IDQwLFxuXHRTOiA4Myxcbn07XG5cbmNvbnN0IEdZUk9fTU9ERSA9IHtcblx0Tk9ORTogXCJub25lXCIsXG5cdFlBV1BJVENIOiBcInlhd1BpdGNoXCIsXG5cdFZSOiBcIlZSXCJcbn07XG5cbmV4cG9ydCB7XG5cdEdZUk9fTU9ERSxcblxuXHRDT05UUk9MX01PREVfVlIsXG5cdENPTlRST0xfTU9ERV9ZQVdQSVRDSCxcblxuXHRUT1VDSF9ESVJFQ1RJT05fTk9ORSxcblx0VE9VQ0hfRElSRUNUSU9OX1lBVyxcblx0VE9VQ0hfRElSRUNUSU9OX1BJVENILFxuXHRUT1VDSF9ESVJFQ1RJT05fQUxMLFxuXG5cdE1DX0RFQ0VMRVJBVElPTixcblx0TUNfTUFYSU1VTV9EVVJBVElPTixcblx0TUNfQklORF9TQ0FMRSxcblx0TUlOX0ZJRUxEX09GX1ZJRVcsXG5cdE1BWF9GSUVMRF9PRl9WSUVXLFxuXHRQQU5fU0NBTEUsXG5cdERFTFRBX1RIUkVTSE9MRCxcblx0WUFXX1JBTkdFX0hBTEYsXG5cdFBJVENIX1JBTkdFX0hBTEYsXG5cdENJUkNVTEFSX1BJVENIX1JBTkdFX0hBTEYsXG5cdFBJTkNIX0VWRU5UUyxcblx0S0VZTUFQXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1lhd1BpdGNoQ29udHJvbC9jb25zdHMuanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIFV0aWwgPSB3aW5kb3cuVXRpbCB8fCB7fTtcblxuVXRpbC5NSU5fVElNRVNURVAgPSAwLjAwMTtcblV0aWwuTUFYX1RJTUVTVEVQID0gMTtcblxuVXRpbC5iYXNlNjQgPSBmdW5jdGlvbihtaW1lVHlwZSwgYmFzZTY0KSB7XG4gIHJldHVybiAnZGF0YTonICsgbWltZVR5cGUgKyAnO2Jhc2U2NCwnICsgYmFzZTY0O1xufTtcblxuVXRpbC5jbGFtcCA9IGZ1bmN0aW9uKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCB2YWx1ZSksIG1heCk7XG59O1xuXG5VdGlsLmxlcnAgPSBmdW5jdGlvbihhLCBiLCB0KSB7XG4gIHJldHVybiBhICsgKChiIC0gYSkgKiB0KTtcbn07XG5cbi8qKlxuICogTGlnaHQgcG9seWZpbGwgZm9yIGBQcm9taXNlLnJhY2VgLiBSZXR1cm5zXG4gKiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBmaXJzdCBwcm9taXNlXG4gKiBwcm92aWRlZCByZXNvbHZlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFByb21pc2U+fSBwcm9taXNlc1xuICovXG5VdGlsLnJhY2UgPSBmdW5jdGlvbihwcm9taXNlcykge1xuICBpZiAoUHJvbWlzZS5yYWNlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShwcm9taXNlcyk7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb21pc2VzW2ldLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9XG4gIH0pO1xufTtcblxuVXRpbC5pc0lPUyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGlzSU9TID0gL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc0lPUztcbiAgfTtcbn0pKCk7XG5cblV0aWwuaXNXZWJWaWV3QW5kcm9pZCA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGlzV2ViVmlld0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1ZlcnNpb24nKSAhPT0gLTEgJiZcbiAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQW5kcm9pZCcpICE9PSAtMSAmJlxuICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSAhPT0gLTE7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNXZWJWaWV3QW5kcm9pZDtcbiAgfTtcbn0pKCk7XG5cblV0aWwuaXNTYWZhcmkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNTYWZhcmk7XG4gIH07XG59KSgpO1xuXG5VdGlsLmlzRmlyZWZveEFuZHJvaWQgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBpc0ZpcmVmb3hBbmRyb2lkID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgIT09IC0xICYmXG4gICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0FuZHJvaWQnKSAhPT0gLTE7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNGaXJlZm94QW5kcm9pZDtcbiAgfTtcbn0pKCk7XG5cblV0aWwuaXNSNyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGlzUjcgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1I3IEJ1aWxkJykgIT09IC0xO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzUjc7XG4gIH07XG59KSgpO1xuXG5VdGlsLmlzTGFuZHNjYXBlTW9kZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnRuID0gKHdpbmRvdy5vcmllbnRhdGlvbiA9PSA5MCB8fCB3aW5kb3cub3JpZW50YXRpb24gPT0gLTkwKTtcbiAgcmV0dXJuIFV0aWwuaXNSNygpID8gIXJ0biA6IHJ0bjtcbn07XG5cbi8vIEhlbHBlciBtZXRob2QgdG8gdmFsaWRhdGUgdGhlIHRpbWUgc3RlcHMgb2Ygc2Vuc29yIHRpbWVzdGFtcHMuXG5VdGlsLmlzVGltZXN0YW1wRGVsdGFWYWxpZCA9IGZ1bmN0aW9uKHRpbWVzdGFtcERlbHRhUykge1xuICBpZiAoaXNOYU4odGltZXN0YW1wRGVsdGFTKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGltZXN0YW1wRGVsdGFTIDw9IFV0aWwuTUlOX1RJTUVTVEVQKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aW1lc3RhbXBEZWx0YVMgPiBVdGlsLk1BWF9USU1FU1RFUCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblV0aWwuZ2V0U2NyZWVuV2lkdGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGgubWF4KHdpbmRvdy5zY3JlZW4ud2lkdGgsIHdpbmRvdy5zY3JlZW4uaGVpZ2h0KSAqXG4gICAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbn07XG5cblV0aWwuZ2V0U2NyZWVuSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBNYXRoLm1pbih3aW5kb3cuc2NyZWVuLndpZHRoLCB3aW5kb3cuc2NyZWVuLmhlaWdodCkgKlxuICAgICAgd2luZG93LmRldmljZVBpeGVsUmF0aW87XG59O1xuXG5VdGlsLnJlcXVlc3RGdWxsc2NyZWVuID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICBpZiAoVXRpbC5pc1dlYlZpZXdBbmRyb2lkKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgIGVsZW1lbnQucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgfSBlbHNlIGlmIChlbGVtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgZWxlbWVudC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICB9IGVsc2UgaWYgKGVsZW1lbnQubW96UmVxdWVzdEZ1bGxTY3JlZW4pIHtcbiAgICBlbGVtZW50Lm1velJlcXVlc3RGdWxsU2NyZWVuKCk7XG4gIH0gZWxzZSBpZiAoZWxlbWVudC5tc1JlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgZWxlbWVudC5tc1JlcXVlc3RGdWxsc2NyZWVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5VdGlsLmV4aXRGdWxsc2NyZWVuID0gZnVuY3Rpb24oKSB7XG4gIGlmIChkb2N1bWVudC5leGl0RnVsbHNjcmVlbikge1xuICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk7XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4pIHtcbiAgICBkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbigpO1xuICB9IGVsc2UgaWYgKGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4pIHtcbiAgICBkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKCk7XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbikge1xuICAgIGRvY3VtZW50Lm1zRXhpdEZ1bGxzY3JlZW4oKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblV0aWwuZ2V0RnVsbHNjcmVlbkVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudCB8fFxuICAgICAgZG9jdW1lbnQubW96RnVsbFNjcmVlbkVsZW1lbnQgfHxcbiAgICAgIGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVsZW1lbnQ7XG59O1xuXG5VdGlsLmxpbmtQcm9ncmFtID0gZnVuY3Rpb24oZ2wsIHZlcnRleFNvdXJjZSwgZnJhZ21lbnRTb3VyY2UsIGF0dHJpYkxvY2F0aW9uTWFwKSB7XG4gIC8vIE5vIGVycm9yIGNoZWNraW5nIGZvciBicmV2aXR5LlxuICB2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xuICBnbC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCB2ZXJ0ZXhTb3VyY2UpO1xuICBnbC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlcik7XG5cbiAgdmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gIGdsLnNoYWRlclNvdXJjZShmcmFnbWVudFNoYWRlciwgZnJhZ21lbnRTb3VyY2UpO1xuICBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcblxuICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG5cbiAgZm9yICh2YXIgYXR0cmliTmFtZSBpbiBhdHRyaWJMb2NhdGlvbk1hcClcbiAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0cmliTG9jYXRpb25NYXBbYXR0cmliTmFtZV0sIGF0dHJpYk5hbWUpO1xuXG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuXG4gIHJldHVybiBwcm9ncmFtO1xufTtcblxuVXRpbC5nZXRQcm9ncmFtVW5pZm9ybXMgPSBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICB2YXIgdW5pZm9ybXMgPSB7fTtcbiAgdmFyIHVuaWZvcm1Db3VudCA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TKTtcbiAgdmFyIHVuaWZvcm1OYW1lID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdW5pZm9ybUNvdW50OyBpKyspIHtcbiAgICB2YXIgdW5pZm9ybUluZm8gPSBnbC5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGkpO1xuICAgIHVuaWZvcm1OYW1lID0gdW5pZm9ybUluZm8ubmFtZS5yZXBsYWNlKCdbMF0nLCAnJyk7XG4gICAgdW5pZm9ybXNbdW5pZm9ybU5hbWVdID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbiAgfVxuICByZXR1cm4gdW5pZm9ybXM7XG59O1xuXG5VdGlsLm9ydGhvTWF0cml4ID0gZnVuY3Rpb24gKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpLFxuICAgICAgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCksXG4gICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IC0yICogbHI7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IC0yICogYnQ7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAyICogbmY7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5VdGlsLmNvcHlBcnJheSA9IGZ1bmN0aW9uIChzb3VyY2UsIGRlc3QpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBzb3VyY2UubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgZGVzdFtpXSA9IHNvdXJjZVtpXTtcbiAgfVxufTtcblxuVXRpbC5pc01vYmlsZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2hlY2sgPSBmYWxzZTtcbiAgKGZ1bmN0aW9uKGEpe2lmKC8oYW5kcm9pZHxiYlxcZCt8bWVlZ28pLittb2JpbGV8YXZhbnRnb3xiYWRhXFwvfGJsYWNrYmVycnl8YmxhemVyfGNvbXBhbHxlbGFpbmV8ZmVubmVjfGhpcHRvcHxpZW1vYmlsZXxpcChob25lfG9kKXxpcmlzfGtpbmRsZXxsZ2UgfG1hZW1vfG1pZHB8bW1wfG1vYmlsZS4rZmlyZWZveHxuZXRmcm9udHxvcGVyYSBtKG9ifGluKWl8cGFsbSggb3MpP3xwaG9uZXxwKGl4aXxyZSlcXC98cGx1Y2tlcnxwb2NrZXR8cHNwfHNlcmllcyg0fDYpMHxzeW1iaWFufHRyZW98dXBcXC4oYnJvd3NlcnxsaW5rKXx2b2RhZm9uZXx3YXB8d2luZG93cyBjZXx4ZGF8eGlpbm8vaS50ZXN0KGEpfHwvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298c1xcLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXxcXC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YndcXC0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbVxcLXxjZWxsfGNodG18Y2xkY3xjbWRcXC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGNcXC1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfFxcLWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseShcXC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2ZcXC01fGdcXC1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkXFwtKG18cHx0KXxoZWlcXC18aGkocHR8dGEpfGhwKCBpfGlwKXxoc1xcLWN8aHQoYyhcXC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpXFwtKDIwfGdvfG1hKXxpMjMwfGlhYyggfFxcLXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djXFwtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fFxcLVthLXddKXxsaWJ3fGx5bnh8bTFcXC13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bVxcLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KFxcLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pXFwtfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3xcXC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG5cXC0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHRcXC1nfHFhXFwtYXxxYygwN3wxMnwyMXwzMnw2MHxcXC1bMi03XXxpXFwtKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aFxcLXxvb3xwXFwtKXxzZGtcXC98c2UoYyhcXC18MHwxKXw0N3xtY3xuZHxyaSl8c2doXFwtfHNoYXJ8c2llKFxcLXxtKXxza1xcLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aFxcLXx2XFwtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsXFwtfHRkZ1xcLXx0ZWwoaXxtKXx0aW1cXC18dFxcLW1vfHRvKHBsfHNoKXx0cyg3MHxtXFwtfG0zfG01KXx0eFxcLTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfFxcLXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoXFwtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzXFwtfHlvdXJ8emV0b3x6dGVcXC0vaS50ZXN0KGEuc3Vic3RyKDAsNCkpKWNoZWNrID0gdHJ1ZX0pKG5hdmlnYXRvci51c2VyQWdlbnR8fG5hdmlnYXRvci52ZW5kb3J8fHdpbmRvdy5vcGVyYSk7XG4gIHJldHVybiBjaGVjaztcbn07XG5cblV0aWwuZXh0ZW5kID0gZnVuY3Rpb24oZGVzdCwgc3JjKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGRlc3Rba2V5XSA9IHNyY1trZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufVxuXG5VdGlsLnNhZmFyaUNzc1NpemVXb3JrYXJvdW5kID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gIC8vIFRPRE8oc211cyk6IFJlbW92ZSB0aGlzIHdvcmthcm91bmQgd2hlbiBTYWZhcmkgZm9yIGlPUyBpcyBmaXhlZC5cbiAgLy8gaU9TIG9ubHkgd29ya2Fyb3VuZCAoZm9yIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTI1NTYpLlxuICAvL1xuICAvLyBcIlRvIHRoZSBsYXN0IEkgZ3JhcHBsZSB3aXRoIHRoZWU7XG4gIC8vICBmcm9tIGhlbGwncyBoZWFydCBJIHN0YWIgYXQgdGhlZTtcbiAgLy8gIGZvciBoYXRlJ3Mgc2FrZSBJIHNwaXQgbXkgbGFzdCBicmVhdGggYXQgdGhlZS5cIlxuICAvLyAtLSBNb2J5IERpY2ssIGJ5IEhlcm1hbiBNZWx2aWxsZVxuICBpZiAoVXRpbC5pc0lPUygpKSB7XG4gICAgdmFyIHdpZHRoID0gY2FudmFzLnN0eWxlLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBjYW52YXMuc3R5bGUuaGVpZ2h0O1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IChwYXJzZUludCh3aWR0aCkgKyAxKSArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IChwYXJzZUludChoZWlnaHQpKSArICdweCc7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICB9LCAxMDApO1xuICB9XG5cbiAgLy8gRGVidWcgb25seS5cbiAgd2luZG93LlV0aWwgPSBVdGlsO1xuICB3aW5kb3cuY2FudmFzID0gY2FudmFzO1xufTtcblxuVXRpbC5pc0RlYnVnID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBVdGlsLmdldFF1ZXJ5UGFyYW1ldGVyKCdkZWJ1ZycpO1xufTtcblxuVXRpbC5nZXRRdWVyeVBhcmFtZXRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tcXFtdLywgXCJcXFxcW1wiKS5yZXBsYWNlKC9bXFxdXS8sIFwiXFxcXF1cIik7XG4gIHZhciByZWdleCA9IG5ldyBSZWdFeHAoXCJbXFxcXD8mXVwiICsgbmFtZSArIFwiPShbXiYjXSopXCIpLFxuICAgICAgcmVzdWx0cyA9IHJlZ2V4LmV4ZWMobG9jYXRpb24uc2VhcmNoKTtcbiAgcmV0dXJuIHJlc3VsdHMgPT09IG51bGwgPyBcIlwiIDogZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdHNbMV0ucmVwbGFjZSgvXFwrL2csIFwiIFwiKSk7XG59O1xuXG5VdGlsLmZyYW1lRGF0YUZyb21Qb3NlID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgcGlPdmVyMTgwID0gTWF0aC5QSSAvIDE4MC4wO1xuICB2YXIgcmFkNDUgPSBNYXRoLlBJICogMC4yNTtcblxuICAvLyBCb3Jyb3dlZCBmcm9tIGdsTWF0cml4LlxuICBmdW5jdGlvbiBtYXQ0X3BlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgdXBUYW4gPSBNYXRoLnRhbihmb3YgPyAoZm92LnVwRGVncmVlcyAqIHBpT3ZlcjE4MCkgOiByYWQ0NSksXG4gICAgZG93blRhbiA9IE1hdGgudGFuKGZvdiA/IChmb3YuZG93bkRlZ3JlZXMgKiBwaU92ZXIxODApIDogcmFkNDUpLFxuICAgIGxlZnRUYW4gPSBNYXRoLnRhbihmb3YgPyAoZm92LmxlZnREZWdyZWVzICogcGlPdmVyMTgwKSA6IHJhZDQ1KSxcbiAgICByaWdodFRhbiA9IE1hdGgudGFuKGZvdiA/IChmb3YucmlnaHREZWdyZWVzICogcGlPdmVyMTgwKSA6IHJhZDQ1KSxcbiAgICB4U2NhbGUgPSAyLjAgLyAobGVmdFRhbiArIHJpZ2h0VGFuKSxcbiAgICB5U2NhbGUgPSAyLjAgLyAodXBUYW4gKyBkb3duVGFuKTtcblxuICAgIG91dFswXSA9IHhTY2FsZTtcbiAgICBvdXRbMV0gPSAwLjA7XG4gICAgb3V0WzJdID0gMC4wO1xuICAgIG91dFszXSA9IDAuMDtcbiAgICBvdXRbNF0gPSAwLjA7XG4gICAgb3V0WzVdID0geVNjYWxlO1xuICAgIG91dFs2XSA9IDAuMDtcbiAgICBvdXRbN10gPSAwLjA7XG4gICAgb3V0WzhdID0gLSgobGVmdFRhbiAtIHJpZ2h0VGFuKSAqIHhTY2FsZSAqIDAuNSk7XG4gICAgb3V0WzldID0gKCh1cFRhbiAtIGRvd25UYW4pICogeVNjYWxlICogMC41KTtcbiAgICBvdXRbMTBdID0gZmFyIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxMV0gPSAtMS4wO1xuICAgIG91dFsxMl0gPSAwLjA7XG4gICAgb3V0WzEzXSA9IDAuMDtcbiAgICBvdXRbMTRdID0gKGZhciAqIG5lYXIpIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxNV0gPSAwLjA7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdDRfZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBxLCB2KSB7XG4gICAgLy8gUXVhdGVybmlvbiBtYXRoXG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB4eSA9IHggKiB5MixcbiAgICAgICAgeHogPSB4ICogejIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB5eiA9IHkgKiB6MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICAgIG91dFsxXSA9IHh5ICsgd3o7XG4gICAgb3V0WzJdID0geHogLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHh5IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgICBvdXRbNl0gPSB5eiArIHd4O1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geHogKyB3eTtcbiAgICBvdXRbOV0gPSB5eiAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSB2WzBdO1xuICAgIG91dFsxM10gPSB2WzFdO1xuICAgIG91dFsxNF0gPSB2WzJdO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICBmdW5jdGlvbiBtYXQ0X3RyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXSxcbiAgICAgICAgYTAwLCBhMDEsIGEwMiwgYTAzLFxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXG4gICAgICAgIGEyMCwgYTIxLCBhMjIsIGEyMztcblxuICAgIGlmIChhID09PSBvdXQpIHtcbiAgICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICAgIG91dFsxNF0gPSBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF07XG4gICAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgICAgb3V0WzBdID0gYTAwOyBvdXRbMV0gPSBhMDE7IG91dFsyXSA9IGEwMjsgb3V0WzNdID0gYTAzO1xuICAgICAgb3V0WzRdID0gYTEwOyBvdXRbNV0gPSBhMTE7IG91dFs2XSA9IGExMjsgb3V0WzddID0gYTEzO1xuICAgICAgb3V0WzhdID0gYTIwOyBvdXRbOV0gPSBhMjE7IG91dFsxMF0gPSBhMjI7IG91dFsxMV0gPSBhMjM7XG5cbiAgICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICAgIG91dFsxM10gPSBhMDEgKiB4ICsgYTExICogeSArIGEyMSAqIHogKyBhWzEzXTtcbiAgICAgIG91dFsxNF0gPSBhMDIgKiB4ICsgYTEyICogeSArIGEyMiAqIHogKyBhWzE0XTtcbiAgICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1hdDRfaW52ZXJ0KG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgICBpZiAoIWRldCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICAgIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICAgIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICAgIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICAgIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICB2YXIgZGVmYXVsdE9yaWVudGF0aW9uID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMV0pO1xuICB2YXIgZGVmYXVsdFBvc2l0aW9uID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMF0pO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZUV5ZU1hdHJpY2VzKHByb2plY3Rpb24sIHZpZXcsIHBvc2UsIHBhcmFtZXRlcnMsIHZyRGlzcGxheSkge1xuICAgIG1hdDRfcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcocHJvamVjdGlvbiwgcGFyYW1ldGVycyA/IHBhcmFtZXRlcnMuZmllbGRPZlZpZXcgOiBudWxsLCB2ckRpc3BsYXkuZGVwdGhOZWFyLCB2ckRpc3BsYXkuZGVwdGhGYXIpO1xuXG4gICAgdmFyIG9yaWVudGF0aW9uID0gcG9zZS5vcmllbnRhdGlvbiB8fCBkZWZhdWx0T3JpZW50YXRpb247XG4gICAgdmFyIHBvc2l0aW9uID0gcG9zZS5wb3NpdGlvbiB8fCBkZWZhdWx0UG9zaXRpb247XG5cbiAgICBtYXQ0X2Zyb21Sb3RhdGlvblRyYW5zbGF0aW9uKHZpZXcsIG9yaWVudGF0aW9uLCBwb3NpdGlvbik7XG4gICAgaWYgKHBhcmFtZXRlcnMpXG4gICAgICBtYXQ0X3RyYW5zbGF0ZSh2aWV3LCB2aWV3LCBwYXJhbWV0ZXJzLm9mZnNldCk7XG4gICAgbWF0NF9pbnZlcnQodmlldywgdmlldyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oZnJhbWVEYXRhLCBwb3NlLCB2ckRpc3BsYXkpIHtcbiAgICBpZiAoIWZyYW1lRGF0YSB8fCAhcG9zZSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGZyYW1lRGF0YS5wb3NlID0gcG9zZTtcbiAgICBmcmFtZURhdGEudGltZXN0YW1wID0gcG9zZS50aW1lc3RhbXA7XG5cbiAgICB1cGRhdGVFeWVNYXRyaWNlcyhcbiAgICAgICAgZnJhbWVEYXRhLmxlZnRQcm9qZWN0aW9uTWF0cml4LCBmcmFtZURhdGEubGVmdFZpZXdNYXRyaXgsXG4gICAgICAgIHBvc2UsIHZyRGlzcGxheS5nZXRFeWVQYXJhbWV0ZXJzKFwibGVmdFwiKSwgdnJEaXNwbGF5KTtcbiAgICB1cGRhdGVFeWVNYXRyaWNlcyhcbiAgICAgICAgZnJhbWVEYXRhLnJpZ2h0UHJvamVjdGlvbk1hdHJpeCwgZnJhbWVEYXRhLnJpZ2h0Vmlld01hdHJpeCxcbiAgICAgICAgcG9zZSwgdnJEaXNwbGF5LmdldEV5ZVBhcmFtZXRlcnMoXCJyaWdodFwiKSwgdnJEaXNwbGF5KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufSkoKTtcblxuVXRpbC5pc0luc2lkZUNyb3NzRG9tYWluSUZyYW1lID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpc0ZyYW1lZCA9ICh3aW5kb3cuc2VsZiAhPT0gd2luZG93LnRvcCk7XG4gIHZhciByZWZEb21haW4gPSBVdGlsLmdldERvbWFpbkZyb21VcmwoZG9jdW1lbnQucmVmZXJyZXIpO1xuICB2YXIgdGhpc0RvbWFpbiA9IFV0aWwuZ2V0RG9tYWluRnJvbVVybCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgcmV0dXJuIGlzRnJhbWVkICYmIChyZWZEb21haW4gIT09IHRoaXNEb21haW4pO1xufTtcblxuLy8gRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMzk0NTAyNy5cblV0aWwuZ2V0RG9tYWluRnJvbVVybCA9IGZ1bmN0aW9uKHVybCkge1xuICB2YXIgZG9tYWluO1xuICAvLyBGaW5kICYgcmVtb3ZlIHByb3RvY29sIChodHRwLCBmdHAsIGV0Yy4pIGFuZCBnZXQgZG9tYWluLlxuICBpZiAodXJsLmluZGV4T2YoXCI6Ly9cIikgPiAtMSkge1xuICAgIGRvbWFpbiA9IHVybC5zcGxpdCgnLycpWzJdO1xuICB9XG4gIGVsc2Uge1xuICAgIGRvbWFpbiA9IHVybC5zcGxpdCgnLycpWzBdO1xuICB9XG5cbiAgLy9maW5kICYgcmVtb3ZlIHBvcnQgbnVtYmVyXG4gIGRvbWFpbiA9IGRvbWFpbi5zcGxpdCgnOicpWzBdO1xuXG4gIHJldHVybiBkb21haW47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVXRpbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi93ZWJ2ci1wb2x5ZmlsbC9zcmMvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzExX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcIkBlZ2pzL2F4ZXNcIixcImNvbW1vbmpzMlwiOlwiQGVnanMvYXhlc1wiLFwiYW1kXCI6XCJAZWdqcy9heGVzXCIsXCJyb290XCI6W1wiZWdcIixcIkF4ZXNcIl19XG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJlciB7XG5cdC8vIERlZmluZSBpbnRlcmZhY2UgZm9yIFJlbmRlcmVyc1xuXHQvKipcblx0ICogRm9sbG93aW5nIE1VU1QgQkUgREVGSU5FRCBvbiBDaGlsZCBvZiBSZW5kZXJlclxuXHQgKlxuXHQgKiBEQVRBXG5cdCAqXG5cdCAqICAtIGdldFZlcnRleFBvc2l0aW9uRGF0YVxuXHQgKiAgLSBnZXRJbmRleERhdGFcblx0ICogIC0gZ2V0VGV4dHVyZUNvb3JkRGF0YVxuXHQgKlxuXHQgKiBTT1VSQ0Vcblx0ICpcblx0ICogIC0gZ2V0VmVydGV4U2hhZGVyU291cmNlXG5cdCAqICAtIGdldEZyYWdtZW50U2hhZGVyU291cmNlXG5cdCAqXG5cdCAqIFRFWFRVUkVcblx0ICpcblx0ICogIC0gYmluZFRleHR1cmVcblx0ICovXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvUGFub0ltYWdlUmVuZGVyZXIvcmVuZGVyZXIvUmVuZGVyZXIuanMiLCIvKipcbiAqIENvbnN0YW50IHZhbHVlIGZvciBneXJvIG1vZGUuIDxicj4oUmVmZXJlbmNlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy12aWV3MzYwL3dpa2kvUGFub1ZpZXdlci0zLjAtVXNlci1HdWlkZX0pXG4gKiBAa28gZ3lybyDrqqjrk5wg64yA7ZWcIOyDgeyImCDqsJIuIDxicj4oe0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLXZpZXczNjAvd2lraS9QYW5vVmlld2VyLTMuMC1Vc2VyLUd1aWRlfSDssLjqs6ApXG4gKiBAbmFtZXNwYWNlXG4gKiBAbmFtZSBHWVJPX01PREVcbiAqIEBtZW1iZXJvZiBlZy52aWV3MzYwLlBhbm9WaWV3ZXJcbiAqL1xuLyoqXG4gKiBEaXNhYmxlIGd5cm9cbiAqIEBrbyBneXJvIOu5hO2ZnOyEse2ZlFxuICogQG5hbWUgTk9ORVxuICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlci5HWVJPX01PREVcbiAqIEBjb25zdGFudFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0IFwibm9uZVwiXG4gKi9cbi8qKlxuICogWWF3UGl0Y2ggTW9kZVxuICogQGtvIFlhd1BpdGNoIE1vZGVcbiAqIEBuYW1lIFlBV1BJVENIXG4gKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyLkdZUk9fTU9ERVxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgXCJ5YXdQaXRjaFwiXG4gKi9cbi8qKlxuICogVlIgTW9kZVxuICogQGtvIFZSIE1vZGVcbiAqIEBuYW1lIFZSXG4gKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyLkdZUk9fTU9ERVxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgXCJWUlwiXG4gKi9cbmltcG9ydCB7R1lST19NT0RFfSBmcm9tIFwiLi4vWWF3UGl0Y2hDb250cm9sL2NvbnN0c1wiO1xuXG4vKipcbiAqIENvbnN0YW50IHZhbHVlIGZvciBlcnJvcnNcbiAqIEBrbyDsl5Drn6zsl5Ag64yA7ZWcIOyDgeyImCDqsJJcbiAqIEBuYW1lc3BhY2VcbiAqIEBuYW1lIEVSUk9SX1RZUEVcbiAqIEBtZW1iZXJvZiBlZy52aWV3MzYwLlBhbm9WaWV3ZXJcbiAqL1xuY29uc3QgRVJST1JfVFlQRSA9IHtcblx0LyoqXG5cdCAqIFVuc3VwcG9ydGVkIGRldmljZVxuXHQgKiBAa28g66+47KeA7JuQIOq4sOq4sFxuXHQgKiBAbmFtZSBJTlZBTElEX0RFVklDRVxuXHQgKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyLkVSUk9SX1RZUEVcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDEwXG5cdCAqL1xuXHRJTlZBTElEX0RFVklDRTogMTAsXG5cdC8qKlxuXHQgKiBXZWJnbCBub3Qgc3VwcG9ydFxuXHQgKiBAa28gV0VCR0wg66+47KeA7JuQXG5cdCAqIEBuYW1lIE5PX1dFQkdMXG5cdCAqIEBtZW1iZXJvZiBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuRVJST1JfVFlQRVxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgMTFcblx0ICovXG5cdE5PX1dFQkdMOiAxMSxcblx0LyoqXG5cdCAqIEZhaWxlZCB0byBsb2FkIGltYWdlXG5cdCAqIEBrbyDsnbTrr7jsp4Ag66Gc65OcIOyLpO2MqFxuXHQgKiBAbmFtZSBGQUlMX0lNQUdFX0xPQURcblx0ICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlci5FUlJPUl9UWVBFXG5cdCAqIEBjb25zdGFudFxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAxMlxuXHQgKi9cblx0RkFJTF9JTUFHRV9MT0FEOiAxMixcblx0LyoqXG5cdCAqIEZhaWxlZCB0byBiaW5kIHRleHR1cmVcblx0ICogQGtvIO2FjeyKpOyzkCDrsJTsnbjrlKkg7Iuk7YyoXG5cdCAqIEBuYW1lIEZBSUxfQklORF9URVhUVVJFXG5cdCAqIEBtZW1iZXJvZiBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuRVJST1JfVFlQRVxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgMTNcblx0ICovXG5cdEZBSUxfQklORF9URVhUVVJFOiAxMyxcblx0LyoqXG5cdCAqIE9ubHkgb25lIHJlc291cmNlKGltYWdlIG9yIHZpZGVvKSBzaG91bGQgYmUgc3BlY2lmaWVkXG5cdCAqIEBrbyDrpqzshozsiqQg7KeA7KCVIOyYpOulmCAoaW1hZ2Ug7Zi57J2AIHZpZGVvIOykkSDtlZjrgpjrp4wg7KeA7KCV65CY7Ja07JW8IO2VqClcblx0ICogQG5hbWUgSU5WQUxJRF9SRVNPVVJDRVxuXHQgKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyLkVSUk9SX1RZUEVcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDE0XG5cdCAqL1xuXHRJTlZBTElEX1JFU09VUkNFOiAxNCxcblx0LyoqXG5cdCAqIFdlYkdMIGNvbnRleHQgbG9zdCBvY2N1cnJlZFxuXHQgKiBAa28gV2ViR0wgY29udGV4dCBsb3N0IOuwnOyDnVxuXHQgKiBAbmFtZSBSRU5ERVJJTkdfQ09OVEVYVF9MT1NUXG5cdCAqIEBtZW1iZXJvZiBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuRVJST1JfVFlQRVxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgMTVcblx0ICovXG5cdFJFTkRFUklOR19DT05URVhUX0xPU1Q6IDE1XG59O1xuXG4vKipcbiAqIENvbnN0YW50IHZhbHVlIGZvciBldmVudHNcbiAqIEBrbyDsnbTrsqTtirjsl5Ag64yA7ZWcIOyDgeyImCDqsJJcbiAqIEBuYW1lc3BhY2VcbiAqIEBuYW1lIEVWRU5UU1xuICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlclxuICovXG5jb25zdCBFVkVOVFMgPSB7XG5cdC8qKlxuXHQgKiBFdmVudHMgdGhhdCBpcyBmaXJlZCB3aGVuIFBhbm9WaWV3ZXIgaXMgcmVhZHkgdG8gc2hvdyBpbWFnZSBhbmQgaGFuZGxlIHVzZXIgaW50ZXJhY3Rpb24uXG5cdCAqIEBrbyBQYW5vVmlld2VyIOqwgCDsgqzsmqnsnpDsnZgg7J247YSw66CJ7IWYIOuwjyDroIzrjZTrp4HsnbQg7KSA67mE65CY7IOB7YOc7JeQIOuwnOyDne2VmOuKlCDsnbTrsqTtirhcblx0ICogQG5hbWUgUkVBRFlcblx0ICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlci5FVkVOVFNcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHJlYWR5XG5cdCAqL1xuXHRSRUFEWTogXCJyZWFkeVwiLFxuXHQvKipcblx0ICogRXZlbnRzIHRoYXQgaXMgZmlyZWQgd2hlbiBkaXJlY3Rpb24gb3IgZm92IGlzIGNoYW5nZWQuXG5cdCAqIEBrbyBQYW5vVmlld2VyIOyXkOyEnCDrsJTrnbzrs7Tqs6Ag7J6I64qUIOuwqe2WpeydtOuCmCBGT1Yo7ZmU6rCBKeqwgCDrs4Dqsr3rkJjsl4jsnYTrlYwg67Cc7IOd7ZWY64qUIOydtOuypO2KuFxuXHQgKiBAbmFtZSBWSUVXX0NIQU5HRVxuXHQgKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyLkVWRU5UU1xuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgdmlld0NoYW5nZVxuXHQgKi9cblx0VklFV19DSEFOR0U6IFwidmlld0NoYW5nZVwiLFxuXHQvKipcblx0ICogRXZlbnRzIHRoYXQgaXMgZmlyZWQgd2hlbiBhbmltYXRpb24gd2hpY2ggaXMgdHJpZ2dlcmVkIGJ5IGluZXJ0aWEgaXMgZW5kZWQuXG5cdCAqIEBrbyDqtIDshLHsl5Ag7J2Y7ZWcIOyVoOuLiOuplOydtOyFmCDrj5nsnpHsnbQg7JmE66OM65CY7JeI7J2E65WMIOuwnOyDne2VmOuKlCDsnbTrsqTtirhcblx0ICogQG5hbWUgQU5JTUFUSU9OX0VORFxuXHQgKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyLkVWRU5UU1xuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgYW5pbWF0aW9uRW5kXG5cdCAqL1xuXHRBTklNQVRJT05fRU5EOiBcImFuaW1hdGlvbkVuZFwiLFxuXHQvKipcblx0ICogRXZlbnRzIHRoYXQgaXMgZmlyZWQgd2hlbiBlcnJvciBvY2N1cnNcblx0ICogQGtvIOyXkOufrCDrsJzsg50g7IucIOuwnOyDne2VmOuKlCDsnbTrsqTtirhcblx0ICogQG5hbWUgRVJST1Jcblx0ICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlci5FVkVOVFNcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGVycm9yXG5cdCAqL1xuXHRFUlJPUjogXCJlcnJvclwiXG59O1xuXG4vKipcbiAqIENvbnN0YW50IHZhbHVlIGZvciBwcm9qZWN0aW9uIHR5cGVcbiAqIEBrbyDtlITroZzsoJ3shZgg7YOA7J6FIOuMgO2VnCDsg4HsiJgg6rCSXG4gKiBAbmFtZXNwYWNlXG4gKiBAbmFtZSBQUk9KRUNUSU9OX1RZUEVcbiAqIEBtZW1iZXJvZiBlZy52aWV3MzYwLlBhbm9WaWV3ZXJcbiAqL1xuY29uc3QgUFJPSkVDVElPTl9UWVBFID0ge1xuXHQvKipcblx0ICogQ29uc3RhbnQgdmFsdWUgZm9yIGVxdWlyZWN0YW5ndWxhciB0eXBlLlxuXHQgKiBAa28gZXF1aXJlY3Rhbmd1bGFyIOyXkCDrjIDtlZwg7IOB7IiYIOqwki5cblx0ICogQG5hbWUgRVFVSVJFQ1RBTkdVTEFSXG5cdCAqIEBtZW1iZXJvZiBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuUFJPSkVDVElPTl9UWVBFXG5cdCAqIEBjb25zdGFudFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBlcXVpcmVjdGFuZ3VsYXJcblx0ICovXG5cdEVRVUlSRUNUQU5HVUxBUjogXCJlcXVpcmVjdGFuZ3VsYXJcIixcblx0LyoqXG5cdCAqIENvbnN0YW50IHZhbHVlIGZvciBjdWJlbWFwIHR5cGUuXG5cdCAqIEBrbyBjdWJlbWFwIOyXkCDrjIDtlZwg7IOB7IiYIOqwki5cblx0ICogQG5hbWUgQ1VCRU1BUFxuXHQgKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyLlBST0pFQ1RJT05fVFlQRVxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgY3ViZW1hcFxuXHQgKi9cblx0Q1VCRU1BUDogXCJjdWJlbWFwXCJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRHWVJPX01PREUsXG5cdEVWRU5UUyxcblx0RVJST1JfVFlQRSxcblx0UFJPSkVDVElPTl9UWVBFXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1Bhbm9WaWV3ZXIvY29uc3RzLmpzIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG5cbi8qKlxuICogQGNsYXNzIGVnLnZpZXczNjAuU3ByaXRlSW1hZ2VcbiAqIEBjbGFzc2Rlc2MgQSBtb2R1bGUgdGhhdCBkaXNwbGF5cyBhIHNpbmdsZSBvciBjb250aW51b3VzIGltYWdlIG9mIGFueSBvbmUgb2YgdGhlIFwic3ByaXRlIGltYWdlc1wiLiBTcGluVmlld2VyIGludGVybmFsbHkgdXNlcyBTcHJpdGVJbWFnZSB0byBzaG93IGVhY2ggZnJhbWUgb2YgdGhlIHNwcml0ZSBpbWFnZS5cbiAqIEBrbyDsiqTtlITrnbzsnbTtirgg7J2066+47KeAIOykkSDsnoTsnZjsnZgg7ZWcIO2UhOugiOyehOydhCDri6jrsJzshLEg7Zi57J2AIOyXsOyGjeyggeycvOuhnCDrs7Tsl6zso7zripQg7Lu07Y+s64SM7Yq47J6F64uI64ukLiBTcGluVmlld2VyIOuKlCDrgrTrtoDsoIHsnLzroZwgU3ByaXRlSW1hZ2Ug66W8IOyCrOyaqe2VmOyXrCDsiqTtlITrnbzsnbTtirgg7J2066+47KeA7J2YIOqwgSDtlITroIjsnoTsnYQg67O07Jes7KSN64uI64ukLlxuICogQGV4dGVuZHMgZWcuQ29tcG9uZW50XG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBzaG93IHRoZSBpbWFnZSA8a28+7J2066+47KeA66W8IOuztOyXrOykhCDrjIDsg4Eg7JqU7IaMPC9rbz5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb24gb2JqZWN0PGtvPu2MjOudvOuvuO2EsCDqsJ3ssrQ8L2tvPlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuaW1hZ2VVcmwgVGhlIHVybCBvZiB0aGUgc3ByaXRlIGltYWdlIDxrbz7siqTtlITrnbzsnbTtirgg7J2066+47KeA7J2YIHVybDwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucm93Q291bnQ9MV0gTnVtYmVyIG9mIGhvcml6b250YWwgZnJhbWVzIGluIHRoZSBzcHJpdGUgaW1hZ2UgPGtvPuyKpO2UhOudvOydtO2KuCDsnbTrr7jsp4DsnZgg6rCA66GcIO2UhOugiOyehCDqsK/siJg8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbENvdW50PTFdIE51bWJlciBvZiB2ZXJ0aWNhbCBmcmFtZXMgaW4gdGhlIHNwcml0ZSBpbWFnZSA8a28+7Iqk7ZSE65287J207Yq4IOydtOuvuOyngOydmCDshLjroZwg7ZSE66CI7J6EIOqwr+yImDwva28+XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtvcHRpb25zLndpZHRoPVwiYXV0b1wiXSBUaGUgd2lkdGggb2YgdGhlIHRhcmdldCBlbGVtZW50IHRvIHNob3cgdGhlIGltYWdlIDxrbz7snbTrr7jsp4Drpbwg67O07Jes7KSEIOuMgOyDgSDsmpTshozsnZgg64SI67mEPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW29wdGlvbnMuaGVpZ2h0PVwiYXV0b1wiXSBUaGUgaGVpZ2h0IG9mIHRoZSB0YXJnZXQgZWxlbWVudCB0byBzaG93IHRoZSBpbWFnZSA8a28+7J2066+47KeA66W8IOuztOyXrOykhCDrjIDsg4Eg7JqU7IaM7J2YIOuGkuydtDwva28+XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9IZWlnaHQ9dHJ1ZV0gV2hldGhlciB0byBhdXRvbWF0aWNhbGx5IHNldCB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZSBhcmVhIHRvIG1hdGNoIHRoZSBvcmlnaW5hbCBpbWFnZSdzIHByb3BvcnRpb24gPGtvPuybkOuzuCDsnbTrr7jsp4Ag67mE7Jyo7JeQIOunnuqyjCDsnbTrr7jsp4Ag7JiB7Jet7J2YIOuGkuydtOulvCDsnpDrj5nsnLzroZwg7ISk7KCV7ZWg7KeAIOyXrOu2gDwva28+XG4gKiBAcGFyYW0ge051bWJlcltdfSBbb3B0aW9ucy5jb2xSb3c9WzAsIDBdXSBUaGUgY29sdW1uLCByb3cgY29vcmRpbmF0ZXMgb2YgdGhlIGZpcnN0IGZyYW1lIG9mIHRoZSBzcHJpdGUgaW1hZ2UgKGJhc2VkIG9uIDAgaW5kZXgpIDxrbz4g7Iqk7ZSE65287J207Yq4IOydtOuvuOyngCDspJEg7LKY7J2MIOuztOyXrOykhCDtlITroIjsnoTsnZggKGNvbHVtbiwgcm93KSDsooztkZwgKDAgaW5kZXgg6riw67CYKTwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJhbWVJbmRleD0wXSBmcmFtZUluZGV4IHNwZWNpZmllcyB0aGUgaW5kZXggb2YgdGhlIGZyYW1lIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgXCJTcHJpdGUgaW1hZ2VcIi4gVGhlIGZyYW1lSW5kZXggb3JkZXIgaXMgemVyby1iYXNlZCBhbmQgaW5kZXhlZCBpbiBaIGZvcm0gKGxlZnQtdG8tcmlnaHQsIHRvcC10by1ib3R0b20sIGFuZCBuZXdsaW5lIGFnYWluIGZyb20gbGVmdCB0byByaWdodCkuPGJyPi0gY29sUm93IGlzIGVxdWl2YWxlbnQgdG8gZnJhbWVJbmRleC4gSG93ZXZlciwgaWYgY29sUm93IGlzIHNwZWNpZmllZCBhdCB0aGUgc2FtZSB0aW1lLCBjb2xSb3cgdGFrZXMgcHJlY2VkZW5jZS48a28+7Iqk7ZSE65287J207Yq4IOydtOuvuOyngCDspJHsl5DshJwg67O07Jes7KeIIO2UhOugiOyehOydmCDsnbjrjbHsiqTrpbwg7KeA7KCV7ZWp64uI64ukLiBmcmFtZUluZGV4IOyInOyEnOuKlCAw67aA7YSwIOyLnOyeke2VmOupsCBaIO2Yle2DnCjsmbzsqr3sl5DshJwg7Jik66W47Kq9LCDsnITsl5DshJwg7JWE656YLCDqsJztlokg7IucIOuLpOyLnCDsmbzsqr0g67aA7YSwKeuhnCDsnbjrjbHsi7Htlanri4jri6QuPGJyPi0gY29sUm93IOuKlCBmcmFtZUluZGV4IOyZgCDrj5nsnbztlZwg6riw64ql7J2EIO2VqeuLiOuLpC4g64uoLCBjb2xSb3cg6rCAIOuPmeyLnOyXkCDsp4DsoJXrkJwg6rK97JqwIGNvbFJvdyDqsIAg7Jqw7ISg7ZWp64uI64ukLjwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2NhbGU9MV0gU3BpbiBzY2FsZSAoVGhlIGxhcmdlciB0aGUgc3BpbiwgdGhlIG1vcmUpLjxrbz5TcGluIOuwsOycqCAo7YG0IOyImOuhnSDrjZQg66eO7J20IOybgOyngeyehCk8L2tvPlxuICpcbiAqIEBzdXBwb3J0IHtcImllXCI6IFwiOStcIiwgXCJjaFwiIDogXCJsYXRlc3RcIiwgXCJmZlwiIDogXCJsYXRlc3RcIiwgIFwic2ZcIiA6IFwibGF0ZXN0XCIsIFwiZWRnZVwiIDogXCJsYXRlc3RcIiwgXCJpb3NcIiA6IFwiNytcIiwgXCJhblwiIDogXCIyLjMrIChleGNlcHQgMy54KVwifVxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBJbml0aWFsaXplIFNwcml0ZUltYWdlXG4gKlxuICogdmFyIGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbWFnZS1kaXZcIik7XG4gKiB2YXIgc3ByaXRlcyA9IG5ldyBlZy52aWV3MzYwLlNwcml0ZUltYWdlKGVsLCB7XG4gKiBcdGltYWdlVXJsOiBcIi9pbWcvYmFnMzYwLmpwZ1wiLCAvLyByZXF1aXJlZFxuICogXHRyb3dDb3VudDogMjRcbiAqIH0pO1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcHJpdGVJbWFnZSBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcblx0XHRzdXBlcigpO1xuXHRcdGNvbnN0IG9wdCA9IG9wdGlvbnMgfHwge307XG5cblx0XHR0aGlzLl9lbCA9IGVsZW1lbnQ7XG5cdFx0dGhpcy5fcm93Q291bnQgPSBvcHQucm93Q291bnQgfHwgMTtcblx0XHR0aGlzLl9jb2xDb3VudCA9IG9wdC5jb2xDb3VudCB8fCAxO1xuXHRcdHRoaXMuX3RvdGFsQ291bnQgPSB0aGlzLl9yb3dDb3VudCAqIHRoaXMuX2NvbENvdW50Oy8vIHRvdGFsIGZyYW1lc1xuXHRcdHRoaXMuX3dpZHRoID0gb3B0LndpZHRoIHx8IFwiYXV0b1wiO1xuXHRcdHRoaXMuX2hlaWdodCA9IG9wdC5oZWlnaHQgfHwgXCJhdXRvXCI7XG5cdFx0dGhpcy5fYXV0b0hlaWdodCA9IG9wdC5hdXRvSGVpZ2h0ICE9IG51bGwgPyBvcHQuYXV0b0hlaWdodCA6IFwidHJ1ZVwiOyAvLyBJZiBhdXRvSGVpZ2h0IGlzIHNwZWNpZmllZCwgX2hlaWdodCB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuXHRcdHRoaXMuX2NvbFJvdyA9IFswLCAwXTtcblxuXHRcdGlmIChvcHQuY29sUm93KSB7XG5cdFx0XHR0aGlzLl9jb2xSb3cgPSBvcHQuY29sUm93O1xuXHRcdH0gZWxzZSBpZiAob3B0LmZyYW1lSW5kZXgpIHtcblx0XHRcdHRoaXMuc2V0RnJhbWVJbmRleChvcHQuZnJhbWVJbmRleCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZWwuc3R5bGUud2lkdGggPSBTcHJpdGVJbWFnZS5fZ2V0U2l6ZVN0cmluZyh0aGlzLl93aWR0aCk7XG5cdFx0dGhpcy5fZWwuc3R5bGUuaGVpZ2h0ID0gU3ByaXRlSW1hZ2UuX2dldFNpemVTdHJpbmcodGhpcy5faGVpZ2h0KTtcblxuXHRcdGlmICghb3B0LmltYWdlVXJsKSB7XG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKFwiaW1hZ2VFcnJvclwiLCB7XG5cdFx0XHRcdFx0aW1hZ2VVcmw6IG9wdC5pbWFnZVVybFxuXHRcdFx0XHR9KTtcblx0XHRcdH0sIDApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2ltYWdlID0gbmV3IEltYWdlKCk7XG5cdFx0LyoqXG5cdFx0ICogRXZlbnRcblx0XHQgKi9cblx0XHR0aGlzLl9pbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG5cdFx0XHR0aGlzLl9iZyA9IFNwcml0ZUltYWdlLl9jcmVhdGVCZ0Rpdihcblx0XHRcdFx0dGhpcy5faW1hZ2UsIHRoaXMuX3Jvd0NvdW50LCB0aGlzLl9jb2xDb3VudCwgdGhpcy5fYXV0b0hlaWdodCk7XG5cdFx0XHR0aGlzLl9lbC5hcHBlbmRDaGlsZCh0aGlzLl9iZyk7XG5cdFx0XHR0aGlzLnNldENvbFJvdyh0aGlzLl9jb2xSb3dbMF0sIHRoaXMuX2NvbFJvd1sxXSk7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogRXZlbnRzIHRoYXQgb2NjdXIgd2hlbiBjb21wb25lbnQgbG9hZGluZyBpcyBjb21wbGV0ZVxuXHRcdFx0ICogQGtvIOy7tO2PrOuEjO2KuCDroZzrlKnsnbQg7JmE66OM65CY66m0IOuwnOyDne2VmOuKlCDsnbTrsqTtirhcblx0XHRcdCAqIEBuYW1lIGVnLnZpZXczNjAuU3ByaXRlSW1hZ2UjbG9hZFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gVGhlIG9iamVjdCBvZiBkYXRhIHRvIGJlIHNlbnQgdG8gYW4gZXZlbnQgPGtvPuydtOuypO2KuOyXkCDsoITri6zrkJjripQg642w7J207YSwIOqwneyytDwva28+XG5cdFx0XHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJhbS50YXJnZXQgVGhlIHRhcmdldCBlbGVtZW50IGZvciB3aGljaCB0byBkaXNwbGF5IHRoZSBpbWFnZSA8a28+7J2066+47KeA66W8IOuztOyXrOykhCDrjIDsg4Eg7JeY66as66i87Yq4PC9rbz5cblx0XHRcdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmFtLmJnRWxlbWVudCBHZW5lcmF0ZWQgYmFja2dyb3VuZCBpbWFnZSBlbGVtZW50IDxrbz7sg53shLHrkJwgYmFja2dyb3VuZCDsnbTrr7jsp4Ag7JeY66as66i87Yq4PC9rbz5cblx0XHRcdCAqXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICpcblx0XHRcdCAqIHNwcml0ZXMub24oe1xuXHRcdFx0ICpcdFwibG9hZFwiIDogZnVuY3Rpb24oZXZ0KSB7XG5cdFx0XHQgKlx0XHRjb25zb2xlLmxvZyhcImxvYWQgZXZlbnQgZmlyZWQgLSBlLnRhcmdldFwiLCBlLnRhcmdldCwgXCJlLmJnRWxlbWVudFwiLCBlLmJnRWxlbWVudCk7XG5cdFx0XHQgKlx0fVxuXHRcdFx0ICogfSk7XG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcihcImxvYWRcIiwge1xuXHRcdFx0XHR0YXJnZXQ6IHRoaXMuX2VsLFxuXHRcdFx0XHRiZ0VsZW1lbnQ6IHRoaXMuX2JnXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHRoaXMuX2F1dG9QbGF5UmVzZXJ2ZWRJbmZvKSB7XG5cdFx0XHRcdHRoaXMucGxheSh0aGlzLl9hdXRvUGxheVJlc2VydmVkSW5mbyk7XG5cdFx0XHRcdHRoaXMuX2F1dG9QbGF5UmVzZXJ2ZWRJbmZvID0gbnVsbDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy5faW1hZ2Uub25lcnJvciA9IGUgPT4ge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBBbiBldmVudCB0aGF0IG9jY3VycyB3aGVuIHRoZSBpbWFnZSBpbmRleCBpcyBjaGFuZ2VkIGJ5IHRoZSB1c2VyJ3MgbGVmdCAvIHJpZ2h0IHBhbm5pbmdcblx0XHRcdCAqIEBrbyDsgqzsmqnsnpDsnZgg7KKM7JqwIFBhbm5pbmcg7JeQIOydmO2VtCDsnbTrr7jsp4Ag7J24642x7Iqk6rCAIOuzgOqyveuQmOyXiOydhOuVjCDrsJzsg53tlZjripQg7J2067Kk7Yq4XG5cdFx0XHQgKiBAbmFtZSBlZy52aWV3MzYwLlNwcml0ZUltYWdlI2ltYWdlRXJyb3Jcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIFRoZSBvYmplY3Qgb2YgZGF0YSB0byBiZSBzZW50IHRvIGFuIGV2ZW50IDxrbz7snbTrsqTtirjsl5Ag7KCE64us65CY64qUIOuNsOydtO2EsCDqsJ3ssrQ8L2tvPlxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtLmltYWdlVXJsIFVzZXItc3BlY2lmaWVkIGltYWdlIFVSTCA8a28+7IKs7Jqp7J6Q6rCAIOyngOygle2VnCDsnbTrr7jsp4AgVVJMPC9rbz5cblx0XHRcdCAqXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICpcblx0XHRcdCAqIHNwcml0ZXMub24oe1xuXHRcdFx0ICpcdFwiaW1hZ2VFcnJvclwiIDogZnVuY3Rpb24oZXZ0KSB7XG5cdFx0XHQgKlx0XHQvLyBFcnJvciBoYW5kbGluZ1xuXHRcdFx0ICpcdFx0Y29uc29sZS5sb2coZS5pbWFnZVVybCk7XG5cdFx0XHQgKlx0fVxuXHRcdFx0ICogfSk7XG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcihcImltYWdlRXJyb3JcIiwge1xuXHRcdFx0XHRpbWFnZVVybDogb3B0LmltYWdlVXJsXG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0dGhpcy5faW1hZ2Uuc3JjID0gb3B0LmltYWdlVXJsO1xuXHR9XG5cblx0c3RhdGljIF9jcmVhdGVCZ0RpdihpbWcsIHJvd0NvdW50LCBjb2xDb3VudCwgYXV0b0hlaWdodCkge1xuXHRcdGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuXHRcdGVsLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHtpbWcuc3JjfSlgO1xuXHRcdGVsLnN0eWxlLmJhY2tncm91bmRTaXplID0gYCR7Y29sQ291bnQgKiAxMDB9JSAke3Jvd0NvdW50ICogMTAwfSVgO1xuXG5cdFx0Y29uc3QgdW5pdFdpZHRoID0gaW1nLndpZHRoIC8gY29sQ291bnQ7XG5cdFx0Y29uc3QgdW5pdEhlaWdodCA9IGltZy5oZWlnaHQgLyByb3dDb3VudDtcblxuXHRcdGlmIChhdXRvSGVpZ2h0KSB7XG5cdFx0XHRjb25zdCByID0gdW5pdEhlaWdodCAvIHVuaXRXaWR0aDtcblxuXHRcdFx0ZWwuc3R5bGUucGFkZGluZ0JvdHRvbSA9IGAke3IgKiAxMDB9JWA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuXHRcdH1cblxuXHRcdHJldHVybiBlbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgdGhlIGZyYW1lSW5kZXggb2YgdGhlIGZyYW1lIHRvIGJlIHNob3duIGluIHRoZSBzcHJpdGUgaW1hZ2UuXG5cdCAqIEBrbyDsiqTtlITrnbzsnbTtirgg7J2066+47KeAIOykkSDrs7Tsl6zsp4gg7ZSE66CI7J6E7J2YIGZyYW1lSW5kZXgg6rCS7J2EIOyngOyglVxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuU3ByaXRlSW1hZ2Ujc2V0RnJhbWVJbmRleFxuXHQgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVJbmRleCBmcmFtZSBpbmRleCBvZiBhIGZyYW1lPGtvPu2UhOugiOyehOydmCDsnbjrjbHsiqQ8L2tvPlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBzcHJpdGVzLnNldEZyYW1lSW5kZXgoMCwgMSk7Ly8gY29sID0gMCwgcm93ID0gMVxuXHQgKi9cblx0c2V0RnJhbWVJbmRleChpbmRleCkge1xuXHRcdGNvbnN0IGNvbFJvdyA9IHRoaXMudG9Db2xSb3coaW5kZXgpO1xuXG5cdFx0dGhpcy5zZXRDb2xSb3coY29sUm93WzBdLCBjb2xSb3dbMV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGZyYW1lSW5kZXggb2YgdGhlIGZyYW1lIHRvIGJlIHNob3duIGluIHRoZSBzcHJpdGUgaW1hZ2UuXG5cdCAqIEBrbyDsiqTtlITrnbzsnbTtirgg7J2066+47KeAIOykkSDrs7Tsl6zsp4DripQg7ZSE66CI7J6E7J2YIGluZGV4IOqwkuydhCDrsJjtmZhcblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlNwcml0ZUltYWdlI2dldEZyYW1lSW5kZXhcblx0ICogQHJldHVybiB7TnVtYmVyfSBmcmFtZSBpbmRleCA8a28+ZnJhbWUg7J24642x7IqkPC9rbz5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogdmFyIGZyYW1lSW5kZXggPSBzcHJpdGVzLmdldEZyYW1lSW5kZXgoKTsgLy8gZWcuIGZyYW1lSW5kZXggPSAxXG5cdCAqXG5cdCAqL1xuXHRnZXRGcmFtZUluZGV4KCkge1xuXHRcdHJldHVybiB0aGlzLl9jb2xSb3dbMV0gKiB0aGlzLl9jb2xDb3VudCArIHRoaXMuX2NvbFJvd1swXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgdGhlIGNvbCBhbmQgcm93IHZhbHVlcyBvZiB0aGUgZnJhbWUgdG8gYmUgc2hvd24gaW4gdGhlIHNwcml0ZSBpbWFnZS5cblx0ICogQGtvIOyKpO2UhOudvOydtO2KuCDsnbTrr7jsp4Ag7KSRIOuztOyXrOyniCDtlITroIjsnoTsnZggY29sLCByb3cg6rCS7J2EIOyngOyglVxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuU3ByaXRlSW1hZ2Ujc2V0Q29sUm93XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2wgQ29sdW1uIG51bWJlciBvZiBhIGZyYW1lPGtvPu2UhOugiOyehOydmCDtlonqsJI8L2tvPlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcm93IFJvdyBudW1iZXIgb2YgYSBmcmFtZTxrbz7tlITroIjsnoTsnZgg7Je06rCSPC9rbz5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogc3ByaXRlcy5zZXRsQ29sUm93KDEsIDIpOyAvLyBjb2wgPSAxLCByb3cgPSAyXG5cdCAqL1xuXHRzZXRDb2xSb3coY29sLCByb3cpIHtcblx0XHRpZiAocm93ID4gdGhpcy5fcm93Q291bnQgLSAxIHx8IGNvbCA+IHRoaXMuX2NvbENvdW50IC0gMSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9iZykge1xuXHRcdFx0dGhpcy5fYmcuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gYCR7LWNvbCAqIDEwMH0lICR7LXJvdyAqIDEwMH0lYDtcblx0XHR9XG5cblx0XHR0aGlzLl9jb2xSb3cgPSBbY29sLCByb3ddO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNvbCBhbmQgcm93IHZhbHVlcyBvZiB0aGUgZnJhbWUgdG8gYmUgc2hvd24gaW4gdGhlIHNwcml0ZSBpbWFnZS5cblx0ICogQGtvIOyKpO2UhOudvOydtO2KuCDsnbTrr7jsp4Ag7KSRIOuztOyXrOyngOuKlCDtlITroIjsnoTsnZggY29sLCByb3cg6rCS7J2E7ZmY67CY7ZmYXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5TcHJpdGVJbWFnZSNnZWxDb2xSb3dcblx0ICogQHJldHVybiB7TnVtYmVyW119IEFycmF5IGNvbnRhaW5pbmcgY29sLCByb3c8a28+Y29sLCByb3cg7KCV67O066W8IOuLtOuKlCDrsLDsl7Q8L2tvPlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiB2YXIgY29sUm93ID0gc3ByaXRlcy5nZXRsQ29sUm93KCk7XG5cdCAqIC8vIGNvbFJvdyA9IFsxLCAyXSAtIGluZGV4IG9mIGNvbCBpcyAxLCBpbmRleCBvZiByb3cgaXMgMlxuXHQgKlxuXHQgKi9cblx0Z2V0Q29sUm93KCkge1xuXHRcdHJldHVybiB0aGlzLl9jb2xSb3c7XG5cdH1cblxuXHRzdGF0aWMgX2dldFNpemVTdHJpbmcoc2l6ZSkge1xuXHRcdGlmICh0eXBlb2Ygc2l6ZSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0cmV0dXJuIGAke3NpemV9cHhgO1xuXHRcdH1cblxuXHRcdHJldHVybiBzaXplO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0b3AgcGxheWluZ1xuXHQgKiBAa28gcGxheSDrkJjqs6Ag7J6I642YIO2UhOugiOyehCDsnqzsg53snYQg7KSR7KeA7ZWp64uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuU3ByaXRlSW1hZ2Ujc3RvcFxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiB2aWV3ZXIuc3RvcCgpO1xuXHQgKlxuXHQgKi9cblx0c3RvcCgpIHtcblx0XHRpZiAodGhpcy5fYXV0b1BsYXlUaW1lcikge1xuXHRcdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLl9hdXRvUGxheVRpbWVyKTtcblx0XHRcdHRoaXMuX2F1dG9QbGF5VGltZXIgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTd2l0Y2hlcyBmcmFtZXMgc2VxdWVudGlhbGx5IGluIHRoZSAnaW50ZXJ2YWwnIHN0YXJ0aW5nIGZyb20gdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgZnJhbWUgYW5kIHBsYXlzIGFsbCBmcmFtZXMgYnkgJ3BsYXlDb3VudCcuXG5cdCAqIEBrbyDtmITsnqwg67O07Jes7KeA6rOgIOyeiOuKlCDtlITroIjsnoTsnYQg7Iuc7J6R7Jy866GcICdpbnRlcnZhbCcg6rCE6rKp7Jy866GcIOyInOywqOyggeycvOuhnCDtlITroIjsnoTsnYQg7KCE7ZmY7ZWY66mwIOuqqOuToCDtlITroIjsnoTsnYQgJ3BsYXlDb3VudCcg66eM7YG8IOyerOyDne2VnOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlNwcml0ZUltYWdlI3BsYXlcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIFRoZSBwYXJhbWV0ZXIgb2JqZWN0PGtvPu2MjOudvOuvuO2EsCDqsJ3ssrQ8L2tvPlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtLmludGVydmFsPTEwMDAgLyB0b3RhbEZyYW1lQ291bnRdIEludGVyZnJhbWUgSW50ZXJ2YWwgLSBpbiBtaWxsaXNlY29uZHM8a28+7ZSE66CI7J6E6rCEIOqwhOqyqSAtIOuwgOumrOyEuOy7qOuTnCDri6jsnIQ8L2tvPlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtLnBsYXlDb3VudD0wXSBQbGF5Q291bnQgPSAxIGluIHdoaWNoIGFsbCBmcmFtZXMgYXJlIHJlcHJvZHVjZWQgb25jZSwgYW5kIHBsYXlDb3VudCA9IG4gaW4gd2hpY2ggYWxsIGZyYW1lcyBhcmUgcmVwZWF0ZWQgbiB0aW1lcy4gcGxheUNvdW50ID0gMCBpbiB3aGljaCBhbGwgZnJhbWVzIGFyZSByZXBlYXRlZCBpbmZpbml0ZWx5PGtvPuuqqOuToCDtlITroIjsnoTsnYQgMe2ajOyUqSDsnqzsg53tlZwg6rKD7J20IHBsYXlDb3VudCA9IDEsIOuqqOuToCDtlITroIjsnoTsnYQgbiDtmowg7J6s7IOB7ZWcIOqyg+ydtCBwbGF5Q291bnQgPSBuIOydtCDrkJzri6QuIDAgZG1zIOustO2VnOuwmOuztTwva28+XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIHZpZXdlci5wbGF5KHthbmdsZTogMTYsIHBsYXlDb3VudDogMX0pO1xuXHQgKlxuXHQgKi9cblx0cGxheSh7aW50ZXJ2YWwsIHBsYXlDb3VudH0gPSB7aW50ZXJ2YWw6IDEwMDAgLyB0aGlzLl90b3RhbENvdW50LCBwbGF5Q291bnQ6IDB9KSB7XG5cdFx0aWYgKCF0aGlzLl9iZykge1xuXHRcdFx0dGhpcy5fYXV0b1BsYXlSZXNlcnZlZEluZm8gPSB7aW50ZXJ2YWwsIHBsYXlDb3VudH07XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2F1dG9QbGF5VGltZXIpIHtcblx0XHRcdGNsZWFySW50ZXJ2YWwodGhpcy5fYXV0b1BsYXlUaW1lcik7XG5cdFx0XHR0aGlzLl9hdXRvUGxheVRpbWVyID0gbnVsbDtcblx0XHR9XG5cblx0XHRsZXQgZnJhbWVJbmRleCA9IHRoaXMuZ2V0RnJhbWVJbmRleCgpO1xuXHRcdGxldCBjb3VudCA9IDA7XG5cdFx0bGV0IGZyYW1lQ291bnQgPSAwOyAvLyBmb3IgY2hlY2tpbmcgMSBjeWNsZVxuXG5cdFx0dGhpcy5fYXV0b1BsYXlUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcblx0XHRcdGZyYW1lSW5kZXggJT0gdGhpcy5fdG90YWxDb3VudDtcblx0XHRcdGNvbnN0IGNvbFJvdyA9IHRoaXMudG9Db2xSb3coZnJhbWVJbmRleCk7XG5cblx0XHRcdHRoaXMuc2V0Q29sUm93KGNvbFJvd1swXSwgY29sUm93WzFdKTtcblx0XHRcdGZyYW1lSW5kZXgrKztcblxuXHRcdFx0Ly8gRG9uZSAxIEN5Y2xlP1xuXHRcdFx0aWYgKCsrZnJhbWVDb3VudCA9PT0gdGhpcy5fdG90YWxDb3VudCkge1xuXHRcdFx0XHRmcmFtZUNvdW50ID0gMDtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHBsYXlDb3VudCA+IDAgJiYgY291bnQgPT09IHBsYXlDb3VudCkge1xuXHRcdFx0XHRjbGVhckludGVydmFsKHRoaXMuX2F1dG9QbGF5VGltZXIpO1xuXHRcdFx0fVxuXHRcdH0sIGludGVydmFsKTtcblx0fVxuXG5cdHRvQ29sUm93KGZyYW1lSW5kZXgpIHtcblx0XHRjb25zdCBjb2xDb3VudCA9IHRoaXMuX2NvbENvdW50O1xuXHRcdGNvbnN0IHJvd0NvdW50ID0gdGhpcy5fcm93Q291bnQ7XG5cblx0XHRpZiAoZnJhbWVJbmRleCA8IDApIHtcblx0XHRcdHJldHVybiBbMCwgMF07XG5cdFx0fSBlbHNlIGlmIChmcmFtZUluZGV4ID49IHRoaXMuX3RvdGFsQ291bnQpIHtcblx0XHRcdHJldHVybiBbY29sQ291bnQgLSAxLCByb3dDb3VudCAtIDFdO1xuXHRcdH1cblxuXHRcdGNvbnN0IGNvbCA9IGZyYW1lSW5kZXggJSBjb2xDb3VudDtcblx0XHRjb25zdCByb3cgPSBNYXRoLmZsb29yKGZyYW1lSW5kZXggLyBjb2xDb3VudCk7XG5cblx0XHQvLyBjb25zb2xlLmxvZyhmcmFtZUluZGV4LCBjb2wsIHJvdyk7XG5cdFx0cmV0dXJuIFtjb2wsIHJvd107XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TcGluVmlld2VyL1Nwcml0ZUltYWdlLmpzIiwiaW1wb3J0IHt3aW5kb3d9IGZyb20gXCIuL2Jyb3dzZXJcIjtcbmltcG9ydCB7Z2xNYXRyaXh9IGZyb20gXCIuLi91dGlscy9tYXRoLXV0aWxcIjtcblxuLy8gU2luZ2xldG9uXG5sZXQgc2NyZWVuUm90YXRpb25BbmdsZUluc3QgPSBudWxsO1xubGV0IHJlZkNvdW50ID0gMDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NyZWVuUm90YXRpb25BbmdsZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHJlZkNvdW50Kys7XG5cblx0XHRpZiAoc2NyZWVuUm90YXRpb25BbmdsZUluc3QpIHtcblx0XHRcdHJldHVybiBzY3JlZW5Sb3RhdGlvbkFuZ2xlSW5zdDtcblx0XHR9XG5cdFx0LyogZXNsaW50LWRpc2FibGUgKi9cblx0XHRzY3JlZW5Sb3RhdGlvbkFuZ2xlSW5zdCA9IHRoaXM7XG5cdFx0LyogZXNsaW50LWVuYWJsZSAqL1xuXHRcdHRoaXMuX29uRGV2aWNlT3JpZW50YXRpb24gPSB0aGlzLl9vbkRldmljZU9yaWVudGF0aW9uLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSA9IHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKTtcblxuXHRcdHRoaXMuX3NwaW5SID0gMDtcblxuXHRcdHRoaXMuX3NjcmVlbk9yaWVudGF0aW9uQW5nbGUgPSAwO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZGV2aWNlb3JpZW50YXRpb25cIiwgdGhpcy5fb25EZXZpY2VPcmllbnRhdGlvbik7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKTtcblx0fVxuXG5cdF9vbkRldmljZU9yaWVudGF0aW9uKGUpIHtcblx0XHRpZiAoZS5iZXRhID09PSBudWxsIHx8IGUuZ2FtbWEgPT09IG51bGwpIHtcblx0XHRcdC8vIChDaHJvbWUpIGRldmljZW9yaWVudGF0aW9uIGlzIGZpcmVkIHdpdGggaW52YWxpZCBpbmZvcm1hdGlvbiB7YWxwaGE9bnVsbCwgYmV0YT1udWxsLCAuLi59IGRlc3BpdGUgb2Ygbm90IGRpc3BhdGNoaW5nIGl0LiBXZSBza2lwIGl0LlxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJhZGlhblxuXHRcdGNvbnN0IGJldGFSID0gZ2xNYXRyaXgudG9SYWRpYW4oZS5iZXRhKTtcblx0XHRjb25zdCBnYW1tYVIgPSBnbE1hdHJpeC50b1JhZGlhbihlLmdhbW1hKTtcblxuXHRcdC8qIHNwaW5SIHJhbmdlID0gWy0xODAsIDE4MF0sIGxlZnQgc2lkZTogMCB+IC0xODAoZGVnKSwgcmlnaHQgc2lkZTogMCB+IDE4MChkZWcpICovXG5cdFx0dGhpcy5fc3BpblIgPSBNYXRoLmF0YW4yKE1hdGguY29zKGJldGFSKSAqIE1hdGguc2luKGdhbW1hUiksIE1hdGguc2luKGJldGFSKSk7XG5cdH1cblxuXHRfb25PcmllbnRhdGlvbkNoYW5nZShlKSB7XG5cdFx0aWYgKHdpbmRvdy5zY3JlZW4gJiYgd2luZG93LnNjcmVlbi5vcmllbnRhdGlvbiAmJiB3aW5kb3cuc2NyZWVuLm9yaWVudGF0aW9uLmFuZ2xlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX3NjcmVlbk9yaWVudGF0aW9uQW5nbGUgPSBzY3JlZW4ub3JpZW50YXRpb24uYW5nbGU7XG5cdFx0fSBlbHNlIGlmICh3aW5kb3cub3JpZW50YXRpb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0LyogaU9TICovXG5cdFx0XHR0aGlzLl9zY3JlZW5PcmllbnRhdGlvbkFuZ2xlID0gd2luZG93Lm9yaWVudGF0aW9uID49IDAgP1xuXHRcdFx0XHR3aW5kb3cub3JpZW50YXRpb24gOiAzNjAgKyB3aW5kb3cub3JpZW50YXRpb247XG5cdFx0fVxuXHR9XG5cblx0Z2V0UmFkaWFuKCkge1xuXHRcdC8vIEpvaW4gd2l0aCBzY3JlZW4gb3JpZW50YXRpb25cblx0XHQvLyB0aGlzLl90ZXN0VmFsID0gdGhpcy5fc3BpblIgKyBcIiwgXCIgKyB0aGlzLl9zY3JlZW5PcmllbnRhdGlvbkFuZ2xlICsgXCIsIFwiICsgd2luZG93Lm9yaWVudGF0aW9uO1xuXHRcdHJldHVybiB0aGlzLl9zcGluUiArIGdsTWF0cml4LnRvUmFkaWFuKHRoaXMuX3NjcmVlbk9yaWVudGF0aW9uQW5nbGUpO1xuXHR9XG5cblx0dW5yZWYoKSB7XG5cdFx0aWYgKC0tcmVmQ291bnQgPiAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkZXZpY2VvcmllbnRhdGlvblwiLCB0aGlzLl9vbkRldmljZU9yaWVudGF0aW9uKTtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpO1xuXG5cdFx0dGhpcy5fc3BpblIgPSAwO1xuXHRcdHRoaXMuX3NjcmVlbk9yaWVudGF0aW9uQW5nbGUgPSAwO1xuXHRcdC8qIGVzbGludC1kaXNhYmxlICovXG5cdFx0c2NyZWVuUm90YXRpb25BbmdsZUluc3QgPSBudWxsO1xuXHRcdC8qIGVzbGludC1lbmFibGUgKi9cblx0XHRyZWZDb3VudCA9IDA7XG5cdH1cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1lhd1BpdGNoQ29udHJvbC9TY3JlZW5Sb3RhdGlvbkFuZ2xlLmpzIiwiaW1wb3J0IFlhd1BpdGNoQ29udHJvbCBmcm9tIFwiLi9ZYXdQaXRjaENvbnRyb2xcIjtcbmltcG9ydCB7XG5cdENPTlRST0xfTU9ERV9WUixcblx0Q09OVFJPTF9NT0RFX1lBV1BJVENILFxuXHRUT1VDSF9ESVJFQ1RJT05fQUxMLFxuXHRUT1VDSF9ESVJFQ1RJT05fWUFXLFxuXHRUT1VDSF9ESVJFQ1RJT05fUElUQ0gsXG5cdFRPVUNIX0RJUkVDVElPTl9OT05FLFxufSBmcm9tIFwiLi9jb25zdHNcIjtcblxuLy8gRXhwb3NlIERldmljZU9yaWVudGF0aW9uQ29udHJvbHMgc3ViIG1vZHVsZSBmb3IgdGVzdCBwdXJwb3NlXG5ZYXdQaXRjaENvbnRyb2wuQ09OVFJPTF9NT0RFX1ZSID0gQ09OVFJPTF9NT0RFX1ZSO1xuWWF3UGl0Y2hDb250cm9sLkNPTlRST0xfTU9ERV9ZQVdQSVRDSCA9IENPTlRST0xfTU9ERV9ZQVdQSVRDSDtcbllhd1BpdGNoQ29udHJvbC5UT1VDSF9ESVJFQ1RJT05fQUxMID0gVE9VQ0hfRElSRUNUSU9OX0FMTDtcbllhd1BpdGNoQ29udHJvbC5UT1VDSF9ESVJFQ1RJT05fWUFXID0gVE9VQ0hfRElSRUNUSU9OX1lBVztcbllhd1BpdGNoQ29udHJvbC5UT1VDSF9ESVJFQ1RJT05fUElUQ0ggPSBUT1VDSF9ESVJFQ1RJT05fUElUQ0g7XG5ZYXdQaXRjaENvbnRyb2wuVE9VQ0hfRElSRUNUSU9OX05PTkUgPSBUT1VDSF9ESVJFQ1RJT05fTk9ORTtcblxuLy8gbW9kdWxlLmV4cG9ydHMgPSBZYXdQaXRjaDtcbmV4cG9ydCB7XG5cdFlhd1BpdGNoQ29udHJvbFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9ZYXdQaXRjaENvbnRyb2wvaW5kZXguanMiLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbmltcG9ydCBhZ2VudCBmcm9tIFwiQGVnanMvYWdlbnRcIjtcbmltcG9ydCBQb3NlUHJlZGljdG9yIGZyb20gXCJ3ZWJ2ci1wb2x5ZmlsbC9zcmMvc2Vuc29yLWZ1c2lvbi9wb3NlLXByZWRpY3RvclwiO1xuaW1wb3J0IE1hdGhVdGlsIGZyb20gXCJ3ZWJ2ci1wb2x5ZmlsbC9zcmMvbWF0aC11dGlsXCI7XG5pbXBvcnQgVXRpbCBmcm9tIFwid2VidnItcG9seWZpbGwvc3JjL3V0aWxcIjtcbmltcG9ydCB7d2luZG93fSBmcm9tIFwiLi4vYnJvd3NlclwiO1xuaW1wb3J0IHtxdWF0fSBmcm9tIFwiLi4vLi4vdXRpbHMvbWF0aC11dGlsXCI7XG5pbXBvcnQgRGV2aWNlTW90aW9uIGZyb20gXCIuL0RldmljZU1vdGlvblwiO1xuaW1wb3J0IENvbXBsZW1lbnRhcnlGaWx0ZXIgZnJvbSBcIi4vQ29tcGxlbWVudGFyeUZpbHRlclwiO1xuXG5jb25zdCBLX0ZJTFRFUiA9IDAuOTg7XG5jb25zdCBQUkVESUNUSU9OX1RJTUVfUyA9IDAuMDQwO1xuY29uc3QgYWdlbnRJbmZvID0gYWdlbnQoKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRnVzaW9uUG9zZVNlbnNvciBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmRldmljZU1vdGlvbiA9IG5ldyBEZXZpY2VNb3Rpb24oKTtcblxuXHRcdHRoaXMuYWNjZWxlcm9tZXRlciA9IG5ldyBNYXRoVXRpbC5WZWN0b3IzKCk7XG5cdFx0dGhpcy5neXJvc2NvcGUgPSBuZXcgTWF0aFV0aWwuVmVjdG9yMygpO1xuXG5cdFx0dGhpcy5fb25EZXZpY2VNb3Rpb25DaGFuZ2UgPSB0aGlzLl9vbkRldmljZU1vdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuX29uU2NyZWVuT3JpZW50YXRpb25DaGFuZ2UgPSB0aGlzLl9vblNjcmVlbk9yaWVudGF0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG5cblx0XHR0aGlzLmZpbHRlciA9IG5ldyBDb21wbGVtZW50YXJ5RmlsdGVyKEtfRklMVEVSKTtcblx0XHR0aGlzLnBvc2VQcmVkaWN0b3IgPSBuZXcgUG9zZVByZWRpY3RvcihQUkVESUNUSU9OX1RJTUVfUyk7XG5cblx0XHR0aGlzLmZpbHRlclRvV29ybGRRID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcblxuXHRcdHRoaXMuaXNGaXJlZm94QW5kcm9pZCA9IFV0aWwuaXNGaXJlZm94QW5kcm9pZCgpO1xuXHRcdHRoaXMuaXNJT1MgPSBVdGlsLmlzSU9TKCk7XG5cblx0XHQvLyBSZWYgaHR0cHM6Ly9naXRodWIuY29tL2ltbWVyc2l2ZS13ZWIvY2FyZGJvYXJkLXZyLWRpc3BsYXkvaXNzdWVzLzE4XG5cdFx0dGhpcy5pc0Nocm9tZVVzaW5nRGVncmVlcyA9IGFnZW50SW5mby5icm93c2VyLm5hbWUgPT09IFwiY2hyb21lXCIgJiZcblx0XHRcdHBhcnNlSW50KGFnZW50SW5mby5icm93c2VyLnZlcnNpb24sIDEwKSA+PSA2NjtcblxuXHRcdHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gU2V0IHRoZSBmaWx0ZXIgdG8gd29ybGQgdHJhbnNmb3JtLCBkZXBlbmRpbmcgb24gT1MuXG5cdFx0aWYgKHRoaXMuaXNJT1MpIHtcblx0XHRcdHRoaXMuZmlsdGVyVG9Xb3JsZFEuc2V0RnJvbUF4aXNBbmdsZShuZXcgTWF0aFV0aWwuVmVjdG9yMygxLCAwLCAwKSwgTWF0aC5QSSAvIDIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmZpbHRlclRvV29ybGRRLnNldEZyb21BeGlzQW5nbGUobmV3IE1hdGhVdGlsLlZlY3RvcjMoMSwgMCwgMCksIC1NYXRoLlBJIC8gMik7XG5cdFx0fVxuXG5cdFx0dGhpcy5pbnZlcnNlV29ybGRUb1NjcmVlblEgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuXHRcdHRoaXMud29ybGRUb1NjcmVlblEgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuXHRcdHRoaXMub3JpZ2luYWxQb3NlQWRqdXN0USA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG5cdFx0dGhpcy5vcmlnaW5hbFBvc2VBZGp1c3RRLnNldEZyb21BeGlzQW5nbGUobmV3IE1hdGhVdGlsLlZlY3RvcjMoMCwgMCwgMSksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQtd2luZG93Lm9yaWVudGF0aW9uICogTWF0aC5QSSAvIDE4MCk7XG5cblx0XHR0aGlzLl9zZXRTY3JlZW5UcmFuc2Zvcm0oKTtcblx0XHQvLyBBZGp1c3QgdGhpcyBmaWx0ZXIgZm9yIGJlaW5nIGluIGxhbmRzY2FwZSBtb2RlLlxuXHRcdGlmIChVdGlsLmlzTGFuZHNjYXBlTW9kZSgpKSB7XG5cdFx0XHR0aGlzLmZpbHRlclRvV29ybGRRLm11bHRpcGx5KHRoaXMuaW52ZXJzZVdvcmxkVG9TY3JlZW5RKTtcblx0XHR9XG5cblx0XHQvLyBLZWVwIHRyYWNrIG9mIGEgcmVzZXQgdHJhbnNmb3JtIGZvciByZXNldFNlbnNvci5cblx0XHR0aGlzLnJlc2V0USA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG5cblx0XHR0aGlzLmRldmljZU1vdGlvbi5vbihcImRldmljZW1vdGlvblwiLCB0aGlzLl9vbkRldmljZU1vdGlvbkNoYW5nZSk7XG5cdFx0dGhpcy5lbmFibGUoKTtcblx0fVxuXHRlbmFibGUoKSB7XG5cdFx0aWYgKHRoaXMuaXNFbmFibGVkKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5kZXZpY2VNb3Rpb24uZW5hYmxlKCk7XG5cdFx0dGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX29uU2NyZWVuT3JpZW50YXRpb25DaGFuZ2UpO1xuXHR9XG5cdGRpc2FibGUoKSB7XG5cdFx0aWYgKCF0aGlzLmlzRW5hYmxlZCgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuZGV2aWNlTW90aW9uLmRpc2FibGUoKTtcblx0XHR0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX29uU2NyZWVuT3JpZW50YXRpb25DaGFuZ2UpO1xuXHR9XG5cdGlzRW5hYmxlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5faXNFbmFibGVkO1xuXHR9XG5cdGRlc3Ryb3koKSB7XG5cdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0dGhpcy5kZXZpY2VNb3Rpb24gPSBudWxsO1xuXHR9XG5cdF90cmlnZ2VyQ2hhbmdlKCkge1xuXHRcdGNvbnN0IG9yaWVudGF0aW9uID0gdGhpcy5nZXRPcmllbnRhdGlvbigpO1xuXG5cdFx0Ly8gaWYgb3JpZW50YXRpb24gaXMgbm90IHByZXBhcmVkLiBkb24ndCB0cmlnZ2VyIGNoYW5nZSBldmVudFxuXHRcdGlmICghb3JpZW50YXRpb24pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX3ByZXZPcmllbnRhdGlvbikge1xuXHRcdFx0dGhpcy5fcHJldk9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHF1YXQuZXF1YWxzKHRoaXMuX3ByZXZPcmllbnRhdGlvbiwgb3JpZW50YXRpb24pKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy50cmlnZ2VyKFwiY2hhbmdlXCIsIHtxdWF0ZXJuaW9uOiBvcmllbnRhdGlvbn0pO1xuXHR9XG5cdGdldE9yaWVudGF0aW9uKCkge1xuXHRcdGxldCBvcmllbnRhdGlvbjtcblxuXHRcdC8vIEhhY2sgYXJvdW5kIHVzaW5nIGRldmljZW9yaWVudGF0aW9uIGluc3RlYWQgb2YgZGV2aWNlbW90aW9uXG5cdFx0aWYgKHRoaXMuZGV2aWNlTW90aW9uLmlzV2l0aG91dERldmljZU1vdGlvbiAmJiB0aGlzLl9kZXZpY2VPcmllbnRhdGlvblEpIHtcblx0XHRcdHRoaXMuZGV2aWNlT3JpZW50YXRpb25GaXhRID0gdGhpcy5kZXZpY2VPcmllbnRhdGlvbkZpeFEgfHwgKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjb25zdCB5ID1cblx0XHRcdFx0XHRuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpLnNldEZyb21BeGlzQW5nbGUoXG5cdFx0XHRcdFx0XHRuZXcgTWF0aFV0aWwuVmVjdG9yMygwLCAxLCAwKSwgLXRoaXMuX2FscGhhKTtcblxuXHRcdFx0XHRyZXR1cm4geTtcblx0XHRcdH0pLmJpbmQodGhpcykoKTtcblxuXHRcdFx0b3JpZW50YXRpb24gPSB0aGlzLl9kZXZpY2VPcmllbnRhdGlvblE7XG5cdFx0XHRjb25zdCBvdXQgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuXG5cdFx0XHRvdXQuY29weShvcmllbnRhdGlvbik7XG5cdFx0XHRvdXQubXVsdGlwbHkodGhpcy5maWx0ZXJUb1dvcmxkUSk7XG5cdFx0XHRvdXQubXVsdGlwbHkodGhpcy5yZXNldFEpO1xuXHRcdFx0b3V0Lm11bHRpcGx5KHRoaXMud29ybGRUb1NjcmVlblEpO1xuXHRcdFx0b3V0Lm11bHRpcGx5UXVhdGVybmlvbnModGhpcy5kZXZpY2VPcmllbnRhdGlvbkZpeFEsIG91dCk7XG5cblx0XHRcdC8vIHJldHVybiBxdWF0ZXJuaW9uIGFzIGdsbWF0cml4IHF1YXRlcm5pb24gb2JqZWN0XG5cdFx0XHRjb25zdCBvdXRfID0gcXVhdC5mcm9tVmFsdWVzKFxuXHRcdFx0XHRvdXQueCxcblx0XHRcdFx0b3V0LnksXG5cdFx0XHRcdG91dC56LFxuXHRcdFx0XHRvdXQud1xuXHRcdFx0KTtcblxuXHRcdFx0cmV0dXJuIHF1YXQubm9ybWFsaXplKG91dF8sIG91dF8pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBDb252ZXJ0IGZyb20gZmlsdGVyIHNwYWNlIHRvIHRoZSB0aGUgc2FtZSBzeXN0ZW0gdXNlZCBieSB0aGVcblx0XHRcdC8vIGRldmljZW9yaWVudGF0aW9uIGV2ZW50LlxuXHRcdFx0b3JpZW50YXRpb24gPSB0aGlzLmZpbHRlci5nZXRPcmllbnRhdGlvbigpO1xuXG5cdFx0XHRpZiAoIW9yaWVudGF0aW9uKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBvdXQgPSB0aGlzLl9jb252ZXJ0RnVzaW9uVG9QcmVkaWN0ZWQob3JpZW50YXRpb24pO1xuXG5cdFx0XHQvLyByZXR1cm4gcXVhdGVybmlvbiBhcyBnbG1hdHJpeCBxdWF0ZXJuaW9uIG9iamVjdFxuXHRcdFx0Y29uc3Qgb3V0XyA9IHF1YXQuZnJvbVZhbHVlcyhcblx0XHRcdFx0b3V0LngsXG5cdFx0XHRcdG91dC55LFxuXHRcdFx0XHRvdXQueixcblx0XHRcdFx0b3V0Lndcblx0XHRcdCk7XG5cblx0XHRcdHJldHVybiBxdWF0Lm5vcm1hbGl6ZShvdXRfLCBvdXRfKTtcblx0XHR9XG5cdH1cblx0X2NvbnZlcnRGdXNpb25Ub1ByZWRpY3RlZChvcmllbnRhdGlvbikge1xuXHRcdC8vIFByZWRpY3Qgb3JpZW50YXRpb24uXG5cdFx0dGhpcy5wcmVkaWN0ZWRRID1cblx0XHRcdHRoaXMucG9zZVByZWRpY3Rvci5nZXRQcmVkaWN0aW9uKG9yaWVudGF0aW9uLCB0aGlzLmd5cm9zY29wZSwgdGhpcy5wcmV2aW91c1RpbWVzdGFtcFMpO1xuXG5cdFx0Ly8gQ29udmVydCB0byBUSFJFRSBjb29yZGluYXRlIHN5c3RlbTogLVogZm9yd2FyZCwgWSB1cCwgWCByaWdodC5cblx0XHRjb25zdCBvdXQgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuXG5cdFx0b3V0LmNvcHkodGhpcy5maWx0ZXJUb1dvcmxkUSk7XG5cdFx0b3V0Lm11bHRpcGx5KHRoaXMucmVzZXRRKTtcblx0XHRvdXQubXVsdGlwbHkodGhpcy5wcmVkaWN0ZWRRKTtcblx0XHRvdXQubXVsdGlwbHkodGhpcy53b3JsZFRvU2NyZWVuUSk7XG5cblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cdF9vbkRldmljZU1vdGlvbkNoYW5nZSh7aW5wdXRFdmVudH0pIHtcblx0XHRjb25zdCBkZXZpY2VvcmllbnRhdGlvbiA9IGlucHV0RXZlbnQuZGV2aWNlb3JpZW50YXRpb247XG5cdFx0Y29uc3QgZGV2aWNlTW90aW9uID0gaW5wdXRFdmVudDtcblx0XHRjb25zdCBhY2NHcmF2aXR5ID0gZGV2aWNlTW90aW9uLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHk7XG5cdFx0Y29uc3Qgcm90UmF0ZSA9IGRldmljZU1vdGlvbi5hZGp1c3RlZFJvdGF0aW9uUmF0ZSB8fCBkZXZpY2VNb3Rpb24ucm90YXRpb25SYXRlO1xuXHRcdGxldCB0aW1lc3RhbXBTID0gZGV2aWNlTW90aW9uLnRpbWVTdGFtcCAvIDEwMDA7XG5cblx0XHRpZiAoZGV2aWNlb3JpZW50YXRpb24pIHtcblx0XHRcdGlmICghdGhpcy5fYWxwaGEpIHtcblx0XHRcdFx0dGhpcy5fYWxwaGEgPSBkZXZpY2VvcmllbnRhdGlvbi5hbHBoYTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2RldmljZU9yaWVudGF0aW9uUSA9IHRoaXMuX2RldmljZU9yaWVudGF0aW9uUSB8fCBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuXHRcdFx0dGhpcy5fZGV2aWNlT3JpZW50YXRpb25RLnNldEZyb21FdWxlcllYWihcblx0XHRcdFx0ZGV2aWNlb3JpZW50YXRpb24uYmV0YSxcblx0XHRcdFx0ZGV2aWNlb3JpZW50YXRpb24uYWxwaGEsXG5cdFx0XHRcdGRldmljZW9yaWVudGF0aW9uLmdhbW1hXG5cdFx0XHQpO1xuXG5cdFx0XHR0aGlzLl90cmlnZ2VyQ2hhbmdlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEZpcmVmb3ggQW5kcm9pZCB0aW1lU3RhbXAgcmV0dXJucyBvbmUgdGhvdXNhbmR0aCBvZiBhIG1pbGxpc2Vjb25kLlxuXHRcdFx0aWYgKHRoaXMuaXNGaXJlZm94QW5kcm9pZCkge1xuXHRcdFx0XHR0aW1lc3RhbXBTIC89IDEwMDA7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYWNjZWxlcm9tZXRlci5zZXQoLWFjY0dyYXZpdHkueCwgLWFjY0dyYXZpdHkueSwgLWFjY0dyYXZpdHkueik7XG5cdFx0XHR0aGlzLmd5cm9zY29wZS5zZXQocm90UmF0ZS5hbHBoYSwgcm90UmF0ZS5iZXRhLCByb3RSYXRlLmdhbW1hKTtcblxuXHRcdFx0Ly8gQnJvd3NlcnMgb24gaU9TLCBGaXJlZm94L0FuZHJvaWQsIGFuZCBDaHJvbWUgbTY2L0FuZHJvaWQgYHJvdGF0aW9uUmF0ZWBcblx0XHRcdC8vIGlzIHJlcG9ydGVkIGluIGRlZ3JlZXMsIHNvIHdlIGZpcnN0IGNvbnZlcnQgdG8gcmFkaWFucy5cblx0XHRcdGlmICh0aGlzLmlzSU9TIHx8IHRoaXMuaXNGaXJlZm94QW5kcm9pZCB8fCB0aGlzLmlzQ2hyb21lVXNpbmdEZWdyZWVzKSB7XG5cdFx0XHRcdHRoaXMuZ3lyb3Njb3BlLm11bHRpcGx5U2NhbGFyKE1hdGguUEkgLyAxODApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmZpbHRlci5hZGRBY2NlbE1lYXN1cmVtZW50KHRoaXMuYWNjZWxlcm9tZXRlciwgdGltZXN0YW1wUyk7XG5cdFx0XHR0aGlzLmZpbHRlci5hZGRHeXJvTWVhc3VyZW1lbnQodGhpcy5neXJvc2NvcGUsIHRpbWVzdGFtcFMpO1xuXG5cdFx0XHR0aGlzLl90cmlnZ2VyQ2hhbmdlKCk7XG5cblx0XHRcdHRoaXMucHJldmlvdXNUaW1lc3RhbXBTID0gdGltZXN0YW1wUztcblx0XHR9XG5cdH1cblx0X29uU2NyZWVuT3JpZW50YXRpb25DaGFuZ2Uoc2NyZWVuT3JpZW50YXRpb24pIHtcblx0XHR0aGlzLl9zZXRTY3JlZW5UcmFuc2Zvcm0od2luZG93Lm9yaWVudGF0aW9uKTtcblx0fVxuXHRfc2V0U2NyZWVuVHJhbnNmb3JtKCkge1xuXHRcdHRoaXMud29ybGRUb1NjcmVlblEuc2V0KDAsIDAsIDAsIDEpO1xuXHRcdHN3aXRjaCAod2luZG93Lm9yaWVudGF0aW9uKSB7XG5cdFx0XHRjYXNlIDA6XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSA5MDpcblx0XHRcdFx0dGhpcy53b3JsZFRvU2NyZWVuUS5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBNYXRoVXRpbC5WZWN0b3IzKDAsIDAsIDEpLCA5MCAvIC0xODAgKiBNYXRoLlBJKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIC05MDpcblx0XHRcdFx0dGhpcy53b3JsZFRvU2NyZWVuUS5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBNYXRoVXRpbC5WZWN0b3IzKDAsIDAsIDEpLCAtOTAgLyAtMTgwICogTWF0aC5QSSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAxODA6XG5cdFx0XHRcdHRoaXMud29ybGRUb1NjcmVlblEuc2V0RnJvbUF4aXNBbmdsZShuZXcgTWF0aFV0aWwuVmVjdG9yMygwLCAwLCAxKSwgMTgwIC8gLTE4MCAqIE1hdGguUEkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHR0aGlzLmludmVyc2VXb3JsZFRvU2NyZWVuUS5jb3B5KHRoaXMud29ybGRUb1NjcmVlblEpO1xuXHRcdHRoaXMuaW52ZXJzZVdvcmxkVG9TY3JlZW5RLmludmVyc2UoKTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1lhd1BpdGNoQ29udHJvbC9pbnB1dC9GdXNpb25Qb3NlU2Vuc29yLmpzIiwiY29uc3QgdXRpbCA9IHt9O1xuXG5mdW5jdGlvbiB0b0F4aXMoc291cmNlLCBvZmZzZXQpIHtcblx0cmV0dXJuIG9mZnNldC5yZWR1Y2UoKGFjYywgdiwgaSkgPT4ge1xuXHRcdGlmIChzb3VyY2VbaV0pIHtcblx0XHRcdGFjY1tzb3VyY2VbaV1dID0gdjtcblx0XHR9XG5cdFx0cmV0dXJuIGFjYztcblx0fSwge30pO1xufVxuXG51dGlsLnRvQXhpcyA9IHRvQXhpcztcblxuZXhwb3J0IGRlZmF1bHQgdXRpbDtcbmV4cG9ydCB7dG9BeGlzfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9ZYXdQaXRjaENvbnRyb2wvdXRpbHMuanMiLCJ2YXIgRU5USVRJRVMgPSBbWydBYWN1dGUnLCBbMTkzXV0sIFsnYWFjdXRlJywgWzIyNV1dLCBbJ0FicmV2ZScsIFsyNThdXSwgWydhYnJldmUnLCBbMjU5XV0sIFsnYWMnLCBbODc2Nl1dLCBbJ2FjZCcsIFs4NzY3XV0sIFsnYWNFJywgWzg3NjYsIDgxOV1dLCBbJ0FjaXJjJywgWzE5NF1dLCBbJ2FjaXJjJywgWzIyNl1dLCBbJ2FjdXRlJywgWzE4MF1dLCBbJ0FjeScsIFsxMDQwXV0sIFsnYWN5JywgWzEwNzJdXSwgWydBRWxpZycsIFsxOThdXSwgWydhZWxpZycsIFsyMzBdXSwgWydhZicsIFs4Mjg5XV0sIFsnQWZyJywgWzEyMDA2OF1dLCBbJ2FmcicsIFsxMjAwOTRdXSwgWydBZ3JhdmUnLCBbMTkyXV0sIFsnYWdyYXZlJywgWzIyNF1dLCBbJ2FsZWZzeW0nLCBbODUwMV1dLCBbJ2FsZXBoJywgWzg1MDFdXSwgWydBbHBoYScsIFs5MTNdXSwgWydhbHBoYScsIFs5NDVdXSwgWydBbWFjcicsIFsyNTZdXSwgWydhbWFjcicsIFsyNTddXSwgWydhbWFsZycsIFsxMDgxNV1dLCBbJ2FtcCcsIFszOF1dLCBbJ0FNUCcsIFszOF1dLCBbJ2FuZGFuZCcsIFsxMDgzN11dLCBbJ0FuZCcsIFsxMDgzNV1dLCBbJ2FuZCcsIFs4NzQzXV0sIFsnYW5kZCcsIFsxMDg0NF1dLCBbJ2FuZHNsb3BlJywgWzEwODQwXV0sIFsnYW5kdicsIFsxMDg0Ml1dLCBbJ2FuZycsIFs4NzM2XV0sIFsnYW5nZScsIFsxMDY2MF1dLCBbJ2FuZ2xlJywgWzg3MzZdXSwgWydhbmdtc2RhYScsIFsxMDY2NF1dLCBbJ2FuZ21zZGFiJywgWzEwNjY1XV0sIFsnYW5nbXNkYWMnLCBbMTA2NjZdXSwgWydhbmdtc2RhZCcsIFsxMDY2N11dLCBbJ2FuZ21zZGFlJywgWzEwNjY4XV0sIFsnYW5nbXNkYWYnLCBbMTA2NjldXSwgWydhbmdtc2RhZycsIFsxMDY3MF1dLCBbJ2FuZ21zZGFoJywgWzEwNjcxXV0sIFsnYW5nbXNkJywgWzg3MzddXSwgWydhbmdydCcsIFs4NzM1XV0sIFsnYW5ncnR2YicsIFs4ODk0XV0sIFsnYW5ncnR2YmQnLCBbMTA2NTNdXSwgWydhbmdzcGgnLCBbODczOF1dLCBbJ2FuZ3N0JywgWzE5N11dLCBbJ2FuZ3phcnInLCBbOTA4NF1dLCBbJ0FvZ29uJywgWzI2MF1dLCBbJ2FvZ29uJywgWzI2MV1dLCBbJ0FvcGYnLCBbMTIwMTIwXV0sIFsnYW9wZicsIFsxMjAxNDZdXSwgWydhcGFjaXInLCBbMTA4NjNdXSwgWydhcCcsIFs4Nzc2XV0sIFsnYXBFJywgWzEwODY0XV0sIFsnYXBlJywgWzg3NzhdXSwgWydhcGlkJywgWzg3NzldXSwgWydhcG9zJywgWzM5XV0sIFsnQXBwbHlGdW5jdGlvbicsIFs4Mjg5XV0sIFsnYXBwcm94JywgWzg3NzZdXSwgWydhcHByb3hlcScsIFs4Nzc4XV0sIFsnQXJpbmcnLCBbMTk3XV0sIFsnYXJpbmcnLCBbMjI5XV0sIFsnQXNjcicsIFsxMTk5NjRdXSwgWydhc2NyJywgWzExOTk5MF1dLCBbJ0Fzc2lnbicsIFs4Nzg4XV0sIFsnYXN0JywgWzQyXV0sIFsnYXN5bXAnLCBbODc3Nl1dLCBbJ2FzeW1wZXEnLCBbODc4MV1dLCBbJ0F0aWxkZScsIFsxOTVdXSwgWydhdGlsZGUnLCBbMjI3XV0sIFsnQXVtbCcsIFsxOTZdXSwgWydhdW1sJywgWzIyOF1dLCBbJ2F3Y29uaW50JywgWzg3NTVdXSwgWydhd2ludCcsIFsxMDc2OV1dLCBbJ2JhY2tjb25nJywgWzg3ODBdXSwgWydiYWNrZXBzaWxvbicsIFsxMDE0XV0sIFsnYmFja3ByaW1lJywgWzgyNDVdXSwgWydiYWNrc2ltJywgWzg3NjVdXSwgWydiYWNrc2ltZXEnLCBbODkwOV1dLCBbJ0JhY2tzbGFzaCcsIFs4NzI2XV0sIFsnQmFydicsIFsxMDk4M11dLCBbJ2JhcnZlZScsIFs4ODkzXV0sIFsnYmFyd2VkJywgWzg5NjVdXSwgWydCYXJ3ZWQnLCBbODk2Nl1dLCBbJ2JhcndlZGdlJywgWzg5NjVdXSwgWydiYnJrJywgWzkxNDFdXSwgWydiYnJrdGJyaycsIFs5MTQyXV0sIFsnYmNvbmcnLCBbODc4MF1dLCBbJ0JjeScsIFsxMDQxXV0sIFsnYmN5JywgWzEwNzNdXSwgWydiZHF1bycsIFs4MjIyXV0sIFsnYmVjYXVzJywgWzg3NTddXSwgWydiZWNhdXNlJywgWzg3NTddXSwgWydCZWNhdXNlJywgWzg3NTddXSwgWydiZW1wdHl2JywgWzEwNjcyXV0sIFsnYmVwc2knLCBbMTAxNF1dLCBbJ2Jlcm5vdScsIFs4NDkyXV0sIFsnQmVybm91bGxpcycsIFs4NDkyXV0sIFsnQmV0YScsIFs5MTRdXSwgWydiZXRhJywgWzk0Nl1dLCBbJ2JldGgnLCBbODUwMl1dLCBbJ2JldHdlZW4nLCBbODgxMl1dLCBbJ0JmcicsIFsxMjAwNjldXSwgWydiZnInLCBbMTIwMDk1XV0sIFsnYmlnY2FwJywgWzg4OThdXSwgWydiaWdjaXJjJywgWzk3MTFdXSwgWydiaWdjdXAnLCBbODg5OV1dLCBbJ2JpZ29kb3QnLCBbMTA3NTJdXSwgWydiaWdvcGx1cycsIFsxMDc1M11dLCBbJ2JpZ290aW1lcycsIFsxMDc1NF1dLCBbJ2JpZ3NxY3VwJywgWzEwNzU4XV0sIFsnYmlnc3RhcicsIFs5NzMzXV0sIFsnYmlndHJpYW5nbGVkb3duJywgWzk2NjFdXSwgWydiaWd0cmlhbmdsZXVwJywgWzk2NTFdXSwgWydiaWd1cGx1cycsIFsxMDc1Nl1dLCBbJ2JpZ3ZlZScsIFs4ODk3XV0sIFsnYmlnd2VkZ2UnLCBbODg5Nl1dLCBbJ2JrYXJvdycsIFsxMDUwOV1dLCBbJ2JsYWNrbG96ZW5nZScsIFsxMDczMV1dLCBbJ2JsYWNrc3F1YXJlJywgWzk2NDJdXSwgWydibGFja3RyaWFuZ2xlJywgWzk2NTJdXSwgWydibGFja3RyaWFuZ2xlZG93bicsIFs5NjYyXV0sIFsnYmxhY2t0cmlhbmdsZWxlZnQnLCBbOTY2Nl1dLCBbJ2JsYWNrdHJpYW5nbGVyaWdodCcsIFs5NjU2XV0sIFsnYmxhbmsnLCBbOTI1MV1dLCBbJ2JsazEyJywgWzk2MThdXSwgWydibGsxNCcsIFs5NjE3XV0sIFsnYmxrMzQnLCBbOTYxOV1dLCBbJ2Jsb2NrJywgWzk2MDhdXSwgWydibmUnLCBbNjEsIDg0MjFdXSwgWydibmVxdWl2JywgWzg4MDEsIDg0MjFdXSwgWydiTm90JywgWzEwOTg5XV0sIFsnYm5vdCcsIFs4OTc2XV0sIFsnQm9wZicsIFsxMjAxMjFdXSwgWydib3BmJywgWzEyMDE0N11dLCBbJ2JvdCcsIFs4ODY5XV0sIFsnYm90dG9tJywgWzg4NjldXSwgWydib3d0aWUnLCBbODkwNF1dLCBbJ2JveGJveCcsIFsxMDY5N11dLCBbJ2JveGRsJywgWzk0ODhdXSwgWydib3hkTCcsIFs5NTU3XV0sIFsnYm94RGwnLCBbOTU1OF1dLCBbJ2JveERMJywgWzk1NTldXSwgWydib3hkcicsIFs5NDg0XV0sIFsnYm94ZFInLCBbOTU1NF1dLCBbJ2JveERyJywgWzk1NTVdXSwgWydib3hEUicsIFs5NTU2XV0sIFsnYm94aCcsIFs5NDcyXV0sIFsnYm94SCcsIFs5NTUyXV0sIFsnYm94aGQnLCBbOTUxNl1dLCBbJ2JveEhkJywgWzk1NzJdXSwgWydib3hoRCcsIFs5NTczXV0sIFsnYm94SEQnLCBbOTU3NF1dLCBbJ2JveGh1JywgWzk1MjRdXSwgWydib3hIdScsIFs5NTc1XV0sIFsnYm94aFUnLCBbOTU3Nl1dLCBbJ2JveEhVJywgWzk1NzddXSwgWydib3htaW51cycsIFs4ODYzXV0sIFsnYm94cGx1cycsIFs4ODYyXV0sIFsnYm94dGltZXMnLCBbODg2NF1dLCBbJ2JveHVsJywgWzk0OTZdXSwgWydib3h1TCcsIFs5NTYzXV0sIFsnYm94VWwnLCBbOTU2NF1dLCBbJ2JveFVMJywgWzk1NjVdXSwgWydib3h1cicsIFs5NDkyXV0sIFsnYm94dVInLCBbOTU2MF1dLCBbJ2JveFVyJywgWzk1NjFdXSwgWydib3hVUicsIFs5NTYyXV0sIFsnYm94dicsIFs5NDc0XV0sIFsnYm94VicsIFs5NTUzXV0sIFsnYm94dmgnLCBbOTUzMl1dLCBbJ2JveHZIJywgWzk1NzhdXSwgWydib3hWaCcsIFs5NTc5XV0sIFsnYm94VkgnLCBbOTU4MF1dLCBbJ2JveHZsJywgWzk1MDhdXSwgWydib3h2TCcsIFs5NTY5XV0sIFsnYm94VmwnLCBbOTU3MF1dLCBbJ2JveFZMJywgWzk1NzFdXSwgWydib3h2cicsIFs5NTAwXV0sIFsnYm94dlInLCBbOTU2Nl1dLCBbJ2JveFZyJywgWzk1NjddXSwgWydib3hWUicsIFs5NTY4XV0sIFsnYnByaW1lJywgWzgyNDVdXSwgWydicmV2ZScsIFs3MjhdXSwgWydCcmV2ZScsIFs3MjhdXSwgWydicnZiYXInLCBbMTY2XV0sIFsnYnNjcicsIFsxMTk5OTFdXSwgWydCc2NyJywgWzg0OTJdXSwgWydic2VtaScsIFs4MjcxXV0sIFsnYnNpbScsIFs4NzY1XV0sIFsnYnNpbWUnLCBbODkwOV1dLCBbJ2Jzb2xiJywgWzEwNjkzXV0sIFsnYnNvbCcsIFs5Ml1dLCBbJ2Jzb2xoc3ViJywgWzEwMTg0XV0sIFsnYnVsbCcsIFs4MjI2XV0sIFsnYnVsbGV0JywgWzgyMjZdXSwgWydidW1wJywgWzg3ODJdXSwgWydidW1wRScsIFsxMDkyNl1dLCBbJ2J1bXBlJywgWzg3ODNdXSwgWydCdW1wZXEnLCBbODc4Ml1dLCBbJ2J1bXBlcScsIFs4NzgzXV0sIFsnQ2FjdXRlJywgWzI2Ml1dLCBbJ2NhY3V0ZScsIFsyNjNdXSwgWydjYXBhbmQnLCBbMTA4MjBdXSwgWydjYXBicmN1cCcsIFsxMDgyNV1dLCBbJ2NhcGNhcCcsIFsxMDgyN11dLCBbJ2NhcCcsIFs4NzQ1XV0sIFsnQ2FwJywgWzg5MTRdXSwgWydjYXBjdXAnLCBbMTA4MjNdXSwgWydjYXBkb3QnLCBbMTA4MTZdXSwgWydDYXBpdGFsRGlmZmVyZW50aWFsRCcsIFs4NTE3XV0sIFsnY2FwcycsIFs4NzQ1LCA2NTAyNF1dLCBbJ2NhcmV0JywgWzgyNTddXSwgWydjYXJvbicsIFs3MTFdXSwgWydDYXlsZXlzJywgWzg0OTNdXSwgWydjY2FwcycsIFsxMDgyOV1dLCBbJ0NjYXJvbicsIFsyNjhdXSwgWydjY2Fyb24nLCBbMjY5XV0sIFsnQ2NlZGlsJywgWzE5OV1dLCBbJ2NjZWRpbCcsIFsyMzFdXSwgWydDY2lyYycsIFsyNjRdXSwgWydjY2lyYycsIFsyNjVdXSwgWydDY29uaW50JywgWzg3NTJdXSwgWydjY3VwcycsIFsxMDgyOF1dLCBbJ2NjdXBzc20nLCBbMTA4MzJdXSwgWydDZG90JywgWzI2Nl1dLCBbJ2Nkb3QnLCBbMjY3XV0sIFsnY2VkaWwnLCBbMTg0XV0sIFsnQ2VkaWxsYScsIFsxODRdXSwgWydjZW1wdHl2JywgWzEwNjc0XV0sIFsnY2VudCcsIFsxNjJdXSwgWydjZW50ZXJkb3QnLCBbMTgzXV0sIFsnQ2VudGVyRG90JywgWzE4M11dLCBbJ2NmcicsIFsxMjAwOTZdXSwgWydDZnInLCBbODQ5M11dLCBbJ0NIY3knLCBbMTA2M11dLCBbJ2NoY3knLCBbMTA5NV1dLCBbJ2NoZWNrJywgWzEwMDAzXV0sIFsnY2hlY2ttYXJrJywgWzEwMDAzXV0sIFsnQ2hpJywgWzkzNV1dLCBbJ2NoaScsIFs5NjddXSwgWydjaXJjJywgWzcxMF1dLCBbJ2NpcmNlcScsIFs4NzkxXV0sIFsnY2lyY2xlYXJyb3dsZWZ0JywgWzg2MzRdXSwgWydjaXJjbGVhcnJvd3JpZ2h0JywgWzg2MzVdXSwgWydjaXJjbGVkYXN0JywgWzg4NTldXSwgWydjaXJjbGVkY2lyYycsIFs4ODU4XV0sIFsnY2lyY2xlZGRhc2gnLCBbODg2MV1dLCBbJ0NpcmNsZURvdCcsIFs4ODU3XV0sIFsnY2lyY2xlZFInLCBbMTc0XV0sIFsnY2lyY2xlZFMnLCBbOTQxNl1dLCBbJ0NpcmNsZU1pbnVzJywgWzg4NTRdXSwgWydDaXJjbGVQbHVzJywgWzg4NTNdXSwgWydDaXJjbGVUaW1lcycsIFs4ODU1XV0sIFsnY2lyJywgWzk2NzVdXSwgWydjaXJFJywgWzEwNjkxXV0sIFsnY2lyZScsIFs4NzkxXV0sIFsnY2lyZm5pbnQnLCBbMTA3NjhdXSwgWydjaXJtaWQnLCBbMTA5OTFdXSwgWydjaXJzY2lyJywgWzEwNjkwXV0sIFsnQ2xvY2t3aXNlQ29udG91ckludGVncmFsJywgWzg3NTRdXSwgWydjbHVicycsIFs5ODI3XV0sIFsnY2x1YnN1aXQnLCBbOTgyN11dLCBbJ2NvbG9uJywgWzU4XV0sIFsnQ29sb24nLCBbODc1OV1dLCBbJ0NvbG9uZScsIFsxMDg2OF1dLCBbJ2NvbG9uZScsIFs4Nzg4XV0sIFsnY29sb25lcScsIFs4Nzg4XV0sIFsnY29tbWEnLCBbNDRdXSwgWydjb21tYXQnLCBbNjRdXSwgWydjb21wJywgWzg3MDVdXSwgWydjb21wZm4nLCBbODcyOF1dLCBbJ2NvbXBsZW1lbnQnLCBbODcwNV1dLCBbJ2NvbXBsZXhlcycsIFs4NDUwXV0sIFsnY29uZycsIFs4NzczXV0sIFsnY29uZ2RvdCcsIFsxMDg2MV1dLCBbJ0NvbmdydWVudCcsIFs4ODAxXV0sIFsnY29uaW50JywgWzg3NTBdXSwgWydDb25pbnQnLCBbODc1MV1dLCBbJ0NvbnRvdXJJbnRlZ3JhbCcsIFs4NzUwXV0sIFsnY29wZicsIFsxMjAxNDhdXSwgWydDb3BmJywgWzg0NTBdXSwgWydjb3Byb2QnLCBbODcyMF1dLCBbJ0NvcHJvZHVjdCcsIFs4NzIwXV0sIFsnY29weScsIFsxNjldXSwgWydDT1BZJywgWzE2OV1dLCBbJ2NvcHlzcicsIFs4NDcxXV0sIFsnQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzU1XV0sIFsnY3JhcnInLCBbODYyOV1dLCBbJ2Nyb3NzJywgWzEwMDA3XV0sIFsnQ3Jvc3MnLCBbMTA3OTldXSwgWydDc2NyJywgWzExOTk2Nl1dLCBbJ2NzY3InLCBbMTE5OTkyXV0sIFsnY3N1YicsIFsxMDk1OV1dLCBbJ2NzdWJlJywgWzEwOTYxXV0sIFsnY3N1cCcsIFsxMDk2MF1dLCBbJ2NzdXBlJywgWzEwOTYyXV0sIFsnY3Rkb3QnLCBbODk0M11dLCBbJ2N1ZGFycmwnLCBbMTA1NTJdXSwgWydjdWRhcnJyJywgWzEwNTQ5XV0sIFsnY3VlcHInLCBbODkyNl1dLCBbJ2N1ZXNjJywgWzg5MjddXSwgWydjdWxhcnInLCBbODYzMF1dLCBbJ2N1bGFycnAnLCBbMTA1NTddXSwgWydjdXBicmNhcCcsIFsxMDgyNF1dLCBbJ2N1cGNhcCcsIFsxMDgyMl1dLCBbJ0N1cENhcCcsIFs4NzgxXV0sIFsnY3VwJywgWzg3NDZdXSwgWydDdXAnLCBbODkxNV1dLCBbJ2N1cGN1cCcsIFsxMDgyNl1dLCBbJ2N1cGRvdCcsIFs4ODQ1XV0sIFsnY3Vwb3InLCBbMTA4MjFdXSwgWydjdXBzJywgWzg3NDYsIDY1MDI0XV0sIFsnY3VyYXJyJywgWzg2MzFdXSwgWydjdXJhcnJtJywgWzEwNTU2XV0sIFsnY3VybHllcXByZWMnLCBbODkyNl1dLCBbJ2N1cmx5ZXFzdWNjJywgWzg5MjddXSwgWydjdXJseXZlZScsIFs4OTEwXV0sIFsnY3VybHl3ZWRnZScsIFs4OTExXV0sIFsnY3VycmVuJywgWzE2NF1dLCBbJ2N1cnZlYXJyb3dsZWZ0JywgWzg2MzBdXSwgWydjdXJ2ZWFycm93cmlnaHQnLCBbODYzMV1dLCBbJ2N1dmVlJywgWzg5MTBdXSwgWydjdXdlZCcsIFs4OTExXV0sIFsnY3djb25pbnQnLCBbODc1NF1dLCBbJ2N3aW50JywgWzg3NTNdXSwgWydjeWxjdHknLCBbOTAwNV1dLCBbJ2RhZ2dlcicsIFs4MjI0XV0sIFsnRGFnZ2VyJywgWzgyMjVdXSwgWydkYWxldGgnLCBbODUwNF1dLCBbJ2RhcnInLCBbODU5NV1dLCBbJ0RhcnInLCBbODYwOV1dLCBbJ2RBcnInLCBbODY1OV1dLCBbJ2Rhc2gnLCBbODIwOF1dLCBbJ0Rhc2h2JywgWzEwOTgwXV0sIFsnZGFzaHYnLCBbODg2N11dLCBbJ2Ria2Fyb3cnLCBbMTA1MTFdXSwgWydkYmxhYycsIFs3MzNdXSwgWydEY2Fyb24nLCBbMjcwXV0sIFsnZGNhcm9uJywgWzI3MV1dLCBbJ0RjeScsIFsxMDQ0XV0sIFsnZGN5JywgWzEwNzZdXSwgWydkZGFnZ2VyJywgWzgyMjVdXSwgWydkZGFycicsIFs4NjUwXV0sIFsnREQnLCBbODUxN11dLCBbJ2RkJywgWzg1MThdXSwgWydERG90cmFoZCcsIFsxMDUxM11dLCBbJ2Rkb3RzZXEnLCBbMTA4NzFdXSwgWydkZWcnLCBbMTc2XV0sIFsnRGVsJywgWzg3MTFdXSwgWydEZWx0YScsIFs5MTZdXSwgWydkZWx0YScsIFs5NDhdXSwgWydkZW1wdHl2JywgWzEwNjczXV0sIFsnZGZpc2h0JywgWzEwNjIzXV0sIFsnRGZyJywgWzEyMDA3MV1dLCBbJ2RmcicsIFsxMjAwOTddXSwgWydkSGFyJywgWzEwNTk3XV0sIFsnZGhhcmwnLCBbODY0M11dLCBbJ2RoYXJyJywgWzg2NDJdXSwgWydEaWFjcml0aWNhbEFjdXRlJywgWzE4MF1dLCBbJ0RpYWNyaXRpY2FsRG90JywgWzcyOV1dLCBbJ0RpYWNyaXRpY2FsRG91YmxlQWN1dGUnLCBbNzMzXV0sIFsnRGlhY3JpdGljYWxHcmF2ZScsIFs5Nl1dLCBbJ0RpYWNyaXRpY2FsVGlsZGUnLCBbNzMyXV0sIFsnZGlhbScsIFs4OTAwXV0sIFsnZGlhbW9uZCcsIFs4OTAwXV0sIFsnRGlhbW9uZCcsIFs4OTAwXV0sIFsnZGlhbW9uZHN1aXQnLCBbOTgzMF1dLCBbJ2RpYW1zJywgWzk4MzBdXSwgWydkaWUnLCBbMTY4XV0sIFsnRGlmZmVyZW50aWFsRCcsIFs4NTE4XV0sIFsnZGlnYW1tYScsIFs5ODldXSwgWydkaXNpbicsIFs4OTQ2XV0sIFsnZGl2JywgWzI0N11dLCBbJ2RpdmlkZScsIFsyNDddXSwgWydkaXZpZGVvbnRpbWVzJywgWzg5MDNdXSwgWydkaXZvbngnLCBbODkwM11dLCBbJ0RKY3knLCBbMTAyNl1dLCBbJ2RqY3knLCBbMTEwNl1dLCBbJ2RsY29ybicsIFs4OTkwXV0sIFsnZGxjcm9wJywgWzg5NzNdXSwgWydkb2xsYXInLCBbMzZdXSwgWydEb3BmJywgWzEyMDEyM11dLCBbJ2RvcGYnLCBbMTIwMTQ5XV0sIFsnRG90JywgWzE2OF1dLCBbJ2RvdCcsIFs3MjldXSwgWydEb3REb3QnLCBbODQxMl1dLCBbJ2RvdGVxJywgWzg3ODRdXSwgWydkb3RlcWRvdCcsIFs4Nzg1XV0sIFsnRG90RXF1YWwnLCBbODc4NF1dLCBbJ2RvdG1pbnVzJywgWzg3NjBdXSwgWydkb3RwbHVzJywgWzg3MjRdXSwgWydkb3RzcXVhcmUnLCBbODg2NV1dLCBbJ2RvdWJsZWJhcndlZGdlJywgWzg5NjZdXSwgWydEb3VibGVDb250b3VySW50ZWdyYWwnLCBbODc1MV1dLCBbJ0RvdWJsZURvdCcsIFsxNjhdXSwgWydEb3VibGVEb3duQXJyb3cnLCBbODY1OV1dLCBbJ0RvdWJsZUxlZnRBcnJvdycsIFs4NjU2XV0sIFsnRG91YmxlTGVmdFJpZ2h0QXJyb3cnLCBbODY2MF1dLCBbJ0RvdWJsZUxlZnRUZWUnLCBbMTA5ODBdXSwgWydEb3VibGVMb25nTGVmdEFycm93JywgWzEwMjMyXV0sIFsnRG91YmxlTG9uZ0xlZnRSaWdodEFycm93JywgWzEwMjM0XV0sIFsnRG91YmxlTG9uZ1JpZ2h0QXJyb3cnLCBbMTAyMzNdXSwgWydEb3VibGVSaWdodEFycm93JywgWzg2NThdXSwgWydEb3VibGVSaWdodFRlZScsIFs4ODcyXV0sIFsnRG91YmxlVXBBcnJvdycsIFs4NjU3XV0sIFsnRG91YmxlVXBEb3duQXJyb3cnLCBbODY2MV1dLCBbJ0RvdWJsZVZlcnRpY2FsQmFyJywgWzg3NDFdXSwgWydEb3duQXJyb3dCYXInLCBbMTA1MTVdXSwgWydkb3duYXJyb3cnLCBbODU5NV1dLCBbJ0Rvd25BcnJvdycsIFs4NTk1XV0sIFsnRG93bmFycm93JywgWzg2NTldXSwgWydEb3duQXJyb3dVcEFycm93JywgWzg2OTNdXSwgWydEb3duQnJldmUnLCBbNzg1XV0sIFsnZG93bmRvd25hcnJvd3MnLCBbODY1MF1dLCBbJ2Rvd25oYXJwb29ubGVmdCcsIFs4NjQzXV0sIFsnZG93bmhhcnBvb25yaWdodCcsIFs4NjQyXV0sIFsnRG93bkxlZnRSaWdodFZlY3RvcicsIFsxMDU3Nl1dLCBbJ0Rvd25MZWZ0VGVlVmVjdG9yJywgWzEwNTkwXV0sIFsnRG93bkxlZnRWZWN0b3JCYXInLCBbMTA1ODJdXSwgWydEb3duTGVmdFZlY3RvcicsIFs4NjM3XV0sIFsnRG93blJpZ2h0VGVlVmVjdG9yJywgWzEwNTkxXV0sIFsnRG93blJpZ2h0VmVjdG9yQmFyJywgWzEwNTgzXV0sIFsnRG93blJpZ2h0VmVjdG9yJywgWzg2NDFdXSwgWydEb3duVGVlQXJyb3cnLCBbODYxNV1dLCBbJ0Rvd25UZWUnLCBbODg2OF1dLCBbJ2RyYmthcm93JywgWzEwNTEyXV0sIFsnZHJjb3JuJywgWzg5OTFdXSwgWydkcmNyb3AnLCBbODk3Ml1dLCBbJ0RzY3InLCBbMTE5OTY3XV0sIFsnZHNjcicsIFsxMTk5OTNdXSwgWydEU2N5JywgWzEwMjldXSwgWydkc2N5JywgWzExMDldXSwgWydkc29sJywgWzEwNzQyXV0sIFsnRHN0cm9rJywgWzI3Ml1dLCBbJ2RzdHJvaycsIFsyNzNdXSwgWydkdGRvdCcsIFs4OTQ1XV0sIFsnZHRyaScsIFs5NjYzXV0sIFsnZHRyaWYnLCBbOTY2Ml1dLCBbJ2R1YXJyJywgWzg2OTNdXSwgWydkdWhhcicsIFsxMDYwN11dLCBbJ2R3YW5nbGUnLCBbMTA2NjJdXSwgWydEWmN5JywgWzEwMzldXSwgWydkemN5JywgWzExMTldXSwgWydkemlncmFycicsIFsxMDIzOV1dLCBbJ0VhY3V0ZScsIFsyMDFdXSwgWydlYWN1dGUnLCBbMjMzXV0sIFsnZWFzdGVyJywgWzEwODYyXV0sIFsnRWNhcm9uJywgWzI4Ml1dLCBbJ2VjYXJvbicsIFsyODNdXSwgWydFY2lyYycsIFsyMDJdXSwgWydlY2lyYycsIFsyMzRdXSwgWydlY2lyJywgWzg3OTBdXSwgWydlY29sb24nLCBbODc4OV1dLCBbJ0VjeScsIFsxMDY5XV0sIFsnZWN5JywgWzExMDFdXSwgWydlRERvdCcsIFsxMDg3MV1dLCBbJ0Vkb3QnLCBbMjc4XV0sIFsnZWRvdCcsIFsyNzldXSwgWydlRG90JywgWzg3ODVdXSwgWydlZScsIFs4NTE5XV0sIFsnZWZEb3QnLCBbODc4Nl1dLCBbJ0VmcicsIFsxMjAwNzJdXSwgWydlZnInLCBbMTIwMDk4XV0sIFsnZWcnLCBbMTA5MDZdXSwgWydFZ3JhdmUnLCBbMjAwXV0sIFsnZWdyYXZlJywgWzIzMl1dLCBbJ2VncycsIFsxMDkwMl1dLCBbJ2Vnc2RvdCcsIFsxMDkwNF1dLCBbJ2VsJywgWzEwOTA1XV0sIFsnRWxlbWVudCcsIFs4NzEyXV0sIFsnZWxpbnRlcnMnLCBbOTE5MV1dLCBbJ2VsbCcsIFs4NDY3XV0sIFsnZWxzJywgWzEwOTAxXV0sIFsnZWxzZG90JywgWzEwOTAzXV0sIFsnRW1hY3InLCBbMjc0XV0sIFsnZW1hY3InLCBbMjc1XV0sIFsnZW1wdHknLCBbODcwOV1dLCBbJ2VtcHR5c2V0JywgWzg3MDldXSwgWydFbXB0eVNtYWxsU3F1YXJlJywgWzk3MjNdXSwgWydlbXB0eXYnLCBbODcwOV1dLCBbJ0VtcHR5VmVyeVNtYWxsU3F1YXJlJywgWzk2NDNdXSwgWydlbXNwMTMnLCBbODE5Nl1dLCBbJ2Vtc3AxNCcsIFs4MTk3XV0sIFsnZW1zcCcsIFs4MTk1XV0sIFsnRU5HJywgWzMzMF1dLCBbJ2VuZycsIFszMzFdXSwgWydlbnNwJywgWzgxOTRdXSwgWydFb2dvbicsIFsyODBdXSwgWydlb2dvbicsIFsyODFdXSwgWydFb3BmJywgWzEyMDEyNF1dLCBbJ2VvcGYnLCBbMTIwMTUwXV0sIFsnZXBhcicsIFs4OTE3XV0sIFsnZXBhcnNsJywgWzEwNzIzXV0sIFsnZXBsdXMnLCBbMTA4NjVdXSwgWydlcHNpJywgWzk0OV1dLCBbJ0Vwc2lsb24nLCBbOTE3XV0sIFsnZXBzaWxvbicsIFs5NDldXSwgWydlcHNpdicsIFsxMDEzXV0sIFsnZXFjaXJjJywgWzg3OTBdXSwgWydlcWNvbG9uJywgWzg3ODldXSwgWydlcXNpbScsIFs4NzcwXV0sIFsnZXFzbGFudGd0cicsIFsxMDkwMl1dLCBbJ2Vxc2xhbnRsZXNzJywgWzEwOTAxXV0sIFsnRXF1YWwnLCBbMTA4NjldXSwgWydlcXVhbHMnLCBbNjFdXSwgWydFcXVhbFRpbGRlJywgWzg3NzBdXSwgWydlcXVlc3QnLCBbODc5OV1dLCBbJ0VxdWlsaWJyaXVtJywgWzg2NTJdXSwgWydlcXVpdicsIFs4ODAxXV0sIFsnZXF1aXZERCcsIFsxMDg3Ml1dLCBbJ2VxdnBhcnNsJywgWzEwNzI1XV0sIFsnZXJhcnInLCBbMTA2MDldXSwgWydlckRvdCcsIFs4Nzg3XV0sIFsnZXNjcicsIFs4NDk1XV0sIFsnRXNjcicsIFs4NDk2XV0sIFsnZXNkb3QnLCBbODc4NF1dLCBbJ0VzaW0nLCBbMTA4NjddXSwgWydlc2ltJywgWzg3NzBdXSwgWydFdGEnLCBbOTE5XV0sIFsnZXRhJywgWzk1MV1dLCBbJ0VUSCcsIFsyMDhdXSwgWydldGgnLCBbMjQwXV0sIFsnRXVtbCcsIFsyMDNdXSwgWydldW1sJywgWzIzNV1dLCBbJ2V1cm8nLCBbODM2NF1dLCBbJ2V4Y2wnLCBbMzNdXSwgWydleGlzdCcsIFs4NzA3XV0sIFsnRXhpc3RzJywgWzg3MDddXSwgWydleHBlY3RhdGlvbicsIFs4NDk2XV0sIFsnZXhwb25lbnRpYWxlJywgWzg1MTldXSwgWydFeHBvbmVudGlhbEUnLCBbODUxOV1dLCBbJ2ZhbGxpbmdkb3RzZXEnLCBbODc4Nl1dLCBbJ0ZjeScsIFsxMDYwXV0sIFsnZmN5JywgWzEwOTJdXSwgWydmZW1hbGUnLCBbOTc5Ml1dLCBbJ2ZmaWxpZycsIFs2NDI1OV1dLCBbJ2ZmbGlnJywgWzY0MjU2XV0sIFsnZmZsbGlnJywgWzY0MjYwXV0sIFsnRmZyJywgWzEyMDA3M11dLCBbJ2ZmcicsIFsxMjAwOTldXSwgWydmaWxpZycsIFs2NDI1N11dLCBbJ0ZpbGxlZFNtYWxsU3F1YXJlJywgWzk3MjRdXSwgWydGaWxsZWRWZXJ5U21hbGxTcXVhcmUnLCBbOTY0Ml1dLCBbJ2ZqbGlnJywgWzEwMiwgMTA2XV0sIFsnZmxhdCcsIFs5ODM3XV0sIFsnZmxsaWcnLCBbNjQyNThdXSwgWydmbHRucycsIFs5NjQ5XV0sIFsnZm5vZicsIFs0MDJdXSwgWydGb3BmJywgWzEyMDEyNV1dLCBbJ2ZvcGYnLCBbMTIwMTUxXV0sIFsnZm9yYWxsJywgWzg3MDRdXSwgWydGb3JBbGwnLCBbODcwNF1dLCBbJ2ZvcmsnLCBbODkxNl1dLCBbJ2Zvcmt2JywgWzEwOTY5XV0sIFsnRm91cmllcnRyZicsIFs4NDk3XV0sIFsnZnBhcnRpbnQnLCBbMTA3NjVdXSwgWydmcmFjMTInLCBbMTg5XV0sIFsnZnJhYzEzJywgWzg1MzFdXSwgWydmcmFjMTQnLCBbMTg4XV0sIFsnZnJhYzE1JywgWzg1MzNdXSwgWydmcmFjMTYnLCBbODUzN11dLCBbJ2ZyYWMxOCcsIFs4NTM5XV0sIFsnZnJhYzIzJywgWzg1MzJdXSwgWydmcmFjMjUnLCBbODUzNF1dLCBbJ2ZyYWMzNCcsIFsxOTBdXSwgWydmcmFjMzUnLCBbODUzNV1dLCBbJ2ZyYWMzOCcsIFs4NTQwXV0sIFsnZnJhYzQ1JywgWzg1MzZdXSwgWydmcmFjNTYnLCBbODUzOF1dLCBbJ2ZyYWM1OCcsIFs4NTQxXV0sIFsnZnJhYzc4JywgWzg1NDJdXSwgWydmcmFzbCcsIFs4MjYwXV0sIFsnZnJvd24nLCBbODk5NF1dLCBbJ2ZzY3InLCBbMTE5OTk1XV0sIFsnRnNjcicsIFs4NDk3XV0sIFsnZ2FjdXRlJywgWzUwMV1dLCBbJ0dhbW1hJywgWzkxNV1dLCBbJ2dhbW1hJywgWzk0N11dLCBbJ0dhbW1hZCcsIFs5ODhdXSwgWydnYW1tYWQnLCBbOTg5XV0sIFsnZ2FwJywgWzEwODg2XV0sIFsnR2JyZXZlJywgWzI4Nl1dLCBbJ2dicmV2ZScsIFsyODddXSwgWydHY2VkaWwnLCBbMjkwXV0sIFsnR2NpcmMnLCBbMjg0XV0sIFsnZ2NpcmMnLCBbMjg1XV0sIFsnR2N5JywgWzEwNDNdXSwgWydnY3knLCBbMTA3NV1dLCBbJ0dkb3QnLCBbMjg4XV0sIFsnZ2RvdCcsIFsyODldXSwgWydnZScsIFs4ODA1XV0sIFsnZ0UnLCBbODgwN11dLCBbJ2dFbCcsIFsxMDg5Ml1dLCBbJ2dlbCcsIFs4OTIzXV0sIFsnZ2VxJywgWzg4MDVdXSwgWydnZXFxJywgWzg4MDddXSwgWydnZXFzbGFudCcsIFsxMDg3OF1dLCBbJ2dlc2NjJywgWzEwOTIxXV0sIFsnZ2VzJywgWzEwODc4XV0sIFsnZ2VzZG90JywgWzEwODgwXV0sIFsnZ2VzZG90bycsIFsxMDg4Ml1dLCBbJ2dlc2RvdG9sJywgWzEwODg0XV0sIFsnZ2VzbCcsIFs4OTIzLCA2NTAyNF1dLCBbJ2dlc2xlcycsIFsxMDkwMF1dLCBbJ0dmcicsIFsxMjAwNzRdXSwgWydnZnInLCBbMTIwMTAwXV0sIFsnZ2cnLCBbODgxMV1dLCBbJ0dnJywgWzg5MjFdXSwgWydnZ2cnLCBbODkyMV1dLCBbJ2dpbWVsJywgWzg1MDNdXSwgWydHSmN5JywgWzEwMjddXSwgWydnamN5JywgWzExMDddXSwgWydnbGEnLCBbMTA5MTddXSwgWydnbCcsIFs4ODIzXV0sIFsnZ2xFJywgWzEwODk4XV0sIFsnZ2xqJywgWzEwOTE2XV0sIFsnZ25hcCcsIFsxMDg5MF1dLCBbJ2duYXBwcm94JywgWzEwODkwXV0sIFsnZ25lJywgWzEwODg4XV0sIFsnZ25FJywgWzg4MDldXSwgWydnbmVxJywgWzEwODg4XV0sIFsnZ25lcXEnLCBbODgwOV1dLCBbJ2duc2ltJywgWzg5MzVdXSwgWydHb3BmJywgWzEyMDEyNl1dLCBbJ2dvcGYnLCBbMTIwMTUyXV0sIFsnZ3JhdmUnLCBbOTZdXSwgWydHcmVhdGVyRXF1YWwnLCBbODgwNV1dLCBbJ0dyZWF0ZXJFcXVhbExlc3MnLCBbODkyM11dLCBbJ0dyZWF0ZXJGdWxsRXF1YWwnLCBbODgwN11dLCBbJ0dyZWF0ZXJHcmVhdGVyJywgWzEwOTE0XV0sIFsnR3JlYXRlckxlc3MnLCBbODgyM11dLCBbJ0dyZWF0ZXJTbGFudEVxdWFsJywgWzEwODc4XV0sIFsnR3JlYXRlclRpbGRlJywgWzg4MTldXSwgWydHc2NyJywgWzExOTk3MF1dLCBbJ2dzY3InLCBbODQ1OF1dLCBbJ2dzaW0nLCBbODgxOV1dLCBbJ2dzaW1lJywgWzEwODk0XV0sIFsnZ3NpbWwnLCBbMTA4OTZdXSwgWydndGNjJywgWzEwOTE5XV0sIFsnZ3RjaXInLCBbMTA4NzRdXSwgWydndCcsIFs2Ml1dLCBbJ0dUJywgWzYyXV0sIFsnR3QnLCBbODgxMV1dLCBbJ2d0ZG90JywgWzg5MTldXSwgWydndGxQYXInLCBbMTA2NDVdXSwgWydndHF1ZXN0JywgWzEwODc2XV0sIFsnZ3RyYXBwcm94JywgWzEwODg2XV0sIFsnZ3RyYXJyJywgWzEwNjE2XV0sIFsnZ3RyZG90JywgWzg5MTldXSwgWydndHJlcWxlc3MnLCBbODkyM11dLCBbJ2d0cmVxcWxlc3MnLCBbMTA4OTJdXSwgWydndHJsZXNzJywgWzg4MjNdXSwgWydndHJzaW0nLCBbODgxOV1dLCBbJ2d2ZXJ0bmVxcScsIFs4ODA5LCA2NTAyNF1dLCBbJ2d2bkUnLCBbODgwOSwgNjUwMjRdXSwgWydIYWNlaycsIFs3MTFdXSwgWydoYWlyc3AnLCBbODIwMl1dLCBbJ2hhbGYnLCBbMTg5XV0sIFsnaGFtaWx0JywgWzg0NTldXSwgWydIQVJEY3knLCBbMTA2Nl1dLCBbJ2hhcmRjeScsIFsxMDk4XV0sIFsnaGFycmNpcicsIFsxMDU2OF1dLCBbJ2hhcnInLCBbODU5Nl1dLCBbJ2hBcnInLCBbODY2MF1dLCBbJ2hhcnJ3JywgWzg2MjFdXSwgWydIYXQnLCBbOTRdXSwgWydoYmFyJywgWzg0NjNdXSwgWydIY2lyYycsIFsyOTJdXSwgWydoY2lyYycsIFsyOTNdXSwgWydoZWFydHMnLCBbOTgyOV1dLCBbJ2hlYXJ0c3VpdCcsIFs5ODI5XV0sIFsnaGVsbGlwJywgWzgyMzBdXSwgWydoZXJjb24nLCBbODg4OV1dLCBbJ2hmcicsIFsxMjAxMDFdXSwgWydIZnInLCBbODQ2MF1dLCBbJ0hpbGJlcnRTcGFjZScsIFs4NDU5XV0sIFsnaGtzZWFyb3cnLCBbMTA1MzNdXSwgWydoa3N3YXJvdycsIFsxMDUzNF1dLCBbJ2hvYXJyJywgWzg3MDNdXSwgWydob210aHQnLCBbODc2M11dLCBbJ2hvb2tsZWZ0YXJyb3cnLCBbODYxN11dLCBbJ2hvb2tyaWdodGFycm93JywgWzg2MThdXSwgWydob3BmJywgWzEyMDE1M11dLCBbJ0hvcGYnLCBbODQ2MV1dLCBbJ2hvcmJhcicsIFs4MjEzXV0sIFsnSG9yaXpvbnRhbExpbmUnLCBbOTQ3Ml1dLCBbJ2hzY3InLCBbMTE5OTk3XV0sIFsnSHNjcicsIFs4NDU5XV0sIFsnaHNsYXNoJywgWzg0NjNdXSwgWydIc3Ryb2snLCBbMjk0XV0sIFsnaHN0cm9rJywgWzI5NV1dLCBbJ0h1bXBEb3duSHVtcCcsIFs4NzgyXV0sIFsnSHVtcEVxdWFsJywgWzg3ODNdXSwgWydoeWJ1bGwnLCBbODI1OV1dLCBbJ2h5cGhlbicsIFs4MjA4XV0sIFsnSWFjdXRlJywgWzIwNV1dLCBbJ2lhY3V0ZScsIFsyMzddXSwgWydpYycsIFs4MjkxXV0sIFsnSWNpcmMnLCBbMjA2XV0sIFsnaWNpcmMnLCBbMjM4XV0sIFsnSWN5JywgWzEwNDhdXSwgWydpY3knLCBbMTA4MF1dLCBbJ0lkb3QnLCBbMzA0XV0sIFsnSUVjeScsIFsxMDQ1XV0sIFsnaWVjeScsIFsxMDc3XV0sIFsnaWV4Y2wnLCBbMTYxXV0sIFsnaWZmJywgWzg2NjBdXSwgWydpZnInLCBbMTIwMTAyXV0sIFsnSWZyJywgWzg0NjVdXSwgWydJZ3JhdmUnLCBbMjA0XV0sIFsnaWdyYXZlJywgWzIzNl1dLCBbJ2lpJywgWzg1MjBdXSwgWydpaWlpbnQnLCBbMTA3NjRdXSwgWydpaWludCcsIFs4NzQ5XV0sIFsnaWluZmluJywgWzEwNzE2XV0sIFsnaWlvdGEnLCBbODQ4OV1dLCBbJ0lKbGlnJywgWzMwNl1dLCBbJ2lqbGlnJywgWzMwN11dLCBbJ0ltYWNyJywgWzI5OF1dLCBbJ2ltYWNyJywgWzI5OV1dLCBbJ2ltYWdlJywgWzg0NjVdXSwgWydJbWFnaW5hcnlJJywgWzg1MjBdXSwgWydpbWFnbGluZScsIFs4NDY0XV0sIFsnaW1hZ3BhcnQnLCBbODQ2NV1dLCBbJ2ltYXRoJywgWzMwNV1dLCBbJ0ltJywgWzg0NjVdXSwgWydpbW9mJywgWzg4ODddXSwgWydpbXBlZCcsIFs0MzddXSwgWydJbXBsaWVzJywgWzg2NThdXSwgWydpbmNhcmUnLCBbODQ1M11dLCBbJ2luJywgWzg3MTJdXSwgWydpbmZpbicsIFs4NzM0XV0sIFsnaW5maW50aWUnLCBbMTA3MTddXSwgWydpbm9kb3QnLCBbMzA1XV0sIFsnaW50Y2FsJywgWzg4OTBdXSwgWydpbnQnLCBbODc0N11dLCBbJ0ludCcsIFs4NzQ4XV0sIFsnaW50ZWdlcnMnLCBbODQ4NF1dLCBbJ0ludGVncmFsJywgWzg3NDddXSwgWydpbnRlcmNhbCcsIFs4ODkwXV0sIFsnSW50ZXJzZWN0aW9uJywgWzg4OThdXSwgWydpbnRsYXJoaycsIFsxMDc3NV1dLCBbJ2ludHByb2QnLCBbMTA4MTJdXSwgWydJbnZpc2libGVDb21tYScsIFs4MjkxXV0sIFsnSW52aXNpYmxlVGltZXMnLCBbODI5MF1dLCBbJ0lPY3knLCBbMTAyNV1dLCBbJ2lvY3knLCBbMTEwNV1dLCBbJ0lvZ29uJywgWzMwMl1dLCBbJ2lvZ29uJywgWzMwM11dLCBbJ0lvcGYnLCBbMTIwMTI4XV0sIFsnaW9wZicsIFsxMjAxNTRdXSwgWydJb3RhJywgWzkyMV1dLCBbJ2lvdGEnLCBbOTUzXV0sIFsnaXByb2QnLCBbMTA4MTJdXSwgWydpcXVlc3QnLCBbMTkxXV0sIFsnaXNjcicsIFsxMTk5OThdXSwgWydJc2NyJywgWzg0NjRdXSwgWydpc2luJywgWzg3MTJdXSwgWydpc2luZG90JywgWzg5NDldXSwgWydpc2luRScsIFs4OTUzXV0sIFsnaXNpbnMnLCBbODk0OF1dLCBbJ2lzaW5zdicsIFs4OTQ3XV0sIFsnaXNpbnYnLCBbODcxMl1dLCBbJ2l0JywgWzgyOTBdXSwgWydJdGlsZGUnLCBbMjk2XV0sIFsnaXRpbGRlJywgWzI5N11dLCBbJ0l1a2N5JywgWzEwMzBdXSwgWydpdWtjeScsIFsxMTEwXV0sIFsnSXVtbCcsIFsyMDddXSwgWydpdW1sJywgWzIzOV1dLCBbJ0pjaXJjJywgWzMwOF1dLCBbJ2pjaXJjJywgWzMwOV1dLCBbJ0pjeScsIFsxMDQ5XV0sIFsnamN5JywgWzEwODFdXSwgWydKZnInLCBbMTIwMDc3XV0sIFsnamZyJywgWzEyMDEwM11dLCBbJ2ptYXRoJywgWzU2N11dLCBbJ0pvcGYnLCBbMTIwMTI5XV0sIFsnam9wZicsIFsxMjAxNTVdXSwgWydKc2NyJywgWzExOTk3M11dLCBbJ2pzY3InLCBbMTE5OTk5XV0sIFsnSnNlcmN5JywgWzEwMzJdXSwgWydqc2VyY3knLCBbMTExMl1dLCBbJ0p1a2N5JywgWzEwMjhdXSwgWydqdWtjeScsIFsxMTA4XV0sIFsnS2FwcGEnLCBbOTIyXV0sIFsna2FwcGEnLCBbOTU0XV0sIFsna2FwcGF2JywgWzEwMDhdXSwgWydLY2VkaWwnLCBbMzEwXV0sIFsna2NlZGlsJywgWzMxMV1dLCBbJ0tjeScsIFsxMDUwXV0sIFsna2N5JywgWzEwODJdXSwgWydLZnInLCBbMTIwMDc4XV0sIFsna2ZyJywgWzEyMDEwNF1dLCBbJ2tncmVlbicsIFszMTJdXSwgWydLSGN5JywgWzEwNjFdXSwgWydraGN5JywgWzEwOTNdXSwgWydLSmN5JywgWzEwMzZdXSwgWydramN5JywgWzExMTZdXSwgWydLb3BmJywgWzEyMDEzMF1dLCBbJ2tvcGYnLCBbMTIwMTU2XV0sIFsnS3NjcicsIFsxMTk5NzRdXSwgWydrc2NyJywgWzEyMDAwMF1dLCBbJ2xBYXJyJywgWzg2NjZdXSwgWydMYWN1dGUnLCBbMzEzXV0sIFsnbGFjdXRlJywgWzMxNF1dLCBbJ2xhZW1wdHl2JywgWzEwNjc2XV0sIFsnbGFncmFuJywgWzg0NjZdXSwgWydMYW1iZGEnLCBbOTIzXV0sIFsnbGFtYmRhJywgWzk1NV1dLCBbJ2xhbmcnLCBbMTAyMTZdXSwgWydMYW5nJywgWzEwMjE4XV0sIFsnbGFuZ2QnLCBbMTA2NDFdXSwgWydsYW5nbGUnLCBbMTAyMTZdXSwgWydsYXAnLCBbMTA4ODVdXSwgWydMYXBsYWNldHJmJywgWzg0NjZdXSwgWydsYXF1bycsIFsxNzFdXSwgWydsYXJyYicsIFs4Njc2XV0sIFsnbGFycmJmcycsIFsxMDUyN11dLCBbJ2xhcnInLCBbODU5Ml1dLCBbJ0xhcnInLCBbODYwNl1dLCBbJ2xBcnInLCBbODY1Nl1dLCBbJ2xhcnJmcycsIFsxMDUyNV1dLCBbJ2xhcnJoaycsIFs4NjE3XV0sIFsnbGFycmxwJywgWzg2MTldXSwgWydsYXJycGwnLCBbMTA1NTNdXSwgWydsYXJyc2ltJywgWzEwNjExXV0sIFsnbGFycnRsJywgWzg2MTBdXSwgWydsYXRhaWwnLCBbMTA1MjFdXSwgWydsQXRhaWwnLCBbMTA1MjNdXSwgWydsYXQnLCBbMTA5MjNdXSwgWydsYXRlJywgWzEwOTI1XV0sIFsnbGF0ZXMnLCBbMTA5MjUsIDY1MDI0XV0sIFsnbGJhcnInLCBbMTA1MDhdXSwgWydsQmFycicsIFsxMDUxMF1dLCBbJ2xiYnJrJywgWzEwMDk4XV0sIFsnbGJyYWNlJywgWzEyM11dLCBbJ2xicmFjaycsIFs5MV1dLCBbJ2xicmtlJywgWzEwNjM1XV0sIFsnbGJya3NsZCcsIFsxMDYzOV1dLCBbJ2xicmtzbHUnLCBbMTA2MzddXSwgWydMY2Fyb24nLCBbMzE3XV0sIFsnbGNhcm9uJywgWzMxOF1dLCBbJ0xjZWRpbCcsIFszMTVdXSwgWydsY2VkaWwnLCBbMzE2XV0sIFsnbGNlaWwnLCBbODk2OF1dLCBbJ2xjdWInLCBbMTIzXV0sIFsnTGN5JywgWzEwNTFdXSwgWydsY3knLCBbMTA4M11dLCBbJ2xkY2EnLCBbMTA1NTBdXSwgWydsZHF1bycsIFs4MjIwXV0sIFsnbGRxdW9yJywgWzgyMjJdXSwgWydsZHJkaGFyJywgWzEwNTk5XV0sIFsnbGRydXNoYXInLCBbMTA1NzFdXSwgWydsZHNoJywgWzg2MjZdXSwgWydsZScsIFs4ODA0XV0sIFsnbEUnLCBbODgwNl1dLCBbJ0xlZnRBbmdsZUJyYWNrZXQnLCBbMTAyMTZdXSwgWydMZWZ0QXJyb3dCYXInLCBbODY3Nl1dLCBbJ2xlZnRhcnJvdycsIFs4NTkyXV0sIFsnTGVmdEFycm93JywgWzg1OTJdXSwgWydMZWZ0YXJyb3cnLCBbODY1Nl1dLCBbJ0xlZnRBcnJvd1JpZ2h0QXJyb3cnLCBbODY0Nl1dLCBbJ2xlZnRhcnJvd3RhaWwnLCBbODYxMF1dLCBbJ0xlZnRDZWlsaW5nJywgWzg5NjhdXSwgWydMZWZ0RG91YmxlQnJhY2tldCcsIFsxMDIxNF1dLCBbJ0xlZnREb3duVGVlVmVjdG9yJywgWzEwNTkzXV0sIFsnTGVmdERvd25WZWN0b3JCYXInLCBbMTA1ODVdXSwgWydMZWZ0RG93blZlY3RvcicsIFs4NjQzXV0sIFsnTGVmdEZsb29yJywgWzg5NzBdXSwgWydsZWZ0aGFycG9vbmRvd24nLCBbODYzN11dLCBbJ2xlZnRoYXJwb29udXAnLCBbODYzNl1dLCBbJ2xlZnRsZWZ0YXJyb3dzJywgWzg2NDddXSwgWydsZWZ0cmlnaHRhcnJvdycsIFs4NTk2XV0sIFsnTGVmdFJpZ2h0QXJyb3cnLCBbODU5Nl1dLCBbJ0xlZnRyaWdodGFycm93JywgWzg2NjBdXSwgWydsZWZ0cmlnaHRhcnJvd3MnLCBbODY0Nl1dLCBbJ2xlZnRyaWdodGhhcnBvb25zJywgWzg2NTFdXSwgWydsZWZ0cmlnaHRzcXVpZ2Fycm93JywgWzg2MjFdXSwgWydMZWZ0UmlnaHRWZWN0b3InLCBbMTA1NzRdXSwgWydMZWZ0VGVlQXJyb3cnLCBbODYxMl1dLCBbJ0xlZnRUZWUnLCBbODg2N11dLCBbJ0xlZnRUZWVWZWN0b3InLCBbMTA1ODZdXSwgWydsZWZ0dGhyZWV0aW1lcycsIFs4OTA3XV0sIFsnTGVmdFRyaWFuZ2xlQmFyJywgWzEwNzAzXV0sIFsnTGVmdFRyaWFuZ2xlJywgWzg4ODJdXSwgWydMZWZ0VHJpYW5nbGVFcXVhbCcsIFs4ODg0XV0sIFsnTGVmdFVwRG93blZlY3RvcicsIFsxMDU3N11dLCBbJ0xlZnRVcFRlZVZlY3RvcicsIFsxMDU5Ml1dLCBbJ0xlZnRVcFZlY3RvckJhcicsIFsxMDU4NF1dLCBbJ0xlZnRVcFZlY3RvcicsIFs4NjM5XV0sIFsnTGVmdFZlY3RvckJhcicsIFsxMDU3OF1dLCBbJ0xlZnRWZWN0b3InLCBbODYzNl1dLCBbJ2xFZycsIFsxMDg5MV1dLCBbJ2xlZycsIFs4OTIyXV0sIFsnbGVxJywgWzg4MDRdXSwgWydsZXFxJywgWzg4MDZdXSwgWydsZXFzbGFudCcsIFsxMDg3N11dLCBbJ2xlc2NjJywgWzEwOTIwXV0sIFsnbGVzJywgWzEwODc3XV0sIFsnbGVzZG90JywgWzEwODc5XV0sIFsnbGVzZG90bycsIFsxMDg4MV1dLCBbJ2xlc2RvdG9yJywgWzEwODgzXV0sIFsnbGVzZycsIFs4OTIyLCA2NTAyNF1dLCBbJ2xlc2dlcycsIFsxMDg5OV1dLCBbJ2xlc3NhcHByb3gnLCBbMTA4ODVdXSwgWydsZXNzZG90JywgWzg5MThdXSwgWydsZXNzZXFndHInLCBbODkyMl1dLCBbJ2xlc3NlcXFndHInLCBbMTA4OTFdXSwgWydMZXNzRXF1YWxHcmVhdGVyJywgWzg5MjJdXSwgWydMZXNzRnVsbEVxdWFsJywgWzg4MDZdXSwgWydMZXNzR3JlYXRlcicsIFs4ODIyXV0sIFsnbGVzc2d0cicsIFs4ODIyXV0sIFsnTGVzc0xlc3MnLCBbMTA5MTNdXSwgWydsZXNzc2ltJywgWzg4MThdXSwgWydMZXNzU2xhbnRFcXVhbCcsIFsxMDg3N11dLCBbJ0xlc3NUaWxkZScsIFs4ODE4XV0sIFsnbGZpc2h0JywgWzEwNjIwXV0sIFsnbGZsb29yJywgWzg5NzBdXSwgWydMZnInLCBbMTIwMDc5XV0sIFsnbGZyJywgWzEyMDEwNV1dLCBbJ2xnJywgWzg4MjJdXSwgWydsZ0UnLCBbMTA4OTddXSwgWydsSGFyJywgWzEwNTk0XV0sIFsnbGhhcmQnLCBbODYzN11dLCBbJ2xoYXJ1JywgWzg2MzZdXSwgWydsaGFydWwnLCBbMTA2MDJdXSwgWydsaGJsaycsIFs5NjA0XV0sIFsnTEpjeScsIFsxMDMzXV0sIFsnbGpjeScsIFsxMTEzXV0sIFsnbGxhcnInLCBbODY0N11dLCBbJ2xsJywgWzg4MTBdXSwgWydMbCcsIFs4OTIwXV0sIFsnbGxjb3JuZXInLCBbODk5MF1dLCBbJ0xsZWZ0YXJyb3cnLCBbODY2Nl1dLCBbJ2xsaGFyZCcsIFsxMDYwM11dLCBbJ2xsdHJpJywgWzk3MjJdXSwgWydMbWlkb3QnLCBbMzE5XV0sIFsnbG1pZG90JywgWzMyMF1dLCBbJ2xtb3VzdGFjaGUnLCBbOTEzNl1dLCBbJ2xtb3VzdCcsIFs5MTM2XV0sIFsnbG5hcCcsIFsxMDg4OV1dLCBbJ2xuYXBwcm94JywgWzEwODg5XV0sIFsnbG5lJywgWzEwODg3XV0sIFsnbG5FJywgWzg4MDhdXSwgWydsbmVxJywgWzEwODg3XV0sIFsnbG5lcXEnLCBbODgwOF1dLCBbJ2xuc2ltJywgWzg5MzRdXSwgWydsb2FuZycsIFsxMDIyMF1dLCBbJ2xvYXJyJywgWzg3MDFdXSwgWydsb2JyaycsIFsxMDIxNF1dLCBbJ2xvbmdsZWZ0YXJyb3cnLCBbMTAyMjldXSwgWydMb25nTGVmdEFycm93JywgWzEwMjI5XV0sIFsnTG9uZ2xlZnRhcnJvdycsIFsxMDIzMl1dLCBbJ2xvbmdsZWZ0cmlnaHRhcnJvdycsIFsxMDIzMV1dLCBbJ0xvbmdMZWZ0UmlnaHRBcnJvdycsIFsxMDIzMV1dLCBbJ0xvbmdsZWZ0cmlnaHRhcnJvdycsIFsxMDIzNF1dLCBbJ2xvbmdtYXBzdG8nLCBbMTAyMzZdXSwgWydsb25ncmlnaHRhcnJvdycsIFsxMDIzMF1dLCBbJ0xvbmdSaWdodEFycm93JywgWzEwMjMwXV0sIFsnTG9uZ3JpZ2h0YXJyb3cnLCBbMTAyMzNdXSwgWydsb29wYXJyb3dsZWZ0JywgWzg2MTldXSwgWydsb29wYXJyb3dyaWdodCcsIFs4NjIwXV0sIFsnbG9wYXInLCBbMTA2MjldXSwgWydMb3BmJywgWzEyMDEzMV1dLCBbJ2xvcGYnLCBbMTIwMTU3XV0sIFsnbG9wbHVzJywgWzEwNzk3XV0sIFsnbG90aW1lcycsIFsxMDgwNF1dLCBbJ2xvd2FzdCcsIFs4NzI3XV0sIFsnbG93YmFyJywgWzk1XV0sIFsnTG93ZXJMZWZ0QXJyb3cnLCBbODYwMV1dLCBbJ0xvd2VyUmlnaHRBcnJvdycsIFs4NjAwXV0sIFsnbG96JywgWzk2NzRdXSwgWydsb3plbmdlJywgWzk2NzRdXSwgWydsb3pmJywgWzEwNzMxXV0sIFsnbHBhcicsIFs0MF1dLCBbJ2xwYXJsdCcsIFsxMDY0M11dLCBbJ2xyYXJyJywgWzg2NDZdXSwgWydscmNvcm5lcicsIFs4OTkxXV0sIFsnbHJoYXInLCBbODY1MV1dLCBbJ2xyaGFyZCcsIFsxMDYwNV1dLCBbJ2xybScsIFs4MjA2XV0sIFsnbHJ0cmknLCBbODg5NV1dLCBbJ2xzYXF1bycsIFs4MjQ5XV0sIFsnbHNjcicsIFsxMjAwMDFdXSwgWydMc2NyJywgWzg0NjZdXSwgWydsc2gnLCBbODYyNF1dLCBbJ0xzaCcsIFs4NjI0XV0sIFsnbHNpbScsIFs4ODE4XV0sIFsnbHNpbWUnLCBbMTA4OTNdXSwgWydsc2ltZycsIFsxMDg5NV1dLCBbJ2xzcWInLCBbOTFdXSwgWydsc3F1bycsIFs4MjE2XV0sIFsnbHNxdW9yJywgWzgyMThdXSwgWydMc3Ryb2snLCBbMzIxXV0sIFsnbHN0cm9rJywgWzMyMl1dLCBbJ2x0Y2MnLCBbMTA5MThdXSwgWydsdGNpcicsIFsxMDg3M11dLCBbJ2x0JywgWzYwXV0sIFsnTFQnLCBbNjBdXSwgWydMdCcsIFs4ODEwXV0sIFsnbHRkb3QnLCBbODkxOF1dLCBbJ2x0aHJlZScsIFs4OTA3XV0sIFsnbHRpbWVzJywgWzg5MDVdXSwgWydsdGxhcnInLCBbMTA2MTRdXSwgWydsdHF1ZXN0JywgWzEwODc1XV0sIFsnbHRyaScsIFs5NjY3XV0sIFsnbHRyaWUnLCBbODg4NF1dLCBbJ2x0cmlmJywgWzk2NjZdXSwgWydsdHJQYXInLCBbMTA2NDZdXSwgWydsdXJkc2hhcicsIFsxMDU3MF1dLCBbJ2x1cnVoYXInLCBbMTA1OThdXSwgWydsdmVydG5lcXEnLCBbODgwOCwgNjUwMjRdXSwgWydsdm5FJywgWzg4MDgsIDY1MDI0XV0sIFsnbWFjcicsIFsxNzVdXSwgWydtYWxlJywgWzk3OTRdXSwgWydtYWx0JywgWzEwMDE2XV0sIFsnbWFsdGVzZScsIFsxMDAxNl1dLCBbJ01hcCcsIFsxMDUwMV1dLCBbJ21hcCcsIFs4NjE0XV0sIFsnbWFwc3RvJywgWzg2MTRdXSwgWydtYXBzdG9kb3duJywgWzg2MTVdXSwgWydtYXBzdG9sZWZ0JywgWzg2MTJdXSwgWydtYXBzdG91cCcsIFs4NjEzXV0sIFsnbWFya2VyJywgWzk2NDZdXSwgWydtY29tbWEnLCBbMTA3OTNdXSwgWydNY3knLCBbMTA1Ml1dLCBbJ21jeScsIFsxMDg0XV0sIFsnbWRhc2gnLCBbODIxMl1dLCBbJ21ERG90JywgWzg3NjJdXSwgWydtZWFzdXJlZGFuZ2xlJywgWzg3MzddXSwgWydNZWRpdW1TcGFjZScsIFs4Mjg3XV0sIFsnTWVsbGludHJmJywgWzg0OTldXSwgWydNZnInLCBbMTIwMDgwXV0sIFsnbWZyJywgWzEyMDEwNl1dLCBbJ21obycsIFs4NDg3XV0sIFsnbWljcm8nLCBbMTgxXV0sIFsnbWlkYXN0JywgWzQyXV0sIFsnbWlkY2lyJywgWzEwOTkyXV0sIFsnbWlkJywgWzg3MzldXSwgWydtaWRkb3QnLCBbMTgzXV0sIFsnbWludXNiJywgWzg4NjNdXSwgWydtaW51cycsIFs4NzIyXV0sIFsnbWludXNkJywgWzg3NjBdXSwgWydtaW51c2R1JywgWzEwNzk0XV0sIFsnTWludXNQbHVzJywgWzg3MjNdXSwgWydtbGNwJywgWzEwOTcxXV0sIFsnbWxkcicsIFs4MjMwXV0sIFsnbW5wbHVzJywgWzg3MjNdXSwgWydtb2RlbHMnLCBbODg3MV1dLCBbJ01vcGYnLCBbMTIwMTMyXV0sIFsnbW9wZicsIFsxMjAxNThdXSwgWydtcCcsIFs4NzIzXV0sIFsnbXNjcicsIFsxMjAwMDJdXSwgWydNc2NyJywgWzg0OTldXSwgWydtc3Rwb3MnLCBbODc2Nl1dLCBbJ011JywgWzkyNF1dLCBbJ211JywgWzk1Nl1dLCBbJ211bHRpbWFwJywgWzg4ODhdXSwgWydtdW1hcCcsIFs4ODg4XV0sIFsnbmFibGEnLCBbODcxMV1dLCBbJ05hY3V0ZScsIFszMjNdXSwgWyduYWN1dGUnLCBbMzI0XV0sIFsnbmFuZycsIFs4NzM2LCA4NDAyXV0sIFsnbmFwJywgWzg3NzddXSwgWyduYXBFJywgWzEwODY0LCA4MjRdXSwgWyduYXBpZCcsIFs4Nzc5LCA4MjRdXSwgWyduYXBvcycsIFszMjldXSwgWyduYXBwcm94JywgWzg3NzddXSwgWyduYXR1cmFsJywgWzk4MzhdXSwgWyduYXR1cmFscycsIFs4NDY5XV0sIFsnbmF0dXInLCBbOTgzOF1dLCBbJ25ic3AnLCBbMTYwXV0sIFsnbmJ1bXAnLCBbODc4MiwgODI0XV0sIFsnbmJ1bXBlJywgWzg3ODMsIDgyNF1dLCBbJ25jYXAnLCBbMTA4MTldXSwgWydOY2Fyb24nLCBbMzI3XV0sIFsnbmNhcm9uJywgWzMyOF1dLCBbJ05jZWRpbCcsIFszMjVdXSwgWyduY2VkaWwnLCBbMzI2XV0sIFsnbmNvbmcnLCBbODc3NV1dLCBbJ25jb25nZG90JywgWzEwODYxLCA4MjRdXSwgWyduY3VwJywgWzEwODE4XV0sIFsnTmN5JywgWzEwNTNdXSwgWyduY3knLCBbMTA4NV1dLCBbJ25kYXNoJywgWzgyMTFdXSwgWyduZWFyaGsnLCBbMTA1MzJdXSwgWyduZWFycicsIFs4NTk5XV0sIFsnbmVBcnInLCBbODY2M11dLCBbJ25lYXJyb3cnLCBbODU5OV1dLCBbJ25lJywgWzg4MDBdXSwgWyduZWRvdCcsIFs4Nzg0LCA4MjRdXSwgWydOZWdhdGl2ZU1lZGl1bVNwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVRoaWNrU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVGhpblNwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVZlcnlUaGluU3BhY2UnLCBbODIwM11dLCBbJ25lcXVpdicsIFs4ODAyXV0sIFsnbmVzZWFyJywgWzEwNTM2XV0sIFsnbmVzaW0nLCBbODc3MCwgODI0XV0sIFsnTmVzdGVkR3JlYXRlckdyZWF0ZXInLCBbODgxMV1dLCBbJ05lc3RlZExlc3NMZXNzJywgWzg4MTBdXSwgWyduZXhpc3QnLCBbODcwOF1dLCBbJ25leGlzdHMnLCBbODcwOF1dLCBbJ05mcicsIFsxMjAwODFdXSwgWyduZnInLCBbMTIwMTA3XV0sIFsnbmdFJywgWzg4MDcsIDgyNF1dLCBbJ25nZScsIFs4ODE3XV0sIFsnbmdlcScsIFs4ODE3XV0sIFsnbmdlcXEnLCBbODgwNywgODI0XV0sIFsnbmdlcXNsYW50JywgWzEwODc4LCA4MjRdXSwgWyduZ2VzJywgWzEwODc4LCA4MjRdXSwgWyduR2cnLCBbODkyMSwgODI0XV0sIFsnbmdzaW0nLCBbODgyMV1dLCBbJ25HdCcsIFs4ODExLCA4NDAyXV0sIFsnbmd0JywgWzg4MTVdXSwgWyduZ3RyJywgWzg4MTVdXSwgWyduR3R2JywgWzg4MTEsIDgyNF1dLCBbJ25oYXJyJywgWzg2MjJdXSwgWyduaEFycicsIFs4NjU0XV0sIFsnbmhwYXInLCBbMTA5OTRdXSwgWyduaScsIFs4NzE1XV0sIFsnbmlzJywgWzg5NTZdXSwgWyduaXNkJywgWzg5NTRdXSwgWyduaXYnLCBbODcxNV1dLCBbJ05KY3knLCBbMTAzNF1dLCBbJ25qY3knLCBbMTExNF1dLCBbJ25sYXJyJywgWzg2MDJdXSwgWydubEFycicsIFs4NjUzXV0sIFsnbmxkcicsIFs4MjI5XV0sIFsnbmxFJywgWzg4MDYsIDgyNF1dLCBbJ25sZScsIFs4ODE2XV0sIFsnbmxlZnRhcnJvdycsIFs4NjAyXV0sIFsnbkxlZnRhcnJvdycsIFs4NjUzXV0sIFsnbmxlZnRyaWdodGFycm93JywgWzg2MjJdXSwgWyduTGVmdHJpZ2h0YXJyb3cnLCBbODY1NF1dLCBbJ25sZXEnLCBbODgxNl1dLCBbJ25sZXFxJywgWzg4MDYsIDgyNF1dLCBbJ25sZXFzbGFudCcsIFsxMDg3NywgODI0XV0sIFsnbmxlcycsIFsxMDg3NywgODI0XV0sIFsnbmxlc3MnLCBbODgxNF1dLCBbJ25MbCcsIFs4OTIwLCA4MjRdXSwgWydubHNpbScsIFs4ODIwXV0sIFsnbkx0JywgWzg4MTAsIDg0MDJdXSwgWydubHQnLCBbODgxNF1dLCBbJ25sdHJpJywgWzg5MzhdXSwgWydubHRyaWUnLCBbODk0MF1dLCBbJ25MdHYnLCBbODgxMCwgODI0XV0sIFsnbm1pZCcsIFs4NzQwXV0sIFsnTm9CcmVhaycsIFs4Mjg4XV0sIFsnTm9uQnJlYWtpbmdTcGFjZScsIFsxNjBdXSwgWydub3BmJywgWzEyMDE1OV1dLCBbJ05vcGYnLCBbODQ2OV1dLCBbJ05vdCcsIFsxMDk4OF1dLCBbJ25vdCcsIFsxNzJdXSwgWydOb3RDb25ncnVlbnQnLCBbODgwMl1dLCBbJ05vdEN1cENhcCcsIFs4ODEzXV0sIFsnTm90RG91YmxlVmVydGljYWxCYXInLCBbODc0Ml1dLCBbJ05vdEVsZW1lbnQnLCBbODcxM11dLCBbJ05vdEVxdWFsJywgWzg4MDBdXSwgWydOb3RFcXVhbFRpbGRlJywgWzg3NzAsIDgyNF1dLCBbJ05vdEV4aXN0cycsIFs4NzA4XV0sIFsnTm90R3JlYXRlcicsIFs4ODE1XV0sIFsnTm90R3JlYXRlckVxdWFsJywgWzg4MTddXSwgWydOb3RHcmVhdGVyRnVsbEVxdWFsJywgWzg4MDcsIDgyNF1dLCBbJ05vdEdyZWF0ZXJHcmVhdGVyJywgWzg4MTEsIDgyNF1dLCBbJ05vdEdyZWF0ZXJMZXNzJywgWzg4MjVdXSwgWydOb3RHcmVhdGVyU2xhbnRFcXVhbCcsIFsxMDg3OCwgODI0XV0sIFsnTm90R3JlYXRlclRpbGRlJywgWzg4MjFdXSwgWydOb3RIdW1wRG93bkh1bXAnLCBbODc4MiwgODI0XV0sIFsnTm90SHVtcEVxdWFsJywgWzg3ODMsIDgyNF1dLCBbJ25vdGluJywgWzg3MTNdXSwgWydub3RpbmRvdCcsIFs4OTQ5LCA4MjRdXSwgWydub3RpbkUnLCBbODk1MywgODI0XV0sIFsnbm90aW52YScsIFs4NzEzXV0sIFsnbm90aW52YicsIFs4OTUxXV0sIFsnbm90aW52YycsIFs4OTUwXV0sIFsnTm90TGVmdFRyaWFuZ2xlQmFyJywgWzEwNzAzLCA4MjRdXSwgWydOb3RMZWZ0VHJpYW5nbGUnLCBbODkzOF1dLCBbJ05vdExlZnRUcmlhbmdsZUVxdWFsJywgWzg5NDBdXSwgWydOb3RMZXNzJywgWzg4MTRdXSwgWydOb3RMZXNzRXF1YWwnLCBbODgxNl1dLCBbJ05vdExlc3NHcmVhdGVyJywgWzg4MjRdXSwgWydOb3RMZXNzTGVzcycsIFs4ODEwLCA4MjRdXSwgWydOb3RMZXNzU2xhbnRFcXVhbCcsIFsxMDg3NywgODI0XV0sIFsnTm90TGVzc1RpbGRlJywgWzg4MjBdXSwgWydOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcicsIFsxMDkxNCwgODI0XV0sIFsnTm90TmVzdGVkTGVzc0xlc3MnLCBbMTA5MTMsIDgyNF1dLCBbJ25vdG5pJywgWzg3MTZdXSwgWydub3RuaXZhJywgWzg3MTZdXSwgWydub3RuaXZiJywgWzg5NThdXSwgWydub3RuaXZjJywgWzg5NTddXSwgWydOb3RQcmVjZWRlcycsIFs4ODMyXV0sIFsnTm90UHJlY2VkZXNFcXVhbCcsIFsxMDkyNywgODI0XV0sIFsnTm90UHJlY2VkZXNTbGFudEVxdWFsJywgWzg5MjhdXSwgWydOb3RSZXZlcnNlRWxlbWVudCcsIFs4NzE2XV0sIFsnTm90UmlnaHRUcmlhbmdsZUJhcicsIFsxMDcwNCwgODI0XV0sIFsnTm90UmlnaHRUcmlhbmdsZScsIFs4OTM5XV0sIFsnTm90UmlnaHRUcmlhbmdsZUVxdWFsJywgWzg5NDFdXSwgWydOb3RTcXVhcmVTdWJzZXQnLCBbODg0NywgODI0XV0sIFsnTm90U3F1YXJlU3Vic2V0RXF1YWwnLCBbODkzMF1dLCBbJ05vdFNxdWFyZVN1cGVyc2V0JywgWzg4NDgsIDgyNF1dLCBbJ05vdFNxdWFyZVN1cGVyc2V0RXF1YWwnLCBbODkzMV1dLCBbJ05vdFN1YnNldCcsIFs4ODM0LCA4NDAyXV0sIFsnTm90U3Vic2V0RXF1YWwnLCBbODg0MF1dLCBbJ05vdFN1Y2NlZWRzJywgWzg4MzNdXSwgWydOb3RTdWNjZWVkc0VxdWFsJywgWzEwOTI4LCA4MjRdXSwgWydOb3RTdWNjZWVkc1NsYW50RXF1YWwnLCBbODkyOV1dLCBbJ05vdFN1Y2NlZWRzVGlsZGUnLCBbODgzMSwgODI0XV0sIFsnTm90U3VwZXJzZXQnLCBbODgzNSwgODQwMl1dLCBbJ05vdFN1cGVyc2V0RXF1YWwnLCBbODg0MV1dLCBbJ05vdFRpbGRlJywgWzg3NjldXSwgWydOb3RUaWxkZUVxdWFsJywgWzg3NzJdXSwgWydOb3RUaWxkZUZ1bGxFcXVhbCcsIFs4Nzc1XV0sIFsnTm90VGlsZGVUaWxkZScsIFs4Nzc3XV0sIFsnTm90VmVydGljYWxCYXInLCBbODc0MF1dLCBbJ25wYXJhbGxlbCcsIFs4NzQyXV0sIFsnbnBhcicsIFs4NzQyXV0sIFsnbnBhcnNsJywgWzExMDA1LCA4NDIxXV0sIFsnbnBhcnQnLCBbODcwNiwgODI0XV0sIFsnbnBvbGludCcsIFsxMDc3Ml1dLCBbJ25wcicsIFs4ODMyXV0sIFsnbnByY3VlJywgWzg5MjhdXSwgWyducHJlYycsIFs4ODMyXV0sIFsnbnByZWNlcScsIFsxMDkyNywgODI0XV0sIFsnbnByZScsIFsxMDkyNywgODI0XV0sIFsnbnJhcnJjJywgWzEwNTQ3LCA4MjRdXSwgWyducmFycicsIFs4NjAzXV0sIFsnbnJBcnInLCBbODY1NV1dLCBbJ25yYXJydycsIFs4NjA1LCA4MjRdXSwgWyducmlnaHRhcnJvdycsIFs4NjAzXV0sIFsnblJpZ2h0YXJyb3cnLCBbODY1NV1dLCBbJ25ydHJpJywgWzg5MzldXSwgWyducnRyaWUnLCBbODk0MV1dLCBbJ25zYycsIFs4ODMzXV0sIFsnbnNjY3VlJywgWzg5MjldXSwgWyduc2NlJywgWzEwOTI4LCA4MjRdXSwgWydOc2NyJywgWzExOTk3N11dLCBbJ25zY3InLCBbMTIwMDAzXV0sIFsnbnNob3J0bWlkJywgWzg3NDBdXSwgWyduc2hvcnRwYXJhbGxlbCcsIFs4NzQyXV0sIFsnbnNpbScsIFs4NzY5XV0sIFsnbnNpbWUnLCBbODc3Ml1dLCBbJ25zaW1lcScsIFs4NzcyXV0sIFsnbnNtaWQnLCBbODc0MF1dLCBbJ25zcGFyJywgWzg3NDJdXSwgWyduc3FzdWJlJywgWzg5MzBdXSwgWyduc3FzdXBlJywgWzg5MzFdXSwgWyduc3ViJywgWzg4MzZdXSwgWyduc3ViRScsIFsxMDk0OSwgODI0XV0sIFsnbnN1YmUnLCBbODg0MF1dLCBbJ25zdWJzZXQnLCBbODgzNCwgODQwMl1dLCBbJ25zdWJzZXRlcScsIFs4ODQwXV0sIFsnbnN1YnNldGVxcScsIFsxMDk0OSwgODI0XV0sIFsnbnN1Y2MnLCBbODgzM11dLCBbJ25zdWNjZXEnLCBbMTA5MjgsIDgyNF1dLCBbJ25zdXAnLCBbODgzN11dLCBbJ25zdXBFJywgWzEwOTUwLCA4MjRdXSwgWyduc3VwZScsIFs4ODQxXV0sIFsnbnN1cHNldCcsIFs4ODM1LCA4NDAyXV0sIFsnbnN1cHNldGVxJywgWzg4NDFdXSwgWyduc3Vwc2V0ZXFxJywgWzEwOTUwLCA4MjRdXSwgWydudGdsJywgWzg4MjVdXSwgWydOdGlsZGUnLCBbMjA5XV0sIFsnbnRpbGRlJywgWzI0MV1dLCBbJ250bGcnLCBbODgyNF1dLCBbJ250cmlhbmdsZWxlZnQnLCBbODkzOF1dLCBbJ250cmlhbmdsZWxlZnRlcScsIFs4OTQwXV0sIFsnbnRyaWFuZ2xlcmlnaHQnLCBbODkzOV1dLCBbJ250cmlhbmdsZXJpZ2h0ZXEnLCBbODk0MV1dLCBbJ051JywgWzkyNV1dLCBbJ251JywgWzk1N11dLCBbJ251bScsIFszNV1dLCBbJ251bWVybycsIFs4NDcwXV0sIFsnbnVtc3AnLCBbODE5OV1dLCBbJ252YXAnLCBbODc4MSwgODQwMl1dLCBbJ252ZGFzaCcsIFs4ODc2XV0sIFsnbnZEYXNoJywgWzg4NzddXSwgWyduVmRhc2gnLCBbODg3OF1dLCBbJ25WRGFzaCcsIFs4ODc5XV0sIFsnbnZnZScsIFs4ODA1LCA4NDAyXV0sIFsnbnZndCcsIFs2MiwgODQwMl1dLCBbJ252SGFycicsIFsxMDUwMF1dLCBbJ252aW5maW4nLCBbMTA3MThdXSwgWydudmxBcnInLCBbMTA0OThdXSwgWydudmxlJywgWzg4MDQsIDg0MDJdXSwgWydudmx0JywgWzYwLCA4NDAyXV0sIFsnbnZsdHJpZScsIFs4ODg0LCA4NDAyXV0sIFsnbnZyQXJyJywgWzEwNDk5XV0sIFsnbnZydHJpZScsIFs4ODg1LCA4NDAyXV0sIFsnbnZzaW0nLCBbODc2NCwgODQwMl1dLCBbJ253YXJoaycsIFsxMDUzMV1dLCBbJ253YXJyJywgWzg1OThdXSwgWydud0FycicsIFs4NjYyXV0sIFsnbndhcnJvdycsIFs4NTk4XV0sIFsnbnduZWFyJywgWzEwNTM1XV0sIFsnT2FjdXRlJywgWzIxMV1dLCBbJ29hY3V0ZScsIFsyNDNdXSwgWydvYXN0JywgWzg4NTldXSwgWydPY2lyYycsIFsyMTJdXSwgWydvY2lyYycsIFsyNDRdXSwgWydvY2lyJywgWzg4NThdXSwgWydPY3knLCBbMTA1NF1dLCBbJ29jeScsIFsxMDg2XV0sIFsnb2Rhc2gnLCBbODg2MV1dLCBbJ09kYmxhYycsIFszMzZdXSwgWydvZGJsYWMnLCBbMzM3XV0sIFsnb2RpdicsIFsxMDgwOF1dLCBbJ29kb3QnLCBbODg1N11dLCBbJ29kc29sZCcsIFsxMDY4NF1dLCBbJ09FbGlnJywgWzMzOF1dLCBbJ29lbGlnJywgWzMzOV1dLCBbJ29mY2lyJywgWzEwNjg3XV0sIFsnT2ZyJywgWzEyMDA4Ml1dLCBbJ29mcicsIFsxMjAxMDhdXSwgWydvZ29uJywgWzczMV1dLCBbJ09ncmF2ZScsIFsyMTBdXSwgWydvZ3JhdmUnLCBbMjQyXV0sIFsnb2d0JywgWzEwNjg5XV0sIFsnb2hiYXInLCBbMTA2NzddXSwgWydvaG0nLCBbOTM3XV0sIFsnb2ludCcsIFs4NzUwXV0sIFsnb2xhcnInLCBbODYzNF1dLCBbJ29sY2lyJywgWzEwNjg2XV0sIFsnb2xjcm9zcycsIFsxMDY4M11dLCBbJ29saW5lJywgWzgyNTRdXSwgWydvbHQnLCBbMTA2ODhdXSwgWydPbWFjcicsIFszMzJdXSwgWydvbWFjcicsIFszMzNdXSwgWydPbWVnYScsIFs5MzddXSwgWydvbWVnYScsIFs5NjldXSwgWydPbWljcm9uJywgWzkyN11dLCBbJ29taWNyb24nLCBbOTU5XV0sIFsnb21pZCcsIFsxMDY3OF1dLCBbJ29taW51cycsIFs4ODU0XV0sIFsnT29wZicsIFsxMjAxMzRdXSwgWydvb3BmJywgWzEyMDE2MF1dLCBbJ29wYXInLCBbMTA2NzldXSwgWydPcGVuQ3VybHlEb3VibGVRdW90ZScsIFs4MjIwXV0sIFsnT3BlbkN1cmx5UXVvdGUnLCBbODIxNl1dLCBbJ29wZXJwJywgWzEwNjgxXV0sIFsnb3BsdXMnLCBbODg1M11dLCBbJ29yYXJyJywgWzg2MzVdXSwgWydPcicsIFsxMDgzNl1dLCBbJ29yJywgWzg3NDRdXSwgWydvcmQnLCBbMTA4NDVdXSwgWydvcmRlcicsIFs4NTAwXV0sIFsnb3JkZXJvZicsIFs4NTAwXV0sIFsnb3JkZicsIFsxNzBdXSwgWydvcmRtJywgWzE4Nl1dLCBbJ29yaWdvZicsIFs4ODg2XV0sIFsnb3JvcicsIFsxMDgzOF1dLCBbJ29yc2xvcGUnLCBbMTA4MzldXSwgWydvcnYnLCBbMTA4NDNdXSwgWydvUycsIFs5NDE2XV0sIFsnT3NjcicsIFsxMTk5NzhdXSwgWydvc2NyJywgWzg1MDBdXSwgWydPc2xhc2gnLCBbMjE2XV0sIFsnb3NsYXNoJywgWzI0OF1dLCBbJ29zb2wnLCBbODg1Nl1dLCBbJ090aWxkZScsIFsyMTNdXSwgWydvdGlsZGUnLCBbMjQ1XV0sIFsnb3RpbWVzYXMnLCBbMTA4MDZdXSwgWydPdGltZXMnLCBbMTA4MDddXSwgWydvdGltZXMnLCBbODg1NV1dLCBbJ091bWwnLCBbMjE0XV0sIFsnb3VtbCcsIFsyNDZdXSwgWydvdmJhcicsIFs5MDIxXV0sIFsnT3ZlckJhcicsIFs4MjU0XV0sIFsnT3ZlckJyYWNlJywgWzkxODJdXSwgWydPdmVyQnJhY2tldCcsIFs5MTQwXV0sIFsnT3ZlclBhcmVudGhlc2lzJywgWzkxODBdXSwgWydwYXJhJywgWzE4Ml1dLCBbJ3BhcmFsbGVsJywgWzg3NDFdXSwgWydwYXInLCBbODc0MV1dLCBbJ3BhcnNpbScsIFsxMDk5NV1dLCBbJ3BhcnNsJywgWzExMDA1XV0sIFsncGFydCcsIFs4NzA2XV0sIFsnUGFydGlhbEQnLCBbODcwNl1dLCBbJ1BjeScsIFsxMDU1XV0sIFsncGN5JywgWzEwODddXSwgWydwZXJjbnQnLCBbMzddXSwgWydwZXJpb2QnLCBbNDZdXSwgWydwZXJtaWwnLCBbODI0MF1dLCBbJ3BlcnAnLCBbODg2OV1dLCBbJ3BlcnRlbmsnLCBbODI0MV1dLCBbJ1BmcicsIFsxMjAwODNdXSwgWydwZnInLCBbMTIwMTA5XV0sIFsnUGhpJywgWzkzNF1dLCBbJ3BoaScsIFs5NjZdXSwgWydwaGl2JywgWzk4MV1dLCBbJ3BobW1hdCcsIFs4NDk5XV0sIFsncGhvbmUnLCBbOTc0Ml1dLCBbJ1BpJywgWzkyOF1dLCBbJ3BpJywgWzk2MF1dLCBbJ3BpdGNoZm9yaycsIFs4OTE2XV0sIFsncGl2JywgWzk4Ml1dLCBbJ3BsYW5jaycsIFs4NDYzXV0sIFsncGxhbmNraCcsIFs4NDYyXV0sIFsncGxhbmt2JywgWzg0NjNdXSwgWydwbHVzYWNpcicsIFsxMDc4N11dLCBbJ3BsdXNiJywgWzg4NjJdXSwgWydwbHVzY2lyJywgWzEwNzg2XV0sIFsncGx1cycsIFs0M11dLCBbJ3BsdXNkbycsIFs4NzI0XV0sIFsncGx1c2R1JywgWzEwNzg5XV0sIFsncGx1c2UnLCBbMTA4NjZdXSwgWydQbHVzTWludXMnLCBbMTc3XV0sIFsncGx1c21uJywgWzE3N11dLCBbJ3BsdXNzaW0nLCBbMTA3OTBdXSwgWydwbHVzdHdvJywgWzEwNzkxXV0sIFsncG0nLCBbMTc3XV0sIFsnUG9pbmNhcmVwbGFuZScsIFs4NDYwXV0sIFsncG9pbnRpbnQnLCBbMTA3NzNdXSwgWydwb3BmJywgWzEyMDE2MV1dLCBbJ1BvcGYnLCBbODQ3M11dLCBbJ3BvdW5kJywgWzE2M11dLCBbJ3ByYXAnLCBbMTA5MzVdXSwgWydQcicsIFsxMDkzOV1dLCBbJ3ByJywgWzg4MjZdXSwgWydwcmN1ZScsIFs4ODI4XV0sIFsncHJlY2FwcHJveCcsIFsxMDkzNV1dLCBbJ3ByZWMnLCBbODgyNl1dLCBbJ3ByZWNjdXJseWVxJywgWzg4MjhdXSwgWydQcmVjZWRlcycsIFs4ODI2XV0sIFsnUHJlY2VkZXNFcXVhbCcsIFsxMDkyN11dLCBbJ1ByZWNlZGVzU2xhbnRFcXVhbCcsIFs4ODI4XV0sIFsnUHJlY2VkZXNUaWxkZScsIFs4ODMwXV0sIFsncHJlY2VxJywgWzEwOTI3XV0sIFsncHJlY25hcHByb3gnLCBbMTA5MzddXSwgWydwcmVjbmVxcScsIFsxMDkzM11dLCBbJ3ByZWNuc2ltJywgWzg5MzZdXSwgWydwcmUnLCBbMTA5MjddXSwgWydwckUnLCBbMTA5MzFdXSwgWydwcmVjc2ltJywgWzg4MzBdXSwgWydwcmltZScsIFs4MjQyXV0sIFsnUHJpbWUnLCBbODI0M11dLCBbJ3ByaW1lcycsIFs4NDczXV0sIFsncHJuYXAnLCBbMTA5MzddXSwgWydwcm5FJywgWzEwOTMzXV0sIFsncHJuc2ltJywgWzg5MzZdXSwgWydwcm9kJywgWzg3MTldXSwgWydQcm9kdWN0JywgWzg3MTldXSwgWydwcm9mYWxhcicsIFs5MDA2XV0sIFsncHJvZmxpbmUnLCBbODk3OF1dLCBbJ3Byb2ZzdXJmJywgWzg5NzldXSwgWydwcm9wJywgWzg3MzNdXSwgWydQcm9wb3J0aW9uYWwnLCBbODczM11dLCBbJ1Byb3BvcnRpb24nLCBbODc1OV1dLCBbJ3Byb3B0bycsIFs4NzMzXV0sIFsncHJzaW0nLCBbODgzMF1dLCBbJ3BydXJlbCcsIFs4ODgwXV0sIFsnUHNjcicsIFsxMTk5NzldXSwgWydwc2NyJywgWzEyMDAwNV1dLCBbJ1BzaScsIFs5MzZdXSwgWydwc2knLCBbOTY4XV0sIFsncHVuY3NwJywgWzgyMDBdXSwgWydRZnInLCBbMTIwMDg0XV0sIFsncWZyJywgWzEyMDExMF1dLCBbJ3FpbnQnLCBbMTA3NjRdXSwgWydxb3BmJywgWzEyMDE2Ml1dLCBbJ1FvcGYnLCBbODQ3NF1dLCBbJ3FwcmltZScsIFs4Mjc5XV0sIFsnUXNjcicsIFsxMTk5ODBdXSwgWydxc2NyJywgWzEyMDAwNl1dLCBbJ3F1YXRlcm5pb25zJywgWzg0NjFdXSwgWydxdWF0aW50JywgWzEwNzc0XV0sIFsncXVlc3QnLCBbNjNdXSwgWydxdWVzdGVxJywgWzg3OTldXSwgWydxdW90JywgWzM0XV0sIFsnUVVPVCcsIFszNF1dLCBbJ3JBYXJyJywgWzg2NjddXSwgWydyYWNlJywgWzg3NjUsIDgxN11dLCBbJ1JhY3V0ZScsIFszNDBdXSwgWydyYWN1dGUnLCBbMzQxXV0sIFsncmFkaWMnLCBbODczMF1dLCBbJ3JhZW1wdHl2JywgWzEwNjc1XV0sIFsncmFuZycsIFsxMDIxN11dLCBbJ1JhbmcnLCBbMTAyMTldXSwgWydyYW5nZCcsIFsxMDY0Ml1dLCBbJ3JhbmdlJywgWzEwNjYxXV0sIFsncmFuZ2xlJywgWzEwMjE3XV0sIFsncmFxdW8nLCBbMTg3XV0sIFsncmFycmFwJywgWzEwNjEzXV0sIFsncmFycmInLCBbODY3N11dLCBbJ3JhcnJiZnMnLCBbMTA1MjhdXSwgWydyYXJyYycsIFsxMDU0N11dLCBbJ3JhcnInLCBbODU5NF1dLCBbJ1JhcnInLCBbODYwOF1dLCBbJ3JBcnInLCBbODY1OF1dLCBbJ3JhcnJmcycsIFsxMDUyNl1dLCBbJ3JhcnJoaycsIFs4NjE4XV0sIFsncmFycmxwJywgWzg2MjBdXSwgWydyYXJycGwnLCBbMTA1NjVdXSwgWydyYXJyc2ltJywgWzEwNjEyXV0sIFsnUmFycnRsJywgWzEwNTE4XV0sIFsncmFycnRsJywgWzg2MTFdXSwgWydyYXJydycsIFs4NjA1XV0sIFsncmF0YWlsJywgWzEwNTIyXV0sIFsnckF0YWlsJywgWzEwNTI0XV0sIFsncmF0aW8nLCBbODc1OF1dLCBbJ3JhdGlvbmFscycsIFs4NDc0XV0sIFsncmJhcnInLCBbMTA1MDldXSwgWydyQmFycicsIFsxMDUxMV1dLCBbJ1JCYXJyJywgWzEwNTEyXV0sIFsncmJicmsnLCBbMTAwOTldXSwgWydyYnJhY2UnLCBbMTI1XV0sIFsncmJyYWNrJywgWzkzXV0sIFsncmJya2UnLCBbMTA2MzZdXSwgWydyYnJrc2xkJywgWzEwNjM4XV0sIFsncmJya3NsdScsIFsxMDY0MF1dLCBbJ1JjYXJvbicsIFszNDRdXSwgWydyY2Fyb24nLCBbMzQ1XV0sIFsnUmNlZGlsJywgWzM0Ml1dLCBbJ3JjZWRpbCcsIFszNDNdXSwgWydyY2VpbCcsIFs4OTY5XV0sIFsncmN1YicsIFsxMjVdXSwgWydSY3knLCBbMTA1Nl1dLCBbJ3JjeScsIFsxMDg4XV0sIFsncmRjYScsIFsxMDU1MV1dLCBbJ3JkbGRoYXInLCBbMTA2MDFdXSwgWydyZHF1bycsIFs4MjIxXV0sIFsncmRxdW9yJywgWzgyMjFdXSwgWydDbG9zZUN1cmx5RG91YmxlUXVvdGUnLCBbODIyMV1dLCBbJ3Jkc2gnLCBbODYyN11dLCBbJ3JlYWwnLCBbODQ3Nl1dLCBbJ3JlYWxpbmUnLCBbODQ3NV1dLCBbJ3JlYWxwYXJ0JywgWzg0NzZdXSwgWydyZWFscycsIFs4NDc3XV0sIFsnUmUnLCBbODQ3Nl1dLCBbJ3JlY3QnLCBbOTY0NV1dLCBbJ3JlZycsIFsxNzRdXSwgWydSRUcnLCBbMTc0XV0sIFsnUmV2ZXJzZUVsZW1lbnQnLCBbODcxNV1dLCBbJ1JldmVyc2VFcXVpbGlicml1bScsIFs4NjUxXV0sIFsnUmV2ZXJzZVVwRXF1aWxpYnJpdW0nLCBbMTA2MDddXSwgWydyZmlzaHQnLCBbMTA2MjFdXSwgWydyZmxvb3InLCBbODk3MV1dLCBbJ3JmcicsIFsxMjAxMTFdXSwgWydSZnInLCBbODQ3Nl1dLCBbJ3JIYXInLCBbMTA1OTZdXSwgWydyaGFyZCcsIFs4NjQxXV0sIFsncmhhcnUnLCBbODY0MF1dLCBbJ3JoYXJ1bCcsIFsxMDYwNF1dLCBbJ1JobycsIFs5MjldXSwgWydyaG8nLCBbOTYxXV0sIFsncmhvdicsIFsxMDA5XV0sIFsnUmlnaHRBbmdsZUJyYWNrZXQnLCBbMTAyMTddXSwgWydSaWdodEFycm93QmFyJywgWzg2NzddXSwgWydyaWdodGFycm93JywgWzg1OTRdXSwgWydSaWdodEFycm93JywgWzg1OTRdXSwgWydSaWdodGFycm93JywgWzg2NThdXSwgWydSaWdodEFycm93TGVmdEFycm93JywgWzg2NDRdXSwgWydyaWdodGFycm93dGFpbCcsIFs4NjExXV0sIFsnUmlnaHRDZWlsaW5nJywgWzg5NjldXSwgWydSaWdodERvdWJsZUJyYWNrZXQnLCBbMTAyMTVdXSwgWydSaWdodERvd25UZWVWZWN0b3InLCBbMTA1ODldXSwgWydSaWdodERvd25WZWN0b3JCYXInLCBbMTA1ODFdXSwgWydSaWdodERvd25WZWN0b3InLCBbODY0Ml1dLCBbJ1JpZ2h0Rmxvb3InLCBbODk3MV1dLCBbJ3JpZ2h0aGFycG9vbmRvd24nLCBbODY0MV1dLCBbJ3JpZ2h0aGFycG9vbnVwJywgWzg2NDBdXSwgWydyaWdodGxlZnRhcnJvd3MnLCBbODY0NF1dLCBbJ3JpZ2h0bGVmdGhhcnBvb25zJywgWzg2NTJdXSwgWydyaWdodHJpZ2h0YXJyb3dzJywgWzg2NDldXSwgWydyaWdodHNxdWlnYXJyb3cnLCBbODYwNV1dLCBbJ1JpZ2h0VGVlQXJyb3cnLCBbODYxNF1dLCBbJ1JpZ2h0VGVlJywgWzg4NjZdXSwgWydSaWdodFRlZVZlY3RvcicsIFsxMDU4N11dLCBbJ3JpZ2h0dGhyZWV0aW1lcycsIFs4OTA4XV0sIFsnUmlnaHRUcmlhbmdsZUJhcicsIFsxMDcwNF1dLCBbJ1JpZ2h0VHJpYW5nbGUnLCBbODg4M11dLCBbJ1JpZ2h0VHJpYW5nbGVFcXVhbCcsIFs4ODg1XV0sIFsnUmlnaHRVcERvd25WZWN0b3InLCBbMTA1NzVdXSwgWydSaWdodFVwVGVlVmVjdG9yJywgWzEwNTg4XV0sIFsnUmlnaHRVcFZlY3RvckJhcicsIFsxMDU4MF1dLCBbJ1JpZ2h0VXBWZWN0b3InLCBbODYzOF1dLCBbJ1JpZ2h0VmVjdG9yQmFyJywgWzEwNTc5XV0sIFsnUmlnaHRWZWN0b3InLCBbODY0MF1dLCBbJ3JpbmcnLCBbNzMwXV0sIFsncmlzaW5nZG90c2VxJywgWzg3ODddXSwgWydybGFycicsIFs4NjQ0XV0sIFsncmxoYXInLCBbODY1Ml1dLCBbJ3JsbScsIFs4MjA3XV0sIFsncm1vdXN0YWNoZScsIFs5MTM3XV0sIFsncm1vdXN0JywgWzkxMzddXSwgWydybm1pZCcsIFsxMDk5MF1dLCBbJ3JvYW5nJywgWzEwMjIxXV0sIFsncm9hcnInLCBbODcwMl1dLCBbJ3JvYnJrJywgWzEwMjE1XV0sIFsncm9wYXInLCBbMTA2MzBdXSwgWydyb3BmJywgWzEyMDE2M11dLCBbJ1JvcGYnLCBbODQ3N11dLCBbJ3JvcGx1cycsIFsxMDc5OF1dLCBbJ3JvdGltZXMnLCBbMTA4MDVdXSwgWydSb3VuZEltcGxpZXMnLCBbMTA2MDhdXSwgWydycGFyJywgWzQxXV0sIFsncnBhcmd0JywgWzEwNjQ0XV0sIFsncnBwb2xpbnQnLCBbMTA3NzBdXSwgWydycmFycicsIFs4NjQ5XV0sIFsnUnJpZ2h0YXJyb3cnLCBbODY2N11dLCBbJ3JzYXF1bycsIFs4MjUwXV0sIFsncnNjcicsIFsxMjAwMDddXSwgWydSc2NyJywgWzg0NzVdXSwgWydyc2gnLCBbODYyNV1dLCBbJ1JzaCcsIFs4NjI1XV0sIFsncnNxYicsIFs5M11dLCBbJ3JzcXVvJywgWzgyMTddXSwgWydyc3F1b3InLCBbODIxN11dLCBbJ0Nsb3NlQ3VybHlRdW90ZScsIFs4MjE3XV0sIFsncnRocmVlJywgWzg5MDhdXSwgWydydGltZXMnLCBbODkwNl1dLCBbJ3J0cmknLCBbOTY1N11dLCBbJ3J0cmllJywgWzg4ODVdXSwgWydydHJpZicsIFs5NjU2XV0sIFsncnRyaWx0cmknLCBbMTA3MDJdXSwgWydSdWxlRGVsYXllZCcsIFsxMDc0MF1dLCBbJ3J1bHVoYXInLCBbMTA2MDBdXSwgWydyeCcsIFs4NDc4XV0sIFsnU2FjdXRlJywgWzM0Nl1dLCBbJ3NhY3V0ZScsIFszNDddXSwgWydzYnF1bycsIFs4MjE4XV0sIFsnc2NhcCcsIFsxMDkzNl1dLCBbJ1NjYXJvbicsIFszNTJdXSwgWydzY2Fyb24nLCBbMzUzXV0sIFsnU2MnLCBbMTA5NDBdXSwgWydzYycsIFs4ODI3XV0sIFsnc2NjdWUnLCBbODgyOV1dLCBbJ3NjZScsIFsxMDkyOF1dLCBbJ3NjRScsIFsxMDkzMl1dLCBbJ1NjZWRpbCcsIFszNTBdXSwgWydzY2VkaWwnLCBbMzUxXV0sIFsnU2NpcmMnLCBbMzQ4XV0sIFsnc2NpcmMnLCBbMzQ5XV0sIFsnc2NuYXAnLCBbMTA5MzhdXSwgWydzY25FJywgWzEwOTM0XV0sIFsnc2Nuc2ltJywgWzg5MzddXSwgWydzY3BvbGludCcsIFsxMDc3MV1dLCBbJ3Njc2ltJywgWzg4MzFdXSwgWydTY3knLCBbMTA1N11dLCBbJ3NjeScsIFsxMDg5XV0sIFsnc2RvdGInLCBbODg2NV1dLCBbJ3Nkb3QnLCBbODkwMV1dLCBbJ3Nkb3RlJywgWzEwODU0XV0sIFsnc2VhcmhrJywgWzEwNTMzXV0sIFsnc2VhcnInLCBbODYwMF1dLCBbJ3NlQXJyJywgWzg2NjRdXSwgWydzZWFycm93JywgWzg2MDBdXSwgWydzZWN0JywgWzE2N11dLCBbJ3NlbWknLCBbNTldXSwgWydzZXN3YXInLCBbMTA1MzddXSwgWydzZXRtaW51cycsIFs4NzI2XV0sIFsnc2V0bW4nLCBbODcyNl1dLCBbJ3NleHQnLCBbMTAwMzhdXSwgWydTZnInLCBbMTIwMDg2XV0sIFsnc2ZyJywgWzEyMDExMl1dLCBbJ3Nmcm93bicsIFs4OTk0XV0sIFsnc2hhcnAnLCBbOTgzOV1dLCBbJ1NIQ0hjeScsIFsxMDY1XV0sIFsnc2hjaGN5JywgWzEwOTddXSwgWydTSGN5JywgWzEwNjRdXSwgWydzaGN5JywgWzEwOTZdXSwgWydTaG9ydERvd25BcnJvdycsIFs4NTk1XV0sIFsnU2hvcnRMZWZ0QXJyb3cnLCBbODU5Ml1dLCBbJ3Nob3J0bWlkJywgWzg3MzldXSwgWydzaG9ydHBhcmFsbGVsJywgWzg3NDFdXSwgWydTaG9ydFJpZ2h0QXJyb3cnLCBbODU5NF1dLCBbJ1Nob3J0VXBBcnJvdycsIFs4NTkzXV0sIFsnc2h5JywgWzE3M11dLCBbJ1NpZ21hJywgWzkzMV1dLCBbJ3NpZ21hJywgWzk2M11dLCBbJ3NpZ21hZicsIFs5NjJdXSwgWydzaWdtYXYnLCBbOTYyXV0sIFsnc2ltJywgWzg3NjRdXSwgWydzaW1kb3QnLCBbMTA4NThdXSwgWydzaW1lJywgWzg3NzFdXSwgWydzaW1lcScsIFs4NzcxXV0sIFsnc2ltZycsIFsxMDkxMF1dLCBbJ3NpbWdFJywgWzEwOTEyXV0sIFsnc2ltbCcsIFsxMDkwOV1dLCBbJ3NpbWxFJywgWzEwOTExXV0sIFsnc2ltbmUnLCBbODc3NF1dLCBbJ3NpbXBsdXMnLCBbMTA3ODhdXSwgWydzaW1yYXJyJywgWzEwNjEwXV0sIFsnc2xhcnInLCBbODU5Ml1dLCBbJ1NtYWxsQ2lyY2xlJywgWzg3MjhdXSwgWydzbWFsbHNldG1pbnVzJywgWzg3MjZdXSwgWydzbWFzaHAnLCBbMTA4MDNdXSwgWydzbWVwYXJzbCcsIFsxMDcyNF1dLCBbJ3NtaWQnLCBbODczOV1dLCBbJ3NtaWxlJywgWzg5OTVdXSwgWydzbXQnLCBbMTA5MjJdXSwgWydzbXRlJywgWzEwOTI0XV0sIFsnc210ZXMnLCBbMTA5MjQsIDY1MDI0XV0sIFsnU09GVGN5JywgWzEwNjhdXSwgWydzb2Z0Y3knLCBbMTEwMF1dLCBbJ3NvbGJhcicsIFs5MDIzXV0sIFsnc29sYicsIFsxMDY5Ml1dLCBbJ3NvbCcsIFs0N11dLCBbJ1NvcGYnLCBbMTIwMTM4XV0sIFsnc29wZicsIFsxMjAxNjRdXSwgWydzcGFkZXMnLCBbOTgyNF1dLCBbJ3NwYWRlc3VpdCcsIFs5ODI0XV0sIFsnc3BhcicsIFs4NzQxXV0sIFsnc3FjYXAnLCBbODg1MV1dLCBbJ3NxY2FwcycsIFs4ODUxLCA2NTAyNF1dLCBbJ3NxY3VwJywgWzg4NTJdXSwgWydzcWN1cHMnLCBbODg1MiwgNjUwMjRdXSwgWydTcXJ0JywgWzg3MzBdXSwgWydzcXN1YicsIFs4ODQ3XV0sIFsnc3FzdWJlJywgWzg4NDldXSwgWydzcXN1YnNldCcsIFs4ODQ3XV0sIFsnc3FzdWJzZXRlcScsIFs4ODQ5XV0sIFsnc3FzdXAnLCBbODg0OF1dLCBbJ3Nxc3VwZScsIFs4ODUwXV0sIFsnc3FzdXBzZXQnLCBbODg0OF1dLCBbJ3Nxc3Vwc2V0ZXEnLCBbODg1MF1dLCBbJ3NxdWFyZScsIFs5NjMzXV0sIFsnU3F1YXJlJywgWzk2MzNdXSwgWydTcXVhcmVJbnRlcnNlY3Rpb24nLCBbODg1MV1dLCBbJ1NxdWFyZVN1YnNldCcsIFs4ODQ3XV0sIFsnU3F1YXJlU3Vic2V0RXF1YWwnLCBbODg0OV1dLCBbJ1NxdWFyZVN1cGVyc2V0JywgWzg4NDhdXSwgWydTcXVhcmVTdXBlcnNldEVxdWFsJywgWzg4NTBdXSwgWydTcXVhcmVVbmlvbicsIFs4ODUyXV0sIFsnc3F1YXJmJywgWzk2NDJdXSwgWydzcXUnLCBbOTYzM11dLCBbJ3NxdWYnLCBbOTY0Ml1dLCBbJ3NyYXJyJywgWzg1OTRdXSwgWydTc2NyJywgWzExOTk4Ml1dLCBbJ3NzY3InLCBbMTIwMDA4XV0sIFsnc3NldG1uJywgWzg3MjZdXSwgWydzc21pbGUnLCBbODk5NV1dLCBbJ3NzdGFyZicsIFs4OTAyXV0sIFsnU3RhcicsIFs4OTAyXV0sIFsnc3RhcicsIFs5NzM0XV0sIFsnc3RhcmYnLCBbOTczM11dLCBbJ3N0cmFpZ2h0ZXBzaWxvbicsIFsxMDEzXV0sIFsnc3RyYWlnaHRwaGknLCBbOTgxXV0sIFsnc3RybnMnLCBbMTc1XV0sIFsnc3ViJywgWzg4MzRdXSwgWydTdWInLCBbODkxMl1dLCBbJ3N1YmRvdCcsIFsxMDk0MV1dLCBbJ3N1YkUnLCBbMTA5NDldXSwgWydzdWJlJywgWzg4MzhdXSwgWydzdWJlZG90JywgWzEwOTQ3XV0sIFsnc3VibXVsdCcsIFsxMDk0NV1dLCBbJ3N1Ym5FJywgWzEwOTU1XV0sIFsnc3VibmUnLCBbODg0Ml1dLCBbJ3N1YnBsdXMnLCBbMTA5NDNdXSwgWydzdWJyYXJyJywgWzEwNjE3XV0sIFsnc3Vic2V0JywgWzg4MzRdXSwgWydTdWJzZXQnLCBbODkxMl1dLCBbJ3N1YnNldGVxJywgWzg4MzhdXSwgWydzdWJzZXRlcXEnLCBbMTA5NDldXSwgWydTdWJzZXRFcXVhbCcsIFs4ODM4XV0sIFsnc3Vic2V0bmVxJywgWzg4NDJdXSwgWydzdWJzZXRuZXFxJywgWzEwOTU1XV0sIFsnc3Vic2ltJywgWzEwOTUxXV0sIFsnc3Vic3ViJywgWzEwOTY1XV0sIFsnc3Vic3VwJywgWzEwOTYzXV0sIFsnc3VjY2FwcHJveCcsIFsxMDkzNl1dLCBbJ3N1Y2MnLCBbODgyN11dLCBbJ3N1Y2NjdXJseWVxJywgWzg4MjldXSwgWydTdWNjZWVkcycsIFs4ODI3XV0sIFsnU3VjY2VlZHNFcXVhbCcsIFsxMDkyOF1dLCBbJ1N1Y2NlZWRzU2xhbnRFcXVhbCcsIFs4ODI5XV0sIFsnU3VjY2VlZHNUaWxkZScsIFs4ODMxXV0sIFsnc3VjY2VxJywgWzEwOTI4XV0sIFsnc3VjY25hcHByb3gnLCBbMTA5MzhdXSwgWydzdWNjbmVxcScsIFsxMDkzNF1dLCBbJ3N1Y2Nuc2ltJywgWzg5MzddXSwgWydzdWNjc2ltJywgWzg4MzFdXSwgWydTdWNoVGhhdCcsIFs4NzE1XV0sIFsnc3VtJywgWzg3MjFdXSwgWydTdW0nLCBbODcyMV1dLCBbJ3N1bmcnLCBbOTgzNF1dLCBbJ3N1cDEnLCBbMTg1XV0sIFsnc3VwMicsIFsxNzhdXSwgWydzdXAzJywgWzE3OV1dLCBbJ3N1cCcsIFs4ODM1XV0sIFsnU3VwJywgWzg5MTNdXSwgWydzdXBkb3QnLCBbMTA5NDJdXSwgWydzdXBkc3ViJywgWzEwOTY4XV0sIFsnc3VwRScsIFsxMDk1MF1dLCBbJ3N1cGUnLCBbODgzOV1dLCBbJ3N1cGVkb3QnLCBbMTA5NDhdXSwgWydTdXBlcnNldCcsIFs4ODM1XV0sIFsnU3VwZXJzZXRFcXVhbCcsIFs4ODM5XV0sIFsnc3VwaHNvbCcsIFsxMDE4NV1dLCBbJ3N1cGhzdWInLCBbMTA5NjddXSwgWydzdXBsYXJyJywgWzEwNjE5XV0sIFsnc3VwbXVsdCcsIFsxMDk0Nl1dLCBbJ3N1cG5FJywgWzEwOTU2XV0sIFsnc3VwbmUnLCBbODg0M11dLCBbJ3N1cHBsdXMnLCBbMTA5NDRdXSwgWydzdXBzZXQnLCBbODgzNV1dLCBbJ1N1cHNldCcsIFs4OTEzXV0sIFsnc3Vwc2V0ZXEnLCBbODgzOV1dLCBbJ3N1cHNldGVxcScsIFsxMDk1MF1dLCBbJ3N1cHNldG5lcScsIFs4ODQzXV0sIFsnc3Vwc2V0bmVxcScsIFsxMDk1Nl1dLCBbJ3N1cHNpbScsIFsxMDk1Ml1dLCBbJ3N1cHN1YicsIFsxMDk2NF1dLCBbJ3N1cHN1cCcsIFsxMDk2Nl1dLCBbJ3N3YXJoaycsIFsxMDUzNF1dLCBbJ3N3YXJyJywgWzg2MDFdXSwgWydzd0FycicsIFs4NjY1XV0sIFsnc3dhcnJvdycsIFs4NjAxXV0sIFsnc3dud2FyJywgWzEwNTM4XV0sIFsnc3psaWcnLCBbMjIzXV0sIFsnVGFiJywgWzldXSwgWyd0YXJnZXQnLCBbODk4Ml1dLCBbJ1RhdScsIFs5MzJdXSwgWyd0YXUnLCBbOTY0XV0sIFsndGJyaycsIFs5MTQwXV0sIFsnVGNhcm9uJywgWzM1Nl1dLCBbJ3RjYXJvbicsIFszNTddXSwgWydUY2VkaWwnLCBbMzU0XV0sIFsndGNlZGlsJywgWzM1NV1dLCBbJ1RjeScsIFsxMDU4XV0sIFsndGN5JywgWzEwOTBdXSwgWyd0ZG90JywgWzg0MTFdXSwgWyd0ZWxyZWMnLCBbODk4MV1dLCBbJ1RmcicsIFsxMjAwODddXSwgWyd0ZnInLCBbMTIwMTEzXV0sIFsndGhlcmU0JywgWzg3NTZdXSwgWyd0aGVyZWZvcmUnLCBbODc1Nl1dLCBbJ1RoZXJlZm9yZScsIFs4NzU2XV0sIFsnVGhldGEnLCBbOTIwXV0sIFsndGhldGEnLCBbOTUyXV0sIFsndGhldGFzeW0nLCBbOTc3XV0sIFsndGhldGF2JywgWzk3N11dLCBbJ3RoaWNrYXBwcm94JywgWzg3NzZdXSwgWyd0aGlja3NpbScsIFs4NzY0XV0sIFsnVGhpY2tTcGFjZScsIFs4Mjg3LCA4MjAyXV0sIFsnVGhpblNwYWNlJywgWzgyMDFdXSwgWyd0aGluc3AnLCBbODIwMV1dLCBbJ3Roa2FwJywgWzg3NzZdXSwgWyd0aGtzaW0nLCBbODc2NF1dLCBbJ1RIT1JOJywgWzIyMl1dLCBbJ3Rob3JuJywgWzI1NF1dLCBbJ3RpbGRlJywgWzczMl1dLCBbJ1RpbGRlJywgWzg3NjRdXSwgWydUaWxkZUVxdWFsJywgWzg3NzFdXSwgWydUaWxkZUZ1bGxFcXVhbCcsIFs4NzczXV0sIFsnVGlsZGVUaWxkZScsIFs4Nzc2XV0sIFsndGltZXNiYXInLCBbMTA4MDFdXSwgWyd0aW1lc2InLCBbODg2NF1dLCBbJ3RpbWVzJywgWzIxNV1dLCBbJ3RpbWVzZCcsIFsxMDgwMF1dLCBbJ3RpbnQnLCBbODc0OV1dLCBbJ3RvZWEnLCBbMTA1MzZdXSwgWyd0b3Bib3QnLCBbOTAxNF1dLCBbJ3RvcGNpcicsIFsxMDk5M11dLCBbJ3RvcCcsIFs4ODY4XV0sIFsnVG9wZicsIFsxMjAxMzldXSwgWyd0b3BmJywgWzEyMDE2NV1dLCBbJ3RvcGZvcmsnLCBbMTA5NzBdXSwgWyd0b3NhJywgWzEwNTM3XV0sIFsndHByaW1lJywgWzgyNDRdXSwgWyd0cmFkZScsIFs4NDgyXV0sIFsnVFJBREUnLCBbODQ4Ml1dLCBbJ3RyaWFuZ2xlJywgWzk2NTNdXSwgWyd0cmlhbmdsZWRvd24nLCBbOTY2M11dLCBbJ3RyaWFuZ2xlbGVmdCcsIFs5NjY3XV0sIFsndHJpYW5nbGVsZWZ0ZXEnLCBbODg4NF1dLCBbJ3RyaWFuZ2xlcScsIFs4Nzk2XV0sIFsndHJpYW5nbGVyaWdodCcsIFs5NjU3XV0sIFsndHJpYW5nbGVyaWdodGVxJywgWzg4ODVdXSwgWyd0cmlkb3QnLCBbOTcwOF1dLCBbJ3RyaWUnLCBbODc5Nl1dLCBbJ3RyaW1pbnVzJywgWzEwODEwXV0sIFsnVHJpcGxlRG90JywgWzg0MTFdXSwgWyd0cmlwbHVzJywgWzEwODA5XV0sIFsndHJpc2InLCBbMTA3MDFdXSwgWyd0cml0aW1lJywgWzEwODExXV0sIFsndHJwZXppdW0nLCBbOTE4Nl1dLCBbJ1RzY3InLCBbMTE5OTgzXV0sIFsndHNjcicsIFsxMjAwMDldXSwgWydUU2N5JywgWzEwNjJdXSwgWyd0c2N5JywgWzEwOTRdXSwgWydUU0hjeScsIFsxMDM1XV0sIFsndHNoY3knLCBbMTExNV1dLCBbJ1RzdHJvaycsIFszNThdXSwgWyd0c3Ryb2snLCBbMzU5XV0sIFsndHdpeHQnLCBbODgxMl1dLCBbJ3R3b2hlYWRsZWZ0YXJyb3cnLCBbODYwNl1dLCBbJ3R3b2hlYWRyaWdodGFycm93JywgWzg2MDhdXSwgWydVYWN1dGUnLCBbMjE4XV0sIFsndWFjdXRlJywgWzI1MF1dLCBbJ3VhcnInLCBbODU5M11dLCBbJ1VhcnInLCBbODYwN11dLCBbJ3VBcnInLCBbODY1N11dLCBbJ1VhcnJvY2lyJywgWzEwNTY5XV0sIFsnVWJyY3knLCBbMTAzOF1dLCBbJ3VicmN5JywgWzExMThdXSwgWydVYnJldmUnLCBbMzY0XV0sIFsndWJyZXZlJywgWzM2NV1dLCBbJ1VjaXJjJywgWzIxOV1dLCBbJ3VjaXJjJywgWzI1MV1dLCBbJ1VjeScsIFsxMDU5XV0sIFsndWN5JywgWzEwOTFdXSwgWyd1ZGFycicsIFs4NjQ1XV0sIFsnVWRibGFjJywgWzM2OF1dLCBbJ3VkYmxhYycsIFszNjldXSwgWyd1ZGhhcicsIFsxMDYwNl1dLCBbJ3VmaXNodCcsIFsxMDYyMl1dLCBbJ1VmcicsIFsxMjAwODhdXSwgWyd1ZnInLCBbMTIwMTE0XV0sIFsnVWdyYXZlJywgWzIxN11dLCBbJ3VncmF2ZScsIFsyNDldXSwgWyd1SGFyJywgWzEwNTk1XV0sIFsndWhhcmwnLCBbODYzOV1dLCBbJ3VoYXJyJywgWzg2MzhdXSwgWyd1aGJsaycsIFs5NjAwXV0sIFsndWxjb3JuJywgWzg5ODhdXSwgWyd1bGNvcm5lcicsIFs4OTg4XV0sIFsndWxjcm9wJywgWzg5NzVdXSwgWyd1bHRyaScsIFs5NzIwXV0sIFsnVW1hY3InLCBbMzYyXV0sIFsndW1hY3InLCBbMzYzXV0sIFsndW1sJywgWzE2OF1dLCBbJ1VuZGVyQmFyJywgWzk1XV0sIFsnVW5kZXJCcmFjZScsIFs5MTgzXV0sIFsnVW5kZXJCcmFja2V0JywgWzkxNDFdXSwgWydVbmRlclBhcmVudGhlc2lzJywgWzkxODFdXSwgWydVbmlvbicsIFs4ODk5XV0sIFsnVW5pb25QbHVzJywgWzg4NDZdXSwgWydVb2dvbicsIFszNzBdXSwgWyd1b2dvbicsIFszNzFdXSwgWydVb3BmJywgWzEyMDE0MF1dLCBbJ3VvcGYnLCBbMTIwMTY2XV0sIFsnVXBBcnJvd0JhcicsIFsxMDUxNF1dLCBbJ3VwYXJyb3cnLCBbODU5M11dLCBbJ1VwQXJyb3cnLCBbODU5M11dLCBbJ1VwYXJyb3cnLCBbODY1N11dLCBbJ1VwQXJyb3dEb3duQXJyb3cnLCBbODY0NV1dLCBbJ3VwZG93bmFycm93JywgWzg1OTddXSwgWydVcERvd25BcnJvdycsIFs4NTk3XV0sIFsnVXBkb3duYXJyb3cnLCBbODY2MV1dLCBbJ1VwRXF1aWxpYnJpdW0nLCBbMTA2MDZdXSwgWyd1cGhhcnBvb25sZWZ0JywgWzg2MzldXSwgWyd1cGhhcnBvb25yaWdodCcsIFs4NjM4XV0sIFsndXBsdXMnLCBbODg0Nl1dLCBbJ1VwcGVyTGVmdEFycm93JywgWzg1OThdXSwgWydVcHBlclJpZ2h0QXJyb3cnLCBbODU5OV1dLCBbJ3Vwc2knLCBbOTY1XV0sIFsnVXBzaScsIFs5NzhdXSwgWyd1cHNpaCcsIFs5NzhdXSwgWydVcHNpbG9uJywgWzkzM11dLCBbJ3Vwc2lsb24nLCBbOTY1XV0sIFsnVXBUZWVBcnJvdycsIFs4NjEzXV0sIFsnVXBUZWUnLCBbODg2OV1dLCBbJ3VwdXBhcnJvd3MnLCBbODY0OF1dLCBbJ3VyY29ybicsIFs4OTg5XV0sIFsndXJjb3JuZXInLCBbODk4OV1dLCBbJ3VyY3JvcCcsIFs4OTc0XV0sIFsnVXJpbmcnLCBbMzY2XV0sIFsndXJpbmcnLCBbMzY3XV0sIFsndXJ0cmknLCBbOTcyMV1dLCBbJ1VzY3InLCBbMTE5OTg0XV0sIFsndXNjcicsIFsxMjAwMTBdXSwgWyd1dGRvdCcsIFs4OTQ0XV0sIFsnVXRpbGRlJywgWzM2MF1dLCBbJ3V0aWxkZScsIFszNjFdXSwgWyd1dHJpJywgWzk2NTNdXSwgWyd1dHJpZicsIFs5NjUyXV0sIFsndXVhcnInLCBbODY0OF1dLCBbJ1V1bWwnLCBbMjIwXV0sIFsndXVtbCcsIFsyNTJdXSwgWyd1d2FuZ2xlJywgWzEwNjYzXV0sIFsndmFuZ3J0JywgWzEwNjUyXV0sIFsndmFyZXBzaWxvbicsIFsxMDEzXV0sIFsndmFya2FwcGEnLCBbMTAwOF1dLCBbJ3Zhcm5vdGhpbmcnLCBbODcwOV1dLCBbJ3ZhcnBoaScsIFs5ODFdXSwgWyd2YXJwaScsIFs5ODJdXSwgWyd2YXJwcm9wdG8nLCBbODczM11dLCBbJ3ZhcnInLCBbODU5N11dLCBbJ3ZBcnInLCBbODY2MV1dLCBbJ3ZhcnJobycsIFsxMDA5XV0sIFsndmFyc2lnbWEnLCBbOTYyXV0sIFsndmFyc3Vic2V0bmVxJywgWzg4NDIsIDY1MDI0XV0sIFsndmFyc3Vic2V0bmVxcScsIFsxMDk1NSwgNjUwMjRdXSwgWyd2YXJzdXBzZXRuZXEnLCBbODg0MywgNjUwMjRdXSwgWyd2YXJzdXBzZXRuZXFxJywgWzEwOTU2LCA2NTAyNF1dLCBbJ3ZhcnRoZXRhJywgWzk3N11dLCBbJ3ZhcnRyaWFuZ2xlbGVmdCcsIFs4ODgyXV0sIFsndmFydHJpYW5nbGVyaWdodCcsIFs4ODgzXV0sIFsndkJhcicsIFsxMDk4NF1dLCBbJ1ZiYXInLCBbMTA5ODddXSwgWyd2QmFydicsIFsxMDk4NV1dLCBbJ1ZjeScsIFsxMDQyXV0sIFsndmN5JywgWzEwNzRdXSwgWyd2ZGFzaCcsIFs4ODY2XV0sIFsndkRhc2gnLCBbODg3Ml1dLCBbJ1ZkYXNoJywgWzg4NzNdXSwgWydWRGFzaCcsIFs4ODc1XV0sIFsnVmRhc2hsJywgWzEwOTgyXV0sIFsndmVlYmFyJywgWzg4OTFdXSwgWyd2ZWUnLCBbODc0NF1dLCBbJ1ZlZScsIFs4ODk3XV0sIFsndmVlZXEnLCBbODc5NF1dLCBbJ3ZlbGxpcCcsIFs4OTQyXV0sIFsndmVyYmFyJywgWzEyNF1dLCBbJ1ZlcmJhcicsIFs4MjE0XV0sIFsndmVydCcsIFsxMjRdXSwgWydWZXJ0JywgWzgyMTRdXSwgWydWZXJ0aWNhbEJhcicsIFs4NzM5XV0sIFsnVmVydGljYWxMaW5lJywgWzEyNF1dLCBbJ1ZlcnRpY2FsU2VwYXJhdG9yJywgWzEwMDcyXV0sIFsnVmVydGljYWxUaWxkZScsIFs4NzY4XV0sIFsnVmVyeVRoaW5TcGFjZScsIFs4MjAyXV0sIFsnVmZyJywgWzEyMDA4OV1dLCBbJ3ZmcicsIFsxMjAxMTVdXSwgWyd2bHRyaScsIFs4ODgyXV0sIFsndm5zdWInLCBbODgzNCwgODQwMl1dLCBbJ3Zuc3VwJywgWzg4MzUsIDg0MDJdXSwgWydWb3BmJywgWzEyMDE0MV1dLCBbJ3ZvcGYnLCBbMTIwMTY3XV0sIFsndnByb3AnLCBbODczM11dLCBbJ3ZydHJpJywgWzg4ODNdXSwgWydWc2NyJywgWzExOTk4NV1dLCBbJ3ZzY3InLCBbMTIwMDExXV0sIFsndnN1Ym5FJywgWzEwOTU1LCA2NTAyNF1dLCBbJ3ZzdWJuZScsIFs4ODQyLCA2NTAyNF1dLCBbJ3ZzdXBuRScsIFsxMDk1NiwgNjUwMjRdXSwgWyd2c3VwbmUnLCBbODg0MywgNjUwMjRdXSwgWydWdmRhc2gnLCBbODg3NF1dLCBbJ3Z6aWd6YWcnLCBbMTA2NTBdXSwgWydXY2lyYycsIFszNzJdXSwgWyd3Y2lyYycsIFszNzNdXSwgWyd3ZWRiYXInLCBbMTA4NDddXSwgWyd3ZWRnZScsIFs4NzQzXV0sIFsnV2VkZ2UnLCBbODg5Nl1dLCBbJ3dlZGdlcScsIFs4NzkzXV0sIFsnd2VpZXJwJywgWzg0NzJdXSwgWydXZnInLCBbMTIwMDkwXV0sIFsnd2ZyJywgWzEyMDExNl1dLCBbJ1dvcGYnLCBbMTIwMTQyXV0sIFsnd29wZicsIFsxMjAxNjhdXSwgWyd3cCcsIFs4NDcyXV0sIFsnd3InLCBbODc2OF1dLCBbJ3dyZWF0aCcsIFs4NzY4XV0sIFsnV3NjcicsIFsxMTk5ODZdXSwgWyd3c2NyJywgWzEyMDAxMl1dLCBbJ3hjYXAnLCBbODg5OF1dLCBbJ3hjaXJjJywgWzk3MTFdXSwgWyd4Y3VwJywgWzg4OTldXSwgWyd4ZHRyaScsIFs5NjYxXV0sIFsnWGZyJywgWzEyMDA5MV1dLCBbJ3hmcicsIFsxMjAxMTddXSwgWyd4aGFycicsIFsxMDIzMV1dLCBbJ3hoQXJyJywgWzEwMjM0XV0sIFsnWGknLCBbOTI2XV0sIFsneGknLCBbOTU4XV0sIFsneGxhcnInLCBbMTAyMjldXSwgWyd4bEFycicsIFsxMDIzMl1dLCBbJ3htYXAnLCBbMTAyMzZdXSwgWyd4bmlzJywgWzg5NTVdXSwgWyd4b2RvdCcsIFsxMDc1Ml1dLCBbJ1hvcGYnLCBbMTIwMTQzXV0sIFsneG9wZicsIFsxMjAxNjldXSwgWyd4b3BsdXMnLCBbMTA3NTNdXSwgWyd4b3RpbWUnLCBbMTA3NTRdXSwgWyd4cmFycicsIFsxMDIzMF1dLCBbJ3hyQXJyJywgWzEwMjMzXV0sIFsnWHNjcicsIFsxMTk5ODddXSwgWyd4c2NyJywgWzEyMDAxM11dLCBbJ3hzcWN1cCcsIFsxMDc1OF1dLCBbJ3h1cGx1cycsIFsxMDc1Nl1dLCBbJ3h1dHJpJywgWzk2NTFdXSwgWyd4dmVlJywgWzg4OTddXSwgWyd4d2VkZ2UnLCBbODg5Nl1dLCBbJ1lhY3V0ZScsIFsyMjFdXSwgWyd5YWN1dGUnLCBbMjUzXV0sIFsnWUFjeScsIFsxMDcxXV0sIFsneWFjeScsIFsxMTAzXV0sIFsnWWNpcmMnLCBbMzc0XV0sIFsneWNpcmMnLCBbMzc1XV0sIFsnWWN5JywgWzEwNjddXSwgWyd5Y3knLCBbMTA5OV1dLCBbJ3llbicsIFsxNjVdXSwgWydZZnInLCBbMTIwMDkyXV0sIFsneWZyJywgWzEyMDExOF1dLCBbJ1lJY3knLCBbMTAzMV1dLCBbJ3lpY3knLCBbMTExMV1dLCBbJ1lvcGYnLCBbMTIwMTQ0XV0sIFsneW9wZicsIFsxMjAxNzBdXSwgWydZc2NyJywgWzExOTk4OF1dLCBbJ3lzY3InLCBbMTIwMDE0XV0sIFsnWVVjeScsIFsxMDcwXV0sIFsneXVjeScsIFsxMTAyXV0sIFsneXVtbCcsIFsyNTVdXSwgWydZdW1sJywgWzM3Nl1dLCBbJ1phY3V0ZScsIFszNzddXSwgWyd6YWN1dGUnLCBbMzc4XV0sIFsnWmNhcm9uJywgWzM4MV1dLCBbJ3pjYXJvbicsIFszODJdXSwgWydaY3knLCBbMTA0N11dLCBbJ3pjeScsIFsxMDc5XV0sIFsnWmRvdCcsIFszNzldXSwgWyd6ZG90JywgWzM4MF1dLCBbJ3plZXRyZicsIFs4NDg4XV0sIFsnWmVyb1dpZHRoU3BhY2UnLCBbODIwM11dLCBbJ1pldGEnLCBbOTE4XV0sIFsnemV0YScsIFs5NTBdXSwgWyd6ZnInLCBbMTIwMTE5XV0sIFsnWmZyJywgWzg0ODhdXSwgWydaSGN5JywgWzEwNDZdXSwgWyd6aGN5JywgWzEwNzhdXSwgWyd6aWdyYXJyJywgWzg2NjldXSwgWyd6b3BmJywgWzEyMDE3MV1dLCBbJ1pvcGYnLCBbODQ4NF1dLCBbJ1pzY3InLCBbMTE5OTg5XV0sIFsnenNjcicsIFsxMjAwMTVdXSwgWyd6d2onLCBbODIwNV1dLCBbJ3p3bmonLCBbODIwNF1dXTtcblxudmFyIGFscGhhSW5kZXggPSB7fTtcbnZhciBjaGFySW5kZXggPSB7fTtcblxuY3JlYXRlSW5kZXhlcyhhbHBoYUluZGV4LCBjaGFySW5kZXgpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIdG1sNUVudGl0aWVzKCkge31cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJigjP1tcXHdcXGRdKyk7Py9nLCBmdW5jdGlvbihzLCBlbnRpdHkpIHtcbiAgICAgICAgdmFyIGNocjtcbiAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGVudGl0eS5jaGFyQXQoMSkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigyKS50b0xvd2VyQ2FzZSgpLCAxNikgOlxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMSkpO1xuXG4gICAgICAgICAgICBpZiAoIShpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkpIHtcbiAgICAgICAgICAgICAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyID0gYWxwaGFJbmRleFtlbnRpdHldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHIgfHwgcztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoYXJJbmZvID0gY2hhckluZGV4W3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgaWYgKGNoYXJJbmZvKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBjaGFySW5mb1tzdHIuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbHBoYSA9IGNoYXJJbmZvWycnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBjaGFySW5mbyA9IGNoYXJJbmRleFtjXTtcbiAgICAgICAgaWYgKGNoYXJJbmZvKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBjaGFySW5mb1tzdHIuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbHBoYSA9IGNoYXJJbmZvWycnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMzIgfHwgYyA+IDEyNikge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICBpKytcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGFscGhhSW5kZXggUGFzc2VkIGJ5IHJlZmVyZW5jZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGFySW5kZXggUGFzc2VkIGJ5IHJlZmVyZW5jZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5kZXhlcyhhbHBoYUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICB2YXIgaSA9IEVOVElUSUVTLmxlbmd0aDtcbiAgICB2YXIgX3Jlc3VsdHMgPSBbXTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciBlID0gRU5USVRJRVNbaV07XG4gICAgICAgIHZhciBhbHBoYSA9IGVbMF07XG4gICAgICAgIHZhciBjaGFycyA9IGVbMV07XG4gICAgICAgIHZhciBjaHIgPSBjaGFyc1swXTtcbiAgICAgICAgdmFyIGFkZENoYXIgPSAoY2hyIDwgMzIgfHwgY2hyID4gMTI2KSB8fCBjaHIgPT09IDYyIHx8IGNociA9PT0gNjAgfHwgY2hyID09PSAzOCB8fCBjaHIgPT09IDM0IHx8IGNociA9PT0gMzk7XG4gICAgICAgIHZhciBjaGFySW5mbztcbiAgICAgICAgaWYgKGFkZENoYXIpIHtcbiAgICAgICAgICAgIGNoYXJJbmZvID0gY2hhckluZGV4W2Nocl0gPSBjaGFySW5kZXhbY2hyXSB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcnNbMV0pIHtcbiAgICAgICAgICAgIHZhciBjaHIyID0gY2hhcnNbMV07XG4gICAgICAgICAgICBhbHBoYUluZGV4W2FscGhhXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMik7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGFkZENoYXIgJiYgKGNoYXJJbmZvW2NocjJdID0gYWxwaGEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFscGhhSW5kZXhbYWxwaGFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChhZGRDaGFyICYmIChjaGFySW5mb1snJ10gPSBhbHBoYSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWw1RW50aXRpZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaHRtbC1lbnRpdGllcy9saWIvaHRtbDUtZW50aXRpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7WWF3UGl0Y2hDb250cm9sfSBmcm9tIFwiLi9ZYXdQaXRjaENvbnRyb2xcIjtcbmltcG9ydCB7UGFub1ZpZXdlcn0gZnJvbSBcIi4vUGFub1ZpZXdlclwiO1xuaW1wb3J0IHtTcGluVmlld2VyLCBTcHJpdGVJbWFnZX0gZnJvbSBcIi4vU3BpblZpZXdlclwiO1xuXG5jb25zdCBWRVJTSU9OID0gXCIzLjAuMC1yY1wiO1xuXG5leHBvcnQge1xuXHRZYXdQaXRjaENvbnRyb2wsXG5cdFBhbm9WaWV3ZXIsXG5cdFNwaW5WaWV3ZXIsXG5cdFNwcml0ZUltYWdlLFxuXHRWRVJTSU9OXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgX19yZXNvdXJjZVF1ZXJ5IFdvcmtlckdsb2JhbFNjb3BlIHNlbGYgKi9cbi8qIGVzbGludCBwcmVmZXItZGVzdHJ1Y3R1cmluZzogb2ZmICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbnZhciBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG52YXIgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKS5nZXRMb2dnZXIoJ3dlYnBhY2stZGV2LXNlcnZlcicpO1xudmFyIHNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG52YXIgb3ZlcmxheSA9IHJlcXVpcmUoJy4vb3ZlcmxheScpO1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0U291cmNlKCkge1xuICAvLyBgZG9jdW1lbnQuY3VycmVudFNjcmlwdGAgaXMgdGhlIG1vc3QgYWNjdXJhdGUgd2F5IHRvIGZpbmQgdGhlIGN1cnJlbnQgc2NyaXB0LFxuICAvLyBidXQgaXMgbm90IHN1cHBvcnRlZCBpbiBhbGwgYnJvd3NlcnMuXG4gIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgfVxuICAvLyBGYWxsIGJhY2sgdG8gZ2V0dGluZyBhbGwgc2NyaXB0cyBpbiB0aGUgZG9jdW1lbnQuXG4gIHZhciBzY3JpcHRFbGVtZW50cyA9IGRvY3VtZW50LnNjcmlwdHMgfHwgW107XG4gIHZhciBjdXJyZW50U2NyaXB0ID0gc2NyaXB0RWxlbWVudHNbc2NyaXB0RWxlbWVudHMubGVuZ3RoIC0gMV07XG4gIGlmIChjdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgfVxuICAvLyBGYWlsIGFzIHRoZXJlIHdhcyBubyBzY3JpcHQgdG8gdXNlLlxuICB0aHJvdyBuZXcgRXJyb3IoJ1tXRFNdIEZhaWxlZCB0byBnZXQgY3VycmVudCBzY3JpcHQgc291cmNlLicpO1xufVxuXG52YXIgdXJsUGFydHMgPSB2b2lkIDA7XG52YXIgaG90UmVsb2FkID0gdHJ1ZTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB2YXIgcXMgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnRvTG93ZXJDYXNlKCk7XG4gIGhvdFJlbG9hZCA9IHFzLmluZGV4T2YoJ2hvdHJlbG9hZD1mYWxzZScpID09PSAtMTtcbn1cbmlmICh0eXBlb2YgX19yZXNvdXJjZVF1ZXJ5ID09PSAnc3RyaW5nJyAmJiBfX3Jlc291cmNlUXVlcnkpIHtcbiAgLy8gSWYgdGhpcyBidW5kbGUgaXMgaW5saW5lZCwgdXNlIHRoZSByZXNvdXJjZSBxdWVyeSB0byBnZXQgdGhlIGNvcnJlY3QgdXJsLlxuICB1cmxQYXJ0cyA9IHVybC5wYXJzZShfX3Jlc291cmNlUXVlcnkuc3Vic3RyKDEpKTtcbn0gZWxzZSB7XG4gIC8vIEVsc2UsIGdldCB0aGUgdXJsIGZyb20gdGhlIDxzY3JpcHQ+IHRoaXMgZmlsZSB3YXMgY2FsbGVkIHdpdGguXG4gIHZhciBzY3JpcHRIb3N0ID0gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgc2NyaXB0SG9zdCA9IHNjcmlwdEhvc3QucmVwbGFjZSgvXFwvW15cXC9dKyQvLCAnJyk7XG4gIHVybFBhcnRzID0gdXJsLnBhcnNlKHNjcmlwdEhvc3QgfHwgJy8nLCBmYWxzZSwgdHJ1ZSk7XG59XG5cbmlmICghdXJsUGFydHMucG9ydCB8fCB1cmxQYXJ0cy5wb3J0ID09PSAnMCcpIHtcbiAgdXJsUGFydHMucG9ydCA9IHNlbGYubG9jYXRpb24ucG9ydDtcbn1cblxudmFyIF9ob3QgPSBmYWxzZTtcbnZhciBpbml0aWFsID0gdHJ1ZTtcbnZhciBjdXJyZW50SGFzaCA9ICcnO1xudmFyIHVzZVdhcm5pbmdPdmVybGF5ID0gZmFsc2U7XG52YXIgdXNlRXJyb3JPdmVybGF5ID0gZmFsc2U7XG52YXIgdXNlUHJvZ3Jlc3MgPSBmYWxzZTtcblxudmFyIElORk8gPSAnaW5mbyc7XG52YXIgV0FSTklORyA9ICd3YXJuaW5nJztcbnZhciBFUlJPUiA9ICdlcnJvcic7XG52YXIgTk9ORSA9ICdub25lJztcblxuLy8gU2V0IHRoZSBkZWZhdWx0IGxvZyBsZXZlbFxubG9nLnNldERlZmF1bHRMZXZlbChJTkZPKTtcblxuLy8gU2VuZCBtZXNzYWdlcyB0byB0aGUgb3V0c2lkZSwgc28gcGx1Z2lucyBjYW4gY29uc3VtZSBpdC5cbmZ1bmN0aW9uIHNlbmRNc2codHlwZSwgZGF0YSkge1xuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPT09ICd1bmRlZmluZWQnIHx8ICEoc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSkpIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6ICd3ZWJwYWNrJyArIHR5cGUsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSwgJyonKTtcbiAgfVxufVxuXG52YXIgb25Tb2NrZXRNc2cgPSB7XG4gIGhvdDogZnVuY3Rpb24gaG90KCkge1xuICAgIF9ob3QgPSB0cnVlO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGVuYWJsZWQuJyk7XG4gIH0sXG4gIGludmFsaWQ6IGZ1bmN0aW9uIGludmFsaWQoKSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEFwcCB1cGRhdGVkLiBSZWNvbXBpbGluZy4uLicpO1xuICAgIC8vIGZpeGVzICMxMDQyLiBvdmVybGF5IGRvZXNuJ3QgY2xlYXIgaWYgZXJyb3JzIGFyZSBmaXhlZCBidXQgd2FybmluZ3MgcmVtYWluLlxuICAgIGlmICh1c2VXYXJuaW5nT3ZlcmxheSB8fCB1c2VFcnJvck92ZXJsYXkpIG92ZXJsYXkuY2xlYXIoKTtcbiAgICBzZW5kTXNnKCdJbnZhbGlkJyk7XG4gIH0sXG4gIGhhc2g6IGZ1bmN0aW9uIGhhc2goX2hhc2gpIHtcbiAgICBjdXJyZW50SGFzaCA9IF9oYXNoO1xuICB9LFxuXG4gICdzdGlsbC1vayc6IGZ1bmN0aW9uIHN0aWxsT2soKSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIE5vdGhpbmcgY2hhbmdlZC4nKTtcbiAgICBpZiAodXNlV2FybmluZ092ZXJsYXkgfHwgdXNlRXJyb3JPdmVybGF5KSBvdmVybGF5LmNsZWFyKCk7XG4gICAgc2VuZE1zZygnU3RpbGxPaycpO1xuICB9LFxuICAnbG9nLWxldmVsJzogZnVuY3Rpb24gbG9nTGV2ZWwobGV2ZWwpIHtcbiAgICB2YXIgaG90Q3R4ID0gcmVxdWlyZS5jb250ZXh0KCd3ZWJwYWNrL2hvdCcsIGZhbHNlLCAvXlxcLlxcL2xvZyQvKTtcbiAgICBpZiAoaG90Q3R4LmtleXMoKS5pbmRleE9mKCcuL2xvZycpICE9PSAtMSkge1xuICAgICAgaG90Q3R4KCcuL2xvZycpLnNldExvZ0xldmVsKGxldmVsKTtcbiAgICB9XG4gICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgY2FzZSBJTkZPOlxuICAgICAgY2FzZSBFUlJPUjpcbiAgICAgICAgbG9nLnNldExldmVsKGxldmVsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFdBUk5JTkc6XG4gICAgICAgIC8vIGxvZ2xldmVsJ3Mgd2FybmluZyBuYW1lIGlzIGRpZmZlcmVudCBmcm9tIHdlYnBhY2snc1xuICAgICAgICBsb2cuc2V0TGV2ZWwoJ3dhcm4nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE5PTkU6XG4gICAgICAgIGxvZy5kaXNhYmxlQWxsKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbG9nLmVycm9yKCdbV0RTXSBVbmtub3duIGNsaWVudExvZ0xldmVsIFxcJycgKyBsZXZlbCArICdcXCcnKTtcbiAgICB9XG4gIH0sXG4gIG92ZXJsYXk6IGZ1bmN0aW9uIG92ZXJsYXkodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHVzZVdhcm5pbmdPdmVybGF5ID0gZmFsc2U7XG4gICAgICAgIHVzZUVycm9yT3ZlcmxheSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1c2VXYXJuaW5nT3ZlcmxheSA9IHZhbHVlLndhcm5pbmdzO1xuICAgICAgICB1c2VFcnJvck92ZXJsYXkgPSB2YWx1ZS5lcnJvcnM7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwcm9ncmVzczogZnVuY3Rpb24gcHJvZ3Jlc3MoX3Byb2dyZXNzKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHVzZVByb2dyZXNzID0gX3Byb2dyZXNzO1xuICAgIH1cbiAgfSxcblxuICAncHJvZ3Jlc3MtdXBkYXRlJzogZnVuY3Rpb24gcHJvZ3Jlc3NVcGRhdGUoZGF0YSkge1xuICAgIGlmICh1c2VQcm9ncmVzcykgbG9nLmluZm8oJ1tXRFNdICcgKyBkYXRhLnBlcmNlbnQgKyAnJSAtICcgKyBkYXRhLm1zZyArICcuJyk7XG4gIH0sXG4gIG9rOiBmdW5jdGlvbiBvaygpIHtcbiAgICBzZW5kTXNnKCdPaycpO1xuICAgIGlmICh1c2VXYXJuaW5nT3ZlcmxheSB8fCB1c2VFcnJvck92ZXJsYXkpIG92ZXJsYXkuY2xlYXIoKTtcbiAgICBpZiAoaW5pdGlhbCkgcmV0dXJuIGluaXRpYWwgPSBmYWxzZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXR1cm4tYXNzaWduXG4gICAgcmVsb2FkQXBwKCk7XG4gIH0sXG5cbiAgJ2NvbnRlbnQtY2hhbmdlZCc6IGZ1bmN0aW9uIGNvbnRlbnRDaGFuZ2VkKCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBDb250ZW50IGJhc2UgY2hhbmdlZC4gUmVsb2FkaW5nLi4uJyk7XG4gICAgc2VsZi5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfSxcbiAgd2FybmluZ3M6IGZ1bmN0aW9uIHdhcm5pbmdzKF93YXJuaW5ncykge1xuICAgIGxvZy53YXJuKCdbV0RTXSBXYXJuaW5ncyB3aGlsZSBjb21waWxpbmcuJyk7XG4gICAgdmFyIHN0cmlwcGVkV2FybmluZ3MgPSBfd2FybmluZ3MubWFwKGZ1bmN0aW9uICh3YXJuaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKHdhcm5pbmcpO1xuICAgIH0pO1xuICAgIHNlbmRNc2coJ1dhcm5pbmdzJywgc3RyaXBwZWRXYXJuaW5ncyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpcHBlZFdhcm5pbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2cud2FybihzdHJpcHBlZFdhcm5pbmdzW2ldKTtcbiAgICB9XG4gICAgaWYgKHVzZVdhcm5pbmdPdmVybGF5KSBvdmVybGF5LnNob3dNZXNzYWdlKF93YXJuaW5ncyk7XG5cbiAgICBpZiAoaW5pdGlhbCkgcmV0dXJuIGluaXRpYWwgPSBmYWxzZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXR1cm4tYXNzaWduXG4gICAgcmVsb2FkQXBwKCk7XG4gIH0sXG4gIGVycm9yczogZnVuY3Rpb24gZXJyb3JzKF9lcnJvcnMpIHtcbiAgICBsb2cuZXJyb3IoJ1tXRFNdIEVycm9ycyB3aGlsZSBjb21waWxpbmcuIFJlbG9hZCBwcmV2ZW50ZWQuJyk7XG4gICAgdmFyIHN0cmlwcGVkRXJyb3JzID0gX2Vycm9ycy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKGVycm9yKTtcbiAgICB9KTtcbiAgICBzZW5kTXNnKCdFcnJvcnMnLCBzdHJpcHBlZEVycm9ycyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpcHBlZEVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgbG9nLmVycm9yKHN0cmlwcGVkRXJyb3JzW2ldKTtcbiAgICB9XG4gICAgaWYgKHVzZUVycm9yT3ZlcmxheSkgb3ZlcmxheS5zaG93TWVzc2FnZShfZXJyb3JzKTtcbiAgfSxcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKF9lcnJvcikge1xuICAgIGxvZy5lcnJvcihfZXJyb3IpO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgbG9nLmVycm9yKCdbV0RTXSBEaXNjb25uZWN0ZWQhJyk7XG4gICAgc2VuZE1zZygnQ2xvc2UnKTtcbiAgfVxufTtcblxudmFyIGhvc3RuYW1lID0gdXJsUGFydHMuaG9zdG5hbWU7XG52YXIgcHJvdG9jb2wgPSB1cmxQYXJ0cy5wcm90b2NvbDtcblxuLy8gY2hlY2sgaXB2NCBhbmQgaXB2NiBgYWxsIGhvc3RuYW1lYFxuaWYgKGhvc3RuYW1lID09PSAnMC4wLjAuMCcgfHwgaG9zdG5hbWUgPT09ICc6OicpIHtcbiAgLy8gd2h5IGRvIHdlIG5lZWQgdGhpcyBjaGVjaz9cbiAgLy8gaG9zdG5hbWUgbi9hIGZvciBmaWxlIHByb3RvY29sIChleGFtcGxlLCB3aGVuIHVzaW5nIGVsZWN0cm9uLCBpb25pYylcbiAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrLWRldi1zZXJ2ZXIvcHVsbC8zODRcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgaWYgKHNlbGYubG9jYXRpb24uaG9zdG5hbWUgJiYgISF+c2VsZi5sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKCdodHRwJykpIHtcbiAgICBob3N0bmFtZSA9IHNlbGYubG9jYXRpb24uaG9zdG5hbWU7XG4gIH1cbn1cblxuLy8gYGhvc3RuYW1lYCBjYW4gYmUgZW1wdHkgd2hlbiB0aGUgc2NyaXB0IHBhdGggaXMgcmVsYXRpdmUuIEluIHRoYXQgY2FzZSwgc3BlY2lmeWluZ1xuLy8gYSBwcm90b2NvbCB3b3VsZCByZXN1bHQgaW4gYW4gaW52YWxpZCBVUkwuXG4vLyBXaGVuIGh0dHBzIGlzIHVzZWQgaW4gdGhlIGFwcCwgc2VjdXJlIHdlYnNvY2tldHMgYXJlIGFsd2F5cyBuZWNlc3Nhcnlcbi8vIGJlY2F1c2UgdGhlIGJyb3dzZXIgZG9lc24ndCBhY2NlcHQgbm9uLXNlY3VyZSB3ZWJzb2NrZXRzLlxuaWYgKGhvc3RuYW1lICYmIChzZWxmLmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyB8fCB1cmxQYXJ0cy5ob3N0bmFtZSA9PT0gJzAuMC4wLjAnKSkge1xuICBwcm90b2NvbCA9IHNlbGYubG9jYXRpb24ucHJvdG9jb2w7XG59XG5cbnZhciBzb2NrZXRVcmwgPSB1cmwuZm9ybWF0KHtcbiAgcHJvdG9jb2w6IHByb3RvY29sLFxuICBhdXRoOiB1cmxQYXJ0cy5hdXRoLFxuICBob3N0bmFtZTogaG9zdG5hbWUsXG4gIHBvcnQ6IHVybFBhcnRzLnBvcnQsXG4gIHBhdGhuYW1lOiB1cmxQYXJ0cy5wYXRoID09IG51bGwgfHwgdXJsUGFydHMucGF0aCA9PT0gJy8nID8gJy9zb2NranMtbm9kZScgOiB1cmxQYXJ0cy5wYXRoXG59KTtcblxuc29ja2V0KHNvY2tldFVybCwgb25Tb2NrZXRNc2cpO1xuXG52YXIgaXNVbmxvYWRpbmcgPSBmYWxzZTtcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICBpc1VubG9hZGluZyA9IHRydWU7XG59KTtcblxuZnVuY3Rpb24gcmVsb2FkQXBwKCkge1xuICBpZiAoaXNVbmxvYWRpbmcgfHwgIWhvdFJlbG9hZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoX2hvdCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBBcHAgaG90IHVwZGF0ZS4uLicpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZVxuICAgIHZhciBob3RFbWl0dGVyID0gcmVxdWlyZSgnd2VicGFjay9ob3QvZW1pdHRlcicpO1xuICAgIGhvdEVtaXR0ZXIuZW1pdCgnd2VicGFja0hvdFVwZGF0ZScsIGN1cnJlbnRIYXNoKTtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYud2luZG93KSB7XG4gICAgICAvLyBicm9hZGNhc3QgdXBkYXRlIHRvIHdpbmRvd1xuICAgICAgc2VsZi5wb3N0TWVzc2FnZSgnd2VicGFja0hvdFVwZGF0ZScgKyBjdXJyZW50SGFzaCwgJyonKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJvb3RXaW5kb3cgPSBzZWxmO1xuICAgIC8vIHVzZSBwYXJlbnQgd2luZG93IGZvciByZWxvYWQgKGluIGNhc2Ugd2UncmUgaW4gYW4gaWZyYW1lIHdpdGggbm8gdmFsaWQgc3JjKVxuICAgIHZhciBpbnRlcnZhbElkID0gc2VsZi5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocm9vdFdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAhPT0gJ2Fib3V0OicpIHtcbiAgICAgICAgLy8gcmVsb2FkIGltbWVkaWF0ZWx5IGlmIHByb3RvY29sIGlzIHZhbGlkXG4gICAgICAgIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdFdpbmRvdyA9IHJvb3RXaW5kb3cucGFyZW50O1xuICAgICAgICBpZiAocm9vdFdpbmRvdy5wYXJlbnQgPT09IHJvb3RXaW5kb3cpIHtcbiAgICAgICAgICAvLyBpZiBwYXJlbnQgZXF1YWxzIGN1cnJlbnQgd2luZG93IHdlJ3ZlIHJlYWNoZWQgdGhlIHJvb3Qgd2hpY2ggd291bGQgY29udGludWUgZm9yZXZlciwgc28gdHJpZ2dlciBhIHJlbG9hZCBhbnl3YXlzXG4gICAgICAgICAgYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpIHtcbiAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBBcHAgdXBkYXRlZC4gUmVsb2FkaW5nLi4uJyk7XG4gICAgcm9vdFdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudD9odHRwOi8vbG9jYWxob3N0OjgwODBcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm51bGxcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3N0cmluZy1yZXBsYWNlLXdlYnBhY2stcGx1Z2luL2xvYWRlci5qcz9pZD02YXIxOGh5b3h1NnBtdjYzMm9tbDhyNTI5ISh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudD9odHRwOi9sb2NhbGhvc3Q6ODA4MCIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIkBlZ2pzL2NvbXBvbmVudFwiO1xuXG5jb25zdCBTVEFUVVMgPSB7XG5cdFwiTk9ORVwiOiAwLFxuXHRcIkxPQURJTkdcIjogMSxcblx0XCJMT0FERURcIjogMixcblx0XCJFUlJPUlwiOiAzXG59O1xuXG5jb25zdCBFVkVOVCA9IHtcblx0XCJSRUFEWVNUQVRFQ0hBTkdFXCI6IFwicmVhZHlzdGF0ZWNoYW5nZVwiXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbWFnZUxvYWRlciBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKGltYWdlKSB7XG5cdFx0Ly8gU3VwZXIgY29uc3RydWN0b3Jcblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5faW1hZ2UgPSBudWxsO1xuXHRcdHRoaXMuX29uY2VIYW5kbGVycyA9IFtdO1xuXHRcdHRoaXMuX2xvYWRTdGF0dXMgPSBTVEFUVVMuTk9ORTtcblxuXHRcdGltYWdlICYmIHRoaXMuc2V0KGltYWdlKTtcblx0fVxuXG5cdGdldCgpIHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cdFx0XHRpZiAoIXRoaXMuX2ltYWdlKSB7XG5cdFx0XHRcdHJlaihcIkltYWdlTG9hZGVyOiBpbWFnZSBpcyBub3QgZGVmaWVuZFwiKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fbG9hZFN0YXR1cyA9PT0gU1RBVFVTLkxPQURFRCkge1xuXHRcdFx0XHRyZXModGhpcy5nZXRFbGVtZW50KCkpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9sb2FkU3RhdHVzID09PSBTVEFUVVMuTE9BRElORykge1xuXHRcdFx0XHQvKiBDaGVjayBpc01heWJlTG9hZGVkKCkgZmlyc3QgYmVjYXVzZSB0aGVyZSBtYXkgaGF2ZVxuXHRcdFx0XHRcdHBvc2liaWxpdGllcyB0aGF0IGltYWdlIGFscmVhZHkgbG9hZGVkIGJlZm9yZSBnZXQgaXMgY2FsbGVkLlxuXHRcdFx0XHRcdGZvciBleGFtcGxlIGNhbGxpbmcgZ2V0IG9uIGV4dGVybmFsIGltYWdlIG9ubG9hZCBjYWxsYmFjay4qL1xuXHRcdFx0XHRpZiAoSW1hZ2VMb2FkZXIuaXNNYXliZUxvYWRlZCh0aGlzLl9pbWFnZSkpIHtcblx0XHRcdFx0XHR0aGlzLl9sb2FkU3RhdHVzID0gU1RBVFVTLkxPQURFRDtcblx0XHRcdFx0XHRyZXModGhpcy5nZXRFbGVtZW50KCkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMub24oRVZFTlQuUkVBRFlTVEFURUNIQU5HRSwgZSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoZS50eXBlID09PSBTVEFUVVMuTE9BREVEKSB7XG5cdFx0XHRcdFx0XHRcdHJlcyh0aGlzLmdldEVsZW1lbnQoKSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZWooXCJJbWFnZUxvYWRlcjogZmFpbGVkIHRvIGxvYWQgaW1hZ2VzLlwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVqKFwiSW1hZ2VMb2FkZXI6IGZhaWxlZCB0byBsb2FkIGltYWdlc1wiKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gaW1hZ2UgaW1nIGVsZW1lbnQgb3IgaW1nIHVybCBvciBhcnJheSBvZiBpbWcgZWxlbWVudCBvciBhcnJheSBvZiBpbWcgdXJsXG5cdCAqL1xuXHRzZXQoaW1hZ2UpIHtcblx0XHR0aGlzLl9sb2FkU3RhdHVzID0gU1RBVFVTLkxPQURJTkc7XG5cblx0XHR0aGlzLl9pbWFnZSA9IEltYWdlTG9hZGVyLmNyZWF0ZUVsZW1lbnQoaW1hZ2UpO1xuXG5cdFx0aWYgKEltYWdlTG9hZGVyLmlzTWF5YmVMb2FkZWQodGhpcy5faW1hZ2UpKSB7XG5cdFx0XHR0aGlzLl9sb2FkU3RhdHVzID0gU1RBVFVTLkxPQURFRDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLm9uY2VMb2FkZWQoXG5cdFx0XHR0aGlzLl9pbWFnZSxcblx0XHRcdCgpID0+IHtcblx0XHRcdFx0dGhpcy5fbG9hZFN0YXR1cyA9IFNUQVRVUy5MT0FERUQ7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcihFVkVOVC5SRUFEWVNUQVRFQ0hBTkdFLCB7XG5cdFx0XHRcdFx0dHlwZTogU1RBVFVTLkxPQURFRFxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHQoKSA9PiB7XG5cdFx0XHRcdHRoaXMuX2xvYWRTdGF0dXMgPSBTVEFUVVMuRVJST1I7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcihFVkVOVC5SRUFEWVNUQVRFQ0hBTkdFLCB7XG5cdFx0XHRcdFx0dHlwZTogU1RBVFVTLkVSUk9SXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdCk7XG5cdH1cblxuXHRzdGF0aWMgY3JlYXRlRWxlbWVudChpbWFnZSkge1xuXHRcdGNvbnN0IGltYWdlcyA9IGltYWdlIGluc3RhbmNlb2YgQXJyYXkgPyBpbWFnZSA6IFtpbWFnZV07XG5cblx0XHRyZXR1cm4gaW1hZ2VzLm1hcChpbWcgPT4ge1xuXHRcdFx0bGV0IF9pbWcgPSBpbWc7XG5cblx0XHRcdGlmICh0eXBlb2YgaW1nID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdF9pbWcgPSBuZXcgSW1hZ2UoKTtcblx0XHRcdFx0X2ltZy5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG5cdFx0XHRcdF9pbWcuc3JjID0gaW1nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIF9pbWc7XG5cdFx0fSk7XG5cdH1cblxuXHRnZXRFbGVtZW50KCkge1xuXHRcdHJldHVybiB0aGlzLl9pbWFnZS5sZW5ndGggPT09IDEgPyB0aGlzLl9pbWFnZVswXSA6IHRoaXMuX2ltYWdlO1xuXHR9XG5cblx0c3RhdGljIGlzTWF5YmVMb2FkZWQoaW1hZ2UpIHtcblx0XHRyZXR1cm4gaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZSA/XG5cdFx0XHRpbWFnZS5jb21wbGV0ZSAmJiBpbWFnZS5uYXR1cmFsV2lkdGggIT09IDAgOlxuXHRcdFx0IWltYWdlLnNvbWUoaW1nID0+ICFpbWcuY29tcGxldGUgfHwgaW1nLm5hdHVyYWxXaWR0aCA9PT0gMCk7XG5cdH1cblxuXHRvbmNlTG9hZGVkKHRhcmdldCwgb25sb2FkLCBvbmVycm9yKSB7XG5cdFx0Y29uc3QgdGFyZ2V0cyA9IHRhcmdldCBpbnN0YW5jZW9mIEFycmF5ID8gdGFyZ2V0IDogW3RhcmdldF07XG5cdFx0Y29uc3QgdGFyZ2V0c05vdExvYWRlZCA9IHRhcmdldHMuZmlsdGVyKGltZyA9PiAhSW1hZ2VMb2FkZXIuaXNNYXliZUxvYWRlZChpbWcpKTtcblx0XHRjb25zdCBsb2FkUHJvbWlzZXMgPSB0YXJnZXRzTm90TG9hZGVkLm1hcChpbWcgPT4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cdFx0XHR0aGlzLl9vbmNlKGltZywgXCJsb2FkXCIsICgpID0+IChyZXMoaW1nKSkpO1xuXHRcdFx0dGhpcy5fb25jZShpbWcsIFwiZXJyb3JcIiwgKCkgPT4gKHJlaihpbWcpKSk7XG5cdFx0fSkpO1xuXG5cdFx0UHJvbWlzZS5hbGwobG9hZFByb21pc2VzKS50aGVuKFxuXHRcdFx0cmVzdWx0ID0+IChvbmxvYWQodGFyZ2V0cy5sZW5ndGggPT09IDEgPyB0YXJnZXRzWzBdIDogdGFyZ2V0cykpLFxuXHRcdFx0cmVhc29uID0+IChvbmVycm9yKHJlYXNvbikpXG5cdFx0KTtcblx0fVxuXG5cdF9vbmNlKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcblx0XHRjb25zdCBmbiA9IGV2ZW50ID0+IHtcblx0XHRcdHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuKTtcblx0XHRcdGxpc3RlbmVyKGV2ZW50KTtcblx0XHR9O1xuXG5cdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4pO1xuXHRcdHRoaXMuX29uY2VIYW5kbGVycy5wdXNoKHt0YXJnZXQsIHR5cGUsIGZufSk7XG5cdH1cblxuXHRnZXRTdGF0dXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRTdGF0dXM7XG5cdH1cblxuXHRkZXN0cm95KCkge1xuXHRcdHRoaXMuX29uY2VIYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4ge1xuXHRcdFx0aGFuZGxlci50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihoYW5kbGVyLnR5cGUsIGhhbmRsZXIuZm4pO1xuXHRcdH0pO1xuXHRcdHRoaXMuX29uY2VIYW5kbGVycyA9IFtdO1xuXHRcdHRoaXMuX2ltYWdlLnNyYyA9IFwiXCI7XG5cdFx0dGhpcy5faW1hZ2UgPSBudWxsO1xuXHRcdHRoaXMuX2xvYWRTdGF0dXMgPSBTVEFUVVMuTk9ORTtcblx0fVxufVxuXG5JbWFnZUxvYWRlci5TVEFUVVMgPSBTVEFUVVM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvUGFub0ltYWdlUmVuZGVyZXIvSW1hZ2VMb2FkZXIuanMiLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbmltcG9ydCBJbWFnZUxvYWRlciBmcm9tIFwiLi9JbWFnZUxvYWRlclwiO1xuaW1wb3J0IFZpZGVvTG9hZGVyIGZyb20gXCIuL1ZpZGVvTG9hZGVyXCI7XG5pbXBvcnQgV2ViR0xVdGlscyBmcm9tIFwiLi9XZWJHTFV0aWxzXCI7XG5pbXBvcnQgQ3ViZVJlbmRlcmVyIGZyb20gXCIuL3JlbmRlcmVyL0N1YmVSZW5kZXJlclwiO1xuaW1wb3J0IFNwaGVyZVJlbmRlcmVyIGZyb20gXCIuL3JlbmRlcmVyL1NwaGVyZVJlbmRlcmVyXCI7XG5pbXBvcnQge2dsTWF0cml4LCBtYXQ0LCBxdWF0fSBmcm9tIFwiLi4vdXRpbHMvbWF0aC11dGlsLmpzXCI7XG5pbXBvcnQge2RldmljZVBpeGVsUmF0aW99IGZyb20gXCIuL2Jyb3dzZXJcIjtcbmltcG9ydCB7UFJPSkVDVElPTl9UWVBFfSBmcm9tIFwiLi4vUGFub1ZpZXdlci9jb25zdHNcIjtcblxuY29uc3QgSW1hZ2VUeXBlID0gUFJPSkVDVElPTl9UWVBFO1xuXG5sZXQgREVWSUNFX1BJWEVMX1JBVElPID0gZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuXG4vLyBERVZJQ0VfUElYRUxfUkFUSU8g6rCAIDLrpbwg7LSI6rO87ZWY64qUIOqyveyasOuKlCDrpqzshozsiqQg64Kt67mE7J2066+A66GcIDLroZwg66ee7LaY64ukLlxuaWYgKERFVklDRV9QSVhFTF9SQVRJTyA+IDIpIHtcblx0REVWSUNFX1BJWEVMX1JBVElPID0gMjtcbn1cblxuLy8gZGVmaW5lIGN1c3RvbSBldmVudHMgbmFtZVxuLyoqXG4gKiBUT0RPOiBob3cgdG8gbWFuYWdlIGV2ZW50cy9lcnJvcnR5cGUgd2l0aCBQYW5vVmlld2VyXG4gKlxuICogSSB0aGluayByZW5kZXJlciBldmVudHMgc2hvdWxkIGJlIHNlcGVyYXRlZCBmcm9tIHZpZXdlciBldmVudHMgYWx0aG91Z2ggaXQgaGFzIHNhbWUgbmFtZS5cbiAqL1xuY29uc3QgRVZFTlRTID0ge1xuXHRCSU5EX1RFWFRVUkU6IFwiYmluZFRleHR1cmVcIixcblx0SU1BR0VfTE9BREVEOiBcImltYWdlTG9hZGVkXCIsXG5cdEVSUk9SOiBcImVycm9yXCIsXG5cdFJFTkRFUklOR19DT05URVhUX0xPU1Q6IFwicmVuZGVyaW5nQ29udGV4dExvc3RcIixcblx0UkVOREVSSU5HX0NPTlRFWFRfUkVTVE9SRTogXCJyZW5kZXJpbmdDb250ZXh0UmVzdG9yZVwiLFxufTtcblxuY29uc3QgRVJST1JfVFlQRSA9IHtcblx0SU5WQUxJRF9ERVZJQ0U6IDEwLFxuXHROT19XRUJHTDogMTEsXG5cdEZBSUxfSU1BR0VfTE9BRDogMTJcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhbm9JbWFnZVJlbmRlcmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoaW1hZ2UsIHdpZHRoLCBoZWlnaHQsIGlzVmlkZW8sIHNwaGVyaWNhbENvbmZpZywgcmVuZGVyaW5nQ29udGV4dEF0dHJpYnV0ZXMpIHtcblx0XHQvLyBTdXBlciBjb25zdHJ1Y3RvclxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnNwaGVyaWNhbENvbmZpZyA9IHNwaGVyaWNhbENvbmZpZztcblx0XHR0aGlzLmZpZWxkT2ZWaWV3ID0gc3BoZXJpY2FsQ29uZmlnLmZpZWxkT2ZWaWV3O1xuXG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0dGhpcy5fbGFzdFF1YXRlcm5pb24gPSBudWxsO1xuXHRcdHRoaXMuX2xhc3RZYXcgPSBudWxsO1xuXHRcdHRoaXMuX2xhc3RQaXRjaCA9IG51bGw7XG5cdFx0dGhpcy5fbGFzdEZpZWxkT2ZWaWV3ID0gbnVsbDtcblxuXHRcdHRoaXMucE1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cdFx0dGhpcy5tdk1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cblx0XHQvLyBpbml0aWFsemllIHBNYXRyaXhcblx0XHRtYXQ0LnBlcnNwZWN0aXZlKHRoaXMucE1hdHJpeCwgZ2xNYXRyaXgudG9SYWRpYW4odGhpcy5maWVsZE9mVmlldyksIHdpZHRoIC8gaGVpZ2h0LCAwLjEsIDEwMCk7XG5cblx0XHR0aGlzLnRleHR1cmVDb29yZEJ1ZmZlciA9IG51bGw7XG5cdFx0dGhpcy52ZXJ0ZXhCdWZmZXIgPSBudWxsO1xuXHRcdHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuXHRcdHRoaXMuY2FudmFzID0gdGhpcy5faW5pdENhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcblx0XHR0aGlzLl9yZW5kZXJpbmdDb250ZXh0QXR0cmlidXRlcyA9IHJlbmRlcmluZ0NvbnRleHRBdHRyaWJ1dGVzO1xuXHRcdHRoaXMuX2ltYWdlID0gbnVsbDtcblx0XHR0aGlzLl9pbWFnZUNvbmZpZyA9IG51bGw7XG5cdFx0dGhpcy5faW1hZ2VJc1JlYWR5ID0gZmFsc2U7XG5cdFx0dGhpcy5fc2hvdWxkRm9yY2VEcmF3ID0gZmFsc2U7XG5cdFx0dGhpcy5fa2VlcFVwZGF0ZSA9IGZhbHNlOyAvLyBGbGFnIHRvIHNwZWNpZnkgJ2NvbnRpbnVvdXMgdXBkYXRlJyBvbiB2aWRlbyBldmVuIHdoZW4gc3RpbGwuXG5cblx0XHR0aGlzLl9vbkNvbnRlbnRMb2FkID0gXHR0aGlzLl9vbkNvbnRlbnRMb2FkLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5fb25Db250ZW50RXJyb3IgPSBcdHRoaXMuX29uQ29udGVudEVycm9yLmJpbmQodGhpcyk7XG5cblx0XHRpZiAoaW1hZ2UpIHtcblx0XHRcdHRoaXMuc2V0SW1hZ2Uoe1xuXHRcdFx0XHRpbWFnZSxcblx0XHRcdFx0aW1hZ2VUeXBlOiBzcGhlcmljYWxDb25maWcuaW1hZ2VUeXBlLFxuXHRcdFx0XHRpc1ZpZGVvLFxuXHRcdFx0XHRjdWJlbWFwQ29uZmlnOiBzcGhlcmljYWxDb25maWcuY3ViZW1hcENvbmZpZ1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0Q29udGVudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2U7XG5cdH1cblxuXHRzZXRJbWFnZSh7aW1hZ2UsIGltYWdlVHlwZSwgaXNWaWRlbyA9IGZhbHNlLCBjdWJlbWFwQ29uZmlnfSkge1xuXHRcdHRoaXMuX2ltYWdlSXNSZWFkeSA9IGZhbHNlO1xuXHRcdHRoaXMuX2lzVmlkZW8gPSBpc1ZpZGVvO1xuXHRcdHRoaXMuX2ltYWdlQ29uZmlnID0gT2JqZWN0LmFzc2lnbihcblx0XHRcdHtcblx0XHRcdFx0b3JkZXI6IFwiUkxVREJGXCIsXG5cdFx0XHRcdHRpbGVDb25maWc6IHtcblx0XHRcdFx0XHRmbGlwSGlyb3pvbnRhbDogZmFsc2UsXG5cdFx0XHRcdFx0cm90YXRpb246IDBcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGN1YmVtYXBDb25maWdcblx0XHQpO1xuXHRcdHRoaXMuX3NldEltYWdlVHlwZShpbWFnZVR5cGUpO1xuXG5cdFx0aWYgKHRoaXMuX2NvbnRlbnRMb2FkZXIpIHtcblx0XHRcdHRoaXMuX2NvbnRlbnRMb2FkZXIuZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdGlmIChpc1ZpZGVvKSB7XG5cdFx0XHR0aGlzLl9jb250ZW50TG9hZGVyID0gbmV3IFZpZGVvTG9hZGVyKCk7XG5cdFx0XHR0aGlzLl9rZWVwVXBkYXRlID0gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY29udGVudExvYWRlciA9IG5ldyBJbWFnZUxvYWRlcigpO1xuXHRcdFx0dGhpcy5fa2VlcFVwZGF0ZSA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGltZyBlbGVtZW50IG9yIGltZyB1cmxcblx0XHR0aGlzLl9jb250ZW50TG9hZGVyLnNldChpbWFnZSk7XG5cblx0XHQvLyDsnbTrr7jsp4DsnZgg7IKs7J207KaI66W8IOy6kOyLnO2VnOuLpC5cblx0XHQvLyBpbWFnZSBpcyByZWZlcmVuY2UgZm9yIGNvbnRlbnQgaW4gY29udGVudExvYWRlciwgc28gaXQgbWF5IGJlIG5vdCB2YWxpZCBpZiBjb250ZW50TG9hZGVyIGlzIGRlc3Ryb3llZC5cblx0XHR0aGlzLl9pbWFnZSA9IHRoaXMuX2NvbnRlbnRMb2FkZXIuZ2V0RWxlbWVudCgpO1xuXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnRMb2FkZXIuZ2V0KClcblx0XHRcdC50aGVuKHRoaXMuX29uQ29udGVudExvYWQsIHRoaXMuX29uQ29udGVudEVycm9yKVxuXHRcdFx0LmNhdGNoKGUgPT4gc2V0VGltZW91dCgoKSA9PiB7IHRocm93IGU7IH0pKTsvLyBQcmV2ZW50IGV4Y2VwdGlvbnMgZnJvbSBiZWluZyBpc29sYXRlZCBpbiBwcm9taXNlIGNoYWluLlxuXHR9XG5cblx0X3NldEltYWdlVHlwZShpbWFnZVR5cGUpIHtcblx0XHRpZiAoIWltYWdlVHlwZSB8fCB0aGlzLl9pbWFnZVR5cGUgPT09IGltYWdlVHlwZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2ltYWdlVHlwZSA9IGltYWdlVHlwZTtcblx0XHR0aGlzLl9pc0N1YmVNYXAgPSBpbWFnZVR5cGUgPT09IEltYWdlVHlwZS5DVUJFTUFQO1xuXHRcdHRoaXMuX3JlbmRlcmVyID0gdGhpcy5faXNDdWJlTWFwID8gQ3ViZVJlbmRlcmVyIDogU3BoZXJlUmVuZGVyZXI7XG5cdFx0dGhpcy5faW5pdFdlYkdMKCk7XG5cdH1cblxuXHRfaW5pdENhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblxuXHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0Y2FudmFzLnN0eWxlLmJvdHRvbSA9IDA7XG5cdFx0Y2FudmFzLnN0eWxlLmxlZnQgPSAwO1xuXHRcdGNhbnZhcy5zdHlsZS5yaWdodCA9IDA7XG5cdFx0Y2FudmFzLnN0eWxlLnRvcCA9IDA7XG5cdFx0Y2FudmFzLnN0eWxlLm1hcmdpbiA9IFwiYXV0b1wiO1xuXHRcdGNhbnZhcy5zdHlsZS5tYXhIZWlnaHQgPSBcIjEwMCVcIjtcblx0XHRjYW52YXMuc3R5bGUubWF4V2lkdGggPSBcIjEwMCVcIjtcblx0XHRjYW52YXMuc3R5bGUub3V0bGluZSA9IFwibm9uZVwiO1xuXHRcdGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblxuXHRcdHRoaXMuX29uV2ViZ2xjb250ZXh0bG9zdCA9IHRoaXMuX29uV2ViZ2xjb250ZXh0bG9zdC5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuX29uV2ViZ2xjb250ZXh0cmVzdG9yZWQgPSB0aGlzLl9vbldlYmdsY29udGV4dHJlc3RvcmVkLmJpbmQodGhpcyk7XG5cblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dGxvc3RcIiwgdGhpcy5fb25XZWJnbGNvbnRleHRsb3N0KTtcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dHJlc3RvcmVkXCIsIHRoaXMuX29uV2ViZ2xjb250ZXh0cmVzdG9yZWQpO1xuXG5cdFx0cmV0dXJuIGNhbnZhcztcblx0fVxuXG5cdF9vbkNvbnRlbnRFcnJvcihlcnJvcikge1xuXHRcdHRoaXMuX2ltYWdlSXNSZWFkeSA9IGZhbHNlO1xuXHRcdHRoaXMuX2ltYWdlID0gbnVsbDtcblx0XHR0aGlzLnRyaWdnZXIoRVZFTlRTLkVSUk9SLCB7XG5cdFx0XHR0eXBlOiBFUlJPUl9UWVBFLkZBSUxfSU1BR0VfTE9BRCxcblx0XHRcdG1lc3NhZ2U6IFwiZmFpbGVkIHRvIGxvYWQgaW1hZ2VcIlxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0X3RyaWdnZXJDb250ZW50TG9hZCgpIHtcblx0XHR0aGlzLnRyaWdnZXIoRVZFTlRTLklNQUdFX0xPQURFRCwge1xuXHRcdFx0Y29udGVudDogdGhpcy5faW1hZ2UsXG5cdFx0XHRpc1ZpZGVvOiB0aGlzLl9pc1ZpZGVvLFxuXHRcdFx0cHJvamVjdGlvblR5cGU6IHRoaXMuX2ltYWdlVHlwZVxuXHRcdH0pO1xuXHR9XG5cdF9vbkNvbnRlbnRMb2FkKGltYWdlKSB7XG5cdFx0dGhpcy5faW1hZ2VJc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdHRoaXMuX3RyaWdnZXJDb250ZW50TG9hZCgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aXNJbWFnZUxvYWRlZCgpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9pbWFnZSAmJiB0aGlzLl9pbWFnZUlzUmVhZHkgJiZcblx0XHRcdCghdGhpcy5faXNWaWRlbyB8fCB0aGlzLl9pbWFnZS5yZWFkeVN0YXRlID49IDIgLyogSEFWRV9DVVJSRU5UX0RBVEEgKi8pO1xuXHR9XG5cblx0YmluZFRleHR1cmUoKSB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXHRcdFx0aWYgKCF0aGlzLl9jb250ZW50TG9hZGVyKSB7XG5cdFx0XHRcdHJlaihcIkltYWdlTG9hZGVyIGlzIG5vdCBpbml0aWFsaXplZFwiKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9jb250ZW50TG9hZGVyLmdldCgpXG5cdFx0XHRcdC50aGVuKCgpID0+IHRoaXMuX2JpbmRUZXh0dXJlKCksIHJlailcblx0XHRcdFx0LnRoZW4ocmVzKTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIOu2gOuqqCDsl5jrpqzrqLztirjsl5AgY2FudmFzIOulvCDrtpnsnoRcblx0YXR0YWNoVG8ocGFyZW50RWxlbWVudCkge1xuXHRcdHRoaXMuZGV0YWNoKCk7XG5cdFx0cGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG5cdH1cblxuXHRmb3JjZUNvbnRleHRMb3NzKCkge1xuXHRcdGlmICh0aGlzLmhhc1JlbmRlcmluZ0NvbnRleHQoKSkge1xuXHRcdFx0Y29uc3QgbG9zZUNvbnRleHRFeHRlbnNpb24gPSB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpO1xuXG5cdFx0XHRpZiAobG9zZUNvbnRleHRFeHRlbnNpb24pIHtcblx0XHRcdFx0bG9zZUNvbnRleHRFeHRlbnNpb24ubG9zZUNvbnRleHQoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyDrtoDrqqgg7JeY66as66i87Yq47JeQ7IScIGNhbnZhcyDrpbwg7KCc6rGwXG5cdGRldGFjaCgpIHtcblx0XHRpZiAodGhpcy5jYW52YXMucGFyZW50RWxlbWVudCkge1xuXHRcdFx0dGhpcy5jYW52YXMucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7XG5cdFx0fVxuXHR9XG5cblx0ZGVzdHJveSgpIHtcblx0XHRpZiAodGhpcy5fY29udGVudExvYWRlcikge1xuXHRcdFx0dGhpcy5fY29udGVudExvYWRlci5kZXN0cm95KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5kZXRhY2goKTtcblx0XHR0aGlzLmZvcmNlQ29udGV4dExvc3MoKTtcblxuXHRcdHRoaXMub2ZmKCk7XG5cblx0XHR0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0bG9zdFwiLCB0aGlzLl9vbldlYmdsY29udGV4dGxvc3QpO1xuXHRcdHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRyZXN0b3JlZFwiLCB0aGlzLl9vbldlYmdsY29udGV4dHJlc3RvcmVkKTtcblx0fVxuXG5cdGhhc1JlbmRlcmluZ0NvbnRleHQoKSB7XG5cdFx0aWYgKCEodGhpcy5jb250ZXh0ICYmICF0aGlzLmNvbnRleHQuaXNDb250ZXh0TG9zdCgpKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHR0aGlzLmNvbnRleHQgJiZcblx0XHRcdCF0aGlzLmNvbnRleHQuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLnNoYWRlclByb2dyYW0sIHRoaXMuY29udGV4dC5MSU5LX1NUQVRVUykpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRfb25XZWJnbGNvbnRleHRsb3N0KGUpIHtcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0dGhpcy50cmlnZ2VyKEVWRU5UUy5SRU5ERVJJTkdfQ09OVEVYVF9MT1NUKTtcblx0fVxuXG5cdF9vbldlYmdsY29udGV4dHJlc3RvcmVkKGUpIHtcblx0XHR0aGlzLl9pbml0V2ViR0woKTtcblx0XHR0aGlzLnRyaWdnZXIoRVZFTlRTLlJFTkRFUklOR19DT05URVhUX1JFU1RPUkUpO1xuXHR9XG5cblx0dXBkYXRlRmllbGRPZlZpZXcoZmllbGRPZlZpZXcpIHtcblx0XHR0aGlzLmZpZWxkT2ZWaWV3ID0gZmllbGRPZlZpZXc7XG5cdFx0dGhpcy5fdXBkYXRlVmlld3BvcnQoKTtcblx0fVxuXG5cdHVwZGF0ZVZpZXdwb3J0RGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0bGV0IHZpZXdQb3J0Q2hhbmdlZCA9IGZhbHNlO1xuXG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0Y29uc3QgdyA9IHdpZHRoICogREVWSUNFX1BJWEVMX1JBVElPO1xuXHRcdGNvbnN0IGggPSBoZWlnaHQgKiBERVZJQ0VfUElYRUxfUkFUSU87XG5cblx0XHRpZiAodyAhPT0gdGhpcy5jYW52YXMud2lkdGgpIHtcblx0XHRcdHRoaXMuY2FudmFzLndpZHRoID0gdztcblx0XHRcdHZpZXdQb3J0Q2hhbmdlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGggIT09IHRoaXMuY2FudmFzLmhlaWdodCkge1xuXHRcdFx0dGhpcy5jYW52YXMuaGVpZ2h0ID0gaDtcblx0XHRcdHZpZXdQb3J0Q2hhbmdlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCF2aWV3UG9ydENoYW5nZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVWaWV3cG9ydCgpO1xuXHRcdHRoaXMuX3Nob3VsZEZvcmNlRHJhdyA9IHRydWU7XG5cdH1cblxuXHRfdXBkYXRlVmlld3BvcnQoKSB7XG5cdFx0bWF0NC5wZXJzcGVjdGl2ZShcblx0XHRcdHRoaXMucE1hdHJpeCxcblx0XHRcdGdsTWF0cml4LnRvUmFkaWFuKHRoaXMuZmllbGRPZlZpZXcpLFxuXHRcdFx0dGhpcy5jYW52YXMud2lkdGggLyB0aGlzLmNhbnZhcy5oZWlnaHQsXG5cdFx0XHQwLjEsXG5cdFx0XHQxMDApO1xuXG5cdFx0dGhpcy5jb250ZXh0LnZpZXdwb3J0KDAsIDAsIHRoaXMuY29udGV4dC5kcmF3aW5nQnVmZmVyV2lkdGgsIHRoaXMuY29udGV4dC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcblx0fVxuXG5cdF9pbml0V2ViR0woKSB7XG5cdFx0Ly8gVE9ETzogRm9sbG93aW5nIGNvZGUgZG9lcyBuZWVkIHRvIGJlIGV4ZWN1dGVkIG9ubHkgaWYgd2lkdGgvaGVpZ2h0LCBjdWJpY1N0cmlwIHByb3BlcnR5IGlzIGNoYW5nZWQuXG5cdFx0dHJ5IHtcblx0XHRcdHRoaXMuX2luaXRSZW5kZXJpbmdDb250ZXh0KCk7XG5cdFx0XHR0aGlzLnVwZGF0ZVZpZXdwb3J0RGltZW5zaW9ucyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cblx0XHRcdGlmICh0aGlzLnNoYWRlclByb2dyYW0pIHtcblx0XHRcdFx0dGhpcy5jb250ZXh0LmRlbGV0ZVByb2dyYW0odGhpcy5zaGFkZXJQcm9ncmFtKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zaGFkZXJQcm9ncmFtID0gdGhpcy5faW5pdFNoYWRlclByb2dyYW0odGhpcy5jb250ZXh0KTtcblx0XHRcdGlmICghdGhpcy5zaGFkZXJQcm9ncmFtKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGludGlhbGl6ZSBzaGFkZXJzOiAke1dlYkdMVXRpbHMuZ2V0RXJyb3JOYW1lRnJvbVdlYkdMRXJyb3JDb2RlKHRoaXMuY29udGV4dC5nZXRFcnJvcigpKX1gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnVmZmVycyBmb3Igc2hhZGVyXG5cdFx0XHR0aGlzLl9pbml0QnVmZmVycygpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHRoaXMudHJpZ2dlcihFVkVOVFMuRVJST1IsIHtcblx0XHRcdFx0dHlwZTogRVJST1JfVFlQRS5OT19XRUJHTCxcblx0XHRcdFx0bWVzc2FnZTogXCJubyB3ZWJnbCBzdXBwb3J0XCJcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdC8vIOy6lOuyhOyKpOulvCDtiKzrqoXsnLzroZwg7LGE7Jq064ukLlxuXHRcdHRoaXMuY29udGV4dC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuXHRcdGNvbnN0IHRleHR1cmVUYXJnZXQgPSB0aGlzLl9pc0N1YmVNYXAgPyB0aGlzLmNvbnRleHQuVEVYVFVSRV9DVUJFX01BUCA6IHRoaXMuY29udGV4dC5URVhUVVJFXzJEO1xuXG5cdFx0aWYgKHRoaXMudGV4dHVyZSkge1xuXHRcdFx0dGhpcy5jb250ZXh0LmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlKTtcblx0XHR9XG5cblx0XHR0aGlzLnRleHR1cmUgPSBXZWJHTFV0aWxzLmNyZWF0ZVRleHR1cmUodGhpcy5jb250ZXh0LCB0ZXh0dXJlVGFyZ2V0KTtcblx0fVxuXG5cdF9pbml0UmVuZGVyaW5nQ29udGV4dCgpIHtcblx0XHRpZiAodGhpcy5oYXNSZW5kZXJpbmdDb250ZXh0KCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIldlYkdMUmVuZGVyaW5nQ29udGV4dCBub3QgYXZhaWxhYmxlLlwiKTtcblx0XHR9XG5cblx0XHR0aGlzLmNvbnRleHQgPSBXZWJHTFV0aWxzLmdldFdlYmdsQ29udGV4dCh0aGlzLmNhbnZhcywgdGhpcy5fcmVuZGVyaW5nQ29udGV4dEF0dHJpYnV0ZXMpO1xuXG5cdFx0aWYgKCF0aGlzLmNvbnRleHQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBhY3F1aXJlIDNEIHJlbmRlcmluZyBjb250ZXh0XCIpO1xuXHRcdH1cblx0fVxuXG5cdF9pbml0U2hhZGVyUHJvZ3JhbShnbCkge1xuXHRcdGNvbnN0IHZlcnRleFNoYWRlclNvdXJjZSA9IHRoaXMuX3JlbmRlcmVyLmdldFZlcnRleFNoYWRlclNvdXJjZSgpO1xuXHRcdGNvbnN0IHZlcnRleFNoYWRlciA9IFdlYkdMVXRpbHMuY3JlYXRlU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpO1xuXG5cdFx0aWYgKCF2ZXJ0ZXhTaGFkZXIpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRjb25zdCBmcmFnbWVudFNoYWRlclNvdXJjZSA9IHRoaXMuX3JlbmRlcmVyLmdldEZyYWdtZW50U2hhZGVyU291cmNlKCk7XG5cdFx0Y29uc3QgZnJhZ21lbnRTaGFkZXIgPSBXZWJHTFV0aWxzLmNyZWF0ZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG5cblx0XHRpZiAoIWZyYWdtZW50U2hhZGVyKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2hhZGVyUHJvZ3JhbSA9IFdlYkdMVXRpbHMuY3JlYXRlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcik7XG5cblx0XHRpZiAoIXNoYWRlclByb2dyYW0pIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGdsLnVzZVByb2dyYW0oc2hhZGVyUHJvZ3JhbSk7XG5cdFx0c2hhZGVyUHJvZ3JhbS52ZXJ0ZXhQb3NpdGlvbkF0dHJpYnV0ZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHNoYWRlclByb2dyYW0sIFwiYVZlcnRleFBvc2l0aW9uXCIpO1xuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlclByb2dyYW0udmVydGV4UG9zaXRpb25BdHRyaWJ1dGUpO1xuXHRcdHNoYWRlclByb2dyYW0ucE1hdHJpeFVuaWZvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgXCJ1UE1hdHJpeFwiKTtcblx0XHRzaGFkZXJQcm9ncmFtLm12TWF0cml4VW5pZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXJQcm9ncmFtLCBcInVNVk1hdHJpeFwiKTtcblx0XHRzaGFkZXJQcm9ncmFtLnNhbXBsZXJVbmlmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlclByb2dyYW0sIFwidVNhbXBsZXJcIik7XG5cdFx0c2hhZGVyUHJvZ3JhbS50ZXh0dXJlQ29vcmRBdHRyaWJ1dGUgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihzaGFkZXJQcm9ncmFtLCBcImFUZXh0dXJlQ29vcmRcIik7XG5cdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoc2hhZGVyUHJvZ3JhbS50ZXh0dXJlQ29vcmRBdHRyaWJ1dGUpO1xuXG5cdFx0Ly8gY2xlYXIgYnVmZmVyXG5cdFx0Z2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQgfCBnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xuXHRcdC8vIFVzZSBURVhUVVJFMFxuXHRcdGdsLnVuaWZvcm0xaShzaGFkZXJQcm9ncmFtLnNhbXBsZXJVbmlmb3JtLCAwKTtcblxuXHRcdHJldHVybiBzaGFkZXJQcm9ncmFtO1xuXHR9XG5cblx0X2luaXRCdWZmZXJzKCkge1xuXHRcdGNvbnN0IHZlcnRleFBvc2l0aW9uRGF0YSA9IHRoaXMuX3JlbmRlcmVyLmdldFZlcnRleFBvc2l0aW9uRGF0YSgpO1xuXHRcdGNvbnN0IGluZGV4RGF0YSA9IHRoaXMuX3JlbmRlcmVyLmdldEluZGV4RGF0YSgpO1xuXHRcdGNvbnN0IHRleHR1cmVDb29yZERhdGEgPSB0aGlzLl9yZW5kZXJlci5nZXRUZXh0dXJlQ29vcmREYXRhKHRoaXMuX2ltYWdlQ29uZmlnKTtcblx0XHRjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcblxuXHRcdHRoaXMudmVydGV4QnVmZmVyID0gV2ViR0xVdGlscy5pbml0QnVmZmVyKFxuXHRcdFx0Z2wsIGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheSh2ZXJ0ZXhQb3NpdGlvbkRhdGEpLCAzLFxuXHRcdFx0dGhpcy5zaGFkZXJQcm9ncmFtLnZlcnRleFBvc2l0aW9uQXR0cmlidXRlKTtcblxuXHRcdHRoaXMuaW5kZXhCdWZmZXIgPSBXZWJHTFV0aWxzLmluaXRCdWZmZXIoXG5cdFx0XHRnbCwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG5ldyBVaW50MTZBcnJheShpbmRleERhdGEpLCAxKTtcblxuXHRcdHRoaXMudGV4dHVyZUNvb3JkQnVmZmVyID0gV2ViR0xVdGlscy5pbml0QnVmZmVyKFxuXHRcdFx0Z2wsIGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheSh0ZXh0dXJlQ29vcmREYXRhKSwgdGhpcy5faXNDdWJlTWFwID8gMyA6IDIsXG5cdFx0XHR0aGlzLnNoYWRlclByb2dyYW0udGV4dHVyZUNvb3JkQXR0cmlidXRlKTtcblx0fVxuXG5cdF9iaW5kVGV4dHVyZSgpIHtcblx0XHR0aGlzLl9yZW5kZXJlci5iaW5kVGV4dHVyZShcblx0XHRcdHRoaXMuY29udGV4dCxcblx0XHRcdHRoaXMudGV4dHVyZSxcblx0XHRcdHRoaXMuX2ltYWdlLFxuXHRcdFx0dGhpcy5faW1hZ2VDb25maWcsXG5cdFx0KTtcblx0XHR0aGlzLl9zaG91bGRGb3JjZURyYXcgPSB0cnVlO1xuXG5cdFx0dGhpcy50cmlnZ2VyKEVWRU5UUy5CSU5EX1RFWFRVUkUpO1xuXHR9XG5cblx0X3VwZGF0ZVRleHR1cmUoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIudXBkYXRlVGV4dHVyZShcblx0XHRcdHRoaXMuY29udGV4dCxcblx0XHRcdHRoaXMuX2ltYWdlLFxuXHRcdFx0dGhpcy5faW1hZ2VDb25maWcsXG5cdFx0KTtcblx0fVxuXG5cdGtlZXBVcGRhdGUoZG9VcGRhdGUpIHtcblx0XHRpZiAoZG9VcGRhdGUgJiYgdGhpcy5pc0ltYWdlTG9hZGVkKCkgPT09IGZhbHNlKSB7XG5cdFx0XHQvLyBGb3JjZSB0byBkcmF3IGEgZnJhbWUgYWZ0ZXIgaW1hZ2UgaXMgbG9hZGVkIG9uIHJlbmRlcigpXG5cdFx0XHR0aGlzLl9zaG91bGRGb3JjZURyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdHRoaXMuX2tlZXBVcGRhdGUgPSBkb1VwZGF0ZTtcblx0fVxuXG5cdHJlbmRlcldpdGhRdWF0ZXJuaW9uKHF1YXRlcm5pb24sIGZpZWxkT2ZWaWV3KSB7XG5cdFx0aWYgKCF0aGlzLmlzSW1hZ2VMb2FkZWQoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9rZWVwVXBkYXRlID09PSBmYWxzZSAmJlxuXHRcdFx0dGhpcy5fbGFzdFF1YXRlcm5pb24gJiYgcXVhdC5leGFjdEVxdWFscyh0aGlzLl9sYXN0UXVhdGVybmlvbiwgcXVhdGVybmlvbikgJiZcblx0XHRcdHRoaXMuZmllbGRPZlZpZXcgJiYgdGhpcy5maWVsZE9mVmlldyA9PT0gZmllbGRPZlZpZXcgJiZcblx0XHRcdHRoaXMuX3Nob3VsZEZvcmNlRHJhdyA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyB1cGRhdGVmaWVsZE9mVmlldyBvbmx5IGlmIGZpZWxkT2ZWaWV3IGlzIGNoYW5nZWQuXG5cdFx0aWYgKGZpZWxkT2ZWaWV3ICE9PSB1bmRlZmluZWQgJiYgZmllbGRPZlZpZXcgIT09IHRoaXMuZmllbGRPZlZpZXcpIHtcblx0XHRcdHRoaXMudXBkYXRlRmllbGRPZlZpZXcoZmllbGRPZlZpZXcpO1xuXHRcdH1cblxuXHRcdGxldCBvdXRRO1xuXG5cdFx0aWYgKCF0aGlzLl9pc0N1YmVNYXApIHtcblx0XHRcdC8vIFRPRE86IFJlbW92ZSB0aGlzIHlhdyByZXZpc2lvbiBieSBjb3JyZWN0aW5nIHNoYWRlclxuXHRcdFx0b3V0USA9IHF1YXQucm90YXRlWShxdWF0LmNyZWF0ZSgpLCBxdWF0ZXJuaW9uLCBnbE1hdHJpeC50b1JhZGlhbig5MCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvdXRRID0gcXVhdGVybmlvbjtcblx0XHR9XG5cblx0XHR0aGlzLm12TWF0cml4ID0gbWF0NC5mcm9tUXVhdChtYXQ0LmNyZWF0ZSgpLCBvdXRRKTtcblxuXHRcdHRoaXMuX2RyYXcoKTtcblxuXHRcdHRoaXMuX2xhc3RRdWF0ZXJuaW9uID0gcXVhdC5jbG9uZShxdWF0ZXJuaW9uKTtcblx0XHRpZiAodGhpcy5fc2hvdWxkRm9yY2VEcmF3KSB7XG5cdFx0XHR0aGlzLl9zaG91bGRGb3JjZURyYXcgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRyZW5kZXIoeWF3LCBwaXRjaCwgZmllbGRPZlZpZXcpIHtcblx0XHRpZiAoIXRoaXMuaXNJbWFnZUxvYWRlZCgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2tlZXBVcGRhdGUgPT09IGZhbHNlICYmXG5cdFx0XHRcdHRoaXMuX2xhc3RZYXcgIT09IG51bGwgJiYgdGhpcy5fbGFzdFlhdyA9PT0geWF3ICYmXG5cdFx0XHRcdHRoaXMuX2xhc3RQaXRjaCAhPT0gbnVsbCAmJiB0aGlzLl9sYXN0UGl0Y2ggPT09IHBpdGNoICYmXG5cdFx0XHRcdHRoaXMuZmllbGRPZlZpZXcgJiYgdGhpcy5maWVsZE9mVmlldyA9PT0gZmllbGRPZlZpZXcgJiZcblx0XHRcdFx0dGhpcy5fc2hvdWxkRm9yY2VEcmF3ID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZpZWxkT2ZWaWV3IOqwgCDsobTsnqztlZjrqbTshJwg6riw7KG07J2YIOqwkuqzvCDri6Trpbwg6rK97Jqw7JeQ66eMIOyXheuNsOydtO2KuCDtmLjstpxcblx0XHRpZiAoZmllbGRPZlZpZXcgIT09IHVuZGVmaW5lZCAmJiBmaWVsZE9mVmlldyAhPT0gdGhpcy5maWVsZE9mVmlldykge1xuXHRcdFx0dGhpcy51cGRhdGVGaWVsZE9mVmlldyhmaWVsZE9mVmlldyk7XG5cdFx0fVxuXG5cdFx0bWF0NC5pZGVudGl0eSh0aGlzLm12TWF0cml4KTtcblx0XHRtYXQ0LnJvdGF0ZVgodGhpcy5tdk1hdHJpeCwgdGhpcy5tdk1hdHJpeCwgLWdsTWF0cml4LnRvUmFkaWFuKHBpdGNoKSk7XG5cdFx0bWF0NC5yb3RhdGVZKHRoaXMubXZNYXRyaXgsIHRoaXMubXZNYXRyaXgsXG5cdFx0XHQtZ2xNYXRyaXgudG9SYWRpYW4oeWF3IC0gKHRoaXMuX2lzQ3ViZU1hcCA/IDAgOiA5MCkpKTtcblxuXHRcdHRoaXMuX2RyYXcoKTtcblxuXHRcdHRoaXMuX2xhc3RZYXcgPSB5YXc7XG5cdFx0dGhpcy5fbGFzdFBpdGNoID0gcGl0Y2g7XG5cdFx0aWYgKHRoaXMuX3Nob3VsZEZvcmNlRHJhdykge1xuXHRcdFx0dGhpcy5fc2hvdWxkRm9yY2VEcmF3ID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0X2RyYXcoKSB7XG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG5cblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuc2hhZGVyUHJvZ3JhbS5wTWF0cml4VW5pZm9ybSwgZmFsc2UsIHRoaXMucE1hdHJpeCk7XG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLnNoYWRlclByb2dyYW0ubXZNYXRyaXhVbmlmb3JtLCBmYWxzZSwgdGhpcy5tdk1hdHJpeCk7XG5cblx0XHRpZiAodGhpcy5faXNWaWRlbyAmJiB0aGlzLl9rZWVwVXBkYXRlKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVUZXh0dXJlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaW5kZXhCdWZmZXIpIHtcblx0XHRcdGdsLmRyYXdFbGVtZW50cyhcblx0XHRcdFx0Z2wuVFJJQU5HTEVTLCB0aGlzLmluZGV4QnVmZmVyLm51bUl0ZW1zLCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG5cdFx0fVxuXHR9XG59XG5cblBhbm9JbWFnZVJlbmRlcmVyLkVWRU5UUyA9IEVWRU5UUztcblBhbm9JbWFnZVJlbmRlcmVyLkVSUk9SX1RZUEUgPSBFUlJPUl9UWVBFO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1Bhbm9JbWFnZVJlbmRlcmVyL1Bhbm9JbWFnZVJlbmRlcmVyLmpzIiwiLy8gaW1wb3J0IEFnZW50IGZyb20gXCJAZWdqcy9hZ2VudFwiO1xuXG4vKiBSZWYgaHR0cHM6Ly93d3cudzNzY2hvb2xzLmNvbS90YWdzL2F2X3Byb3BfcmVhZHlzdGF0ZS5hc3AgKi9cbmNvbnN0IFJFQURZX1NUQVRVUyA9IHtcblx0SEFWRV9OT1RISU5HOiAwLCAvLyBubyBpbmZvcm1hdGlvbiB3aGV0aGVyIG9yIG5vdCB0aGUgYXVkaW8vdmlkZW8gaXMgcmVhZHlcblx0SEFWRV9NRVRBREFUQTogMSwgLy8gSEFWRV9NRVRBREFUQSAtIG1ldGFkYXRhIGZvciB0aGUgYXVkaW8vdmlkZW8gaXMgcmVhZHlcblx0SEFWRV9DVVJSRU5UX0RBVEE6IDIsIC8vIGRhdGEgZm9yIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGlzIGF2YWlsYWJsZSwgYnV0IG5vdCBlbm91Z2ggZGF0YSB0byBwbGF5IG5leHQgZnJhbWUvbWlsbGlzZWNvbmRcblx0SEFWRV9GVVRVUkVfREFUQTogMywgLy8gZGF0YSBmb3IgdGhlIGN1cnJlbnQgYW5kIGF0IGxlYXN0IHRoZSBuZXh0IGZyYW1lIGlzIGF2YWlsYWJsZVxuXHRIQVZFX0VOT1VHSF9EQVRBOiA0LCAvLyBlbm91Z2ggZGF0YSBhdmFpbGFibGUgdG8gc3RhcnQgcGxheWluZ1xuXHQvLyBiZWxvdyBpcyBjdXN0b20gc3RhdHVzIGZvciBmYWlsZWQgdG8gbG9hZCBzdGF0dXNcblx0TE9BRElOR19GQUlMRUQ6IC0xXG59O1xuXG5jb25zdCBSRUFEWVNUQVRFQ0hBTkdFX0VWRU5UX05BTUUgPSB7fTtcblxuUkVBRFlTVEFURUNIQU5HRV9FVkVOVF9OQU1FW1JFQURZX1NUQVRVUy5IQVZFX01FVEFEQVRBXSA9IFwibG9hZGVkbWV0YWRhdGFcIjtcblJFQURZU1RBVEVDSEFOR0VfRVZFTlRfTkFNRVtSRUFEWV9TVEFUVVMuSEFWRV9DVVJSRU5UX0RBVEFdID0gXCJsb2FkZWRkYXRhXCI7XG5SRUFEWVNUQVRFQ0hBTkdFX0VWRU5UX05BTUVbUkVBRFlfU1RBVFVTLkhBVkVfRlVUVVJFX0RBVEFdID0gXCJjYW5wbGF5XCI7XG5SRUFEWVNUQVRFQ0hBTkdFX0VWRU5UX05BTUVbUkVBRFlfU1RBVFVTLkhBVkVfRU5PVUdIX0RBVEFdID0gXCJjYW5wbGF5dGhyb3VnaFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWRlb0xvYWRlciB7XG5cdGNvbnN0cnVjdG9yKHZpZGVvKSB7XG5cdFx0dGhpcy5faGFuZGxlcnMgPSBbXTtcblx0XHR0aGlzLl9zb3VyY2VDb3VudCA9IDA7XG5cblx0XHQvLyBvbiBpT1Mgc2FmYXJpLCAnbG9hZGVkZGF0YScgd2lsbCBub3QgdHJpZ2dlcmVkIHVubGVzcyB0aGUgdXNlciBoaXRzIHBsYXksXG5cdFx0Ly8gc28gdXNlZCAnbG9hZGVkbWV0YWRhdGEnIGluc3RlYWQuXG5cdFx0dGhpcy5fdGhyZXNob2xkUmVhZHlTdGF0ZSA9IFJFQURZX1NUQVRVUy5IQVZFX01FVEFEQVRBO1xuXHRcdHRoaXMuX3RocmVzaG9sZEV2ZW50TmFtZSA9IFJFQURZU1RBVEVDSEFOR0VfRVZFTlRfTkFNRVt0aGlzLl90aHJlc2hvbGRSZWFkeVN0YXRlXTtcblxuXHRcdHRoaXMuX2xvYWRTdGF0dXMgPSAodmlkZW8gJiYgdmlkZW8ucmVhZHlTdGF0ZSkgfHwgUkVBRFlfU1RBVFVTLkhBVkVfTk9USElORztcblxuXHRcdHRoaXMuX29uZXJyb3IgPSB0aGlzLl9vbmVycm9yLmJpbmQodGhpcyk7XG5cblx0XHR2aWRlbyAmJiB0aGlzLnNldCh2aWRlbyk7XG5cdH1cblxuXHRfb25lcnJvcigpIHtcblx0XHR0aGlzLl9lcnJvckNvdW50Kys7XG5cdFx0aWYgKHRoaXMuX2Vycm9yQ291bnQgPj0gdGhpcy5fc291cmNlQ291bnQpIHtcblx0XHRcdHRoaXMuX2xvYWRTdGF0dXMgPSBSRUFEWV9TVEFUVVMuTE9BRElOR19GQUlMRUQ7XG5cdFx0XHR0aGlzLl9kZXRhY2hFcnJvckhhbmRsZXIodGhpcy5fb25lcnJvcik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0IHwgU3RyaW5nfSB2aWRlbyBPYmplY3Qgb3IgU3RyaW5nIGNvbnRhaW5pbmcgVmlkZW8gU291cmNlIFVSTDxrbz7ruYTrlJTsmKQgVVJMIOygleuztOulvCDri7Tqs6Ag7J6I64qUIOusuOyekOyXtOydtOuCmCDqsJ3ssrQge3R5cGUsIHNyY308L2tvPlxuXHQgKi9cblx0X2FwcGVuZFNvdXJjZUVsZW1lbnQodmlkZW9VcmwpIHtcblx0XHRsZXQgdmlkZW9TcmM7XG5cdFx0bGV0IHZpZGVvVHlwZTtcblxuXHRcdGlmICh0eXBlb2YgdmlkZW9VcmwgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdHZpZGVvU3JjID0gdmlkZW9Vcmwuc3JjO1xuXHRcdFx0dmlkZW9UeXBlID0gdmlkZW9VcmwudHlwZTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2aWRlb1VybCA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmlkZW9TcmMgPSB2aWRlb1VybDtcblx0XHR9XG5cblx0XHRpZiAoIXZpZGVvU3JjKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc291cmNlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzb3VyY2VcIik7XG5cblx0XHRzb3VyY2VFbGVtZW50LnNyYyA9IHZpZGVvU3JjO1xuXHRcdHZpZGVvVHlwZSAmJiAoc291cmNlRWxlbWVudC50eXBlID0gdmlkZW9UeXBlKTtcblxuXHRcdHRoaXMuX3ZpZGVvLmFwcGVuZENoaWxkKHNvdXJjZUVsZW1lbnQpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0c2V0KHZpZGVvKSB7XG5cdFx0dGhpcy5fcmVzZXQoKTsgLy8gcmVzZXQgcmVzb3VyY2VzLlxuXG5cdFx0aWYgKCF2aWRlbykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh2aWRlbyBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcblx0XHRcdC8vIHZpZGVvIHRhZ1xuXHRcdFx0dGhpcy5fdmlkZW8gPSB2aWRlbztcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2aWRlbyA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmlkZW8gPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdC8vIHVybFxuXHRcdFx0dGhpcy5fdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG5cdFx0XHR0aGlzLl92aWRlby5zZXRBdHRyaWJ1dGUoXCJjcm9zc29yaWdpblwiLCBcImFub255bW91c1wiKTtcblx0XHRcdHRoaXMuX3ZpZGVvLnNldEF0dHJpYnV0ZShcIndlYmtpdC1wbGF5c2lubGluZVwiLCBcIlwiKTtcblx0XHRcdHRoaXMuX3ZpZGVvLnNldEF0dHJpYnV0ZShcInBsYXlzaW5saW5lXCIsIFwiXCIpO1xuXG5cdFx0XHRpZiAodmlkZW8gaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHR2aWRlby5mb3JFYWNoKHYgPT4gdGhpcy5fYXBwZW5kU291cmNlRWxlbWVudCh2KSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9hcHBlbmRTb3VyY2VFbGVtZW50KHZpZGVvKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc291cmNlQ291bnQgPSB0aGlzLl92aWRlby5xdWVyeVNlbGVjdG9yQWxsKFwic291cmNlXCIpLmxlbmd0aDtcblxuXHRcdFx0aWYgKHRoaXMuX3NvdXJjZUNvdW50ID4gMCkge1xuXHRcdFx0XHRpZiAodGhpcy5fdmlkZW8ucmVhZHlTdGF0ZSA8IHRoaXMuX3RocmVzaG9sZFJlYWR5U3RhdGUpIHtcblx0XHRcdFx0XHR0aGlzLl92aWRlby5sb2FkKCk7XG5cdFx0XHRcdFx0Ly8gYXR0YWNoIGxvYWRpbmcgZXJyb3IgbGlzdGVuZXJcblx0XHRcdFx0XHR0aGlzLl9hdHRhY2hFcnJvckhhbmRsZXIodGhpcy5fb25lcnJvcik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3ZpZGVvID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRfYXR0YWNoRXJyb3JIYW5kbGVyKGhhbmRsZXIpIHtcblx0XHR0aGlzLl92aWRlby5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgaGFuZGxlcik7XG5cdFx0dGhpcy5fc291cmNlcyA9IHRoaXMuX3ZpZGVvLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzb3VyY2VcIik7XG5cdFx0W10uZm9yRWFjaC5jYWxsKHRoaXMuX3NvdXJjZXMsIHNvdXJjZSA9PiB7XG5cdFx0XHRzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGhhbmRsZXIpO1xuXHRcdH0pO1xuXHR9XG5cblx0X2RldGFjaEVycm9ySGFuZGxlcihoYW5kbGVyKSB7XG5cdFx0dGhpcy5fdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGhhbmRsZXIpO1xuXHRcdFtdLmZvckVhY2guY2FsbCh0aGlzLl9zb3VyY2VzLCBzb3VyY2UgPT4ge1xuXHRcdFx0c291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBoYW5kbGVyKTtcblx0XHR9KTtcblx0fVxuXG5cdGdldCgpIHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cdFx0XHRpZiAoIXRoaXMuX3ZpZGVvKSB7XG5cdFx0XHRcdHJlaihcIlZpZGVvTG9hZGVyOiB2aWRlbyBpcyB1bmRlZmluZWRcIik7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2xvYWRTdGF0dXMgPT09IFJFQURZX1NUQVRVUy5MT0FESU5HX0ZBSUxFRCkge1xuXHRcdFx0XHRyZWooXCJWaWRlb0xvYWRlcjogdmlkZW8gc291cmNlIGlzIGludmFsaWRcIik7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3ZpZGVvLnJlYWR5U3RhdGUgPj0gdGhpcy5fdGhyZXNob2xkUmVhZHlTdGF0ZSkge1xuXHRcdFx0XHRyZXModGhpcy5fdmlkZW8pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gY2hlY2sgZXJyb3JDbnQgYW5kIHJlamVjdFxuXHRcdFx0XHRjb25zdCByZWplY3RvciA9ICgpID0+IHtcblx0XHRcdFx0XHRpZiAodGhpcy5fbG9hZFN0YXR1cyA9PT0gUkVBRFlfU1RBVFVTLkxPQURJTkdfRkFJTEVEKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZXRhY2hFcnJvckhhbmRsZXIocmVqZWN0b3IpO1xuXHRcdFx0XHRcdFx0cmVqKFwiVmlkZW9Mb2FkZXI6IHZpZGVvIHNvdXJjZSBpcyBpbnZhbGlkXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLl9hdHRhY2hFcnJvckhhbmRsZXIocmVqZWN0b3IpO1xuXHRcdFx0XHR0aGlzLl9vbmNlKHRoaXMuX3RocmVzaG9sZEV2ZW50TmFtZSwgKCkgPT4gcmVzKHRoaXMuX3ZpZGVvKSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRnZXRFbGVtZW50KCkge1xuXHRcdHJldHVybiB0aGlzLl92aWRlbztcblx0fVxuXG5cdGRlc3Ryb3koKSB7XG5cdFx0dGhpcy5fcmVzZXQoKTtcblx0fVxuXG5cdF9yZXNldCgpIHtcblx0XHR0aGlzLl9oYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4ge1xuXHRcdFx0dGhpcy5fdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihoYW5kbGVyLnR5cGUsIGhhbmRsZXIuZm4pO1xuXHRcdH0pO1xuXHRcdHRoaXMuX2hhbmRsZXJzID0gW107XG5cdFx0dGhpcy5fdmlkZW8gPSBudWxsO1xuXG5cdFx0dGhpcy5fc291cmNlQ291bnQgPSAwO1xuXHRcdHRoaXMuX2Vycm9yQ291bnQgPSAwO1xuXHR9XG5cblx0X29uY2UodHlwZSwgbGlzdGVuZXIpIHtcblx0XHRjb25zdCB0YXJnZXQgPSB0aGlzLl92aWRlbztcblxuXHRcdGNvbnN0IGZuID0gZXZlbnQgPT4ge1xuXHRcdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4pO1xuXHRcdFx0bGlzdGVuZXIoZXZlbnQpO1xuXHRcdH07XG5cblx0XHQvKiBCeSB1c2VDYXB0dXJlIG1vZGUgZW5hYmxlZCwgeW91IGNhbiBjYXB0dXJlIHRoZSBlcnJvciBldmVudCBiZWluZyBmaXJlZCBvbiBzb3VyY2UoY2hpbGQpKi9cblx0XHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgdHJ1ZSk7XG5cdFx0dGhpcy5faGFuZGxlcnMucHVzaCh7dHlwZSwgZm59KTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1Bhbm9JbWFnZVJlbmRlcmVyL1ZpZGVvTG9hZGVyLmpzIiwiZXhwb3J0IGNvbnN0IHVzZXJBZ2VudCA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuZXhwb3J0IGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9icm93c2VyLmpzIiwiaW1wb3J0IFBhbm9JbWFnZVJlbmRlcmVyIGZyb20gXCIuL1Bhbm9JbWFnZVJlbmRlcmVyXCI7XG5pbXBvcnQgV2ViR0xVdGlscyBmcm9tIFwiLi9XZWJHTFV0aWxzXCI7XG5cbmV4cG9ydCB7XG5cdFBhbm9JbWFnZVJlbmRlcmVyLFxuXHRXZWJHTFV0aWxzXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1Bhbm9JbWFnZVJlbmRlcmVyL2luZGV4LmpzIiwiaW1wb3J0IEFnZW50IGZyb20gXCJAZWdqcy9hZ2VudFwiO1xuaW1wb3J0IFJlbmRlcmVyIGZyb20gXCIuL1JlbmRlcmVyLmpzXCI7XG5pbXBvcnQge3V0aWx9IGZyb20gXCIuLi8uLi91dGlscy9tYXRoLXV0aWwuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3ViZVJlbmRlcmVyIGV4dGVuZHMgUmVuZGVyZXIge1xuXHRzdGF0aWMgZ2V0VmVydGV4UG9zaXRpb25EYXRhKCkge1xuXHRcdEN1YmVSZW5kZXJlci5fVkVSVEVYX1BPU0lUSU9OX0RBVEEgPVxuXHRcdFx0Q3ViZVJlbmRlcmVyLl9WRVJURVhfUE9TSVRJT05fREFUQSAhPT0gbnVsbCA/IEN1YmVSZW5kZXJlci5fVkVSVEVYX1BPU0lUSU9OX0RBVEEgOiBbXG5cdFx0XHRcdC8vIGJhY2tcblx0XHRcdFx0MSwgLTEsIDEsXG5cdFx0XHRcdC0xLCAtMSwgMSxcblx0XHRcdFx0LTEsIDEsIDEsXG5cdFx0XHRcdDEsIDEsIDEsXG5cblx0XHRcdFx0Ly8gZnJvbnRcblx0XHRcdFx0LTEsIC0xLCAtMSxcblx0XHRcdFx0MSwgLTEsIC0xLFxuXHRcdFx0XHQxLCAxLCAtMSxcblx0XHRcdFx0LTEsIDEsIC0xLFxuXG5cdFx0XHRcdC8vIHRvcFxuXHRcdFx0XHQtMSwgMSwgLTEsXG5cdFx0XHRcdDEsIDEsIC0xLFxuXHRcdFx0XHQxLCAxLCAxLFxuXHRcdFx0XHQtMSwgMSwgMSxcblxuXHRcdFx0XHQvLyBib3R0b21cblx0XHRcdFx0MSwgLTEsIC0xLFxuXHRcdFx0XHQtMSwgLTEsIC0xLFxuXHRcdFx0XHQtMSwgLTEsIDEsXG5cdFx0XHRcdDEsIC0xLCAxLFxuXG5cdFx0XHRcdC8vIHJpZ2h0XG5cdFx0XHRcdDEsIC0xLCAtMSxcblx0XHRcdFx0MSwgLTEsIDEsXG5cdFx0XHRcdDEsIDEsIDEsXG5cdFx0XHRcdDEsIDEsIC0xLFxuXG5cdFx0XHRcdC8vIGxlZnRcblx0XHRcdFx0LTEsIC0xLCAxLFxuXHRcdFx0XHQtMSwgLTEsIC0xLFxuXHRcdFx0XHQtMSwgMSwgLTEsXG5cdFx0XHRcdC0xLCAxLCAxXG5cdFx0XHRdO1xuXG5cdFx0cmV0dXJuIEN1YmVSZW5kZXJlci5fVkVSVEVYX1BPU0lUSU9OX0RBVEE7XG5cdH1cblxuXHRzdGF0aWMgZ2V0SW5kZXhEYXRhKCkge1xuXHRcdGlmIChDdWJlUmVuZGVyZXIuX0lOREVYX0RBVEEpIHtcblx0XHRcdHJldHVybiBDdWJlUmVuZGVyZXIuX0lOREVYX0RBVEE7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5kZXhEYXRhID0gW107XG5cdFx0Y29uc3QgdmVydGV4UG9zaXRpb25EYXRhID0gQ3ViZVJlbmRlcmVyLmdldFZlcnRleFBvc2l0aW9uRGF0YSgpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCAodmVydGV4UG9zaXRpb25EYXRhLmxlbmd0aCAvIDMpOyBpICs9IDQpIHtcblx0XHRcdGluZGV4RGF0YS5wdXNoKFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRpICsgMixcblx0XHRcdFx0aSArIDEsXG5cdFx0XHRcdGksXG5cdFx0XHRcdGkgKyAzLFxuXHRcdFx0XHRpICsgMlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRDdWJlUmVuZGVyZXIuX0lOREVYX0RBVEEgPSBpbmRleERhdGE7XG5cdFx0cmV0dXJuIGluZGV4RGF0YTtcblx0fVxuXG5cdHN0YXRpYyBleHRyYWN0VGlsZUNvbmZpZyhpbWFnZUNvbmZpZykge1xuXHRcdGxldCB0aWxlQ29uZmlnID1cblx0XHRcdEFycmF5LmlzQXJyYXkoaW1hZ2VDb25maWcudGlsZUNvbmZpZykgP1xuXHRcdFx0XHRpbWFnZUNvbmZpZy50aWxlQ29uZmlnIDogQXJyYXkoLi4uQXJyYXkoNikpLm1hcCgoKSA9PiBpbWFnZUNvbmZpZy50aWxlQ29uZmlnKTtcblxuXHRcdHRpbGVDb25maWcgPSB0aWxlQ29uZmlnLm1hcChcblx0XHRcdGNvbmZpZyA9PiBPYmplY3QuYXNzaWduKHtcblx0XHRcdFx0ZmxpcEhvcml6b250YWw6IGZhbHNlLFxuXHRcdFx0XHRyb3RhdGlvbjogMFxuXHRcdFx0fSwgY29uZmlnKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGlsZUNvbmZpZztcblx0fVxuXG5cdHN0YXRpYyBleHRyYWN0T3JkZXIoaW1hZ2VDb25maWcpIHtcblx0XHRyZXR1cm4gaW1hZ2VDb25maWcub3JkZXIgfHwgXCJSTFVEQkZcIjtcblx0fVxuXG5cdHN0YXRpYyBnZXRUZXh0dXJlQ29vcmREYXRhKGltYWdlQ29uZmlnKSB7XG5cdFx0Y29uc3QgdmVydGV4T3JkZXIgPSBcIkJGVURSTFwiO1xuXHRcdGNvbnN0IG9yZGVyID0gQ3ViZVJlbmRlcmVyLmV4dHJhY3RPcmRlcihpbWFnZUNvbmZpZyk7XG5cdFx0Y29uc3QgYmFzZSA9IEN1YmVSZW5kZXJlci5nZXRWZXJ0ZXhQb3NpdGlvbkRhdGEoKTtcblx0XHRjb25zdCB0aWxlQ29uZmlnID0gQ3ViZVJlbmRlcmVyLmV4dHJhY3RUaWxlQ29uZmlnKGltYWdlQ29uZmlnKTtcblx0XHRjb25zdCBlbGVtU2l6ZSA9IDM7XG5cdFx0Y29uc3QgdmVydGV4UGVyVGlsZSA9IDQ7XG5cdFx0Y29uc3QgdGV4dHVyZUNvb3JkRGF0YSA9XG5cdFx0dmVydGV4T3JkZXIuc3BsaXQoXCJcIilcblx0XHQubWFwKGZhY2UgPT4gdGlsZUNvbmZpZ1tvcmRlci5pbmRleE9mKGZhY2UpXSlcblx0XHQubWFwKChjb25maWcsIGkpID0+IHtcblx0XHRcdGNvbnN0IHJvdGF0aW9uID0gcGFyc2VJbnQoY29uZmlnLnJvdGF0aW9uIC8gOTAsIDEwKTtcblx0XHRcdGNvbnN0IG9yZGVybWFwXyA9IGNvbmZpZy5mbGlwSG9yaXpvbnRhbCA/IFswLCAxLCAyLCAzXSA6IFsxLCAwLCAzLCAyXTtcblxuXHRcdFx0Zm9yIChsZXQgciA9IDA7IHIgPCBNYXRoLmFicyhyb3RhdGlvbik7IHIrKykge1xuXHRcdFx0XHRpZiAoKGNvbmZpZy5mbGlwSG9yaXpvbnRhbCAmJiByb3RhdGlvbiA+IDApIHx8XG5cdFx0XHRcdFx0KCFjb25maWcuZmxpcEhvcml6b250YWwgJiYgcm90YXRpb24gPCAwKSkge1xuXHRcdFx0XHRcdG9yZGVybWFwXy5wdXNoKG9yZGVybWFwXy5zaGlmdCgpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvcmRlcm1hcF8udW5zaGlmdChvcmRlcm1hcF8ucG9wKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGVsZW1QZXJUaWxlID0gZWxlbVNpemUgKiB2ZXJ0ZXhQZXJUaWxlO1xuXHRcdFx0Y29uc3QgdGlsZVZlcnRleCA9IGJhc2Uuc2xpY2UoaSAqIGVsZW1QZXJUaWxlLCBpICogZWxlbVBlclRpbGUgKyBlbGVtUGVyVGlsZSk7XG5cdFx0XHRjb25zdCB0aWxlVGVtcCA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IHZlcnRleFBlclRpbGU7IGorKykge1xuXHRcdFx0XHR0aWxlVGVtcFtvcmRlcm1hcF9bal1dID0gdGlsZVZlcnRleC5zcGxpY2UoMCwgZWxlbVNpemUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRpbGVUZW1wO1xuXHRcdH0pXG5cdFx0LmpvaW4oKVxuXHRcdC5zcGxpdChcIixcIilcblx0XHQubWFwKHYgPT4gcGFyc2VJbnQodiwgMTApKTtcblxuXHRcdHJldHVybiB0ZXh0dXJlQ29vcmREYXRhO1xuXHR9XG5cblx0c3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpIHtcblx0XHRyZXR1cm4gYFxuXHRcdFx0YXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xuXHRcdFx0YXR0cmlidXRlIHZlYzMgYVRleHR1cmVDb29yZDtcblx0XHRcdHVuaWZvcm0gbWF0NCB1TVZNYXRyaXg7XG5cdFx0XHR1bmlmb3JtIG1hdDQgdVBNYXRyaXg7XG5cdFx0XHR2YXJ5aW5nIGhpZ2hwIHZlYzMgdlZlcnRleERpcmVjdGlvblZlY3Rvcjtcblx0XHRcdHZvaWQgbWFpbih2b2lkKSB7XG5cdFx0XHRcdGdsX1Bvc2l0aW9uID0gdVBNYXRyaXggKiB1TVZNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcblx0XHRcdFx0dlZlcnRleERpcmVjdGlvblZlY3RvciA9IGFUZXh0dXJlQ29vcmQ7XG5cdFx0XHR9YDtcblx0fVxuXG5cdHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpIHtcblx0XHRyZXR1cm4gYFxuXHRcdFx0dmFyeWluZyBoaWdocCB2ZWMzIHZWZXJ0ZXhEaXJlY3Rpb25WZWN0b3I7XG5cdFx0XHR1bmlmb3JtIHNhbXBsZXJDdWJlIHVTYW1wbGVyO1xuXHRcdFx0dm9pZCBtYWluKHZvaWQpIHtcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUodVNhbXBsZXIsIHZWZXJ0ZXhEaXJlY3Rpb25WZWN0b3IpO1xuXHRcdFx0fWA7XG5cdH1cblxuXHRzdGF0aWMgdXBkYXRlVGV4dHVyZShnbCwgaW1hZ2UsIGltYWdlQ29uZmlnKSB7XG5cdFx0Y29uc3QgYmFzZU9yZGVyID0gXCJSTFVEQkZcIjtcblx0XHRjb25zdCBvcmRlciA9IEN1YmVSZW5kZXJlci5leHRyYWN0T3JkZXIoaW1hZ2VDb25maWcpO1xuXHRcdGNvbnN0IG9yZGVyTWFwID0ge307XG5cblx0XHRvcmRlci5zcGxpdChcIlwiKS5mb3JFYWNoKCh2LCBpKSA9PiB7XG5cdFx0XHRvcmRlck1hcFt2XSA9IGk7XG5cdFx0fSk7XG5cblx0XHR0cnkge1xuXHRcdFx0aWYgKGltYWdlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0Zm9yIChsZXQgc3VyZmFjZUlkeCA9IDA7IHN1cmZhY2VJZHggPCA2OyBzdXJmYWNlSWR4KyspIHtcblx0XHRcdFx0XHRjb25zdCB0aWxlSWR4ID0gb3JkZXJNYXBbYmFzZU9yZGVyW3N1cmZhY2VJZHhdXTtcblxuXHRcdFx0XHRcdGdsLnRleEltYWdlMkQoXG5cdFx0XHRcdFx0XHRnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBzdXJmYWNlSWR4LCAwLCBnbC5SR0JBLFxuXHRcdFx0XHRcdFx0Z2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2VbdGlsZUlkeF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBtYXhDdWJlTWFwVGV4dHVyZVNpemUgPSBDdWJlUmVuZGVyZXIuZ2V0TWF4Q3ViZU1hcFRleHR1cmVTaXplKGdsLCBpbWFnZSk7XG5cblx0XHRcdFx0Zm9yIChsZXQgc3VyZmFjZUlkeCA9IDA7IHN1cmZhY2VJZHggPCA2OyBzdXJmYWNlSWR4KyspIHtcblx0XHRcdFx0XHRjb25zdCB0aWxlSWR4ID0gb3JkZXJNYXBbYmFzZU9yZGVyW3N1cmZhY2VJZHhdXTtcblx0XHRcdFx0XHRjb25zdCB0aWxlID0gQ3ViZVJlbmRlcmVyLmV4dHJhY3RUaWxlRnJvbUltYWdlKFxuXHRcdFx0XHRcdFx0aW1hZ2UsIHRpbGVJZHgsIG1heEN1YmVNYXBUZXh0dXJlU2l6ZVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKFxuXHRcdFx0XHRcdFx0Z2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgc3VyZmFjZUlkeCwgMCwgZ2wuUkdCQSxcblx0XHRcdFx0XHRcdGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRpbGVcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXG5cdFx0fVxuXHR9XG5cblx0c3RhdGljIGJpbmRUZXh0dXJlKGdsLCB0ZXh0dXJlLCBpbWFnZSwgaW1hZ2VDb25maWcpIHtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlKTtcblx0XHRDdWJlUmVuZGVyZXIudXBkYXRlVGV4dHVyZShnbCwgaW1hZ2UsIGltYWdlQ29uZmlnKTtcblx0fVxuXG5cdHN0YXRpYyBfZ2V0RGltZW5zaW9uKHBpeGVsU291cmNlKSB7XG5cdFx0Y29uc3Qgd2lkdGggPSBwaXhlbFNvdXJjZS5uYXR1cmFsV2lkdGggfHwgcGl4ZWxTb3VyY2UudmlkZW9XaWR0aDtcblx0XHRjb25zdCBoZWlnaHQgPSBwaXhlbFNvdXJjZS5uYXR1cmFsSGVpZ2h0IHx8IHBpeGVsU291cmNlLnZpZGVvSGVpZ2h0O1xuXG5cdFx0cmV0dXJuIHt3aWR0aCwgaGVpZ2h0fTtcblx0fVxuXG5cdHN0YXRpYyBnZXRTb3VyY2VUaWxlU2l6ZShpbWFnZSkge1xuXHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuX2dldERpbWVuc2lvbihpbWFnZSk7XG5cdFx0Y29uc3QgYXNwZWN0UmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcblx0XHRsZXQgaW5wdXRUZXh0dXJlU2l6ZTtcblxuXHRcdGlmIChhc3BlY3RSYXRpbyA9PT0gMSAvIDYpIHtcblx0XHRcdGlucHV0VGV4dHVyZVNpemUgPSB3aWR0aDtcblx0XHR9IGVsc2UgaWYgKGFzcGVjdFJhdGlvID09PSA2KSB7XG5cdFx0XHRpbnB1dFRleHR1cmVTaXplID0gaGVpZ2h0O1xuXHRcdH0gZWxzZSBpZiAoYXNwZWN0UmF0aW8gPT09IDIgLyAzKSB7XG5cdFx0XHRpbnB1dFRleHR1cmVTaXplID0gd2lkdGggLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnB1dFRleHR1cmVTaXplID0gd2lkdGggLyAzO1xuXHRcdH1cblx0XHRyZXR1cm4gaW5wdXRUZXh0dXJlU2l6ZTtcblx0fVxuXG5cdHN0YXRpYyBleHRyYWN0VGlsZUZyb21JbWFnZShpbWFnZSwgdGlsZUlkeCwgb3V0cHV0VGV4dHVyZVNpemUpIHtcblx0XHRjb25zdCB7d2lkdGh9ID0gdGhpcy5fZ2V0RGltZW5zaW9uKGltYWdlKTtcblx0XHRjb25zdCBpbnB1dFRleHR1cmVTaXplID0gQ3ViZVJlbmRlcmVyLmdldFNvdXJjZVRpbGVTaXplKGltYWdlKTtcblxuXHRcdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cblx0XHRjYW52YXMud2lkdGggPSBvdXRwdXRUZXh0dXJlU2l6ZTtcblx0XHRjYW52YXMuaGVpZ2h0ID0gb3V0cHV0VGV4dHVyZVNpemU7XG5cdFx0Y29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0Y29uc3QgdGlsZVBlclJvdyA9IHdpZHRoIC8gaW5wdXRUZXh0dXJlU2l6ZTtcblxuXHRcdGNvbnN0IHggPSBpbnB1dFRleHR1cmVTaXplICogdGlsZUlkeCAlIChpbnB1dFRleHR1cmVTaXplICogdGlsZVBlclJvdyk7XG5cdFx0Y29uc3QgeSA9IHBhcnNlSW50KHRpbGVJZHggLyB0aWxlUGVyUm93LCAxMCkgKiAoaW5wdXRUZXh0dXJlU2l6ZSk7XG5cblx0XHRjb250ZXh0LmRyYXdJbWFnZShcblx0XHRcdGltYWdlLCB4LCB5LFxuXHRcdFx0aW5wdXRUZXh0dXJlU2l6ZSwgaW5wdXRUZXh0dXJlU2l6ZSwgMCwgMCwgb3V0cHV0VGV4dHVyZVNpemUsIG91dHB1dFRleHR1cmVTaXplXG5cdFx0KTtcblx0XHRyZXR1cm4gY2FudmFzO1xuXHR9XG5cblx0c3RhdGljIGdldE1heEN1YmVNYXBUZXh0dXJlU2l6ZShnbCwgaW1hZ2UpIHtcblx0XHRjb25zdCBhZ2VudCA9IEFnZW50KCk7XG5cdFx0Y29uc3QgbWF4Q3ViZU1hcFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUpO1xuXHRcdGxldCBfaW1hZ2VXaWR0aCA9IEN1YmVSZW5kZXJlci5nZXRTb3VyY2VUaWxlU2l6ZShpbWFnZSk7XG5cblx0XHRpZiAoYWdlbnQuYnJvd3Nlci5uYW1lID09PSBcImllXCIgJiYgcGFyc2VJbnQoYWdlbnQuYnJvd3Nlci52ZXJzaW9uLCAxMCkgPT09IDExKSB7XG5cdFx0XHRpZiAoIXV0aWwuaXNQb3dlck9mVHdvKF9pbWFnZVdpZHRoKSkge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IG1heEN1YmVNYXBUZXh0dXJlU2l6ZTsgaSAqPSAyKSB7XG5cdFx0XHRcdFx0aWYgKGkgPCBfaW1hZ2VXaWR0aCkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdF9pbWFnZVdpZHRoID0gaTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBpb3MgOSDsnZgg6rK97JqwIO2FjeyKpOyzkCDstZzrjIDsgqzsnbTspojripQgMTAyNCDsnbTri6QuXG5cdFx0aWYgKGFnZW50Lm9zLm5hbWUgPT09IFwiaW9zXCIgJiYgcGFyc2VJbnQoYWdlbnQub3MudmVyc2lvbiwgMTApID09PSA5KSB7XG5cdFx0XHRfaW1hZ2VXaWR0aCA9IDEwMjQ7XG5cdFx0fVxuXHRcdC8vIGlvcyA4IOydmCDqsr3smrAg7YWN7Iqk7LOQIOy1nOuMgOyCrOydtOymiOuKlCA1MTIg7J2064ukLlxuXHRcdGlmIChhZ2VudC5vcy5uYW1lID09PSBcImlvc1wiICYmIHBhcnNlSW50KGFnZW50Lm9zLnZlcnNpb24sIDEwKSA9PT0gOCkge1xuXHRcdFx0X2ltYWdlV2lkdGggPSA1MTI7XG5cdFx0fVxuXHRcdC8vIG1heEN1YmVNYXBUZXh0dXJlU2l6ZSDrs7Tri6TripQg7J6R6rOgLCBpbWFnZVdpZHRoIOuztOuLpCDtgbAgMuydmCDsirnsiJgg7KSRIOqwgOyepSDsnpHsnYAg7IiYXG5cdFx0cmV0dXJuIE1hdGgubWluKG1heEN1YmVNYXBUZXh0dXJlU2l6ZSwgX2ltYWdlV2lkdGgpO1xuXHR9XG59XG5cbkN1YmVSZW5kZXJlci5fVkVSVEVYX1BPU0lUSU9OX0RBVEEgPSBudWxsO1xuQ3ViZVJlbmRlcmVyLl9JTkRFWF9EQVRBID0gbnVsbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9yZW5kZXJlci9DdWJlUmVuZGVyZXIuanMiLCJpbXBvcnQgQWdlbnQgZnJvbSBcIkBlZ2pzL2FnZW50XCI7XG5pbXBvcnQgUmVuZGVyZXIgZnJvbSBcIi4vUmVuZGVyZXIuanNcIjtcblxuY29uc3QgYWdlbnQgPSBBZ2VudCgpO1xuY29uc3QgaXNJRTExID0gYWdlbnQuYnJvd3Nlci5uYW1lID09PSBcImllXCIgJiYgYWdlbnQuYnJvd3Nlci52ZXJzaW9uID09PSBcIjExLjBcIjtcbmxldCBwaXhlbENhbnZhcztcbmxldCBwaXhlbENvbnRleHQ7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwaGVyZVJlbmRlcmVyIGV4dGVuZHMgUmVuZGVyZXIge1xuXHRzdGF0aWMgZ2V0VmVydGV4UG9zaXRpb25EYXRhKCkge1xuXHRcdHJldHVybiBTcGhlcmVSZW5kZXJlci5fVkVSVEVYX1BPU0lUSU9OX0RBVEE7XG5cdH1cblxuXHRzdGF0aWMgZ2V0SW5kZXhEYXRhKCkge1xuXHRcdHJldHVybiBTcGhlcmVSZW5kZXJlci5fSU5ERVhfREFUQTtcblx0fVxuXG5cdHN0YXRpYyBnZXRUZXh0dXJlQ29vcmREYXRhKCkge1xuXHRcdHJldHVybiBTcGhlcmVSZW5kZXJlci5fVEVYVFVSRV9DT09SRF9EQVRBO1xuXHR9XG5cblx0c3RhdGljIGdldFZlcnRleFNoYWRlclNvdXJjZSgpIHtcblx0XHRyZXR1cm4gYFxuXHRcdFx0YXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xuXHRcdFx0YXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcblx0XHRcdHVuaWZvcm0gbWF0NCB1TVZNYXRyaXg7XG5cdFx0XHR1bmlmb3JtIG1hdDQgdVBNYXRyaXg7XG5cdFx0XHR2YXJ5aW5nIGhpZ2hwIHZlYzIgdlRleHR1cmVDb29yZDtcblx0XHRcdHZvaWQgbWFpbih2b2lkKSB7XG5cdFx0XHRcdGdsX1Bvc2l0aW9uID0gdVBNYXRyaXggKiB1TVZNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcblx0XHRcdFx0dlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XG5cdFx0XHR9YDtcblx0fVxuXG5cdHN0YXRpYyBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpIHtcblx0XHRyZXR1cm4gYFxuXHRcdFx0dmFyeWluZyBoaWdocCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcblx0XHRcdHZvaWQgbWFpbih2b2lkKSB7XG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRChcblx0XHRcdFx0XHR1U2FtcGxlcixcblx0XHRcdFx0XHR2ZWMyKHZUZXh0dXJlQ29vcmQucywgdlRleHR1cmVDb29yZC50KVxuXHRcdFx0XHQpO1xuXHRcdFx0fWA7XG5cdH1cblxuXHRzdGF0aWMgX2dldFBpeGVsU291cmNlKGltYWdlKSB7XG5cdFx0aWYgKCFwaXhlbENhbnZhcykge1xuXHRcdFx0cmV0dXJuIGltYWdlO1xuXHRcdH1cblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLl9nZXREaW1lbnNpb24oaW1hZ2UpO1xuXG5cdFx0aWYgKHBpeGVsQ2FudmFzLndpZHRoICE9PSB3aWR0aCkge1xuXHRcdFx0cGl4ZWxDYW52YXMud2lkdGggPSB3aWR0aDtcblx0XHR9XG5cblx0XHRpZiAocGl4ZWxDYW52YXMuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcblx0XHRcdHBpeGVsQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcblx0XHR9XG5cblx0XHRwaXhlbENvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcblxuXHRcdHJldHVybiBwaXhlbENhbnZhcztcblx0fVxuXG5cdHN0YXRpYyBfZ2V0RGltZW5zaW9uKHBpeGVsU291cmNlKSB7XG5cdFx0Y29uc3Qgd2lkdGggPSBwaXhlbFNvdXJjZS5uYXR1cmFsV2lkdGggfHwgcGl4ZWxTb3VyY2UudmlkZW9XaWR0aDtcblx0XHRjb25zdCBoZWlnaHQgPSBwaXhlbFNvdXJjZS5uYXR1cmFsSGVpZ2h0IHx8IHBpeGVsU291cmNlLnZpZGVvSGVpZ2h0O1xuXG5cdFx0cmV0dXJuIHt3aWR0aCwgaGVpZ2h0fTtcblx0fVxuXG5cdHN0YXRpYyB1cGRhdGVUZXh0dXJlKGdsLCBpbWFnZSkge1xuXHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5fZ2V0UGl4ZWxTb3VyY2UoaW1hZ2UpKTtcblx0fVxuXG5cdHN0YXRpYyBiaW5kVGV4dHVyZShnbCwgdGV4dHVyZSwgaW1hZ2UpIHtcblx0XHQvLyBNYWtlIHN1cmUgaW1hZ2UgaXNuJ3QgdG9vIGJpZ1xuXHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuX2dldERpbWVuc2lvbihpbWFnZSk7XG5cdFx0Y29uc3Qgc2l6ZSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuXHRcdGNvbnN0IG1heFNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSk7XG5cblx0XHRpZiAoc2l6ZSA+IG1heFNpemUpIHtcblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cblx0XHRcdGNvbnNvbGUud2FybihgSW1hZ2Ugd2lkdGgoJHt3aWR0aH0pIGV4Y2VlZHMgZGV2aWNlIGxpbWl0KCR7bWF4U2l6ZX0pKWApO1xuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGlzSUUxMSAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcblx0XHRcdHBpeGVsQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblx0XHRcdHBpeGVsQ2FudmFzLndpZHRoID0gd2lkdGg7XG5cdFx0XHRwaXhlbENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHRwaXhlbENvbnRleHQgPSBwaXhlbENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0fVxuXG5cdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG5cdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG5cblx0XHRTcGhlcmVSZW5kZXJlci51cGRhdGVUZXh0dXJlKGdsLCBpbWFnZSk7XG5cdH1cblxuXHRzdGF0aWMgX2luaXREYXRhKCkge1xuXHRcdGNvbnN0IGxhdGl0dWRlQmFuZHMgPSA2MDtcblx0XHRjb25zdCBsb25naXR1ZGVCYW5kcyA9IDYwO1xuXHRcdGNvbnN0IHJhZGl1cyA9IDI7XG5cblx0XHRjb25zdCB0ZXh0dXJlQ29vcmREYXRhID0gW107XG5cdFx0Y29uc3QgdmVydGV4UG9zaXRpb25EYXRhID0gW107XG5cdFx0Y29uc3QgaW5kZXhEYXRhID0gW107XG5cdFx0bGV0IGxhdElkeDtcblx0XHRsZXQgbG5nSWR4O1xuXG5cdFx0Zm9yIChsYXRJZHggPSAwOyBsYXRJZHggPD0gbGF0aXR1ZGVCYW5kczsgbGF0SWR4KyspIHtcblx0XHRcdGNvbnN0IHRoZXRhID0gKGxhdElkeCAvIGxhdGl0dWRlQmFuZHMgLSAwLjUpICogTWF0aC5QSTtcblx0XHRcdGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuXHRcdFx0Y29uc3QgY29zVGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XG5cblx0XHRcdGZvciAobG5nSWR4ID0gMDsgbG5nSWR4IDw9IGxvbmdpdHVkZUJhbmRzOyBsbmdJZHgrKykge1xuXHRcdFx0XHRjb25zdCBwaGkgPSAobG5nSWR4IC8gbG9uZ2l0dWRlQmFuZHMgLSAwLjUpICogMiAqIE1hdGguUEk7XG5cdFx0XHRcdGNvbnN0IHNpblBoaSA9IE1hdGguc2luKHBoaSk7XG5cdFx0XHRcdGNvbnN0IGNvc1BoaSA9IE1hdGguY29zKHBoaSk7XG5cdFx0XHRcdGNvbnN0IHggPSBjb3NQaGkgKiBjb3NUaGV0YTtcblx0XHRcdFx0Y29uc3QgeSA9IHNpblRoZXRhO1xuXHRcdFx0XHRjb25zdCB6ID0gc2luUGhpICogY29zVGhldGE7XG5cdFx0XHRcdGNvbnN0IHUgPSBsbmdJZHggLyBsb25naXR1ZGVCYW5kcztcblx0XHRcdFx0Y29uc3QgdiA9IGxhdElkeCAvIGxhdGl0dWRlQmFuZHM7XG5cblx0XHRcdFx0dGV4dHVyZUNvb3JkRGF0YS5wdXNoKHUsIHYpO1xuXHRcdFx0XHR2ZXJ0ZXhQb3NpdGlvbkRhdGEucHVzaChyYWRpdXMgKiB4LCByYWRpdXMgKiB5LCByYWRpdXMgKiB6KTtcblxuXHRcdFx0XHRpZiAobG5nSWR4ICE9PSBsb25naXR1ZGVCYW5kcyAmJiBsYXRJZHggIT09IGxhdGl0dWRlQmFuZHMpIHtcblx0XHRcdFx0XHRjb25zdCBhID0gbGF0SWR4ICogKGxvbmdpdHVkZUJhbmRzICsgMSkgKyBsbmdJZHg7XG5cdFx0XHRcdFx0Y29uc3QgYiA9IGEgKyBsb25naXR1ZGVCYW5kcyArIDE7XG5cblx0XHRcdFx0XHRpbmRleERhdGEucHVzaChhLCBiLCBhICsgMSwgYiwgYiArIDEsIGEgKyAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdFNwaGVyZVJlbmRlcmVyLl9WRVJURVhfUE9TSVRJT05fREFUQSA9IHZlcnRleFBvc2l0aW9uRGF0YTtcblx0XHRTcGhlcmVSZW5kZXJlci5fVEVYVFVSRV9DT09SRF9EQVRBID0gdGV4dHVyZUNvb3JkRGF0YTtcblx0XHRTcGhlcmVSZW5kZXJlci5fSU5ERVhfREFUQSA9IGluZGV4RGF0YTtcblx0fVxufVxuXG5TcGhlcmVSZW5kZXJlci5fVkVSVEVYX1BPU0lUSU9OX0RBVEEgPSBudWxsO1xuU3BoZXJlUmVuZGVyZXIuX1RFWFRVUkVfQ09PUkRfREFUQSA9IG51bGw7XG5TcGhlcmVSZW5kZXJlci5fSU5ERVhfREFUQSA9IG51bGw7XG5cblNwaGVyZVJlbmRlcmVyLl9pbml0RGF0YSgpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1Bhbm9JbWFnZVJlbmRlcmVyL3JlbmRlcmVyL1NwaGVyZVJlbmRlcmVyLmpzIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG5pbXBvcnQge1xuXHREZXZpY2VNb3Rpb25FdmVudFxufSBmcm9tIFwiLi9icm93c2VyXCI7XG5cbmltcG9ydCB7WWF3UGl0Y2hDb250cm9sfSBmcm9tIFwiLi4vWWF3UGl0Y2hDb250cm9sXCI7XG5pbXBvcnQge1Bhbm9JbWFnZVJlbmRlcmVyfSBmcm9tIFwiLi4vUGFub0ltYWdlUmVuZGVyZXJcIjtcbmltcG9ydCBXZWJHTFV0aWxzIGZyb20gXCIuLi9QYW5vSW1hZ2VSZW5kZXJlci9XZWJHTFV0aWxzXCI7XG5pbXBvcnQge0VSUk9SX1RZUEUsIEVWRU5UUywgR1lST19NT0RFLCBQUk9KRUNUSU9OX1RZUEV9IGZyb20gXCIuL2NvbnN0c1wiO1xuaW1wb3J0IHtnbE1hdHJpeH0gZnJvbSBcIi4uL3V0aWxzL21hdGgtdXRpbC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYW5vVmlld2VyIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIEBjbGFzc2Rlc2MgMzYwIG1lZGlhIHZpZXdlclxuXHQgKiBAa28gMzYwIOuvuOuUlOyWtCDrt7DslrRcblx0ICogQGNsYXNzXG5cdCAqIEBuYW1lIGVnLnZpZXczNjAuUGFub1ZpZXdlclxuXHQgKiBAZXh0ZW5kcyBlZy5Db21wb25lbnRcblx0ICpcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIFRoZSBjb250YWluZXIgZWxlbWVudCBmb3IgdGhlIHJlbmRlcmVyLiA8a28+66CM642U65+s7J2YIOy7qO2FjOydtOuEiCDsl5jrpqzrqLztirg8L2tvPlxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEltYWdlfSBjb25maWcuaW1hZ2UgSW5wdXQgaW1hZ2UgdXJsIG9yIGVsZW1lbnQgKFVzZSBvbmx5IGltYWdlIHByb3BlcnR5IG9yIHZpZGVvIHByb3BlcnR5KTxrbz7snoXroKUg7J2066+47KeAIFVSTCDtmLnsnYAg7JeY66as66i87Yq4KGltYWdlIOyZgCB2aWRlbyDrkZgg7KSRIO2VmOuCmOunjCDshKTsoJUpPC9rbz5cblx0ICogQHBhcmFtIHtTdHJpbmd8SFRNTFZpZGVvRWxlbWVudH0gY29uZmlnLnZpZGVvIElucHV0IHZpZGVvIHVybCBvciBlbGVtZW50KFVzZSBvbmx5IGltYWdlIHByb3BlcnR5IG9yIHZpZGVvIHByb3BlcnR5KTxrbz7snoXroKUg67mE65SU7JikIFVSTCDtmLnsnYAg7JeY66as66i87Yq4KGltYWdlIOyZgCB2aWRlbyDrkZgg7KSRIO2VmOuCmOunjCDshKTsoJUpPC9rbz5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcucHJvamVjdGlvblR5cGU9ZXF1aXJlY3Rhbmd1bGFyXSBUaGUgdHlwZSBvZiBwcm9qZWN0aW9uOiBlcXVpcmVjdGFuZ3VsYXIsIGN1YmVtYXAgPGJyLz57QGxpbmsgZWcudmlldzM2MC5QYW5vVmlld2VyLlBST0pFQ1RJT05fVFlQRX08a28+UHJvamVjdGlvbiDsnKDtmJUgOiBlcXVpcmVjdGFuZ3VsYXIsIGN1YmVtYXAgPGJyLz57QGxpbmsgZWcudmlldzM2MC5QYW5vVmlld2VyLlBST0pFQ1RJT05fVFlQRX08L2tvPlxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLmN1YmVtYXBDb25maWcgY29uZmlnIGN1YmVtYXAgcHJvamVjdGlvbiBsYXlvdXQuIDxrbz5jdWJlbWFwIHByb2plY3Rpb24gdHlwZSDsnZgg66CI7J207JWE7JuD7J2EIOyEpOygle2VnOuLpC48L2tvPlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aD13aWR0aCBvZiBjb250YWluZXJdIHRoZSB2aWV3ZXIncyB3aWR0aC4gKGluIHB4KSA8a28+67ew7Ja07J2YIOuEiOu5hCAocHgg64uo7JyEKTwva28+XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodD1oZWlnaHQgb2YgY29udGFpbmVyXSB0aGUgdmlld2VyJ3MgaGVpZ2h0LihpbiBweCkgPGtvPuu3sOyWtOydmCDrhpLsnbQgKHB4IOuLqOychCk8L2tvPlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55YXc9MF0gSW5pdGlhbCBZYXcgb2YgY2FtZXJhIChpbiBkZWdyZWUpIDxrbz7subTrqZTrnbzsnZgg7LSI6riwIFlhdyAoZGVncmVlIOuLqOychCk8L2tvPlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5waXRjaD0wXSBJbml0aWFsIFBpdGNoIG9mIGNhbWVyYSAoaW4gZGVncmVlKSA8a28+7Lm066mU65287J2YIOy0iOq4sCBQaXRjaCAoZGVncmVlIOuLqOychCk8L2tvPlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5mb3Y9NjVdIEluaXRpYWwgdmVydGljYWwgZmllbGQgb2YgdmlldyBvZiBjYW1lcmEgKGluIGRlZ3JlZSkgPGtvPuy5tOuplOudvOydmCDstIjquLAg7IiY7KeBIGZpZWxkIG9mIHZpZXcgKGRlZ3JlZSDri6jsnIQpPC9rbz5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNob3dQb2xlUG9pbnQ9ZmFsc2VdIElmIGZhbHNlLCB0aGUgcG9sZSBpcyBub3QgZGlzcGxheWVkIGluc2lkZSB0aGUgdmlld3BvcnQgPGtvPmZhbHNlIOyduCDqsr3smrAsIOq3ueygkOydgCDrt7Dtj6ztirgg64K067aA7JeQIO2RnOyLnOuQmOyngCDslYrsirXri4jri6Q8L2tvPlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudXNlWm9vbT10cnVlXSBXaGVuIHRydWUsIGVuYWJsZXMgem9vbSB3aXRoIHRoZSB3aGVlbCBhbmQgUGluY2ggZ2VzdHVyZSA8a28+dHJ1ZSDsnbwg65WMIO2coCDrsI8g7KeR6riwIOygnOyKpOy2sOuhnCDtmZXrjIAgLyDstpXshowg7ZWgIOyImCDsnojsirXri4jri6QuPC9rbz5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnVzZUtleWJvYXJkPXRydWVdIFdoZW4gdHJ1ZSwgZW5hYmxlcyB0aGUga2V5Ym9hcmQgbW92ZSBrZXkgY29udHJvbDogYXdzZCwgYXJyb3cga2V5cyA8a28+dHJ1ZSDsnbTrqbQg7YKk67O065OcIOydtOuPmSDtgqQg7Luo7Yq466Gk7J2EIO2ZnOyEse2ZlO2VqeuLiOuLpDogYXdzZCwg7ZmU7IK07ZGcIO2CpDwva28+XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmd5cm9Nb2RlPXlhd1BpdGNoXSBFbmFibGVzIGNvbnRyb2wgdGhyb3VnaCBkZXZpY2UgbW90aW9uLiAoXCJub25lXCIsIFwieWF3UGl0Y2hcIiwgXCJWUlwiKSA8YnIvPntAbGluayBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuR1lST19NT0RFfSA8a28+65SU67CU7J207IqkIOybgOyngeyehOydhCDthrXtlZwg7Luo7Yq466Gk7J2EIO2ZnOyEse2ZlCDtlanri4jri6QuIChcIm5vbmVcIiwgXCJ5YXdQaXRjaFwiLCBcIlZSXCIpIDxici8+e0BsaW5rIGVnLnZpZXczNjAuUGFub1ZpZXdlci5HWVJPX01PREV9IDwva28+XG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcueWF3UmFuZ2U9Wy0xODAsIDE4MF1dIFJhbmdlIG9mIGNvbnRyb2xsYWJsZSBZYXcgdmFsdWVzIDxrbz7soJzslrQg6rCA64ql7ZWcIFlhdyDqsJLsnZgg67KU7JyEPC9rbz5cblx0ICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5waXRjaFJhbmdlPVstOTAsIDkwXV0gUmFuZ2Ugb2YgY29udHJvbGxhYmxlIFBpdGNoIHZhbHVlcyA8a28+7KCc7Ja0IOqwgOuKpe2VnCBQaXRjaCDqsJLsnZgg67KU7JyEPC9rbz5cblx0ICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5mb3ZSYW5nZT1bMzAsIDExMF1dIFJhbmdlIG9mIGNvbnRyb2xsYWJsZSB2ZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IHZhbHVlcyA8a28+7KCc7Ja0IOqwgOuKpe2VnCDsiJjsp4EgZmllbGQgb2YgdmlldyDqsJLsnZgg67KU7JyEPC9rbz5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcudG91Y2hEaXJlY3Rpb249IHtAbGluayBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OLkFMTH0oNildIERpcmVjdGlvbiBvZiB0b3VjaCB0aGF0IGNhbiBiZSBjb250cm9sbGVkIGJ5IHVzZXIgPGJyLz57QGxpbmsgZWcudmlldzM2MC5QYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTn08a28+7IKs7Jqp7J6Q6rCAIO2EsOy5mOuhnCDsobDsnpEg6rCA64ql7ZWcIOuwqe2WpSA8YnIvPntAbGluayBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OfTwva28+XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIC8vIGNyZWF0ZSBQYW5vVmlld2VyIHdpdGggb3B0aW9uXG5cdCAqIHZhciBQYW5vVmlld2VyID0gZWcudmlldzM2MC5QYW5vVmlld2VyO1xuXHQgKiAvLyBBcmVhIHdoZXJlIHRoZSBpbWFnZSB3aWxsIGJlIGRpc3BsYXllZChIVE1MRWxlbWVudClcblx0ICogdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXlQYW5vVmlld2VyXCIpO1xuXHQgKlxuXHQgKiB2YXIgcGFub1ZpZXdlciA9IG5ldyBQYW5vVmlld2VyKGNvbnRhaW5lciwge1xuXHQgKiAgICAgLy8gSWYgcHJvamVjdGlvblR5cGUgaXMgbm90IHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgaXMgXCJlcXVpcmVjdGFuZ3VsYXJcIi5cblx0ICogICAgIC8vIFNwZWNpZmllcyBhbiBpbWFnZSBvZiB0aGUgXCJlcXVpcmVjdGFuZ3VsYXJcIiB0eXBlLlxuXHQgKiAgICAgaW1hZ2U6IFwiL3BhdGgvdG8vaW1hZ2UvaW1hZ2UuanBnXCJcblx0ICp9KTtcblx0ICovXG5cdGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgb3B0aW9ucyA9IHt9KSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdC8vIFJhaXNlcyB0aGUgZXJyb3IgZXZlbnQgaWYgd2ViZ2wgaXMgbm90IHN1cHBvcnRlZC5cblx0XHRpZiAoIVdlYkdMVXRpbHMuaXNXZWJHTEF2YWlsYWJsZSgpKSB7XG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKEVWRU5UUy5FUlJPUiwge1xuXHRcdFx0XHRcdHR5cGU6IEVSUk9SX1RZUEUuTk9fV0VCR0wsXG5cdFx0XHRcdFx0bWVzc2FnZTogXCJubyB3ZWJnbCBzdXBwb3J0XCJcblx0XHRcdFx0fSk7XG5cdFx0XHR9LCAwKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICghV2ViR0xVdGlscy5pc1N0YWJsZVdlYkdMKCkpIHtcblx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoRVZFTlRTLkVSUk9SLCB7XG5cdFx0XHRcdFx0dHlwZTogRVJST1JfVFlQRS5JTlZBTElEX0RFVklDRSxcblx0XHRcdFx0XHRtZXNzYWdlOiBcImJsYWNrbGlzdGVkIGJyb3dzZXJcIlxuXHRcdFx0XHR9KTtcblx0XHRcdH0sIDApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoISFvcHRpb25zLmltYWdlICYmICEhb3B0aW9ucy52aWRlbykge1xuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcihFVkVOVFMuRVJST1IsIHtcblx0XHRcdFx0XHR0eXBlOiBFUlJPUl9UWVBFLklOVkFMSURfUkVTT1VSQ0UsXG5cdFx0XHRcdFx0bWVzc2FnZTogXCJTcGVjaWZ5aW5nIG11bHRpIHJlc291Y2VzKGJvdGggaW1hZ2UgYW5kIHZpZGVvKSBpcyBub3QgdmFsaWQuXCJcblx0XHRcdFx0fSk7XG5cdFx0XHR9LCAwKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcblx0XHR0aGlzLl9pbWFnZSA9IG9wdGlvbnMuaW1hZ2UgfHwgb3B0aW9ucy52aWRlbztcblx0XHR0aGlzLl9pc1ZpZGVvID0gISFvcHRpb25zLnZpZGVvO1xuXHRcdHRoaXMuX3Byb2plY3Rpb25UeXBlID0gb3B0aW9ucy5wcm9qZWN0aW9uVHlwZSB8fCBQUk9KRUNUSU9OX1RZUEUuRVFVSVJFQ1RBTkdVTEFSO1xuXHRcdHRoaXMuX2N1YmVtYXBDb25maWcgPSBPYmplY3QuYXNzaWduKHtcblx0XHRcdG9yZGVyOiBcIlJMVURCRlwiLFxuXHRcdFx0dGlsZUNvbmZpZzoge1xuXHRcdFx0XHRmbGlwSGlyb3pvbnRhbDogZmFsc2UsXG5cdFx0XHRcdHJvdGF0aW9uOiAwXG5cdFx0XHR9XG5cdFx0fSwgb3B0aW9ucy5jdWJlbWFwQ29uZmlnKTtcblxuXHRcdC8vIElmIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBub3QgcHJvdmlkZWQsIHdpbGwgdXNlIHRoZSBzaXplIG9mIHRoZSBjb250YWluZXIuXG5cdFx0dGhpcy5fd2lkdGggPSBvcHRpb25zLndpZHRoIHx8IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcikud2lkdGgsIDEwKTtcblx0XHR0aGlzLl9oZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpLmhlaWdodCwgMTApO1xuXG5cdFx0dGhpcy5feWF3ID0gb3B0aW9ucy55YXcgfHwgMDtcblx0XHR0aGlzLl9waXRjaCA9IG9wdGlvbnMucGl0Y2ggfHwgMDtcblx0XHR0aGlzLl9mb3YgPSBvcHRpb25zLmZvdiB8fCA2NTtcblxuXHRcdHRoaXMuX2d5cm9Nb2RlID0gb3B0aW9ucy5neXJvTW9kZSB8fCBHWVJPX01PREUuWUFXUElUQ0g7XG5cdFx0dGhpcy5fcXVhdGVybmlvbiA9IG51bGw7XG5cblx0XHR0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuX3dpZHRoIC8gdGhpcy5faGVpZ2h0O1xuXHRcdGNvbnN0IGZvdlJhbmdlID0gb3B0aW9ucy5mb3ZSYW5nZSB8fCBbMzAsIDExMF07XG5cdFx0Y29uc3QgdG91Y2hEaXJlY3Rpb24gPSBQYW5vVmlld2VyLl9pc1ZhbGlkVG91Y2hEaXJlY3Rpb24ob3B0aW9ucy50b3VjaERpcmVjdGlvbikgP1xuXHRcdFx0b3B0aW9ucy50b3VjaERpcmVjdGlvbiA6IFlhd1BpdGNoQ29udHJvbC5UT1VDSF9ESVJFQ1RJT05fQUxMO1xuXHRcdGNvbnN0IHlhd1BpdGNoQ29uZmlnID0gT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7XG5cdFx0XHRlbGVtZW50OiBjb250YWluZXIsXG5cdFx0XHR5YXc6IHRoaXMuX3lhdyxcblx0XHRcdHBpdGNoOiB0aGlzLl9waXRjaCxcblx0XHRcdGZvdjogdGhpcy5fZm92LFxuXHRcdFx0Z3lyb01vZGU6IHRoaXMuX2d5cm9Nb2RlLFxuXHRcdFx0Zm92UmFuZ2UsXG5cdFx0XHRhc3BlY3RSYXRpbzogdGhpcy5fYXNwZWN0UmF0aW8sXG5cdFx0XHR0b3VjaERpcmVjdGlvblxuXHRcdH0pO1xuXG5cdFx0dGhpcy5faXNSZWFkeSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5faW5pdFlhd1BpdGNoQ29udHJvbCh5YXdQaXRjaENvbmZpZyk7XG5cdFx0dGhpcy5faW5pdFJlbmRlcmVyKHRoaXMuX3lhdywgdGhpcy5fcGl0Y2gsIHRoaXMuX2ZvdiwgdGhpcy5fcHJvamVjdGlvblR5cGUsIHRoaXMuX2N1YmVtYXBDb25maWcpO1xuXHR9XG5cblx0LyoqXG5cdFx0KiBHZXQgdGhlIHZpZGVvIGVsZW1lbnQgdGhhdCB0aGUgdmlld2VyIGlzIGN1cnJlbnRseSBwbGF5aW5nLiBZb3UgY2FuIHVzZSB0aGlzIGZvciBwbGF5YmFjay5cblx0XHQqIEBrbyDrt7DslrTqsIAg7ZiE7J6sIOyCrOyaqSDspJHsnbgg67mE65SU7JikIOyalOyGjOulvCDslrvsirXri4jri6QuIOydtCDsmpTshozrpbwg7J207Jqp7ZW0IOu5hOuUlOyYpOydmCDsu6jtirjroaTsnYQg7ZWgIOyImCDsnojsirXri4jri6QuXG5cdFx0KiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNnZXRWaWRlb1xuXHRcdCogQHJldHVybiB7SFRNTFZpZGVvRWxlbWVudH0gSFRNTFZpZGVvRWxlbWVudDxrbz5IVE1MVmlkZW9FbGVtZW50PC9rbz5cblx0XHQqIEBleGFtcGxlXG5cdFx0KiB2YXIgdmlkZW9UYWcgPSBwYW5vVmlld2VyLmdldFZpZGVvKCk7XG5cdFx0KiB2aWRlb1RhZy5wbGF5KCk7IC8vIHBsYXkgdmlkZW8hXG5cdFx0Ki9cblx0Z2V0VmlkZW8oKSB7XG5cdFx0aWYgKCF0aGlzLl9pc1ZpZGVvKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlci5nZXRDb250ZW50KCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRoZSB2aWRlbyBpbmZvcm1hdGlvbiB0byBiZSB1c2VkIGJ5IHRoZSB2aWV3ZXIuXG5cdCAqIEBrbyDrt7DslrTqsIAg7IKs7Jqp7ZWgIOydtOuvuOyngCDsoJXrs7Trpbwg7ISk7KCV7ZWp64uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNzZXRWaWRlb1xuXHQgKiBAcGFyYW0ge1N0cmluZ3xIVE1MVmlkZW9FbGVtZW50fE9iamVjdH0gdmlkZW8gSW5wdXQgdmlkZW8gdXJsIG9yIGVsZW1lbnQgb3IgY29uZmlnIG9iamVjdDxrbz7snoXroKUg67mE65SU7JikIFVSTCDtmLnsnYAg7JeY66as66i87Yq4IO2YueydgCDshKTsoJXqsJ3ssrTrpbwg7Zmc7JqpKGltYWdlIOyZgCB2aWRlbyDrkZgg7KSRIO2VmOuCmOunjCDshKTsoJUpPC9rbz5cblx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyYW0ucHJvamVjdGlvblR5cGU9e0BsaW5rIGVnLnZpZXczNjAuUGFub1ZpZXdlci5QUk9KRUNUSU9OX1RZUEUuRVFVSVJFQ1RBTkdVTEFSfShcImVxdWlyZWN0YW5ndWxhclwiKV0gUHJvamVjdGlvbiBUeXBlPGtvPu2UhOuhnOygneyFmCDtg4DsnoU8L2tvPlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0uY3ViZW1hcENvbmZpZyBjb25maWcgY3ViZW1hcCBwcm9qZWN0aW9uIGxheW91dC4gPGtvPmN1YmVtYXAgcHJvamVjdGlvbiB0eXBlIOydmCDroIjsnbTslYTsm4Mg7ISk7KCVPC9rbz5cblx0ICpcblx0ICogQHJldHVybiB7ZWcudmlldzM2MC5QYW5vVmlld2VyfSBQYW5vVmlld2VyIGluc3RhbmNlPGtvPlBhbm9WaWV3ZXIg7J247Iqk7YS07IqkPC9rbz5cblx0ICogQGV4YW1wbGVcblx0ICogcGFub1ZpZXdlci5zZXRWaWRlbyhcIi9wYXRoL3RvL3ZpZGVvL3ZpZGVvLm1wNFwiLCB7XG5cdCAqICAgICBwcm9qZWN0aW9uVHlwZTogZWcudmlldzM2MC5QYW5vVmlld2VyLlBST0pFQ1RJT05fVFlQRS5FUVVJUkVDVEFOR1VMQVJcblx0ICogfSk7XG5cdCAqL1xuXHRzZXRWaWRlbyh2aWRlbywgcGFyYW0gPSB7fSkge1xuXHRcdGlmICh2aWRlbykge1xuXHRcdFx0dGhpcy5zZXRJbWFnZSh2aWRlbywge1xuXHRcdFx0XHRwcm9qZWN0aW9uVHlwZTogcGFyYW0ucHJvamVjdGlvblR5cGUsXG5cdFx0XHRcdGlzVmlkZW86IHRydWUsXG5cdFx0XHRcdGN1YmVtYXBDb25maWc6IHBhcmFtLmN1YmVtYXBDb25maWdcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgaW1hZ2UgaW5mb3JtYXRpb24gdGhhdCB0aGUgdmlld2VyIGlzIGN1cnJlbnRseSB1c2luZy5cblx0ICogQGtvIOu3sOyWtOqwgCDtmITsnqwg7IKs7Jqp7ZWY6rOg7J6I64qUIOydtOuvuOyngCDsoJXrs7Trpbwg7Ja77Iq164uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNnZXRJbWFnZVxuXHQgKiBAcmV0dXJuIHtJbWFnZX0gSW1hZ2UgT2JqZWN0PGtvPuydtOuvuOyngCDqsJ3ssrQ8L2tvPlxuXHQgKiBAZXhhbXBsZVxuXHQgKiB2YXIgaW1hZ2VPYmogPSBwYW5vVmlld2VyLmdldEltYWdlKCk7XG5cdCAqL1xuXHRnZXRJbWFnZSgpIHtcblx0XHRpZiAodGhpcy5faXNWaWRlbykge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX3Bob3RvU3BoZXJlUmVuZGVyZXIuZ2V0Q29udGVudCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgaW1hZ2UgaW5mb3JtYXRpb24gdG8gYmUgdXNlZCBieSB0aGUgdmlld2VyLlxuXHQgKiBAa28g67ew7Ja06rCAIOyCrOyaqe2VoCDsnbTrr7jsp4Ag7KCV67O066W8IOyEpOygle2VqeuLiOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjc2V0SW1hZ2Vcblx0ICogQHBhcmFtIHtTdHJpbmd8SW1hZ2V8T2JqZWN0fSBpbWFnZSBJbnB1dCBpbWFnZSB1cmwgb3IgZWxlbWVudCBvciBjb25maWcgb2JqZWN0PGtvPuyeheugpSDsnbTrr7jsp4AgVVJMIO2YueydgCDsl5jrpqzrqLztirgg7Zi57J2AIOyEpOygleqwneyytOulvCDtmZzsmqkoaW1hZ2Ug7JmAIHZpZGVvIOuRmCDspJEg7ZWY64KY66eMIOyEpOygle2VnOuLpC4pPC9rbz5cblx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIEFkZGl0aW9uYWwgaW5mb3JtYXRpb248a28+7J2066+47KeAIOy2lOqwgCDsoJXrs7Q8L2tvPlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtLnByb2plY3Rpb25UeXBlPVwiZXF1aXJlY3Rhbmd1bGFyXCJdIFByb2plY3Rpb24gVHlwZTxrbz7tlITroZzsoJ3shZgg7YOA7J6FPC9rbz5cblx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtLmN1YmVtYXBDb25maWcgY29uZmlnIGN1YmVtYXAgcHJvamVjdGlvbiBsYXlvdXQuIDxrbz5jdWJlbWFwIHByb2plY3Rpb24gdHlwZSDroIjsnbTslYTsm4M8L2tvPlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtlZy52aWV3MzYwLlBhbm9WaWV3ZXJ9IFBhbm9WaWV3ZXIgaW5zdGFuY2U8a28+UGFub1ZpZXdlciDsnbjsiqTthLTsiqQ8L2tvPlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBwYW5vVmlld2VyLnNldEltYWdlKFwiL3BhdGgvdG8vaW1hZ2UvaW1hZ2UucG5nXCIsIHtcblx0ICogICAgIHByb2plY3Rpb25UeXBlOiBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuUFJPSkVDVElPTl9UWVBFLkNVQkVNQVBcblx0ICogfSk7XG5cdCAqL1xuXHRzZXRJbWFnZShpbWFnZSwgcGFyYW0gPSB7fSkge1xuXHRcdGNvbnN0IGN1YmVtYXBDb25maWcgPSBPYmplY3QuYXNzaWduKHtcblx0XHRcdG9yZGVyOiBcIlJMVURCRlwiLFxuXHRcdFx0dGlsZUNvbmZpZzoge1xuXHRcdFx0XHRmbGlwSGlyb3pvbnRhbDogZmFsc2UsXG5cdFx0XHRcdHJvdGF0aW9uOiAwXG5cdFx0XHR9XG5cdFx0fSwgcGFyYW0uY3ViZW1hcENvbmZpZyk7XG5cdFx0Y29uc3QgaXNWaWRlbyA9ICEhKHBhcmFtLmlzVmlkZW8pO1xuXG5cdFx0aWYgKHRoaXMuX2ltYWdlICYmIHRoaXMuX2lzVmlkZW8gIT09IGlzVmlkZW8pIHtcblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cblx0XHRcdGNvbnNvbGUud2FybihcIkN1cnJlbnRseSBub3Qgc3VwcG9ydGluZyB0byBjaGFuZ2UgY29udGVudCB0eXBlKEltYWdlIDwtLT4gVmlkZW8pXCIpO1xuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoaW1hZ2UpIHtcblx0XHRcdHRoaXMuX2ltYWdlID0gaW1hZ2U7XG5cdFx0XHR0aGlzLl9pc1ZpZGVvID0gaXNWaWRlbztcblx0XHRcdHRoaXMuX3Byb2plY3Rpb25UeXBlID0gcGFyYW0ucHJvamVjdGlvblR5cGUgfHwgUFJPSkVDVElPTl9UWVBFLkVRVUlSRUNUQU5HVUxBUjtcblx0XHRcdHRoaXMuX2N1YmVtYXBDb25maWcgPSBjdWJlbWFwQ29uZmlnO1xuXG5cdFx0XHR0aGlzLl9kZWFjdGl2YXRlKCk7XG5cdFx0XHR0aGlzLl9pbml0UmVuZGVyZXIodGhpcy5feWF3LCB0aGlzLl9waXRjaCwgdGhpcy5fZm92LCB0aGlzLl9wcm9qZWN0aW9uVHlwZSwgdGhpcy5fY3ViZW1hcENvbmZpZyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHdoZXRoZXIgdGhlIHJlbmRlcmVyIGFsd2F5cyB1cGRhdGVzIHRoZSB0ZXh0dXJlIGFuZCByZW5kZXJzLlxuXHQgKiBAa28g66CM642U65+s6rCAIO2VreyDgSDthY3siqTss5Drpbwg6rCx7Iug7ZWY6rOgIO2ZlOuptOydhCDroIzrjZTrp4Eg7ZWg7KeAIOyXrOu2gOulvCDshKTsoJXtlaAg7IiYIOyeiOyKteuLiOuLpC5cblx0ICpcblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIja2VlcFVwZGF0ZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGRvVXBkYXRlIFdoZW4gdHJ1ZSB2aWV3ZXIgd2lsbCBhbHdheXMgdXBkYXRlIHRleHR1cmUgYW5kIHJlbmRlciwgd2hlbiBmYWxzZSB2aWV3ZXIgd2lsbCBub3QgdXBkYXRlIHRleHR1cmUgYW5kIHJlbmRlciBvbmx5IGNhbWVyYSBjb25maWcgaXMgY2hhbmdlZC48a28+dHJ1ZeuptCDtla3sg4Eg7YWN7Iqk7LOQ66W8IOqwseyLoO2VmOqzoCDtmZTrqbTsnYQg6re466as64qUIOuwmOuptCwgZmFsc2XrqbQg7YWN7Iqk7LOQIOqwseyLoOydgCDtlZjsp4Ag7JWK7Jy866mwLCDsubTrqZTrnbwg7JqU7IaM7JeQIOuzgO2ZlOqwgCDsnojsnYQg65WM7JeQ66eMIO2ZlOuptOydhCDqt7jrpr3ri4jri6QuPC9rbz5cblx0ICogQHJldHVybiB7ZWcudmlldzM2MC5QYW5vVmlld2VyfSBQYW5vVmlld2VyIGluc3RhbmNlPGtvPlBhbm9WaWV3ZXIg7J247Iqk7YS07IqkPC9rbz5cblx0ICovXG5cdGtlZXBVcGRhdGUoZG9VcGRhdGUpIHtcblx0XHR0aGlzLl9waG90b1NwaGVyZVJlbmRlcmVyLmtlZXBVcGRhdGUoZG9VcGRhdGUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBwcm9qZWN0aW9uIHR5cGUgKGVxdWlyZWN0YW5ndWxhci9jdWJlKVxuXHQgKiBAa28g7ZSE66Gc7KCd7IWYIO2DgOyehShFcXVpcmVjdGFuZ3VsYXIg7Zi57J2AIEN1YmUp7J2EIOuwmO2ZmO2VqeuLiOuLpC5cblx0ICpcblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjZ2V0UHJvamVjdGlvblR5cGVcblx0ICogQHJldHVybiB7U3RyaW5nfSB7QGxpbmsgZWcudmlldzM2MC5QYW5vVmlld2VyLlBST0pFQ1RJT05fVFlQRX1cblx0ICovXG5cdGdldFByb2plY3Rpb25UeXBlKCkge1xuXHRcdHJldHVybiB0aGlzLl9wcm9qZWN0aW9uVHlwZTtcblx0fVxuXG5cdF9pbml0UmVuZGVyZXIoeWF3LCBwaXRjaCwgZm92LCBwcm9qZWN0aW9uVHlwZSwgY3ViZW1hcENvbmZpZykge1xuXHRcdHRoaXMuX3Bob3RvU3BoZXJlUmVuZGVyZXIgPSBuZXcgUGFub0ltYWdlUmVuZGVyZXIoXG5cdFx0XHR0aGlzLl9pbWFnZSxcblx0XHRcdHRoaXMuX3dpZHRoLFxuXHRcdFx0dGhpcy5faGVpZ2h0LFxuXHRcdFx0dGhpcy5faXNWaWRlbyxcblx0XHRcdHtcblx0XHRcdFx0aW5pdGlhbFlhdzogeWF3LFxuXHRcdFx0XHRpbml0aWFsUGl0Y2g6IHBpdGNoLFxuXHRcdFx0XHRmaWVsZE9mVmlldzogZm92LFxuXHRcdFx0XHRpbWFnZVR5cGU6IHByb2plY3Rpb25UeXBlLFxuXHRcdFx0XHRjdWJlbWFwQ29uZmlnXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdHRoaXMuX2JpbmRSZW5kZXJlckhhbmRsZXIoKTtcblxuXHRcdHRoaXMuX3Bob3RvU3BoZXJlUmVuZGVyZXJcblx0XHRcdC5iaW5kVGV4dHVyZSgpXG5cdFx0XHQudGhlbigoKSA9PiB0aGlzLl9hY3RpdmF0ZSgpLCAoKSA9PiB7XG5cdFx0XHRcdHRoaXMuX3RyaWdnZXJFdmVudChFVkVOVFMuRVJST1IsIHtcblx0XHRcdFx0XHR0eXBlOiBFUlJPUl9UWVBFLkZBSUxfQklORF9URVhUVVJFLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IFwiZmFpbGVkIHRvIGJpbmQgdGV4dHVyZVwiXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRfYmluZFJlbmRlcmVySGFuZGxlcigpIHtcblx0XHR0aGlzLl9waG90b1NwaGVyZVJlbmRlcmVyLm9uKFBhbm9JbWFnZVJlbmRlcmVyLkVWRU5UUy5FUlJPUiwgZSA9PiB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoRVZFTlRTLkVSUk9SLCBlKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX3Bob3RvU3BoZXJlUmVuZGVyZXIub24oUGFub0ltYWdlUmVuZGVyZXIuRVZFTlRTLlJFTkRFUklOR19DT05URVhUX0xPU1QsIGUgPT4ge1xuXHRcdFx0dGhpcy5fZGVhY3RpdmF0ZSgpO1xuXHRcdFx0dGhpcy50cmlnZ2VyKEVWRU5UUy5FUlJPUiwge1xuXHRcdFx0XHR0eXBlOiBFUlJPUl9UWVBFLlJFTkRFUklOR19DT05URVhUX0xPU1QsXG5cdFx0XHRcdG1lc3NhZ2U6IFwid2ViZ2wgcmVuZGVyaW5nIGNvbnRleHQgbG9zdFwiXG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cdF9pbml0WWF3UGl0Y2hDb250cm9sKHlhd1BpdGNoQ29uZmlnKSB7XG5cdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sID0gbmV3IFlhd1BpdGNoQ29udHJvbCh5YXdQaXRjaENvbmZpZyk7XG5cblx0XHR0aGlzLl95YXdQaXRjaENvbnRyb2wub24oRVZFTlRTLkFOSU1BVElPTl9FTkQsIGUgPT4ge1xuXHRcdFx0dGhpcy5fdHJpZ2dlckV2ZW50KEVWRU5UUy5BTklNQVRJT05fRU5ELCBlKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX3lhd1BpdGNoQ29udHJvbC5vbihcImNoYW5nZVwiLCBlID0+IHtcblx0XHRcdHRoaXMuX3lhdyA9IGUueWF3O1xuXHRcdFx0dGhpcy5fcGl0Y2ggPSBlLnBpdGNoO1xuXHRcdFx0dGhpcy5fZm92ID0gZS5mb3Y7XG5cdFx0XHR0aGlzLl9xdWF0ZXJuaW9uID0gZS5xdWF0ZXJuaW9uO1xuXG5cdFx0XHR0aGlzLl90cmlnZ2VyRXZlbnQoRVZFTlRTLlZJRVdfQ0hBTkdFLCBlKTtcblx0XHR9KTtcblx0fVxuXG5cdF90cmlnZ2VyRXZlbnQobmFtZSwgcGFyYW0pIHtcblx0XHRjb25zdCBldnQgPSBwYXJhbSB8fCB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEV2ZW50cyB0aGF0IGlzIGZpcmVkIHdoZW4gZXJyb3Igb2NjdXJzXG5cdFx0ICogQGtvIOyXkOufrCDrsJzsg50g7IucIOuwnOyDne2VmOuKlCDsnbTrsqTtirhcblx0XHQgKiBAbmFtZSBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjZXJyb3Jcblx0XHQgKiBAZXZlbnRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gVGhlIG9iamVjdCBvZiBkYXRhIHRvIGJlIHNlbnQgdG8gYW4gZXZlbnQgPGtvPuydtOuypO2KuOyXkCDsoITri6zrkJjripQg642w7J207YSwIOqwneyytDwva28+XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtLnR5cGUgRXJyb3IgdHlwZVxuXHRcdCAqIFx0XHQxMDogSU5WQUxJRF9ERVZJQ0U6IFVuc3VwcG9ydGVkIGRldmljZVxuXHRcdCAqIFx0XHQxMTogTk9fV0VCR0w6IFdlYmdsIG5vdCBzdXBwb3J0XG5cdFx0ICogXHRcdDEyLCBGQUlMX0lNQUdFX0xPQUQ6IEZhaWxlZCB0byBsb2FkIGltYWdlXG5cdFx0ICogXHRcdDEzOiBGQUlMX0JJTkRfVEVYVFVSRTogRmFpbGVkIHRvIGJpbmQgdGV4dHVyZVxuXHRcdCAqIFx0XHQxNDogSU5WQUxJRF9SRVNPVVJDRTogT25seSBvbmUgcmVzb3VyY2UoaW1hZ2Ugb3IgdmlkZW8pIHNob3VsZCBiZSBzcGVjaWZpZWRcblx0XHQgKiBcdFx0MTU6IFJFTkRFUklOR19DT05URVhUX0xPU1Q6IFdlYkdMIGNvbnRleHQgbG9zdCBvY2N1cnJlZFxuXHRcdCAqIDxrbz7sl5Drn6wg7KKF66WYXG5cdFx0ICogXHRcdDEwOiBJTlZBTElEX0RFVklDRTog66+47KeA7JuQIOq4sOq4sFxuXHRcdCAqIFx0XHQxMTogTk9fV0VCR0w6IFdFQkdMIOuvuOyngOybkFxuXHRcdCAqIFx0XHQxMiwgRkFJTF9JTUFHRV9MT0FEOiDsnbTrr7jsp4Ag66Gc65OcIOyLpO2MqFxuXHRcdCAqIFx0XHQxMzogRkFJTF9CSU5EX1RFWFRVUkU6IO2FjeyKpOyzkCDrsJTsnbjrlKkg7Iuk7YyoXG5cdFx0ICogXHRcdDE0OiBJTlZBTElEX1JFU09VUkNFOiDrpqzshozsiqQg7KeA7KCVIOyYpOulmCAoaW1hZ2Ug7Zi57J2AIHZpZGVvIOykkSDtlZjrgpjrp4wg7KeA7KCV65CY7Ja07JW8IO2VqClcblx0XHQgKiBcdFx0MTU6IFJFTkRFUklOR19DT05URVhUX0xPU1Q6IFdlYkdMIGNvbnRleHQgbG9zdCDrsJzsg51cblx0XHQgKiA8L2tvPlxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbS5tZXNzYWdlIEVycm9yIG1lc3NhZ2UgPGtvPuyXkOufrCDrqZTsi5zsp4A8L2tvPlxuXHRcdCAqIEBzZWUge0BsaW5rIGVnLnZpZXczNjAuUGFub1ZpZXdlci5FUlJPUl9UWVBFfVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICpcblx0XHQgKiB2aXdlci5vbih7XG5cdFx0ICpcdFwiZXJyb3JcIiA6IGZ1bmN0aW9uKGV2dCkge1xuXHRcdCAqXHRcdC8vIGV2dC50eXBlID09PSAxM1xuXHRcdCAqXHRcdC8vIGV2dC5tZXNzYWdlID09PSBcImZhaWxlZCB0byBiaW5kIHRleHR1cmVcIlxuXHRcdCAqIH0pO1xuXHRcdCAqXG5cdFx0ICogLy8gY29uc3RhbnQgY2FuIGJlIHVzZWRcblx0XHQgKiB2aXdlci5vbih7XG5cdFx0ICpcdGVnLnZpZXczNjAuUGFub1ZpZXdlci5FVkVOVFMuRVJST1IgOiBmdW5jdGlvbihldnQpIHtcblx0XHQgKlx0XHQvLyBldnQudHlwZSA9PT0gZWcudmlldzM2MC5QYW5vVmlld2VyLkVSUk9SX1RZUEUuRkFJTF9CSU5EX1RFWFRVUkVcblx0XHQgKlx0XHQvLyBldnQubWVzc2FnZSA9PT0gXCJmYWlsZWQgdG8gYmluZCB0ZXh0dXJlXCJcblx0XHQgKiB9KTtcblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIEV2ZW50cyB0aGF0IGlzIGZpcmVkIHdoZW4gUGFub1ZpZXdlciBpcyByZWFkeSB0byBnby5cblx0XHQgKiBAa28gUGFub1ZpZXdlciDqsIAg7KSA67mE65CcIOyDge2DnOyXkCDrsJzsg53tlZjripQg7J2067Kk7Yq4XG5cdFx0ICogQG5hbWUgZWcudmlldzM2MC5QYW5vVmlld2VyI3JlYWR5XG5cdFx0ICogQGV2ZW50XG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqXG5cdFx0ICogdml3ZXIub24oe1xuXHRcdCAqXHRcInJlYWR5XCIgOiBmdW5jdGlvbihldnQpIHtcblx0XHQgKlx0XHQvLyBQYW5vVmlld2VyIGlzIHJlYWR5IHRvIHNob3cgaW1hZ2UgYW5kIGhhbmRsZSB1c2VyIGludGVyYWN0aW9uLlxuXHRcdCAqIH0pO1xuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogRXZlbnRzIHRoYXQgaXMgZmlyZWQgd2hlbiBkaXJlY3Rpb24gb3IgZm92IGlzIGNoYW5nZWQuXG5cdFx0ICogQGtvIFBhbm9WaWV3ZXIg7JeQ7IScIOuwlOudvOuztOqzoCDsnojripQg67Cp7Zal7J2064KYIEZPVijtmZTqsIEp6rCAIOuzgOqyveuQmOyXiOydhOuVjCDrsJzsg53tlZjripQg7J2067Kk7Yq4XG5cdFx0ICogQG5hbWUgZWcudmlldzM2MC5QYW5vVmlld2VyI3ZpZXdDaGFuZ2Vcblx0XHQgKiBAZXZlbnRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gVGhlIG9iamVjdCBvZiBkYXRhIHRvIGJlIHNlbnQgdG8gYW4gZXZlbnQgPGtvPuydtOuypO2KuOyXkCDsoITri6zrkJjripQg642w7J207YSwIOqwneyytDwva28+XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtLnlhdyB5YXc8a28+eWF3PC9rbz5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gcGFyYW0ucGl0Y2ggcGl0Y2ggPGtvPnBpdGNoPC9rbz5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gcGFyYW0uZm92IEZpZWxkIG9mIHZpZXcgKGZvdikgPGtvPu2ZlOqwgTwva28+XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKlxuXHRcdCAqIHZpd2VyLm9uKHtcblx0XHQgKlx0XCJ2aWV3Q2hhbmdlXCIgOiBmdW5jdGlvbihldnQpIHtcblx0XHQgKlx0XHQvL2V2dC55YXcsIGV2dC5waXRjaCwgZXZ0LmZvdiBpcyBhdmFpbGFibGUuXG5cdFx0ICogfSk7XG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiBFdmVudHMgdGhhdCBpcyBmaXJlZCB3aGVuIGFuaW1hdGlvbiB3aGljaCBpcyB0cmlnZ2VyZWQgYnkgaW5lcnRpYSBpcyBlbmRlZC5cblx0XHQgKiBAa28g6rSA7ISx7JeQIOydmO2VnCDslaDri4jrqZTsnbTshZgg64+Z7J6R7J20IOyZhOujjOuQmOyXiOydhOuVjCDrsJzsg53tlZjripQg7J2067Kk7Yq4XG5cdFx0ICogQG5hbWUgZWcudmlldzM2MC5QYW5vVmlld2VyI2FuaW1hdGlvbkVuZFxuXHRcdCAqIEBldmVudFxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICpcblx0XHQgKiB2aXdlci5vbih7XG5cdFx0ICpcdFwiYW5pbWF0aW9uRW5kXCIgOiBmdW5jdGlvbihldnQpIHtcblx0XHQgKlx0XHQvLyBhbmltYXRpb24gaXMgZW5kZWQuXG5cdFx0ICogfSk7XG5cdFx0ICovXG5cdFx0cmV0dXJuIHRoaXMudHJpZ2dlcihuYW1lLCBldnQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdoZW4gc2V0IHRydWUsIGVuYWJsZXMgem9vbSB3aXRoIHRoZSB3aGVlbCBvciBwaW5jaCBnZXN0dXJlLiBIb3dldmVyLCBpbiB0aGUgY2FzZSBvZiB0b3VjaCwgcGluY2ggd29ya3Mgb25seSB3aGVuIHRoZSB0b3VjaERpcmVjdGlvbiBzZXR0aW5nIGlzIHtAbGluayBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OLkFMTH0uXG5cdCAqIEBrbyB0cnVlIOuhnCDshKTsoJUg7IucIO2coCDtmLnsnYAg7KeR6riwIOuPmeyekeycvOuhnCDtmZXrjIAv7LaV7IaMIO2VoCDsiJgg7J6I7Iq164uI64ukLiBmYWxzZSDshKTsoJUg7IucIO2ZleuMgC/stpXshowg6riw64ql7J2EIOu5hO2ZnOyEse2ZlCDtlanri4jri6QuIOuLqCwg7YSw7LmY7J24IOqyveyasCB0b3VjaERpcmVjdGlvbiDshKTsoJXsnbQge0BsaW5rIGVnLnZpZXczNjAuUGFub1ZpZXdlci5UT1VDSF9ESVJFQ1RJT04uQUxMfSDsnbgg6rK97Jqw7JeQ66eMIHBpbmNoIOqwgCDrj5nsnpHtlanri4jri6QuXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI3NldFVzZVpvb21cblx0ICogQHBhcmFtIHtCb29sZWFufSB1c2Vab29tXG5cdCAqIEByZXR1cm4ge2VnLnZpZXczNjAuUGFub1ZpZXdlcn0gUGFub1ZpZXdlciBpbnN0YW5jZTxrbz5QYW5vVmlld2VyIOyduOyKpO2EtOyKpDwva28+XG5cdCAqL1xuXHRzZXRVc2Vab29tKHVzZVpvb20pIHtcblx0XHR0eXBlb2YgdXNlWm9vbSAhPT0gXCJib29sZWFuXCIgJiYgdGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcInVzZVpvb21cIiwgdXNlWm9vbSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBXaGVuIHRydWUsIGVuYWJsZXMgdGhlIGtleWJvYXJkIG1vdmUga2V5IGNvbnRyb2w6IGF3c2QsIGFycm93IGtleXNcblx0ICogQGtvIHRydWXsnbTrqbQg7YKk67O065OcIOydtOuPmSDtgqQg7Luo7Yq466Gk7J2EIO2ZnOyEse2ZlO2VqeuLiOuLpC4gKGF3c2QsIO2ZlOyCtO2RnCDtgqQpXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI3NldFVzZUtleWJvYXJkXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlS2V5Ym9hcmRcblx0ICogQHJldHVybiB7ZWcudmlldzM2MC5QYW5vVmlld2VyfSBQYW5vVmlld2VyIGluc3RhbmNlPGtvPlBhbm9WaWV3ZXIg7J247Iqk7YS07IqkPC9rbz5cblx0ICovXG5cdHNldFVzZUtleWJvYXJkKHVzZUtleWJvYXJkKSB7XG5cdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcInVzZUtleWJvYXJkXCIsIHVzZUtleWJvYXJkKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGVzIGNvbnRyb2wgdGhyb3VnaCBkZXZpY2UgbW90aW9uLiAoXCJub25lXCIsIFwieWF3UGl0Y2hcIiwgXCJWUlwiKVxuXHQgKiBAa28g65SU67CU7J207IqkIOybgOyngeyehOydhCDthrXtlZwg7Luo7Yq466Gk7J2EIO2ZnOyEse2ZlCDtlanri4jri6QuIChcIm5vbmVcIiwgXCJ5YXdQaXRjaFwiLCBcIlZSXCIpXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI3NldEd5cm9Nb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBneXJvTW9kZSB7QGxpbmsgZWcudmlldzM2MC5QYW5vVmlld2VyLkdZUk9fTU9ERX1cblx0ICogQHJldHVybiB7ZWcudmlldzM2MC5QYW5vVmlld2VyfSBQYW5vVmlld2VyIGluc3RhbmNlPGtvPlBhbm9WaWV3ZXIg7J247Iqk7YS07IqkPC9rbz5cblx0ICogQGV4YW1wbGVcblx0ICogcGFub1ZpZXdlci5zZXRHeXJvTW9kZShcInlhd1BpdGNoXCIpO1xuXHQgKiAvL2VxdWl2YWxlbnRcblx0ICogcGFub1ZpZXdlci5zZXRHeXJvTW9kZShlZy52aWV3MzYwLlBhbm9WaWV3ZXIuR1lST19NT0RFLllBV1BJVENIKTtcblx0ICovXG5cdHNldEd5cm9Nb2RlKGd5cm9Nb2RlKSB7XG5cdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcImd5cm9Nb2RlXCIsIGd5cm9Nb2RlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIHJhbmdlIG9mIGNvbnRyb2xsYWJsZSBGT1YgdmFsdWVzXG5cdCAqIEBrbyDsoJzslrQg6rCA64ql7ZWcIEZPViDqtazqsITsnYQg7ISk7KCV7ZWp64uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNzZXRGb3ZSYW5nZVxuXHQgKiBAcGFyYW0ge0FycmF5fSByYW5nZVxuXHQgKiBAcmV0dXJuIHtlZy52aWV3MzYwLlBhbm9WaWV3ZXJ9IFBhbm9WaWV3ZXIgaW5zdGFuY2U8a28+UGFub1ZpZXdlciDsnbjsiqTthLTsiqQ8L2tvPlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBwYW5vVmlld2VyLnNldEZvdlJhbmdlKFs1MCwgOTBdKTtcblx0ICovXG5cdHNldEZvdlJhbmdlKHJhbmdlKSB7XG5cdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcImZvdlJhbmdlXCIsIHJhbmdlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXR0aW5nIHRoZSByYW5nZSBvZiBjb250cm9sbGFibGUgRk9WIHZhbHVlc1xuXHQgKiBAa28g7KCc7Ja0IOqwgOuKpe2VnCBGT1Yg6rWs6rCE7J2EIOuwmO2ZmO2VqeuLiOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjZ2V0Rm92UmFuZ2Vcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqIEBleGFtcGxlXG5cdCAqIHZhciByYW5nZSA9IHBhbm9WaWV3ZXIuZ2V0Rm92UmFuZ2UoKTsgLy9bNTAsIDkwXVxuXHQgKi9cblx0Z2V0Rm92UmFuZ2UoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3lhd1BpdGNoQ29udHJvbC5vcHRpb24oXCJmb3ZSYW5nZVwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgc2l6ZSBvZiBjYW52YXMgZWxlbWVudCBieSBpdCdzIGNvbnRhaW5lciBlbGVtZW50J3Mgb3Igc3BlY2lmaWVkIHNpemUuIElmIHNpemUgaXMgbm90IHNwZWNpZmllZCwgdGhlIHNpemUgb2YgdGhlIGNvbnRhaW5lciBhcmVhIGlzIG9idGFpbmVkIGFuZCB1cGRhdGVkIHRvIHRoYXQgc2l6ZS5cblx0ICogQGtvIOy6lOuyhOyKpCDsl5jrpqzrqLztirjsnZgg7YGs6riw66W8IOy7qO2FjOydtOuEiCDsl5jrpqzrqLztirjsnZgg7YGs6riw64KYIOyngOygleuQnCDtgazquLDroZwg7JeF642w7J207Yq47ZWp64uI64ukLiDrp4zslb0gc2l6ZSDqsIAg7KeA7KCV65CY7KeAIOyViuycvOuptCDsu6jthYzsnbTrhIgg7JiB7Jet7J2YIO2BrOq4sOulvCDslrvslrTsmYAg7ZW064u5IO2BrOq4sOuhnCDqsLHsi6Dtlanri4jri6QuXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI3VwZGF0ZVZpZXdwb3J0RGltZW5zaW9uc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gW3NpemVdXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2l6ZS53aWR0aD13aWR0aCBvZiBjb250YWluZXJdXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2l6ZS5oZWlnaHQ9aGVpZ2h0IG9mIGNvbnRhaW5lcl1cblx0ICogQHJldHVybiB7ZWcudmlldzM2MC5QYW5vVmlld2VyfSBQYW5vVmlld2VyIGluc3RhbmNlPGtvPlBhbm9WaWV3ZXIg7J247Iqk7YS07IqkPC9rbz5cblx0ICovXG5cdHVwZGF0ZVZpZXdwb3J0RGltZW5zaW9ucyhzaXplKSB7XG5cdFx0aWYgKCF0aGlzLl9pc1JlYWR5KSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0dGhpcy5fd2lkdGggPSAoc2l6ZSAmJiBzaXplLndpZHRoKSB8fFxuXHRcdFx0cGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5fY29udGFpbmVyKS53aWR0aCwgMTApO1xuXHRcdHRoaXMuX2hlaWdodCA9IChzaXplICYmIHNpemUuaGVpZ2h0KSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5fY29udGFpbmVyKS5oZWlnaHQsIDEwKTtcblx0XHR0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuX3dpZHRoIC8gdGhpcy5faGVpZ2h0O1xuXHRcdHRoaXMuX3Bob3RvU3BoZXJlUmVuZGVyZXIudXBkYXRlVmlld3BvcnREaW1lbnNpb25zKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuXHRcdHRoaXMuX3lhd1BpdGNoQ29udHJvbC5vcHRpb24oXCJhc3BlY3RSYXRpb1wiLCB0aGlzLl9hc3BlY3RSYXRpbyk7XG5cblx0XHR0aGlzLmxvb2tBdCh7fSwgMCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBjdXJyZW50IGZpZWxkIG9mIHZpZXcoRk9WKVxuXHQgKiBAa28g7ZiE7J6sIGZpZWxkIG9mIHZpZXcoRk9WKSDqsJLsnYQg67CY7ZmY7ZWp64uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNnZXRGb3Zcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKi9cblx0Z2V0Rm92KCkge1xuXHRcdHJldHVybiB0aGlzLl9mb3Y7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBob3Jpem9udGFsIGZpZWxkIG9mIHZpZXcgaW4gZGVncmVlXG5cdCAqL1xuXHRfZ2V0SEZvdigpIHtcblx0XHRyZXR1cm4gZ2xNYXRyaXgudG9EZWdyZWUoXG5cdFx0XHQyICogTWF0aC5hdGFuKHRoaXMuX2FzcGVjdFJhdGlvICogTWF0aC50YW4oZ2xNYXRyaXgudG9SYWRpYW4odGhpcy5fZm92KSAvIDIpKSk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGN1cnJlbnQgeWF3IHZhbHVlXG5cdCAqIEBrbyDtmITsnqwgeWF3IOqwkuydhCDrsJjtmZjtlanri4jri6QuXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI2dldFlhd1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqL1xuXHRnZXRZYXcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3lhdztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgY3VycmVudCBwaXRjaCB2YWx1ZVxuXHQgKiBAa28g7ZiE7J6sIHBpdGNoIOqwkuydhCDrsJjtmZjtlanri4jri6QuXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI2dldFBpdGNoXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICovXG5cdGdldFBpdGNoKCkge1xuXHRcdHJldHVybiB0aGlzLl9waXRjaDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHJhbmdlIG9mIGNvbnRyb2xsYWJsZSBZYXcgdmFsdWVzXG5cdCAqIEBrbyDsu6jtirjroaQg6rCA64ql7ZWcIFlhdyDqtazqsITsnYQg67CY7ZmY7ZWp64uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNnZXRZYXdSYW5nZVxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICovXG5cdGdldFlhd1JhbmdlKCkge1xuXHRcdHJldHVybiB0aGlzLl95YXdQaXRjaENvbnRyb2wub3B0aW9uKFwieWF3UmFuZ2VcIik7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSByYW5nZSBvZiBjb250cm9sbGFibGUgUGl0Y2ggdmFsdWVzXG5cdCAqIEBrbyDsu6jtirjroaQg6rCA64ql7ZWcIFBpdGNoIOq1rOqwhOydhCDqsIDsoLjsmLXri4jri6QuXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI2dldFBpdGNoUmFuZ2Vcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqL1xuXHRnZXRQaXRjaFJhbmdlKCkge1xuXHRcdHJldHVybiB0aGlzLl95YXdQaXRjaENvbnRyb2wub3B0aW9uKFwicGl0Y2hSYW5nZVwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIHJhbmdlIG9mIGNvbnRyb2xsYWJsZSB5YXdcblx0ICogQGtvIOy7qO2KuOuhpCDqsIDriqXtlZwgWWF3IOq1rOqwhOydhCDrsJjtmZjtlanri4jri6QuXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI3NldFlhd1JhbmdlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhbmdlXG5cdCAqIEByZXR1cm4ge2VnLnZpZXczNjAuUGFub1ZpZXdlcn0gUGFub1ZpZXdlciBpbnN0YW5jZTxrbz5QYW5vVmlld2VyIOyduOyKpO2EtOyKpDwva28+XG5cdCAqIEBleGFtcGxlXG5cdCAqIHBhbm9WaWV3ZXIuc2V0WWF3UmFuZ2UoWy05MCwgOTBdKTtcblx0ICovXG5cdHNldFlhd1JhbmdlKHlhd1JhbmdlKSB7XG5cdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcInlhd1JhbmdlXCIsIHlhd1JhbmdlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIHJhbmdlIG9mIGNvbnRyb2xsYWJsZSBQaXRjaCB2YWx1ZXNcblx0ICogQGtvIOy7qO2KuOuhpCDqsIDriqXtlZwgUGl0Y2gg6rWs6rCE7J2EIOyEpOygle2VqeuLiOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjc2V0UGl0Y2hSYW5nZVxuXHQgKiBAcGFyYW0ge0FycmF5fSByYW5nZVxuXHQgKiBAcmV0dXJuIHtlZy52aWV3MzYwLlBhbm9WaWV3ZXJ9IFBhbm9WaWV3ZXIgaW5zdGFuY2U8a28+UGFub1ZpZXdlciDsnbjsiqTthLTsiqQ8L2tvPlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBwYW5vVmlld2VyLnNldFBpdGNoUmFuZ2UoWy00MCwgNDBdKTtcblx0ICovXG5cdHNldFBpdGNoUmFuZ2UocGl0Y2hSYW5nZSkge1xuXHRcdHRoaXMuX3lhd1BpdGNoQ29udHJvbC5vcHRpb24oXCJwaXRjaFJhbmdlXCIsIHBpdGNoUmFuZ2UpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNwZWNpZmllcyB3aGV0aGVyIHRvIGRpc3BsYXkgdGhlIHBvbGUgYnkgbGltaXRpbmcgdGhlIHBpdGNoIHJhbmdlLiBJZiBpdCBpcyB0cnVlLCBwb2xlIHBvaW50IGNhbiBiZSBkaXNwbGF5ZWQuIElmIGl0IGlzIGZhbHNlLCBpdCBpcyBub3QgZGlzcGxheWVkLlxuXHQgKiBAa28gcGl0Y2gg67KU7JyE66W8IOygnO2VnO2VmOyXrCDqt7nsoJDsnYQg7ZGc7Iuc7ZWg7KeA66W8IOyngOygle2VqeuLiOuLpC4gdHJ1ZSDsnbgg6rK97JqwIOq3ueygkOq5jOyngCDtkZztmITtlaAg7IiYIOyeiOycvOupsCBmYWxzZSDsnbgg6rK97JqwIOq3ueygkOq5jOyngCDtkZzsi5ztlZjsp4Ag7JWK7Iq164uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNzZXRTaG93UG9sZVBvaW50XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvd1BvbGVQb2ludFxuXHQgKiBAcmV0dXJuIHtlZy52aWV3MzYwLlBhbm9WaWV3ZXJ9IFBhbm9WaWV3ZXIgaW5zdGFuY2U8a28+UGFub1ZpZXdlciDsnbjsiqTthLTsiqQ8L2tvPlxuXHQgKi9cblx0c2V0U2hvd1BvbGVQb2ludChzaG93UG9sZVBvaW50KSB7XG5cdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcInNob3dQb2xlUG9pbnRcIiwgc2hvd1BvbGVQb2ludCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IGEgbmV3IHZpZXcgYnkgc2V0dGluZyBjYW1lcmEgY29uZmlndXJhdGlvbi4gQW55IHBhcmFtZXRlcnMgbm90IHNwZWNpZmllZCByZW1haW4gdGhlIHNhbWUuXG5cdCAqIEBrbyDsubTrqZTrnbwg7ISk7KCV7J2EIOyngOygle2VmOyXrCDtmZTrqbTsnYQg6rCx7Iug7ZWp64uI64ukLiDsp4DsoJXrkJjsp4Ag7JWK7J2AIOunpOqwnCDrs4DsiJjripQg64+Z7J287ZWY6rKMIOycoOyngOuQqeuLiOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjbG9va0F0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcmllbnRhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gb3JpZW50YXRpb24ueWF3IFRhcmdldCB5YXcgaW4gZGVncmVlIDxrbz7rqqntkZwgeWF3IChkZWdyZWUg64uo7JyEKTwva28+XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBvcmllbnRhdGlvbi5waXRjaCBUYXJnZXQgcGl0Y2ggaW4gZGVncmVlIDxrbz7rqqntkZwgcGl0Y2ggKGRlZ3JlZSDri6jsnIQpPC9rbz5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG9yaWVudGF0aW9uLmZvdiBUYXJnZXQgdmVydGljYWwgZm92IGluIGRlZ3JlZSA8a28+66qp7ZGcIOyImOyngSBmb3YgKGRlZ3JlZSDri6jsnIQpPC9rbz5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgPGtvPuyVoOuLiOuplOydtOyFmCDsi5zqsIQgKOuwgOumrCDstIgpPC9rbz5cblx0ICogQHJldHVybiB7ZWcudmlldzM2MC5QYW5vVmlld2VyfSBQYW5vVmlld2VyIGluc3RhbmNlPGtvPlBhbm9WaWV3ZXIg7J247Iqk7YS07IqkPC9rbz5cblx0ICogQGV4YW1wbGVcblx0ICogLy8gQ2hhbmdlIHRoZSB5YXcgYW5nbGUgKGFic29sdXRlIGFuZ2xlKSB0byAzMCBkZWdyZWVzIGZvciBvbmUgc2Vjb25kLlxuXHQgKiBwYW5vVmlld2VyLmxvb2tBdCh7eWF3OiAzMH0sIDEwMDApO1xuXHQgKi9cblx0bG9va0F0KG9yaWVudGF0aW9uLCBkdXJhdGlvbikge1xuXHRcdGlmICghdGhpcy5faXNSZWFkeSkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Y29uc3QgeWF3ID0gb3JpZW50YXRpb24ueWF3ICE9PSB1bmRlZmluZWQgPyBvcmllbnRhdGlvbi55YXcgOiB0aGlzLl95YXc7XG5cdFx0Y29uc3QgcGl0Y2ggPSBvcmllbnRhdGlvbi5waXRjaCAhPT0gdW5kZWZpbmVkID8gb3JpZW50YXRpb24ucGl0Y2ggOiB0aGlzLl9waXRjaDtcblx0XHRjb25zdCBwaXRjaFJhbmdlID0gdGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcInBpdGNoUmFuZ2VcIik7XG5cdFx0Y29uc3QgdmVydGljYWxBbmdsZU9mSW1hZ2UgPSBwaXRjaFJhbmdlWzFdIC0gcGl0Y2hSYW5nZVswXTtcblx0XHRsZXQgZm92ID0gb3JpZW50YXRpb24uZm92ICE9PSB1bmRlZmluZWQgPyBvcmllbnRhdGlvbi5mb3YgOiB0aGlzLl9mb3Y7XG5cblx0XHRpZiAodmVydGljYWxBbmdsZU9mSW1hZ2UgPCBmb3YpIHtcblx0XHRcdGZvdiA9IHZlcnRpY2FsQW5nbGVPZkltYWdlO1xuXHRcdH1cblxuXHRcdHRoaXMuX3lhd1BpdGNoQ29udHJvbC5sb29rQXQoe3lhdywgcGl0Y2gsIGZvdn0sIGR1cmF0aW9uKTtcblxuXHRcdGlmIChkdXJhdGlvbiA9PT0gMCkge1xuXHRcdFx0dGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlci5yZW5kZXIoeWF3LCBwaXRjaCwgZm92KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRfYWN0aXZhdGUoKSB7XG5cdFx0dGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlci5hdHRhY2hUbyh0aGlzLl9jb250YWluZXIpO1xuXHRcdHRoaXMuX3lhd1BpdGNoQ29udHJvbC5lbmFibGUoKTtcblxuXHRcdHRoaXMudXBkYXRlVmlld3BvcnREaW1lbnNpb25zKCk7XG5cblx0XHR0aGlzLl9pc1JlYWR5ID0gdHJ1ZTtcblx0XHR0aGlzLl90cmlnZ2VyRXZlbnQoRVZFTlRTLlJFQURZKTtcblx0XHR0aGlzLl9zdGFydFJlbmRlcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVyIHRoZSBjYWxsYmFjayBvbiB0aGUgcmFmIHRvIGNhbGwgX3JlbmRlckxvb3AgZXZlcnkgZnJhbWUuXG5cdCAqL1xuXHRfc3RhcnRSZW5kZXIoKSB7XG5cdFx0dGhpcy5fcmVuZGVyTG9vcCA9IHRoaXMuX3JlbmRlckxvb3AuYmluZCh0aGlzKTtcblx0XHR0aGlzLl9yYWZJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fcmVuZGVyTG9vcCk7XG5cdH1cblxuXHRfcmVuZGVyTG9vcCgpIHtcblx0XHRpZiAodGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlcikge1xuXHRcdFx0aWYgKHRoaXMuX3F1YXRlcm5pb24pIHtcblx0XHRcdFx0dGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlci5yZW5kZXJXaXRoUXVhdGVybmlvbih0aGlzLl9xdWF0ZXJuaW9uLCB0aGlzLl9mb3YpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlci5yZW5kZXIodGhpcy5feWF3LCB0aGlzLl9waXRjaCwgdGhpcy5fZm92KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fcmFmSWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckxvb3ApO1xuXHR9XG5cblx0X3N0b3BSZW5kZXIoKSB7XG5cdFx0aWYgKHRoaXMuX3JhZklkKSB7XG5cdFx0XHR3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmFmSWQpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX3JhZklkO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBEZXN0cm95IHdlYmdsIGNvbnRleHQgYW5kIGJsb2NrIHVzZXIgaW50ZXJhY3Rpb24gYW5kIHN0b3AgcmVuZGVyaW5nXG5cdCAqL1xuXHRfZGVhY3RpdmF0ZSgpIHtcblx0XHRpZiAodGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlci5kZXN0cm95KCk7XG5cdFx0XHR0aGlzLl9waG90b1NwaGVyZVJlbmRlcmVyID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5faXNSZWFkeSkge1xuXHRcdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLmRpc2FibGUoKTtcblx0XHRcdHRoaXMuX3N0b3BSZW5kZXIoKTtcblx0XHRcdHRoaXMuX2lzUmVhZHkgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRzdGF0aWMgX2lzVmFsaWRUb3VjaERpcmVjdGlvbihkaXJlY3Rpb24pIHtcblx0XHRyZXR1cm4gZGlyZWN0aW9uID09PSBQYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTi5OT05FIHx8XG5cdFx0XHRkaXJlY3Rpb24gPT09IFBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OLllBVyB8fFxuXHRcdFx0ZGlyZWN0aW9uID09PSBQYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTi5QSVRDSCB8fFxuXHRcdFx0ZGlyZWN0aW9uID09PSBQYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTi5BTEw7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRvdWNoIGRpcmVjdGlvbiBieSB3aGljaCB1c2VyIGNhbiBjb250cm9sLlxuXHQgKiBAa28g7IKs7Jqp7J6Q6rCAIOyhsOyekeqwgOuKpe2VnCDthLDsuZgg67Cp7Zal7J2EIOyngOygle2VqeuLiOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjc2V0VG91Y2hEaXJlY3Rpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvbiBvZiB0aGUgdG91Y2guIHtAbGluayBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OfTxrbz7su6jtirjroaQg6rCA64ql7ZWcIOuwqe2WpSB7QGxpbmsgZWcudmlldzM2MC5QYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTn08L2tvPlxuXHQgKiBAcmV0dXJuIHtlZy52aWV3MzYwLlBhbm9WaWV3ZXJ9IFBhbm9WaWV3ZXIgaW5zdGFuY2Vcblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogcGFub1ZpZXdlciA9IG5ldyBQYW5vVmlld2VyKGVsKTtcblx0ICogLy8gTGltaXQgdGhlIHRvdWNoIGRpcmVjdGlvbiB0byB0aGUgeWF3IGRpcmVjdGlvbiBvbmx5LlxuXHQgKiBwYW5vVmlld2VyLnNldFRvdWNoRGlyZWN0aW9uKGVnLnZpZXczNjAuUGFub1ZpZXdlci5UT1VDSF9ESVJFQ1RJT04uWUFXKTtcblx0ICovXG5cdHNldFRvdWNoRGlyZWN0aW9uKGRpcmVjdGlvbikge1xuXHRcdGlmIChQYW5vVmlld2VyLl9pc1ZhbGlkVG91Y2hEaXJlY3Rpb24oZGlyZWN0aW9uKSkge1xuXHRcdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcInRvdWNoRGlyZWN0aW9uXCIsIGRpcmVjdGlvbik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0b3VjaCBkaXJlY3Rpb24gYnkgd2hpY2ggdXNlciBjYW4gY29udHJvbFxuXHQgKiBAa28g7IKs7Jqp7J6Q6rCAIOyhsOyekeqwgOuKpe2VnCDthLDsuZgg67Cp7Zal7J2EIOuwmO2ZmO2VnOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjZ2V0VG91Y2hEaXJlY3Rpb25cblx0ICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb24gb2YgdGhlIHRvdWNoLiB7QGxpbmsgZWcudmlldzM2MC5QYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTn08a28+7Luo7Yq466GkIOqwgOuKpe2VnCDrsKntlqUge0BsaW5rIGVnLnZpZXczNjAuUGFub1ZpZXdlci5UT1VDSF9ESVJFQ1RJT059PC9rbz5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogcGFub1ZpZXdlciA9IG5ldyBQYW5vVmlld2VyKGVsKTtcblx0ICogLy8gUmV0dXJucyB0aGUgY3VycmVudCB0b3VjaCBkaXJlY3Rpb24uXG5cdCAqIHZhciBkaXIgPSBwYW5vVmlld2VyLmdldFRvdWNoRGlyZWN0aW9uKCk7XG5cdCAqL1xuXHRnZXRUb3VjaERpcmVjdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcInRvdWNoRGlyZWN0aW9uXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlc3Ryb3kgdmlld2VyLiBSZW1vdmUgYWxsIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzIGFuZCByZW1vdmUgdmlld2VyIGNhbnZhcy5cblx0ICogQGtvIOu3sOyWtCDsnbjsiqTthLTsiqTrpbwg7ZW07KCc7ZWp64uI64ukLiDrqqjrk6Ag65Ox66Gd65CcIOydtOuypO2KuOumrOyKpOuEiOulvCDsoJzqsbDtlZjqs6Ag67ew7Ja0IOy6lOuyhOyKpOulvCDsgq3soJztlanri4jri6QuXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI2Rlc3Ryb3lcblx0ICogQHJldHVybiB7ZWcudmlldzM2MC5QYW5vVmlld2VyfSBQYW5vVmlld2VyIGluc3RhbmNlPGtvPlBhbm9WaWV3ZXIg7J247Iqk7YS07IqkPC9rbz5cblx0ICovXG5cdGRlc3Ryb3koKSB7XG5cdFx0dGhpcy5fZGVhY3RpdmF0ZSgpO1xuXG5cdFx0aWYgKHRoaXMuX3lhd1BpdGNoQ29udHJvbCkge1xuXHRcdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLmRlc3Ryb3koKTtcblx0XHRcdHRoaXMuX3lhd1BpdGNoQ29udHJvbCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgd2hldGhlciB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBzdXBwb3J0cyB0aGUgV2ViR0xcblx0ICogQGtvIO2YhOyerCDruIzrnbzsmrDsoIAg7ZmY6rK97J20IFdlYkdMIOydhCDsp4Dsm5DtlZjripTsp4Ag7Jes67aA66W8IO2ZleyduO2VqeuLiOuLpC5cblx0ICogQGZ1bmN0aW9uIGlzV2ViR0xBdmFpbGFibGVcblx0ICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBXZWJHTCBzdXBwb3J0IDxrbz5XZWJHTCDsp4Dsm5Dsl6zrtoA8L2tvPlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgaXNXZWJHTEF2YWlsYWJsZSgpIHtcblx0XHRyZXR1cm4gV2ViR0xVdGlscy5pc1dlYkdMQXZhaWxhYmxlKCk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgd2hldGhlciB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBzdXBwb3J0cyB0aGUgZ3lybyBzZW5zb3IuXG5cdCAqIEBrbyDtmITsnqwg67iM65287Jqw7KCAIO2ZmOqyveydtCDsnpDsnbTroZwg7IS87ISc66W8IOyngOybkO2VmOuKlOyngCDsl6zrtoDrpbwg7ZmV7J247ZWp64uI64ukLlxuXHQgKiBAZnVuY3Rpb24gaXNHeXJvU2Vuc29yQXZhaWxhYmxlXG5cdCAqIEBtZW1iZXJvZiBlZy52aWV3MzYwLlBhbm9WaWV3ZXJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gdGFrZSB0aGUgZ3lybyBzZW5zb3IgYXZhaWxhYmlsaXR5IGFzIGFyZ3VtZW50IDxrbz7snpDsnbTroZwg7IS87ISc66W8IOyngOybkO2VmOuKlOyngCDsl6zrtoDrpbwg7J247J6Q66GcIOuwm+uKlCDtlajsiJg8L2tvPlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgaXNHeXJvU2Vuc29yQXZhaWxhYmxlKGNhbGxiYWNrKSB7XG5cdFx0aWYgKCFEZXZpY2VNb3Rpb25FdmVudCkge1xuXHRcdFx0Y2FsbGJhY2sgJiYgY2FsbGJhY2soZmFsc2UpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGxldCBvbkRldmljZU1vdGlvbkNoYW5nZTtcblxuXHRcdGZ1bmN0aW9uIGNoZWNrR3lybygpIHtcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblx0XHRcdFx0b25EZXZpY2VNb3Rpb25DaGFuZ2UgPSBmdW5jdGlvbihkZXZpY2VNb3Rpb24pIHtcblx0XHRcdFx0XHRjb25zdCBpc0d5cm9TZW5zb3JBdmFpbGFibGUgPSAhKGRldmljZU1vdGlvbi5yb3RhdGlvblJhdGUuYWxwaGEgPT0gbnVsbCk7XG5cblx0XHRcdFx0XHRyZXMoaXNHeXJvU2Vuc29yQXZhaWxhYmxlKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW1vdGlvblwiLCBvbkRldmljZU1vdGlvbkNoYW5nZSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0aW1lb3V0KCkge1xuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHJlcyhmYWxzZSksIDEwMDApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0UHJvbWlzZS5yYWNlKFtjaGVja0d5cm8oKSwgdGltZW91dCgpXSkudGhlbihpc0d5cm9TZW5zb3JBdmFpbGFibGUgPT4ge1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkZXZpY2Vtb3Rpb25cIiwgb25EZXZpY2VNb3Rpb25DaGFuZ2UpO1xuXG5cdFx0XHRjYWxsYmFjayAmJiBjYWxsYmFjayhpc0d5cm9TZW5zb3JBdmFpbGFibGUpO1xuXG5cdFx0XHRQYW5vVmlld2VyLmlzR3lyb1NlbnNvckF2YWlsYWJsZSA9IGZ1bmN0aW9uKGZiKSB7XG5cdFx0XHRcdGZiICYmIGZiKGlzR3lyb1NlbnNvckF2YWlsYWJsZSk7XG5cdFx0XHRcdHJldHVybiBpc0d5cm9TZW5zb3JBdmFpbGFibGU7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHR9XG59XG5cblBhbm9WaWV3ZXIuRVJST1JfVFlQRSA9IEVSUk9SX1RZUEU7XG5QYW5vVmlld2VyLkVWRU5UUyA9IEVWRU5UUztcblBhbm9WaWV3ZXIuUFJPSkVDVElPTl9UWVBFID0gUFJPSkVDVElPTl9UWVBFO1xuUGFub1ZpZXdlci5HWVJPX01PREUgPSBHWVJPX01PREU7XG4vLyBJdCBzaG91bGQgYmUgZGVwcmVjYXRlZCFcblBhbm9WaWV3ZXIuUHJvamVjdGlvblR5cGUgPSBQUk9KRUNUSU9OX1RZUEU7XG4vKipcbiAqIENvbnN0YW50IHZhbHVlIGZvciB0b3VjaCBkaXJlY3Rpb25zXG4gKiBAa28g7YSw7LmYIOuwqe2WpeyXkCDrjIDtlZwg7IOB7IiYIOqwki5cbiAqIEBuYW1lc3BhY2VcbiAqIEBuYW1lIFRPVUNIX0RJUkVDVElPTlxuICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlclxuICovXG5QYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTiA9IHtcblx0LyoqXG5cdCAqIENvbnN0YW50IHZhbHVlIGZvciBub25lIGRpcmVjdGlvbi5cblx0ICogQGtvIG5vbmUg67Cp7Zal7JeQIOuMgO2VnCDsg4HsiJgg6rCSLlxuXHQgKiBAbmFtZSBOT05FXG5cdCAqIEBtZW1iZXJvZiBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OXG5cdCAqIEBjb25zdGFudFxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAxXG5cdCAqL1xuXHROT05FOiBZYXdQaXRjaENvbnRyb2wuVE9VQ0hfRElSRUNUSU9OX05PTkUsXG5cdC8qKlxuXHQgKiBDb25zdGFudCB2YWx1ZSBmb3IgaG9yaXpvbnRhbCh5YXcpIGRpcmVjdGlvbi5cblx0ICogQGtvIGhvcml6b250YWwoeWF3KSDrsKntlqXsl5Ag64yA7ZWcIOyDgeyImCDqsJIuXG5cdCAqIEBuYW1lIFlBV1xuXHQgKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTlxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgNlxuXHQgKi9cblx0WUFXOiBZYXdQaXRjaENvbnRyb2wuVE9VQ0hfRElSRUNUSU9OX1lBVyxcblx0LyoqXG5cdCAqIENvbnN0YW50IHZhbHVlIGZvciB2ZXJ0aWNhbCBkaXJlY3Rpb24uXG5cdCAqIEBrbyB2ZXJ0aWNhbChwaXRjaCkg67Cp7Zal7JeQIOuMgO2VnCDsg4HsiJgg6rCSLlxuXHQgKiBAbmFtZSBQSVRDSFxuXHQgKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTlxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgMjRcblx0ICovXG5cdFBJVENIOiBZYXdQaXRjaENvbnRyb2wuVE9VQ0hfRElSRUNUSU9OX1BJVENILFxuXHQvKipcblx0ICogQ29uc3RhbnQgdmFsdWUgZm9yIGFsbCBkaXJlY3Rpb24uXG5cdCAqIEBrbyBhbGwg67Cp7Zal7JeQIOuMgO2VnCDsg4HsiJgg6rCSLlxuXHQgKiBAbmFtZSBBTExcblx0ICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlci5UT1VDSF9ESVJFQ1RJT05cblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDMwXG5cdCAqL1xuXHRBTEw6IFlhd1BpdGNoQ29udHJvbC5UT1VDSF9ESVJFQ1RJT05fQUxMXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1Bhbm9WaWV3ZXIvUGFub1ZpZXdlci5qcyIsImNvbnN0IHdpbiA9IHdpbmRvdztcblxuZXhwb3J0IHt3aW4gYXMgd2luZG93fTtcbmV4cG9ydCBjb25zdCBEZXZpY2VNb3Rpb25FdmVudCA9IHdpbi5EZXZpY2VNb3Rpb25FdmVudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9QYW5vVmlld2VyL2Jyb3dzZXIuanMiLCJpbXBvcnQgUGFub1ZpZXdlciBmcm9tIFwiLi9QYW5vVmlld2VyXCI7XG5cbmNvbnN0IFZFUlNJT04gPSBcIjMuMC4wLXJjXCI7XG5cbmV4cG9ydCB7XG5cdFBhbm9WaWV3ZXIsXG5cdFZFUlNJT05cbn07XG5cblBhbm9WaWV3ZXIuVkVSU0lPTiA9IFZFUlNJT047XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvUGFub1ZpZXdlci9pbmRleC5qcyIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIkBlZ2pzL2NvbXBvbmVudFwiO1xuaW1wb3J0IEF4ZXMsIHtQYW5JbnB1dH0gZnJvbSBcIkBlZ2pzL2F4ZXNcIjtcbmltcG9ydCBTcHJpdGVJbWFnZSBmcm9tIFwiLi9TcHJpdGVJbWFnZVwiO1xuXG5jb25zdCBERUZBVUxUX1BBTl9TQ0FMRSA9IDAuMjE7XG5cbi8qKlxuICogQGNsYXNzIGVnLnZpZXczNjAuU3BpblZpZXdlclxuICogQGNsYXNzZGVzYyBBIG1vZHVsZSB1c2VkIHRvIGRpc3BsYXlzIGVhY2ggaW1hZ2Ugc2VxdWVudGlhbGx5IGFjY29yZGluZyB0byB0aGUgZGlyZWN0aW9uIG9mIHRoZSB1c2VyJ3MgdG91Y2ggbW92ZW1lbnQgKGxlZnQgLyByaWdodCkgb2YgdGhlIHNwcml0ZSBpbWFnZSB0aGF0IGlzIGNvbGxlY3RlZCBieSByb3RhdGluZyB0aGUgb2JqZWN0LlxuICogQGtvIOusvOyytCDso7zsnITrpbwg7ZqM7KCE7ZWY7JesIOy0rOyYge2VnCDsnbTrr7jsp4Drk6TsnYQg66qo7J2AIOyKpO2UhOudvOydtO2KuCDsnbTrr7jsp4Drpbwg7IKs7Jqp7J6Q7J2YIO2EsOy5mCDsnbTrj5kg67Cp7ZalKOyijCAvIOyasCkg7JeQIOuUsOudvCDqsIEg7J2066+47KeA65Ok7J2EIOyInOywqOyggeycvOuhnCDrs7Tsl6zso7zripQg7Lu07Y+s64SM7Yq47J6F64uI64ukLlxuICogQGV4dGVuZHMgZWcuQ29tcG9uZW50XG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBzaG93IHRoZSBpbWFnZSA8a28+7J2066+47KeA66W8IOuztOyXrOykhCDrjIDsg4Eg7JqU7IaMPC9rbz5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb24gb2JqZWN0PGtvPu2MjOudvOuvuO2EsCDqsJ3ssrQ8L2tvPlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuaW1hZ2VVcmwgVGhlIHVybCBvZiB0aGUgc3ByaXRlIGltYWdlIDxrbz7siqTtlITrnbzsnbTtirgg7J2066+47KeA7J2YIHVybDwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucm93Q291bnQ9MV0gTnVtYmVyIG9mIGhvcml6b250YWwgZnJhbWVzIGluIHRoZSBzcHJpdGUgaW1hZ2UgPGtvPuyKpO2UhOudvOydtO2KuCDsnbTrr7jsp4DsnZgg6rCA66GcIO2UhOugiOyehCDqsK/siJg8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbENvdW50PTFdIE51bWJlciBvZiB2ZXJ0aWNhbCBmcmFtZXMgaW4gdGhlIHNwcml0ZSBpbWFnZSA8a28+7Iqk7ZSE65287J207Yq4IOydtOuvuOyngOydmCDshLjroZwg7ZSE66CI7J6EIOqwr+yImDwva28+XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtvcHRpb25zLndpZHRoPVwiYXV0b1wiXSBUaGUgd2lkdGggb2YgdGhlIHRhcmdldCBlbGVtZW50IHRvIHNob3cgdGhlIGltYWdlIDxrbz7snbTrr7jsp4Drpbwg67O07Jes7KSEIOuMgOyDgSDsmpTshozsnZgg64SI67mEPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW29wdGlvbnMuaGVpZ2h0PVwiYXV0b1wiXSBUaGUgaGVpZ2h0IG9mIHRoZSB0YXJnZXQgZWxlbWVudCB0byBzaG93IHRoZSBpbWFnZSA8a28+7J2066+47KeA66W8IOuztOyXrOykhCDrjIDsg4Eg7JqU7IaM7J2YIOuGkuydtDwva28+XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9IZWlnaHQ9dHJ1ZV0gV2hldGhlciB0byBhdXRvbWF0aWNhbGx5IHNldCB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZSBhcmVhIHRvIG1hdGNoIHRoZSBvcmlnaW5hbCBpbWFnZSdzIHByb3BvcnRpb24gPGtvPuybkOuzuCDsnbTrr7jsp4Ag67mE7Jyo7JeQIOunnuqyjCDsnbTrr7jsp4Ag7JiB7Jet7J2YIOuGkuydtOulvCDsnpDrj5nsnLzroZwg7ISk7KCV7ZWg7KeAIOyXrOu2gDwva28+XG4gKiBAcGFyYW0ge051bWJlcltdfSBbb3B0aW9ucy5jb2xSb3c9WzAsIDBdXSBUaGUgY29sdW1uLCByb3cgY29vcmRpbmF0ZXMgb2YgdGhlIGZpcnN0IGZyYW1lIG9mIHRoZSBzcHJpdGUgaW1hZ2UgKGJhc2VkIG9uIDAgaW5kZXgpIDxrbz4g7Iqk7ZSE65287J207Yq4IOydtOuvuOyngCDspJEg7LKY7J2MIOuztOyXrOykhCDtlITroIjsnoTsnZggKGNvbHVtbiwgcm93KSDsooztkZwgKDAgaW5kZXgg6riw67CYKTwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2NhbGU9MV0gU3BpbiBzY2FsZSAoVGhlIGxhcmdlciB0aGUgc3BpbiwgdGhlIG1vcmUpLjxrbz5TcGluIOuwsOycqCAo7YG0IOyImOuhnSDrjZQg66eO7J20IOybgOyngeyehCk8L2tvPlxuICogQHN1cHBvcnQge1wiaWVcIjogXCI5K1wiLCBcImNoXCIgOiBcImxhdGVzdFwiLCBcImZmXCIgOiBcImxhdGVzdFwiLCAgXCJzZlwiIDogXCJsYXRlc3RcIiwgXCJlZGdlXCIgOiBcImxhdGVzdFwiLCBcImlvc1wiIDogXCI3K1wiLCBcImFuXCIgOiBcIjIuMysgKGV4Y2VwdCAzLngpXCJ9XG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEluaXRpYWxpemUgU3BpblZpZXdlclxuICogdmFyIGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwcm9kdWN0LTM2MFwiKTtcbiAqIHZhciB2aWV3ZXIgPSBuZXcgZWcudmlldzM2MC5TcGluVmlld2VyKGVsLCB7XG4gKiBcdGltYWdlVXJsOiBcIi9pbWcvYmFnMzYwLmpwZ1wiLCAvLyByZXF1aXJlZFxuICogXHRyb3dDb3VudDogMjQgLy9yZXF1aXJlZFxuICogfSk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwaW5WaWV3ZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuX2VsID0gZWxlbWVudDtcblxuXHRcdGNvbnN0IG9wdCA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuXHRcdGNvbnN0IGNvbENvdW50ID0gb3B0LmNvbENvdW50IHx8IDE7XG5cdFx0Y29uc3Qgcm93Q291bnQgPSBvcHQucm93Q291bnQgfHwgMTtcblxuXHRcdHRoaXMuX3NjYWxlID0gKG9wdC5zY2FsZSB8fCAxKTtcblx0XHR0aGlzLl9wYW5TY2FsZSA9IHRoaXMuX3NjYWxlICogREVGQVVMVF9QQU5fU0NBTEU7XG5cblx0XHR0aGlzLl9mcmFtZUNvdW50ID0gY29sQ291bnQgKiByb3dDb3VudDtcblxuXHRcdC8vIEluaXQgU3ByaXRlSW1hZ2Vcblx0XHR0aGlzLl9zcHJpdGVzID0gbmV3IFNwcml0ZUltYWdlKGVsZW1lbnQsIG9wdCkub24oe1xuXHRcdFx0XCJsb2FkXCI6IGV2dCA9PiB7XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBFdmVudHMgdGhhdCBvY2N1ciB3aGVuIGNvbXBvbmVudCBsb2FkaW5nIGlzIGNvbXBsZXRlXG5cdFx0XHRcdCAqIEBrbyDsu7Ttj6zrhIztirgg66Gc65Sp7J20IOyZhOujjOuQmOuptCDrsJzsg53tlZjripQg7J2067Kk7Yq4XG5cdFx0XHRcdCAqIEBuYW1lIGVnLnZpZXczNjAuU3BpblZpZXdlciNsb2FkXG5cdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gVGhlIG9iamVjdCBvZiBkYXRhIHRvIGJlIHNlbnQgdG8gYW4gZXZlbnQgPGtvPuydtOuypO2KuOyXkCDsoITri6zrkJjripQg642w7J207YSwIOqwneyytDwva28+XG5cdFx0XHRcdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmFtLnRhcmdldCBUaGUgdGFyZ2V0IGVsZW1lbnQgZm9yIHdoaWNoIHRvIGRpc3BsYXkgdGhlIGltYWdlIDxrbz7snbTrr7jsp4Drpbwg67O07Jes7KSEIOuMgOyDgSDsl5jrpqzrqLztirg8L2tvPlxuXHRcdFx0XHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJhbS5iZ0VsZW1lbnQgR2VuZXJhdGVkIGJhY2tncm91bmQgaW1hZ2UgZWxlbWVudCA8a28+7IOd7ISx65CcIGJhY2tncm91bmQg7J2066+47KeAIOyXmOumrOuovO2KuDwva28+XG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqIHZpd2VyLm9uKHtcblx0XHRcdFx0ICpcdFwibG9hZFwiIDogZnVuY3Rpb24oZXZ0KSB7XG5cdFx0XHRcdCAqXHRcdHRoaXMuc3BpbkJ5KHthbmdsZTogMzYwLCBkdXJhdGlvbjogMzAwfSk7XG5cdFx0XHRcdCAqXHR9XG5cdFx0XHRcdCAqIH0pO1xuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhpcy50cmlnZ2VyKFwibG9hZFwiLCBldnQpO1xuXHRcdFx0fSxcblx0XHRcdFwiaW1hZ2VFcnJvclwiOiBldnQgPT4ge1xuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogQW4gZXZlbnQgdGhhdCBvY2N1cnMgd2hlbiB0aGUgaW1hZ2UgaW5kZXggaXMgY2hhbmdlZCBieSB0aGUgdXNlcidzIGxlZnQgLyByaWdodCBwYW5uaW5nXG5cdFx0XHRcdCAqIEBrbyDsgqzsmqnsnpDsnZgg7KKM7JqwIFBhbm5pbmcg7JeQIOydmO2VtCDsnbTrr7jsp4Ag7J24642x7Iqk6rCAIOuzgOqyveuQmOyXiOydhOuVjCDrsJzsg53tlZjripQg7J2067Kk7Yq4XG5cdFx0XHRcdCAqIEBuYW1lIGVnLnZpZXczNjAuU3BpblZpZXdlciNpbWFnZUVycm9yXG5cdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gVGhlIG9iamVjdCBvZiBkYXRhIHRvIGJlIHNlbnQgdG8gYW4gZXZlbnQgPGtvPuydtOuypO2KuOyXkCDsoITri6zrkJjripQg642w7J207YSwIOqwneyytDwva28+XG5cdFx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbS5pbWFnZVVybCBVc2VyLXNwZWNpZmllZCBpbWFnZSBVUkwgPGtvPuyCrOyaqeyekOqwgCDsp4DsoJXtlZwg7J2066+47KeAIFVSTDwva28+XG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqIHZpZXdlci5vbih7XG5cdFx0XHRcdCAqXHRcImltYWdlRXJyb3JcIiA6IGZ1bmN0aW9uKGV2dCkge1xuXHRcdFx0XHQgKlx0XHQvLyBFcnJvciBoYW5kbGluZ1xuXHRcdFx0XHQgKlx0XHRjb25zb2xlLmxvZyhlLmltYWdlVXJsKTtcblx0XHRcdFx0ICpcdH1cblx0XHRcdFx0ICogfSk7XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJpbWFnZUVycm9yXCIsIHtcblx0XHRcdFx0XHRpbWFnZVVybDogZXZ0LmltYWdlVXJsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gSW5pdCBBeGVzXG5cdFx0dGhpcy5fcGFuSW5wdXQgPSBuZXcgUGFuSW5wdXQodGhpcy5fZWwsIHtcblx0XHRcdHNjYWxlOiBbdGhpcy5fcGFuU2NhbGUsIHRoaXMuX3BhblNjYWxlXVxuXHRcdH0pO1xuXHRcdHRoaXMuX2F4ZXMgPSBuZXcgQXhlcyh7XG5cdFx0XHRhbmdsZToge1xuXHRcdFx0XHRyYW5nZTogWzAsIDM1OV0sXG5cdFx0XHRcdGNpcmN1bGFyOiB0cnVlXG5cdFx0XHR9XG5cdFx0fSkub24oe1xuXHRcdFx0XCJjaGFuZ2VcIjogZXZ0ID0+IHtcblx0XHRcdFx0Y29uc3QgY3VyciA9IE1hdGguZmxvb3IoZXZ0LnBvcy5hbmdsZSAvICgzNjAgLyB0aGlzLl9mcmFtZUNvdW50KSk7XG5cdFx0XHRcdGNvbnN0IGZyYW1lSW5kZXggPSB0aGlzLl9mcmFtZUNvdW50IC0gY3VyciAtIDE7XG5cblx0XHRcdFx0dGhpcy5fc3ByaXRlcy5zZXRGcmFtZUluZGV4KGZyYW1lSW5kZXgpO1xuXG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBBbiBldmVudCB0aGF0IG9jY3VycyB3aGVuIHRoZSBpbWFnZSBpbmRleCBpcyBjaGFuZ2VkIGJ5IHRoZSB1c2VyJ3MgbGVmdCAvIHJpZ2h0IHBhbm5pbmdcblx0XHRcdFx0ICogQGtvIOyCrOyaqeyekOydmCDsoozsmrAgUGFubmluZyDsl5Ag7J2Y7ZW0IOydtOuvuOyngCDsnbjrjbHsiqTqsIAg67OA6rK965CY7JeI7J2E65WMIOuwnOyDne2VmOuKlCDsnbTrsqTtirhcblx0XHRcdFx0ICogQG5hbWUgZWcudmlldzM2MC5TcGluVmlld2VyI2NoYW5nZVxuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIFRoZSBvYmplY3Qgb2YgZGF0YSB0byBiZSBzZW50IHRvIGFuIGV2ZW50IDxrbz7snbTrsqTtirjsl5Ag7KCE64us65CY64qUIOuNsOydtO2EsCDqsJ3ssrQ8L2tvPlxuXHRcdFx0XHQgKiBAcGFyYW0ge051bWJlcltdfSBwYXJhbS5jb2xSb3cgQ29sdW1uLCByb3cgb2YgdGhlIGZyYW1lIGluIHRoZSBzcHJpdGUgaW1hZ2UgPGtvPuyKpO2UhOudvOydtO2KuCDsnbTrr7jsp4Ag64K0IO2UhOugiOyehOydmCBjb2x1bW4sIHJvdzwva28+XG5cdFx0XHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbS5mcmFtZUluZGV4IEluZGV4IHZhbHVlIHRoYXQgaXMgc2VxdWVudGlhbGx5IGFwcGVuZGVkIGluIFogZGlyZWN0aW9uIGJhc2VkIG9uIGNvbCBhbmQgcm93Ljxrbz5jb2wsIHJvdyDrpbwg6riw67CY7Jy866GcIFog67Cp7Zal7Jy866GcIOyInOywqOyggeycvOuhnCDrtpnsl6zsp4DripQgaW5kZXgg6rCSPC9rbz5cblx0XHRcdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtLmFuZ2xlIFRoZSBhbmdsZSB0aGF0IGlzIGN1cnJlbnRseSBpbnRlcm5hbGx5IGhlbGQgYXQgYW4gYW5nbGUgYmV0d2VlbiAwIGFuZCAzNTkuIChub3QgYSByZWFsIHByb2R1Y3QgYW5nbGUpIDxrbz4wIH4gMzU5IOuylOychOydmCDqsIHrj4TroZwg7ZiE7J6sIOuCtOu2gOyggeycvOuhnCDsnKDsp4DtlZjqs6Ag7J6I64qUIOqwgeuPhCAo7Iuk7KCcIOydtOuvuOyngOydmCDqsIHrj4TqsIAg7JWE64uYKTwva28+XG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqIHZpd2VyLm9uKHtcblx0XHRcdFx0ICpcdFwiY2hhbmdlXCIgOiBmdW5jdGlvbihldnQpIHtcblx0XHRcdFx0ICpcdFx0Y29uc29sZS5sb2coZXZlbnQuZnJhbWVJbmRleCwgZXZlbnQuY29sUm93LCBldmVudC5hbmdsZSk7ICAgLy8gZXZlbnQuY29sUm93ID0gWzAsIDRdIGV2ZW50LmZyYW1lSW5kZXggPSA0LCBldmVudCA9IDMwXG5cdFx0XHRcdCAqXHR9XG5cdFx0XHRcdCAqIH0pO1xuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhpcy50cmlnZ2VyKFwiY2hhbmdlXCIsIHtcblx0XHRcdFx0XHRmcmFtZUluZGV4LFxuXHRcdFx0XHRcdGNvbFJvdzogdGhpcy5fc3ByaXRlcy5nZXRDb2xSb3coKSxcblx0XHRcdFx0XHRhbmdsZTogZXZ0LnBvcy5hbmdsZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHRcImFuaW1hdGlvbkVuZFwiOiBldnQgPT4ge1xuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGFuaW1hdGlvbiBlbmRzLlxuXHRcdFx0XHQgKiBAa28g7JeQ64uI66mU7J207IWY7J20IOuBneuCrOydhCDrlYwg67Cc7IOd7ZWY64qUIOydtOuypO2KuFxuXHRcdFx0XHQgKiBAbmFtZSBlZy52aWV3MzYwLlNwaW5WaWV3ZXIjYW5pbWF0aW9uRW5kXG5cdFx0XHRcdCAqIEBldmVudFxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gVGhlIG9iamVjdCBvZiBkYXRhIHRvIGJlIHNlbnQgdG8gYW4gZXZlbnQgPGtvPuydtOuypO2KuOyXkCDsoITri6zrkJjripQg642w7J207YSwIOqwneyytDwva28+XG5cdFx0XHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW0uaXNUcnVzdGVkIHRydWUgaWYgYW4gZXZlbnQgd2FzIGdlbmVyYXRlZCBieSB0aGUgdXNlciBhY3Rpb24sIG9yIGZhbHNlIGlmIGl0IHdhcyBjYXVzZWQgYnkgYSBzY3JpcHQgb3IgQVBJIGNhbGw8a28+7IKs7Jqp7J6Q7J2YIOyVoeyFmOyXkCDsnZjtlbQg7J2067Kk7Yq46rCAIOuwnOyDne2VmOyYgOycvOuptCB0cnVlLCDsiqTtgazrpr3tirjrgpggQVBJ7Zi47Lac7JeQIOydmO2VtCDrsJzsg53tlZjsmIDsnYQg6rK97Jqw7JeQ64qUIGZhbHNl66W8IOuwmO2ZmO2VnOuLpC48L2tvPlxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiB2aXdlci5vbih7XG5cdFx0XHRcdCAqXHRcImFuaW1hdGlvbkVuZFwiIDogZnVuY3Rpb24oZXZ0KSB7XG5cdFx0XHRcdCAqXHRcdC8vIGV2dC5pc1RydXN0ZWQgPT09IHRydWUgb3IgZmFsc2Vcblx0XHRcdFx0ICpcdH1cblx0XHRcdFx0ICogfSk7XG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJhbmltYXRpb25FbmRcIiwge1xuXHRcdFx0XHRcdGlzVHJ1c3RlZDogZXZ0LmlzVHJ1c3RlZFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuX2F4ZXMuY29ubmVjdChcImFuZ2xlXCIsIHRoaXMuX3BhbklucHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgc3BpbiBzY2FsZVxuXHQgKiBAa28gc2NhbGUg7J2EIOyhsOygle2VoCDsiJgg7J6I64qUIO2VqOyImFxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuU3BpblZpZXdlciNzZXRTY2FsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgUm90YXRpb24gbXVsdGlwbGVzIGF0IHNwaW4sIHRoZSBsYXJnZXIgdGhlIHJvdGF0aW9uPGtvPlNwaW4g7IucIO2ajOyghCDrsLDsiJjqsJIsIOy7pOyniCDsiJjroZ0g642UIOunjuydtCDtmozsoIQ8L2tvPlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEluc3RhbmNlIG9mIFNwaW5WaWV3ZXIgPGtvPlNwaW5WaWV3ZXIg7J247Iqk7YS07IqkPC9rbz5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogdmlld2VyLnNldFNjYWxlKDIpOy8vIEl0IG1vdmVzIHR3aWNlIGFzIG11Y2guXG5cdCAqL1xuXHRzZXRTY2FsZShzY2FsZSkge1xuXHRcdGlmIChpc05hTihzY2FsZSkgfHwgc2NhbGUgPCAwKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0aGlzLl9zY2FsZSA9IHNjYWxlO1xuXHRcdHRoaXMuX3BhblNjYWxlID0gc2NhbGUgKiBERUZBVUxUX1BBTl9TQ0FMRTtcblx0XHR0aGlzLl9wYW5JbnB1dC5vcHRpb25zLnNjYWxlID0gW3RoaXMuX3BhblNjYWxlLCB0aGlzLl9wYW5TY2FsZV07XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgc3BpbiBzY2FsZVxuXHQgKiBAa28gc2NhbGUg6rCS7J2EIOuwmO2ZmO2VnOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlNwaW5WaWV3ZXIjZ2V0U2NhbGVcblx0ICpcblx0ICogQHJldHVybiB7TnVtYmVyfSBSb3RhdGlvbiBtdWx0aXBsZXMgYXQgc3BpbiwgdGhlIGxhcmdlciB0aGUgcm90YXRpb248a28+U3BpbiDsi5wg7ZqM7KCEIOuwsOyImOqwkiwg7Luk7KeIIOyImOuhnSDrjZQg66eO7J20IO2ajOyghDwva28+XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIHZpZXdlci5nZXRTY2FsZSgpOy8vIEl0IHJldHVybnMgbnVtYmVyXG5cdCAqL1xuXHRnZXRTY2FsZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2NhbGU7XG5cdH1cblxuXHQvKipcblx0ICogSXQgZ2l2ZXMgdGhlIGVmZmVjdCBvZiByb3RhdGluZyBmb3IgYSBjZXJ0YWluIGR1cmF0aW9uIGJ5IHRoZSBzcGVjaWZpZWQgYW5nbGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgcm90YXRpb24gYW5nbGUuXG5cdCAqIEBrbyDtmITsnqwg7ZqM7KCEIOqwgeuPhOulvCDquLDspIDsnLzroZwg7KeA7KCV65CcIOqwgeuPhChhbmdsZSnrp4ztgbwg7J287KCVIOyLnOqwhOuPmeyViChkdXJhdGlvbikg7ZqM7KCE7ZWY64qUIO2aqOqzvOulvCDspIDri6QuXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5TcGluVmlld2VyI3NwaW5CeVxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FuZ2xlID0gMF0gYW5nbGU8a28+7IOB64yA7KCBIO2ajOyghCDqsIHrj4Q8L2tvPlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gVGhlIHBhcmFtZXRlciBvYmplY3Q8a28+7YyM652866+47YSwIOqwneyytDwva28+XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW0uZHVyYXRpb24gPSAwXSBkdXJhdGlvbjxrbz7tmozsoITtlaAg7Iuc6rCEIC0g67CA66as7IS47Luo65OcIOuLqOychDwva28+XG5cdCAqXG5cdCAqIEByZXR1cm4ge09iamVjdH0gSW5zdGFuY2Ugb2YgU3BpblZpZXdlciA8a28+U3BpblZpZXdlciDsnbjsiqTthLTsiqQ8L2tvPlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiB2aWV3ZXIuc3BpbkJ5KDcyMCwge2R1cmF0aW9uOiA1MDB9KTtcblx0ICovXG5cdHNwaW5CeShhbmdsZSA9IDAsIHBhcmFtID0ge2R1cmF0aW9uOiAwfSkge1xuXHRcdHRoaXMuX2F4ZXMuc2V0Qnkoe2FuZ2xlfSwgcGFyYW0uZHVyYXRpb24pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEl0IGdpdmVzIHRoZSBlZmZlY3Qgb2Ygcm90YXRpbmcgZm9yIGEgY2VydGFpbiBkdXJhdGlvbiAoZHVyYXRpb24pIGJ5IHRoZSBzcGVjaWZpZWQgYW5nbGUgKGFuZ2xlKS5cblx0ICogQGtvIOyngOygleuQnCDqsIHrj4QoYW5nbGUp66eM7YG8IOydvOyglSDsi5zqsITrj5nslYgoZHVyYXRpb24pIO2ajOyghO2VmOuKlCDtmqjqs7zrpbwg7KSA64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuU3BpblZpZXdlciNzcGluVG9cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthbmdsZSA9IDBdIGFuZ2xlPGtvPu2ajOyghCDqsIHrj4Q8L2tvPlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gVGhlIHBhcmFtZXRlciBvYmplY3Q8a28+7YyM652866+47YSwIOqwneyytDwva28+XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW0uZHVyYXRpb24gPSAwXSBkdXJhdGlvbjxrbz7tmozsoITtlaAg7Iuc6rCEIC0g67CA66as7IS47Luo65OcIOuLqOychDwva28+XG5cdCAqXG5cdCAqIEByZXR1cm4ge09iamVjdH0gSW5zdGFuY2Ugb2YgU3BpblZpZXdlciA8a28+U3BpblZpZXdlciDsnbjsiqTthLTsiqQ8L2tvPlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiB2aWV3ZXIuc3BpblRvKDMwLCB7ZHVyYXRpb246MTAwfSk7XG5cdCAqL1xuXHRzcGluVG8oYW5nbGUgPSAwLCBwYXJhbSA9IHtkdXJhdGlvbjogMH0pIHtcblx0XHR0aGlzLl9heGVzLnNldFRvKHthbmdsZX0sIHBhcmFtLmR1cmF0aW9uKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGN1cnJlbnQgYW5nbGVzXG5cdCAqIEBrbyDsp4DsoJXrkJwg6rCB64+EKGFuZ2xlKeunjO2BvCDsnbzsoJUg7Iuc6rCE64+Z7JWIKGR1cmF0aW9uKSDtmozsoITtlZjripQg7Zqo6rO866W8IOykgOuLpC5cblx0ICpcblx0ICogQHJldHVybiB7TnVtYmVyfSBDdXJyZW50IGFuZ2xlIDxrbz7tmITsnqwg6rCB64+EPC9rbz5cblx0ICovXG5cdGdldEFuZ2xlKCkge1xuXHRcdHJldHVybiB0aGlzLl9heGVzLmdldCgpLmFuZ2xlIHx8IDA7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TcGluVmlld2VyL1NwaW5WaWV3ZXIuanMiLCJpbXBvcnQgU3BpblZpZXdlciBmcm9tIFwiLi9TcGluVmlld2VyXCI7XG5pbXBvcnQgU3ByaXRlSW1hZ2UgZnJvbSBcIi4vU3ByaXRlSW1hZ2VcIjtcblxuY29uc3QgVkVSU0lPTiA9IFwiMy4wLjAtcmNcIjtcblxuZXhwb3J0IHtcblx0U3BpblZpZXdlcixcblx0U3ByaXRlSW1hZ2UsXG5cdFZFUlNJT05cbn07XG5cblNwaW5WaWV3ZXIuVkVSU0lPTiA9IFZFUlNJT047XG5TcHJpdGVJbWFnZS5WRVJTSU9OID0gVkVSU0lPTjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TcGluVmlld2VyL2luZGV4LmpzIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG5pbXBvcnQgRnVzaW9uUG9zZVNlbnNvciBmcm9tIFwiLi9pbnB1dC9GdXNpb25Qb3NlU2Vuc29yXCI7XG5pbXBvcnQgU2NyZWVuUm90YXRpb25BbmdsZSBmcm9tIFwiLi9TY3JlZW5Sb3RhdGlvbkFuZ2xlXCI7XG5pbXBvcnQge3ZlYzMsIGdsTWF0cml4LCBxdWF0fSBmcm9tIFwiLi4vdXRpbHMvbWF0aC11dGlsXCI7XG5cbmNvbnN0IE9SSUdJTl9WRUNUT1IgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMCk7XG5jb25zdCBYX0FYSVNfVkVDVE9SID0gdmVjMy5mcm9tVmFsdWVzKDEsIDAsIDApO1xuY29uc3QgWV9BWElTX1ZFQ1RPUiA9IHZlYzMuZnJvbVZhbHVlcygwLCAxLCAwKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGV2aWNlUXVhdGVybmlvbiBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLl9zY3JlZW5Sb3RhdGlvbkFuZ2xlID0gbmV3IFNjcmVlblJvdGF0aW9uQW5nbGUoKTtcblx0XHR0aGlzLl9mdXNpb25Qb3NlU2Vuc29yID0gbmV3IEZ1c2lvblBvc2VTZW5zb3IoKTtcblx0XHR0aGlzLl9xdWF0ZXJuaW9uID0gcXVhdC5jcmVhdGUoKTtcblxuXHRcdHRoaXMuX2Z1c2lvblBvc2VTZW5zb3IuZW5hYmxlKCk7XG5cdFx0dGhpcy5fZnVzaW9uUG9zZVNlbnNvci5vbihcImNoYW5nZVwiLCBlID0+IHtcblx0XHRcdHRoaXMuX3F1YXRlcm5pb24gPSBlLnF1YXRlcm5pb247XG5cblx0XHRcdHRoaXMudHJpZ2dlcihcImNoYW5nZVwiLCB7aXNUcnVzdGVkOiB0cnVlfSk7XG5cdFx0fSk7XG5cdH1cblxuXHRnZXRDb21iaW5lZFF1YXRlcm5pb24oeWF3LCBwaXRjaCkge1xuXHRcdGNvbnN0IGRldmljZVIgPSB0aGlzLl9zY3JlZW5Sb3RhdGlvbkFuZ2xlLmdldFJhZGlhbigpO1xuXG5cdFx0Ly8gcm90YXRlIHgtYXhpcyBhcm91bmQgei1heGlzIGFib3V0IHNjcmVlbiByb3RhdGlvbiBhbmdsZS5cblx0XHRjb25zdCBwaXRjaEF4aXMgPSB2ZWMzLnJvdGF0ZVoodmVjMy5jcmVhdGUoKSwgWF9BWElTX1ZFQ1RPUiwgT1JJR0lOX1ZFQ1RPUiwgZGV2aWNlUik7XG5cdFx0Y29uc3QgeWF3USA9IHF1YXQuc2V0QXhpc0FuZ2xlKHF1YXQuY3JlYXRlKCksIFlfQVhJU19WRUNUT1IsIGdsTWF0cml4LnRvUmFkaWFuKC15YXcpKTtcblx0XHQvLyByb3RhdGUgcXVhdGVybmlvbiBhcm91bmQgbmV3IHgtYXhpcyBhYm91dCBwaXRjaCBhbmdsZS5cblx0XHRjb25zdCBwaXRjaFEgPSBxdWF0LnNldEF4aXNBbmdsZShxdWF0LmNyZWF0ZSgpLCBwaXRjaEF4aXMsIGdsTWF0cml4LnRvUmFkaWFuKC1waXRjaCkpO1xuXHRcdGNvbnN0IGNvbmogPSBxdWF0LmNvbmp1Z2F0ZShxdWF0LmNyZWF0ZSgpLCB0aGlzLl9xdWF0ZXJuaW9uKTtcblx0XHQvLyBNdWx0aXBseSBwaXRjaCBxdWF0ZXJuaW9uIC0+IGRldmljZSBxdWF0ZXJuaW9uIC0+IHlhdyBxdWF0ZXJuaW9uXG5cdFx0Y29uc3Qgb3V0USA9IHF1YXQubXVsdGlwbHkocXVhdC5jcmVhdGUoKSwgcGl0Y2hRLCBjb25qKTtcblxuXHRcdHF1YXQubXVsdGlwbHkob3V0USwgb3V0USwgeWF3USk7XG5cdFx0cmV0dXJuIG91dFE7XG5cdH1cblxuXHRkZXN0cm95KCkge1xuXHRcdC8vIGRldGFjaCBhbGwgZXZlbnQgaGFuZGxlclxuXHRcdHRoaXMub2ZmKCk7XG5cblx0XHRpZiAodGhpcy5fZnVzaW9uUG9zZVNlbnNvcikge1xuXHRcdFx0dGhpcy5fZnVzaW9uUG9zZVNlbnNvci5vZmYoKTtcblx0XHRcdHRoaXMuX2Z1c2lvblBvc2VTZW5zb3IuZGVzdHJveSgpO1xuXHRcdFx0dGhpcy5fZnVzaW9uUG9zZVNlbnNvciA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3NjcmVlblJvdGF0aW9uQW5nbGUpIHtcblx0XHRcdHRoaXMuX3NjcmVlblJvdGF0aW9uQW5nbGUudW5yZWYoKTtcblx0XHRcdHRoaXMuX3NjcmVlblJvdGF0aW9uQW5nbGUgPSBudWxsO1xuXHRcdH1cblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1lhd1BpdGNoQ29udHJvbC9EZXZpY2VRdWF0ZXJuaW9uLmpzIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG5pbXBvcnQgQXhlcywge1BpbmNoSW5wdXQsIE1vdmVLZXlJbnB1dH0gZnJvbSBcIkBlZ2pzL2F4ZXNcIjtcbmltcG9ydCB7Z2V0Q29tcHV0ZWRTdHlsZSwgU1VQUE9SVF9UT1VDSCwgU1VQUE9SVF9ERVZJQ0VNT1RJT059IGZyb20gXCIuL2Jyb3dzZXJcIjtcbmltcG9ydCBXaGVlbElucHV0IGZyb20gXCIuL2lucHV0L1doZWVsSW5wdXRcIjtcbmltcG9ydCBUaWx0TW90aW9uSW5wdXQgZnJvbSBcIi4vaW5wdXQvVGlsdE1vdGlvbklucHV0XCI7XG5pbXBvcnQgUm90YXRpb25QYW5JbnB1dCBmcm9tIFwiLi9pbnB1dC9Sb3RhdGlvblBhbklucHV0XCI7XG5pbXBvcnQgRGV2aWNlUXVhdGVybmlvbiBmcm9tIFwiLi9EZXZpY2VRdWF0ZXJuaW9uXCI7XG5pbXBvcnQge1xuXHR2ZWMyLFxufSBmcm9tIFwiLi4vdXRpbHMvbWF0aC11dGlsXCI7XG5pbXBvcnQge1xuXHRHWVJPX01PREUsXG5cdFRPVUNIX0RJUkVDVElPTl9ZQVcsXG5cdFRPVUNIX0RJUkVDVElPTl9QSVRDSCxcblx0VE9VQ0hfRElSRUNUSU9OX0FMTCxcblx0TUNfREVDRUxFUkFUSU9OLFxuXHRNQ19NQVhJTVVNX0RVUkFUSU9OLFxuXHRNQ19CSU5EX1NDQUxFLFxuXHRNQVhfRklFTERfT0ZfVklFVyxcblx0UEFOX1NDQUxFLFxuXHRZQVdfUkFOR0VfSEFMRixcblx0UElUQ0hfUkFOR0VfSEFMRixcblx0Q0lSQ1VMQVJfUElUQ0hfUkFOR0VfSEFMRlxufSBmcm9tIFwiLi9jb25zdHNcIjtcblxuY29uc3QgREVGQVVMVF9ZQVdfUkFOR0UgPSBbLVlBV19SQU5HRV9IQUxGLCBZQVdfUkFOR0VfSEFMRl07XG5jb25zdCBERUZBVUxUX1BJVENIX1JBTkdFID0gWy1QSVRDSF9SQU5HRV9IQUxGLCBQSVRDSF9SQU5HRV9IQUxGXTtcbmNvbnN0IENJUkNVTEFSX1BJVENIX1JBTkdFID0gWy1DSVJDVUxBUl9QSVRDSF9SQU5HRV9IQUxGLCBDSVJDVUxBUl9QSVRDSF9SQU5HRV9IQUxGXTtcbi8qKlxuICogQSBtb2R1bGUgdXNlZCB0byBwcm92aWRlIGNvb3JkaW5hdGUgYmFzZWQgb24geWF3L3BpdGNoIG9yaWVudGF0aW9uLiBUaGlzIG1vZHVsZSByZWNlaXZlcyB1c2VyIHRvdWNoIGFjdGlvbiwga2V5Ym9hcmQsIG1vdXNlIGFuZCBkZXZpY2Ugb3JpZW50YXRpb24oaWYgaXQgZXhpc3RzKSBhcyBpbnB1dCwgdGhlbiBjb21iaW5lcyB0aGVtIGFuZCBjb252ZXJ0cyBpdCB0byB5YXcvcGl0Y2ggY29vcmRpbmF0ZXMuXG4gKlxuICogQGFsaWFzIGVnLllhd1BpdGNoQ29udHJvbFxuICogQGV4dGVuZHMgZWcuQ29tcG9uZW50XG4gKlxuICogQHN1cHBvcnQge1wiaWVcIjogXCIxMCtcIiwgXCJjaFwiIDogXCJsYXRlc3RcIiwgXCJmZlwiIDogXCJsYXRlc3RcIiwgIFwic2ZcIiA6IFwibGF0ZXN0XCIsIFwiZWRnZVwiIDogXCJsYXRlc3RcIiwgXCJpb3NcIiA6IFwiNytcIiwgXCJhblwiIDogXCIyLjMrIChleGNlcHQgMy54KVwifVxuICovXG5jb25zdCBZYXdQaXRjaENvbnRyb2wgPSBjbGFzcyBZYXdQaXRjaENvbnRyb2wgZXh0ZW5kcyBDb21wb25lbnQge1xuXHQvKipcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbiBvYmplY3Qgb2YgdGhlIGVnLllhd1BpdGNoIG1vZHVsZVxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9W29wdGlvbnMuZWxlbWVudD1udWxsXSBlbGVtZW50IEEgYmFzZSBlbGVtZW50IGZvciB0aGUgZWcuWWF3UGl0Y2ggbW9kdWxlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy55YXc9MF0gaW5pdGlhbCB5YXcgKGRlZ3JlZSlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBpdGNoPTBdIGluaXRpYWwgcGl0Y2ggKGRlZ3JlZSlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZvdj02NV0gaW5pdGlhbCBmaWVsZCBvZiB2aWV3IChkZWdyZWUpXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvc24uc2hvd1BvbGVQb2ludD10cnVlXSBJbmRpY2F0ZXMgd2hldGhlciBwb2xlIGlzIHNob3duXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlWm9vbT10cnVlXSBJbmRpY2F0ZXMgd2hldGhlciB6b29tIGlzIGF2YWlsYWJsZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVzZUtleWJvYXJkPXRydWVdIEluZGljYXRlcyB3aGV0aGVyIGtleWJvYXJkIGlzIGVuYWJsZWRcblx0ICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZ3lyb01vZGU9eWF3UGl0Y2hdIEVuYWJsZXMgY29udHJvbCB0aHJvdWdoIGRldmljZSBtb3Rpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50b3VjaERpcmVjdGlvbj1UT1VDSF9ESVJFQ1RJT05fQUxMXSBEaXJlY3Rpb24gb2YgdGhlIHRvdWNoIG1vdmVtZW50IChUT1VDSF9ESVJFQ1RJT05fQUxMOiBhbGwsICBUT1VDSF9ESVJFQ1RJT05fWUFXOiBob3Jpem9udGFsLCBUT1VDSF9ESVJFQ1RJT05fUElUQ0g6IHZlcnRpY2FsLCBUT1VDSF9ESVJFQ1RJT05fTk9ORTogbm8gbW92ZSlcblx0ICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMueWF3UmFuZ2U9Wy0xODAsIDE4MF0gUmFuZ2Ugb2YgdmlzaWJsZSB5YXdcblx0ICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMucGl0Y2hSYW5nZT1bLTkwLCA5MF0gUmFuZ2Ugb2YgdmlzaWJsZSBwaXRjaFxuXHQgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5mb3ZSYW5nZT1bMzAsIDExMF0gUmFuZ2Ugb2YgRk9WXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hc3BlY3RSYXRpbz0xXSBBc3BlY3QgUmF0aW9cblx0ICovXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0Y29uc3Qgb3B0ID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0XHRlbGVtZW50OiBudWxsLFxuXHRcdFx0eWF3OiAwLFxuXHRcdFx0cGl0Y2g6IDAsXG5cdFx0XHRmb3Y6IDY1LFxuXHRcdFx0c2hvd1BvbGVQb2ludDogZmFsc2UsXG5cdFx0XHR1c2Vab29tOiB0cnVlLFxuXHRcdFx0dXNlS2V5Ym9hcmQ6IHRydWUsXG5cdFx0XHRneXJvTW9kZTogR1lST19NT0RFLllBV1BJVENILFxuXHRcdFx0dG91Y2hEaXJlY3Rpb246IFRPVUNIX0RJUkVDVElPTl9BTEwsXG5cdFx0XHR5YXdSYW5nZTogREVGQVVMVF9ZQVdfUkFOR0UsXG5cdFx0XHRwaXRjaFJhbmdlOiBERUZBVUxUX1BJVENIX1JBTkdFLFxuXHRcdFx0Zm92UmFuZ2U6IFszMCwgMTEwXSxcblx0XHRcdGFzcGVjdFJhdGlvOiAxLCAvKiBUT0RPOiBOZWVkIE1hbmRhdG9yeT8gKi9cblx0XHR9LCBvcHRpb25zKTtcblxuXHRcdHRoaXMuX2VsZW1lbnQgPSBvcHQuZWxlbWVudDtcblx0XHR0aGlzLl9pbml0aWFsRm92ID0gb3B0LmZvdjtcblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5faXNBbmltYXRpbmcgPSBmYWxzZTtcblx0XHR0aGlzLl9kZXZpY2VRdWF0ZXJuaW9uID0gbnVsbDtcblxuXHRcdHRoaXMuX2luaXRBeGVzKG9wdCk7XG5cdFx0dGhpcy5vcHRpb24ob3B0KTtcblx0fVxuXG5cdF9pbml0QXhlcyhvcHQpIHtcblx0XHRjb25zdCB5UmFuZ2UgPSB0aGlzLl91cGRhdGVZYXdSYW5nZShvcHQueWF3UmFuZ2UsIG9wdC5mb3YsIG9wdC5hc3BlY3RSYXRpbyk7XG5cdFx0Y29uc3QgcFJhbmdlID0gdGhpcy5fdXBkYXRlUGl0Y2hSYW5nZShvcHQucGl0Y2hSYW5nZSwgb3B0LmZvdiwgb3B0LnNob3dQb2xlUG9pbnQpO1xuXHRcdGNvbnN0IHVzZVJvdGF0aW9uID0gb3B0Lmd5cm9Nb2RlID09PSBHWVJPX01PREUuVlI7XG5cblx0XHR0aGlzLmF4ZXNQYW5JbnB1dCA9IG5ldyBSb3RhdGlvblBhbklucHV0KHRoaXMuX2VsZW1lbnQsIHt1c2VSb3RhdGlvbn0pO1xuXHRcdHRoaXMuYXhlc1doZWVsSW5wdXQgPSBuZXcgV2hlZWxJbnB1dCh0aGlzLl9lbGVtZW50LCB7c2NhbGU6IDR9KTtcblx0XHR0aGlzLmF4ZXNUaWx0TW90aW9uSW5wdXQgPSBudWxsO1xuXHRcdHRoaXMuYXhlc1BpbmNoSW5wdXQgPSBTVVBQT1JUX1RPVUNIID8gbmV3IFBpbmNoSW5wdXQodGhpcy5fZWxlbWVudCwge3NjYWxlOiAtMX0pIDogbnVsbDtcblx0XHR0aGlzLmF4ZXNNb3ZlS2V5SW5wdXQgPSBuZXcgTW92ZUtleUlucHV0KHRoaXMuX2VsZW1lbnQsIHtzY2FsZTogWy02LCA2XX0pO1xuXG5cdFx0dGhpcy5heGVzID0gbmV3IEF4ZXMoe1xuXHRcdFx0eWF3OiB7XG5cdFx0XHRcdHJhbmdlOiB5UmFuZ2UsXG5cdFx0XHRcdGNpcmN1bGFyOiBZYXdQaXRjaENvbnRyb2wuaXNDaXJjdWxhcih5UmFuZ2UpLFxuXHRcdFx0XHRib3VuY2U6IFswLCAwXVxuXHRcdFx0fSxcblx0XHRcdHBpdGNoOiB7XG5cdFx0XHRcdHJhbmdlOiBwUmFuZ2UsXG5cdFx0XHRcdGNpcmN1bGFyOiBZYXdQaXRjaENvbnRyb2wuaXNDaXJjdWxhcihwUmFuZ2UpLFxuXHRcdFx0XHRib3VuY2U6IFswLCAwXVxuXHRcdFx0fSxcblx0XHRcdGZvdjoge1xuXHRcdFx0XHRyYW5nZTogb3B0LmZvdlJhbmdlLFxuXHRcdFx0XHRjaXJjdWxhcjogW2ZhbHNlLCBmYWxzZV0sXG5cdFx0XHRcdGJvdW5jZTogWzAsIDBdXG5cdFx0XHR9LFxuXHRcdH0sIHtcblx0XHRcdGRlY2VsZXJhdGlvbjogTUNfREVDRUxFUkFUSU9OLFxuXHRcdFx0bWF4aW11bUR1cmF0aW9uOiBNQ19NQVhJTVVNX0RVUkFUSU9OLFxuXHRcdH0sIHtcblx0XHRcdHlhdzogb3B0Lnlhdyxcblx0XHRcdHBpdGNoOiBvcHQucGl0Y2gsXG5cdFx0XHRmb3Y6IG9wdC5mb3Zcblx0XHR9KVxuXHRcdC5vbih7XG5cdFx0XHRob2xkOiBldnQgPT4ge1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJob2xkXCIsIHtpc1RydXN0ZWQ6IGV2dC5pc1RydXN0ZWR9KTtcblx0XHRcdH0sXG5cdFx0XHRjaGFuZ2U6IGV2dCA9PiB7XG5cdFx0XHRcdGlmIChldnQuZGVsdGEuZm92ICE9PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fc2V0UGFuU2NhbGUoZXZ0LnBvcy5mb3YpO1xuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZUNvbnRyb2xTY2FsZShldnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3RyaWdnZXJDaGFuZ2UoZXZ0KTtcblx0XHRcdH0sXG5cdFx0XHRyZWxlYXNlOiBldnQgPT4ge1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyQ2hhbmdlKGV2dCk7XG5cdFx0XHR9LFxuXHRcdFx0YW5pbWF0aW9uU3RhcnQ6IGV2dCA9PiB7XG5cdFx0XHR9LFxuXHRcdFx0YW5pbWF0aW9uRW5kOiBldnQgPT4ge1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJhbmltYXRpb25FbmRcIiwge2lzVHJ1c3RlZDogZXZ0LmlzVHJ1c3RlZH0pO1xuXHRcdFx0fSxcblx0XHR9KTtcblx0fVxuXG5cdF9zZXRQYW5TY2FsZShmb3YpIHtcblx0XHRjb25zdCBhcmVhSGVpZ2h0ID0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50KS5oZWlnaHQsIDEwKTtcblx0XHRjb25zdCBzY2FsZSA9IE1DX0JJTkRfU0NBTEVbMF0gKiBmb3YgLyB0aGlzLl9pbml0aWFsRm92ICogUEFOX1NDQUxFIC8gYXJlYUhlaWdodDtcblxuXHRcdHRoaXMuYXhlc1BhbklucHV0Lm9wdGlvbnMuc2NhbGUgPSBbc2NhbGUsIHNjYWxlXTtcblx0XHR0aGlzLmF4ZXMub3B0aW9ucy5kZWNlbGVyYXRpb24gPSBNQ19ERUNFTEVSQVRJT04gKiBmb3YgLyBNQVhfRklFTERfT0ZfVklFVztcblx0fVxuXG5cdC8qXG5cdCAqIE92ZXJyaWRlIGNvbXBvbmVudCdzIG9wdGlvbiBtZXRob2Rcblx0ICogdG8gY2FsbCBtZXRob2QgZm9yIHVwZGF0aW5nIHZhbHVlcyB3aGljaCBpcyBhZmZlY3RlZCBieSBvcHRpb24gY2hhbmdlLlxuXHQgKlxuXHQgKiBAcGFyYW0geyp9IGFyZ3Ncblx0ICovXG5cdG9wdGlvbiguLi5hcmdzKSB7XG5cdFx0Y29uc3QgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cblx0XHQvLyBHZXR0ZXJcblx0XHRpZiAoYXJnTGVuID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZ2V0T3B0aW9ucygpO1xuXHRcdH0gZWxzZSBpZiAoYXJnTGVuID09PSAxICYmIHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZ2V0T3B0aW9ucyhhcmdzWzBdKTtcblx0XHR9XG5cblx0XHQvLyBTZXR0ZXJcblx0XHRjb25zdCBiZWZvcmVPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcblx0XHRsZXQgbmV3T3B0aW9ucyA9IHt9O1xuXHRcdGxldCBjaGFuZ2VkS2V5TGlzdCA9IFtdOyAvLyBUT0RPOiBpZiB2YWx1ZSBpcyBub3QgY2hhbmdlZCwgdGhlbiBkbyBub3QgcHVzaCBvbiBjaGFuZ2VkS2V5TGlzdC5cblxuXHRcdGlmIChhcmdMZW4gPT09IDEpIHtcblx0XHRcdGNoYW5nZWRLZXlMaXN0ID0gT2JqZWN0LmtleXMoYXJnc1swXSk7XG5cdFx0XHRuZXdPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYXJnc1swXSk7XG5cdFx0fSBlbHNlIGlmIChhcmdMZW4gPj0gMikge1xuXHRcdFx0Y2hhbmdlZEtleUxpc3QucHVzaChhcmdzWzBdKTtcblx0XHRcdG5ld09wdGlvbnNbYXJnc1swXV0gPSBhcmdzWzFdO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NldE9wdGlvbnModGhpcy5fZ2V0VmFsaWRhdGVkT3B0aW9ucyhuZXdPcHRpb25zKSk7XG5cdFx0dGhpcy5fYXBwbHlPcHRpb25zKGNoYW5nZWRLZXlMaXN0LCBiZWZvcmVPcHRpb25zKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdF9nZXRWYWxpZGF0ZWRPcHRpb25zKG5ld09wdGlvbnMpIHtcblx0XHRpZiAobmV3T3B0aW9ucy55YXdSYW5nZSkge1xuXHRcdFx0bmV3T3B0aW9ucy55YXdSYW5nZSA9XG5cdFx0XHRcdHRoaXMuX2dldFZhbGlkWWF3UmFuZ2UobmV3T3B0aW9ucy55YXdSYW5nZSwgbmV3T3B0aW9ucy5mb3YsIG5ld09wdGlvbnMuYXNwZWN0UmF0aW8pO1xuXHRcdH1cblx0XHRpZiAobmV3T3B0aW9ucy5waXRjaFJhbmdlKSB7XG5cdFx0XHRuZXdPcHRpb25zLnBpdGNoUmFuZ2UgPSB0aGlzLl9nZXRWYWxpZFBpdGNoUmFuZ2UobmV3T3B0aW9ucy5waXRjaFJhbmdlLCBuZXdPcHRpb25zLmZvdik7XG5cdFx0fVxuXHRcdHJldHVybiBuZXdPcHRpb25zO1xuXHR9XG5cblx0X2dldE9wdGlvbnMoa2V5KSB7XG5cdFx0bGV0IHZhbHVlO1xuXG5cdFx0aWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZhbHVlID0gdGhpcy5vcHRpb25zW2tleV07XG5cdFx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHR2YWx1ZSA9IHRoaXMub3B0aW9ucztcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0X3NldE9wdGlvbnMob3B0aW9ucykge1xuXHRcdGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcblx0XHRcdHRoaXMub3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuXHRcdH1cblx0fVxuXG5cdF9hcHBseU9wdGlvbnMoa2V5cywgcHJldk9wdGlvbnMpIHtcblx0XHQvLyBJZiBvbmUgb2YgYmVsb3cgaXMgY2hhbmdlZCwgY2FsbCB1cGRhdGVDb250cm9sU2NhbGUoKVxuXHRcdGlmIChrZXlzLnNvbWUoa2V5ID0+XG5cdFx0XHRcdGtleSA9PT0gXCJzaG93UG9sZVBvaW50XCIgfHwga2V5ID09PSBcImZvdlwiIHx8IGtleSA9PT0gXCJhc3BlY3RSYXRpb1wiIHx8XG5cdFx0XHRcdGtleSA9PT0gXCJ5YXdSYW5nZVwiIHx8IGtleSA9PT0gXCJwaXRjaFJhbmdlXCJcblx0XHRcdCkpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUNvbnRyb2xTY2FsZSgpO1xuXHRcdH1cblxuXHRcdGlmIChrZXlzLnNvbWUoa2V5ID0+IGtleSA9PT0gXCJmb3ZSYW5nZVwiKSkge1xuXHRcdFx0Y29uc3QgZm92UmFuZ2UgPSB0aGlzLm9wdGlvbnMuZm92UmFuZ2U7XG5cdFx0XHRjb25zdCBwcmV2Rm92ID0gdGhpcy5heGVzLmdldCgpLmZvdjtcblx0XHRcdGxldCBuZXh0Rm92ID0gdGhpcy5heGVzLmdldCgpLmZvdjtcblxuXHRcdFx0dmVjMi5jb3B5KHRoaXMuYXhlcy5heGlzLmZvdi5yYW5nZSwgZm92UmFuZ2UpO1xuXG5cdFx0XHRpZiAobmV4dEZvdiA8IGZvdlJhbmdlWzBdKSB7XG5cdFx0XHRcdG5leHRGb3YgPSBmb3ZSYW5nZVswXTtcblx0XHRcdH0gZWxzZSBpZiAocHJldkZvdiA+IGZvdlJhbmdlWzFdKSB7XG5cdFx0XHRcdG5leHRGb3YgPSBmb3ZSYW5nZVsxXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHByZXZGb3YgIT09IG5leHRGb3YpIHtcblx0XHRcdFx0dGhpcy5heGVzLnNldFRvKHtcblx0XHRcdFx0XHRmb3Y6IG5leHRGb3Zcblx0XHRcdFx0fSwgMCk7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZUNvbnRyb2xTY2FsZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChrZXlzLnNvbWUoa2V5ID0+IGtleSA9PT0gXCJneXJvTW9kZVwiKSAmJiBTVVBQT1JUX0RFVklDRU1PVElPTikge1xuXHRcdFx0Y29uc3QgaXNWUiA9IHRoaXMub3B0aW9ucy5neXJvTW9kZSA9PT0gR1lST19NT0RFLlZSO1xuXHRcdFx0Y29uc3QgaXNZYXdQaXRjaCA9IHRoaXMub3B0aW9ucy5neXJvTW9kZSA9PT0gR1lST19NT0RFLllBV1BJVENIO1xuXG5cdFx0XHQvLyBEaXNjb25uZWN0IGZpcnN0XG5cdFx0XHRpZiAodGhpcy5heGVzVGlsdE1vdGlvbklucHV0KSB7XG5cdFx0XHRcdHRoaXMuYXhlcy5kaXNjb25uZWN0KHRoaXMuYXhlc1RpbHRNb3Rpb25JbnB1dCk7XG5cdFx0XHRcdHRoaXMuYXhlc1RpbHRNb3Rpb25JbnB1dC5kZXN0cm95KCk7XG5cdFx0XHRcdHRoaXMuYXhlc1RpbHRNb3Rpb25JbnB1dCA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9kZXZpY2VRdWF0ZXJuaW9uKSB7XG5cdFx0XHRcdHRoaXMuX2RldmljZVF1YXRlcm5pb24uZGVzdHJveSgpO1xuXHRcdFx0XHR0aGlzLl9kZXZpY2VRdWF0ZXJuaW9uID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzVlIpIHtcblx0XHRcdFx0dGhpcy5faW5pdERldmljZVF1YXRlcm5pb24oKTtcblx0XHRcdH0gZWxzZSBpZiAoaXNZYXdQaXRjaCkge1xuXHRcdFx0XHR0aGlzLmF4ZXNUaWx0TW90aW9uSW5wdXQgPSBuZXcgVGlsdE1vdGlvbklucHV0KHRoaXMuX2VsZW1lbnQpO1xuXHRcdFx0XHR0aGlzLmF4ZXMuY29ubmVjdChbXCJ5YXdcIiwgXCJwaXRjaFwiXSwgdGhpcy5heGVzVGlsdE1vdGlvbklucHV0KTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5heGVzUGFuSW5wdXQuc2V0VXNlUm90YXRpb24oaXNWUik7XG5cdFx0fVxuXG5cdFx0aWYgKGtleXMuc29tZShrZXkgPT4ga2V5ID09PSBcInVzZUtleWJvYXJkXCIpKSB7XG5cdFx0XHRjb25zdCB1c2VLZXlib2FyZCA9IHRoaXMub3B0aW9ucy51c2VLZXlib2FyZDtcblxuXHRcdFx0aWYgKHVzZUtleWJvYXJkKSB7XG5cdFx0XHRcdHRoaXMuYXhlcy5jb25uZWN0KFtcInlhd1wiLCBcInBpdGNoXCJdLCB0aGlzLmF4ZXNNb3ZlS2V5SW5wdXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5heGVzLmRpc2Nvbm5lY3QodGhpcy5heGVzTW92ZUtleUlucHV0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoa2V5cy5zb21lKGtleSA9PiBrZXkgPT09IFwidXNlWm9vbVwiKSkge1xuXHRcdFx0Y29uc3QgdXNlWm9vbSA9IHRoaXMub3B0aW9ucy51c2Vab29tO1xuXG5cdFx0XHQvLyBEaXNjb25uZWN0IGZpcnN0XG5cdFx0XHR0aGlzLmF4ZXMuZGlzY29ubmVjdCh0aGlzLmF4ZXNXaGVlbElucHV0KTtcblx0XHRcdGlmICh1c2Vab29tKSB7XG5cdFx0XHRcdHRoaXMuYXhlcy5jb25uZWN0KFtcImZvdlwiXSwgdGhpcy5heGVzV2hlZWxJbnB1dCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fdG9nZ2xlUGluY2hJbnB1dEJ5T3B0aW9uKHRoaXMub3B0aW9ucy50b3VjaERpcmVjdGlvbiwgdGhpcy5vcHRpb25zLnVzZVpvb20pO1xuXG5cdFx0aWYgKGtleXMuc29tZShrZXkgPT4ga2V5ID09PSBcInRvdWNoRGlyZWN0aW9uXCIpKSB7XG5cdFx0XHR0aGlzLl9lbmFibGVkICYmIHRoaXMuX2VuYWJsZVRvdWNoKHRoaXMub3B0aW9ucy50b3VjaERpcmVjdGlvbik7XG5cdFx0fVxuXHR9XG5cblx0X3RvZ2dsZVBpbmNoSW5wdXRCeU9wdGlvbih0b3VjaERpcmVjdGlvbiwgdXNlWm9vbSkge1xuXHRcdGlmICh0aGlzLmF4ZXNQaW5jaElucHV0KSB7XG5cdFx0XHQvLyBkaXNjb25uZWN0IGZpcnN0XG5cdFx0XHR0aGlzLmF4ZXMuZGlzY29ubmVjdCh0aGlzLmF4ZXNQaW5jaElucHV0KTtcblxuXHRcdFx0Ly8gSWYgdGhlIHRvdWNoRGlyZWN0aW9uIG9wdGlvbiBpcyBub3QgQUxMLCBwaW5jaElucHV0IHNob3VsZCBiZSBkaXNjb25uZWN0ZWQgdG8gbWFrZSB1c2Ugb2YgYSBuYXRpdmUgc2Nyb2xsLlxuXHRcdFx0aWYgKFxuXHRcdFx0XHR1c2Vab29tICYmXG5cdFx0XHRcdHRvdWNoRGlyZWN0aW9uID09PSBUT1VDSF9ESVJFQ1RJT05fQUxMICYmXG5cdFx0XHRcdC8vIFRPRE86IEdldCByaWQgb2YgdXNpbmcgcHJpdmF0ZSBwcm9wZXJ0eSBvZiBheGVzIGluc3RhbmNlLlxuXHRcdFx0XHR0aGlzLmF4ZXMuX2lucHV0cy5pbmRleE9mKHRoaXMuYXhlc1BpbmNoSW5wdXQpID09PSAtMVxuXHRcdFx0KSB7XG5cdFx0XHRcdHRoaXMuYXhlcy5jb25uZWN0KFtcImZvdlwiXSwgdGhpcy5heGVzUGluY2hJbnB1dCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0X2VuYWJsZVRvdWNoKGRpcmVjdGlvbikge1xuXHRcdC8vIERpc2Nvbm5lY3QgZmlyc3Rcblx0XHR0aGlzLmF4ZXNQYW5JbnB1dCAmJiB0aGlzLmF4ZXMuZGlzY29ubmVjdCh0aGlzLmF4ZXNQYW5JbnB1dCk7XG5cblx0XHRjb25zdCB5YXdFbmFibGVkID0gZGlyZWN0aW9uICYgVE9VQ0hfRElSRUNUSU9OX1lBVyA/IFwieWF3XCIgOiBudWxsO1xuXHRcdGNvbnN0IHBpdGNoRW5hYmxlZCA9IGRpcmVjdGlvbiAmIFRPVUNIX0RJUkVDVElPTl9QSVRDSCA/IFwicGl0Y2hcIiA6IG51bGw7XG5cblx0XHR0aGlzLmF4ZXMuY29ubmVjdChbeWF3RW5hYmxlZCwgcGl0Y2hFbmFibGVkXSwgdGhpcy5heGVzUGFuSW5wdXQpO1xuXHR9XG5cblx0X2luaXREZXZpY2VRdWF0ZXJuaW9uKCkge1xuXHRcdHRoaXMuX2RldmljZVF1YXRlcm5pb24gPSBuZXcgRGV2aWNlUXVhdGVybmlvbigpO1xuXHRcdHRoaXMuX2RldmljZVF1YXRlcm5pb24ub24oXCJjaGFuZ2VcIiwgZSA9PiB7XG5cdFx0XHR0aGlzLl90cmlnZ2VyQ2hhbmdlKGUpO1xuXHRcdH0pO1xuXHR9XG5cblx0X2dldFZhbGlkWWF3UmFuZ2UobmV3WWF3UmFuZ2UsIG5ld0ZvdiwgbmV3QXNwZWN0UmF0aW8pIHtcblx0XHRjb25zdCByYXRpbyA9IFlhd1BpdGNoQ29udHJvbC5hZGp1c3RBc3BlY3RSYXRpbyhuZXdBc3BlY3RSYXRpbyB8fCB0aGlzLm9wdGlvbnMuYXNwZWN0UmF0aW8gfHwgMSk7XG5cdFx0Y29uc3QgZm92ID0gbmV3Rm92IHx8IHRoaXMuYXhlcy5nZXQoKS5mb3Y7XG5cdFx0Y29uc3QgaG9yaXpvbnRhbEZvdiA9IGZvdiAqIHJhdGlvO1xuXHRcdGNvbnN0IGlzVmFsaWQgPSBuZXdZYXdSYW5nZVsxXSAtIG5ld1lhd1JhbmdlWzBdID49IGhvcml6b250YWxGb3Y7XG5cblx0XHRpZiAoaXNWYWxpZCkge1xuXHRcdFx0cmV0dXJuIG5ld1lhd1JhbmdlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnlhd1JhbmdlIHx8IERFRkFVTFRfWUFXX1JBTkdFO1xuXHRcdH1cblx0fVxuXG5cdF9nZXRWYWxpZFBpdGNoUmFuZ2UobmV3UGl0Y2hSYW5nZSwgbmV3Rm92KSB7XG5cdFx0Y29uc3QgZm92ID0gbmV3Rm92IHx8IHRoaXMuYXhlcy5nZXQoKS5mb3Y7XG5cdFx0Y29uc3QgaXNWYWxpZCA9IG5ld1BpdGNoUmFuZ2VbMV0gLSBuZXdQaXRjaFJhbmdlWzBdID49IGZvdjtcblxuXHRcdGlmIChpc1ZhbGlkKSB7XG5cdFx0XHRyZXR1cm4gbmV3UGl0Y2hSYW5nZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5waXRjaFJhbmdlIHx8IERFRkFVTFRfUElUQ0hfUkFOR0U7XG5cdFx0fVxuXHR9XG5cblx0c3RhdGljIGlzQ2lyY3VsYXIocmFuZ2UpIHtcblx0XHRyZXR1cm4gcmFuZ2VbMV0gLSByYW5nZVswXSA8IDM2MCA/IFtmYWxzZSwgZmFsc2VdIDogW3RydWUsIHRydWVdO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB5YXcvcGl0Y2ggbWluL21heCBieSA1IGZhY3RvclxuXHQgKlxuXHQgKiAxLiBzaG93UG9sZVBvaW50XG5cdCAqIDIuIGZvdlxuXHQgKiAzLiB5YXdSYW5nZVxuXHQgKiA0LiBwaXRjaFJhbmdlXG5cdCAqIDUuIGFzcGVjdFJhdGlvXG5cdCAqXG5cdCAqIElmIG9uZSBvZiBhYm92ZSBpcyBjaGFuZ2VkLCBjYWxsIHRoaXMgZnVuY3Rpb25cblx0ICovXG5cdF91cGRhdGVDb250cm9sU2NhbGUoY2hhbmdlRXZ0KSB7XG5cdFx0Y29uc3Qgb3B0ID0gdGhpcy5vcHRpb25zO1xuXHRcdGNvbnN0IGZvdiA9IHRoaXMuYXhlcy5nZXQoKS5mb3Y7XG5cblx0XHRjb25zdCBwUmFuZ2UgPSB0aGlzLl91cGRhdGVQaXRjaFJhbmdlKG9wdC5waXRjaFJhbmdlLCBmb3YsIG9wdC5zaG93UG9sZVBvaW50KTtcblx0XHRjb25zdCB5UmFuZ2UgPSB0aGlzLl91cGRhdGVZYXdSYW5nZShvcHQueWF3UmFuZ2UsIGZvdiwgb3B0LmFzcGVjdFJhdGlvKTtcblxuXHRcdC8vIFRPRE86IElmIG5vdCBjaGFuZ2VkIT9cblx0XHRjb25zdCBwb3MgPSB0aGlzLmF4ZXMuZ2V0KCk7XG5cdFx0bGV0IHkgPSBwb3MueWF3O1xuXHRcdGxldCBwID0gcG9zLnBpdGNoO1xuXG5cdFx0dmVjMi5jb3B5KHRoaXMuYXhlcy5heGlzLnlhdy5yYW5nZSwgeVJhbmdlKTtcblx0XHR2ZWMyLmNvcHkodGhpcy5heGVzLmF4aXMucGl0Y2gucmFuZ2UsIHBSYW5nZSk7XG5cdFx0dGhpcy5heGVzLmF4aXMueWF3LmNpcmN1bGFyID0gWWF3UGl0Y2hDb250cm9sLmlzQ2lyY3VsYXIoeVJhbmdlKTtcblx0XHR0aGlzLmF4ZXMuYXhpcy5waXRjaC5jaXJjdWxhciA9IFlhd1BpdGNoQ29udHJvbC5pc0NpcmN1bGFyKHBSYW5nZSk7XG5cblx0XHQvKipcblx0XHQgKiB1cGRhdGUgeWF3L3BpdGNoIGJ5IGl0J3MgcmFuZ2UuXG5cdFx0ICovXG5cdFx0aWYgKHkgPCB5UmFuZ2VbMF0pIHtcblx0XHRcdHkgPSB5UmFuZ2VbMF07XG5cdFx0fSBlbHNlIGlmICh5ID4geVJhbmdlWzFdKSB7XG5cdFx0XHR5ID0geVJhbmdlWzFdO1xuXHRcdH1cblxuXHRcdGlmIChwIDwgcFJhbmdlWzBdKSB7XG5cdFx0XHRwID0gcFJhbmdlWzBdO1xuXHRcdH0gZWxzZSBpZiAocCA+IHBSYW5nZVsxXSkge1xuXHRcdFx0cCA9IHBSYW5nZVsxXTtcblx0XHR9XG5cblx0XHRpZiAoY2hhbmdlRXZ0KSB7XG5cdFx0XHRjaGFuZ2VFdnQuc2V0KHtcblx0XHRcdFx0eWF3OiB5LFxuXHRcdFx0XHRwaXRjaDogcCxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuYXhlcy5zZXRUbyh7XG5cdFx0XHR5YXc6IHksXG5cdFx0XHRwaXRjaDogcCxcblx0XHR9LCAwKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0X3VwZGF0ZVBpdGNoUmFuZ2UocGl0Y2hSYW5nZSwgZm92LCBzaG93UG9sZVBvaW50KSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5neXJvTW9kZSA9PT0gR1lST19NT0RFLlZSKSB7XG5cdFx0XHQvLyBDaXJjdWxhciBwaXRjaCBvbiBWUlxuXHRcdFx0cmV0dXJuIENJUkNVTEFSX1BJVENIX1JBTkdFO1xuXHRcdH1cblxuXHRcdGNvbnN0IHZlcnRpY2FsQW5nbGUgPSBwaXRjaFJhbmdlWzFdIC0gcGl0Y2hSYW5nZVswXTtcblx0XHRjb25zdCBoYWxmRm92ID0gZm92IC8gMjtcblx0XHRjb25zdCBpc1Bhbm9yYW1hID0gdmVydGljYWxBbmdsZSA8IDE4MDtcblxuXHRcdGlmIChzaG93UG9sZVBvaW50ICYmICFpc1Bhbm9yYW1hKSB7XG5cdFx0XHQvLyBVc2UgZnVsbCBwaW5jaCByYW5nZVxuXHRcdFx0cmV0dXJuIHBpdGNoUmFuZ2UubWFwKHYgPT4gK3YudG9GaXhlZCg1KSk7XG5cdFx0fVxuXG5cdFx0Ly8gUm91bmQgdmFsdWUgYXMgbW92YWJsZUNvb2QgZG8uXG5cdFx0cmV0dXJuIFtwaXRjaFJhbmdlWzBdICsgaGFsZkZvdiwgcGl0Y2hSYW5nZVsxXSAtIGhhbGZGb3ZdLm1hcCh2ID0+ICt2LnRvRml4ZWQoNSkpO1xuXHR9XG5cblx0X3VwZGF0ZVlhd1JhbmdlKHlhd1JhbmdlLCBmb3YsIGFzcGVjdFJhdGlvKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5neXJvTW9kZSA9PT0gR1lST19NT0RFLlZSKSB7XG5cdFx0XHRyZXR1cm4gREVGQVVMVF9ZQVdfUkFOR0U7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaG9yaXpvbnRhbEFuZ2xlID0geWF3UmFuZ2VbMV0gLSB5YXdSYW5nZVswXTtcblxuXHRcdC8qKlxuXHRcdCAqIEZ1bGwgMzYwIE1vZGVcblx0XHQgKi9cblx0XHRpZiAoaG9yaXpvbnRhbEFuZ2xlID49IDM2MCkge1xuXHRcdFx0Ly8gRG9uJ3QgbGltaXQgeWF3IHJhbmdlIG9uIEZ1bGwgMzYwIG1vZGUuXG5cdFx0XHRyZXR1cm4geWF3UmFuZ2UubWFwKHYgPT4gK3YudG9GaXhlZCg1KSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUGFub3JhbWEgbW9kZVxuXHRcdCAqL1xuXHRcdGxldCBNQUdJQ19OVU1CRVIgPSAxO1xuXHRcdGNvbnN0IHJhdGlvID0gWWF3UGl0Y2hDb250cm9sLmFkanVzdEFzcGVjdFJhdGlvKGFzcGVjdFJhdGlvKTtcblx0XHRjb25zdCBoYWxmSG9yaXpvbnRhbEZvdiA9IGZvdiAvIDIgKiByYXRpbztcblxuXHRcdC8vIFRPRE86IE1hZ2ljIE51bWJlciBGaXghXG5cdFx0aWYgKGhvcml6b250YWxBbmdsZSA+IDI5MCkge1xuXHRcdFx0TUFHSUNfTlVNQkVSID0gMC43OTQ7Ly8gaG9yaXpvbnRhbEFuZ2xlID0gMjg2O1xuXHRcdH0gZWxzZSBpZiAoaG9yaXpvbnRhbEFuZ2xlID4gMTI1KSB7XG5cdFx0XHRNQUdJQ19OVU1CRVIgPSAwLjk4OyAvLyBob3Jpem9udGFsQW5nbGUgKj0gMC45ODtcblx0XHR9XG5cblx0XHQvLyBSb3VuZCB2YWx1ZSBhcyBtb3ZhYmxlQ29vZCBkby5cblx0XHRyZXR1cm4gW1xuXHRcdFx0KHlhd1JhbmdlWzBdICogTUFHSUNfTlVNQkVSKSArIGhhbGZIb3Jpem9udGFsRm92LFxuXHRcdFx0KHlhd1JhbmdlWzFdICogTUFHSUNfTlVNQkVSKSAtIGhhbGZIb3Jpem9udGFsRm92XS5tYXAodiA9PiArdi50b0ZpeGVkKDUpKTtcblx0fVxuXG5cdF90cmlnZ2VyQ2hhbmdlKGV2dCkge1xuXHRcdGNvbnN0IHBvcyA9IHRoaXMuYXhlcy5nZXQoKTtcblx0XHRjb25zdCBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cdFx0Y29uc3QgZXZlbnQgPSB7XG5cdFx0XHR0YXJnZXRFbGVtZW50OiBvcHQuZWxlbWVudCxcblx0XHRcdGlzVHJ1c3RlZDogZXZ0LmlzVHJ1c3RlZCxcblx0XHR9O1xuXG5cdFx0ZXZlbnQueWF3ID0gcG9zLnlhdztcblx0XHRldmVudC5waXRjaCA9IHBvcy5waXRjaDtcblx0XHRldmVudC5mb3YgPSBwb3MuZm92O1xuXG5cdFx0aWYgKG9wdC5neXJvTW9kZSA9PT0gR1lST19NT0RFLlZSICYmIHRoaXMuX2RldmljZVF1YXRlcm5pb24pIHtcblx0XHRcdGV2ZW50LnF1YXRlcm5pb24gPSB0aGlzLl9kZXZpY2VRdWF0ZXJuaW9uLmdldENvbWJpbmVkUXVhdGVybmlvbihwb3MueWF3LCBwb3MucGl0Y2gpO1xuXHRcdH1cblx0XHR0aGlzLnRyaWdnZXIoXCJjaGFuZ2VcIiwgZXZlbnQpO1xuXHR9XG5cblx0Ly8gVE9ETzogbWFrZXMgY29uc3RhbnQgdG8gYmUgbG9naWNcblx0c3RhdGljIGFkanVzdEFzcGVjdFJhdGlvKGlucHV0KSB7XG5cdFx0Y29uc3QgaW5wdXRSYW5nZSA9IFswLjUyMCwgMC41NDAsIDAuNTYzLCAwLjU3MCwgMC41ODQsIDAuNTkwLCAwLjYwOSwgMC42NzAsXG5cdFx0XHQwLjcwMiwgMC43MjAsIDAuNzYwLCAwLjc4MCwgMC44MjAsIDAuOTIwLCAwLjk3MCwgMS4wMCwgMS4wNywgMS4xNCwgMS4xOSxcblx0XHRcdDEuMjUsIDEuMzIsIDEuMzgsIDEuNDAsIDEuNDMsIDEuNTMsIDEuNjIsIDEuNzYsIDEuNzcsIDEuODYsIDEuOTYsIDIuMjYsXG5cdFx0XHQyLjMwLCAyLjYwLCAzLjAwLCA1LjAwLCA2LjAwXTtcblx0XHRjb25zdCBvdXRwdXRSYW5nZSA9IFswLjUxMCwgMC41NDAsIDAuNjA2LCAwLjU2MCwgMC42MjgsIDAuNjMwLCAwLjY0NywgMC43MTAsXG5cdFx0XHQwLjczNiwgMC43NTcsIDAuNzgwLCAwLjc3MCwgMC44MDAsIDAuODkwLCAwLjk3NSwgMS4wMCwgMS4wNywgMS4xMCwgMS4xNSxcblx0XHRcdDEuMTgsIDEuMjIsIDEuMjcsIDEuMzAsIDEuMzMsIDEuMzksIDEuNDUsIDEuNTQsIDEuNTUsIDEuNTgsIDEuNjIsIDEuNzIsXG5cdFx0XHQxLjgyLCAxLjkyLCAyLjAwLCAyLjI0LCAyLjMwXTtcblxuXHRcdGxldCByYW5nZUlkeCA9IC0xO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFJhbmdlLmxlbmd0aCAtIDE7IGkrKykge1xuXHRcdFx0aWYgKGlucHV0UmFuZ2VbaV0gPD0gaW5wdXQgJiYgaW5wdXRSYW5nZVtpICsgMV0gPj0gaW5wdXQpIHtcblx0XHRcdFx0cmFuZ2VJZHggPSBpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocmFuZ2VJZHggPT09IC0xKSB7XG5cdFx0XHRpZiAoaW5wdXRSYW5nZVswXSA+IGlucHV0KSB7XG5cdFx0XHRcdHJldHVybiBvdXRwdXRSYW5nZVswXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBvdXRwdXRSYW5nZVtvdXRwdXRSYW5nZVswXS5sZW5ndGggLSAxXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCBpbnB1dEEgPSBpbnB1dFJhbmdlW3JhbmdlSWR4XTtcblx0XHRjb25zdCBpbnB1dEIgPSBpbnB1dFJhbmdlW3JhbmdlSWR4ICsgMV07XG5cdFx0Y29uc3Qgb3V0cHV0QSA9IG91dHB1dFJhbmdlW3JhbmdlSWR4XTtcblx0XHRjb25zdCBvdXRwdXRCID0gb3V0cHV0UmFuZ2VbcmFuZ2VJZHggKyAxXTtcblxuXHRcdHJldHVybiBZYXdQaXRjaENvbnRyb2wubGVycChvdXRwdXRBLCBvdXRwdXRCLCAoaW5wdXQgLSBpbnB1dEEpIC8gKGlucHV0QiAtIGlucHV0QSkpO1xuXHR9XG5cblx0c3RhdGljIGxlcnAoYSwgYiwgZnJhY3Rpb24pIHtcblx0XHRyZXR1cm4gYSArIGZyYWN0aW9uICogKGIgLSBhKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGUgWWF3UGl0Y2ggZnVuY3Rpb25hbGl0eVxuXHQgKlxuXHQgKiBAbWV0aG9kIGVnLllhd1BpdGNoI2VuYWJsZVxuXHQgKi9cblx0ZW5hYmxlKCkge1xuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0aGlzLl9lbmFibGVkID0gdHJ1ZTtcblxuXHRcdC8vIHRvdWNoRGlyZWN0aW9uIGlzIGRlY2lkZWQgYnkgcGFyYW1ldGVyIGlzIHZhbGlkIHN0cmluZyAoUmVmLiBBeGVzLmNvbm5lY3QpXG5cdFx0dGhpcy5fYXBwbHlPcHRpb25zKE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucyksIHRoaXMub3B0aW9ucyk7XG5cblx0XHR0aGlzLl9zZXRQYW5TY2FsZSh0aGlzLmdldEZvdigpKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpc2FibGUgWWF3UGl0Y2ggZnVuY3Rpb25hbGl0eVxuXHQgKlxuXHQgKiBAbWV0aG9kIGVnLllhd1BpdGNoI2Rpc2FibGVcblx0ICovXG5cdGRpc2FibGUocGVyc2lzdE9yaWVudGF0aW9uKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBUT0RPOiBDaGVjayBwZXJpc3RPcmllbnRhdGlvbiBpcyBuZWVkZWQhXG5cdFx0aWYgKCFwZXJzaXN0T3JpZW50YXRpb24pIHtcblx0XHRcdHRoaXMuX3Jlc2V0T3JpZW50YXRpb24oKTtcblx0XHR9XG5cdFx0dGhpcy5heGVzLmRpc2Nvbm5lY3QoKTtcblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRfcmVzZXRPcmllbnRhdGlvbigpIHtcblx0XHRjb25zdCBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLmF4ZXMuc2V0VG8oe1xuXHRcdFx0eWF3OiBvcHQueWF3LFxuXHRcdFx0cGl0Y2g6IG9wdC5waXRjaCxcblx0XHRcdGZvdjogb3B0LmZvdixcblx0XHR9LCAwKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblxuXHQvKipcblx0ICogU2V0IG9uZSBvciBtb3JlIG9mIHlhdywgcGl0Y2gsIGZvdlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29vcmRpbmF0ZSB5YXcsIHBpdGNoLCBmb3Zcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIEFuaW1hdGlvbiBkdXJhdGlvbi4gaWYgaXQgaXMgYWJvdmUgMCB0aGVuIGl0J3MgYW5pbWF0ZWQuXG5cdCAqL1xuXHRsb29rQXQoe3lhdywgcGl0Y2gsIGZvdn0sIGR1cmF0aW9uKSB7XG5cdFx0Y29uc3QgcG9zID0gdGhpcy5heGVzLmdldCgpO1xuXG5cdFx0Y29uc3QgeSA9IHlhdyA9PT0gdW5kZWZpbmVkID8gMCA6IHlhdyAtIHBvcy55YXc7XG5cdFx0Y29uc3QgcCA9IHBpdGNoID09PSB1bmRlZmluZWQgPyAwIDogcGl0Y2ggLSBwb3MucGl0Y2g7XG5cdFx0Y29uc3QgZiA9IGZvdiA9PT0gdW5kZWZpbmVkID8gMCA6IGZvdiAtIHBvcy5mb3Y7XG5cblx0XHR0aGlzLmF4ZXMuc2V0Qnkoe1xuXHRcdFx0eWF3OiB5LFxuXHRcdFx0cGl0Y2g6IHAsXG5cdFx0XHRmb3Y6IGZcblx0XHR9LCBkdXJhdGlvbik7XG5cdH1cblxuXHRnZXQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXhlcy5nZXQoKTtcblx0fVxuXG5cdGdldFlhdygpIHtcblx0XHRyZXR1cm4gdGhpcy5heGVzLmdldCgpLnlhdztcblx0fVxuXG5cdGdldFBpdGNoKCkge1xuXHRcdHJldHVybiB0aGlzLmF4ZXMuZ2V0KCkucGl0Y2g7XG5cdH1cblxuXHRnZXRGb3YoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXhlcy5nZXQoKS5mb3Y7XG5cdH1cblxuXHQvKipcblx0ICogRGVzdHJveXMgb2JqZWN0c1xuXHQgKi9cblx0ZGVzdHJveSgpIHtcblx0XHR0aGlzLmF4ZXMgJiYgdGhpcy5heGVzLmRlc3Ryb3koKTtcblx0XHR0aGlzLmF4aXNQYW5JbnB1dCAmJiB0aGlzLmF4aXNQYW5JbnB1dC5kZXN0cm95KCk7XG5cdFx0dGhpcy5heGVzV2hlZWxJbnB1dCAmJiB0aGlzLmF4ZXNXaGVlbElucHV0LmRlc3Ryb3koKTtcblx0XHR0aGlzLmF4ZXNUaWx0TW90aW9uSW5wdXQgJiYgdGhpcy5heGVzVGlsdE1vdGlvbklucHV0LmRlc3Ryb3koKTtcblx0XHR0aGlzLmF4ZXNEZXZpY2VPcmllbnRhdGlvbklucHV0ICYmIHRoaXMuYXhlc0RldmljZU9yaWVudGF0aW9uSW5wdXQuZGVzdHJveSgpO1xuXHRcdHRoaXMuYXhlc1BpbmNoSW5wdXQgJiYgdGhpcy5heGVzUGluY2hJbnB1dC5kZXN0cm95KCk7XG5cdFx0dGhpcy5heGVzTW92ZUtleUlucHV0ICYmIHRoaXMuYXhlc01vdmVLZXlJbnB1dC5kZXN0cm95KCk7XG5cdFx0dGhpcy5fZGV2aWNlUXVhdGVybmlvbiAmJiB0aGlzLl9kZXZpY2VRdWF0ZXJuaW9uLmRlc3Ryb3koKTtcblx0fVxufTtcblxuWWF3UGl0Y2hDb250cm9sLlZFUlNJT04gPSBcIjMuMC4wLXJjXCI7XG5leHBvcnQgZGVmYXVsdCBZYXdQaXRjaENvbnRyb2w7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvWWF3UGl0Y2hDb250cm9sL1lhd1BpdGNoQ29udHJvbC5qcyIsImltcG9ydCBNYXRoVXRpbCBmcm9tIFwid2VidnItcG9seWZpbGwvc3JjL21hdGgtdXRpbFwiO1xuaW1wb3J0IENvbXBsZW1lbnRhcnlGaWx0ZXIgZnJvbSBcIndlYnZyLXBvbHlmaWxsL3NyYy9zZW5zb3ItZnVzaW9uL2NvbXBsZW1lbnRhcnktZmlsdGVyXCI7XG5cbkNvbXBsZW1lbnRhcnlGaWx0ZXIucHJvdG90eXBlLnJ1bl8gPSBmdW5jdGlvbigpIHtcblx0aWYgKCF0aGlzLmlzT3JpZW50YXRpb25Jbml0aWFsaXplZCkge1xuXHRcdHRoaXMuYWNjZWxRID0gdGhpcy5hY2NlbFRvUXVhdGVybmlvbl8odGhpcy5jdXJyZW50QWNjZWxNZWFzdXJlbWVudC5zYW1wbGUpO1xuXHRcdHRoaXMucHJldmlvdXNGaWx0ZXJRLmNvcHkodGhpcy5hY2NlbFEpO1xuXHRcdHRoaXMuaXNPcmllbnRhdGlvbkluaXRpYWxpemVkID0gdHJ1ZTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBkZWx0YVQgPSB0aGlzLmN1cnJlbnRHeXJvTWVhc3VyZW1lbnQudGltZXN0YW1wUyAtXG5cdHRoaXMucHJldmlvdXNHeXJvTWVhc3VyZW1lbnQudGltZXN0YW1wUztcblxuXHQvLyBDb252ZXJ0IGd5cm8gcm90YXRpb24gdmVjdG9yIHRvIGEgcXVhdGVybmlvbiBkZWx0YS5cblx0Y29uc3QgZ3lyb0RlbHRhUSA9IHRoaXMuZ3lyb1RvUXVhdGVybmlvbkRlbHRhXyh0aGlzLmN1cnJlbnRHeXJvTWVhc3VyZW1lbnQuc2FtcGxlLCBkZWx0YVQpO1xuXG5cdHRoaXMuZ3lyb0ludGVncmFsUS5tdWx0aXBseShneXJvRGVsdGFRKTtcblxuXHQvLyBmaWx0ZXJfMSA9IEsgKiAoZmlsdGVyXzAgKyBneXJvICogZFQpICsgKDEgLSBLKSAqIGFjY2VsLlxuXHR0aGlzLmZpbHRlclEuY29weSh0aGlzLnByZXZpb3VzRmlsdGVyUSk7XG5cdHRoaXMuZmlsdGVyUS5tdWx0aXBseShneXJvRGVsdGFRKTtcblxuXHQvLyBDYWxjdWxhdGUgdGhlIGRlbHRhIGJldHdlZW4gdGhlIGN1cnJlbnQgZXN0aW1hdGVkIGdyYXZpdHkgYW5kIHRoZSByZWFsXG5cdC8vIGdyYXZpdHkgdmVjdG9yIGZyb20gYWNjZWxlcm9tZXRlci5cblx0Y29uc3QgaW52RmlsdGVyUSA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG5cblx0aW52RmlsdGVyUS5jb3B5KHRoaXMuZmlsdGVyUSk7XG5cdGludkZpbHRlclEuaW52ZXJzZSgpO1xuXG5cdHRoaXMuZXN0aW1hdGVkR3Jhdml0eS5zZXQoMCwgMCwgLTEpO1xuXHR0aGlzLmVzdGltYXRlZEdyYXZpdHkuYXBwbHlRdWF0ZXJuaW9uKGludkZpbHRlclEpO1xuXHR0aGlzLmVzdGltYXRlZEdyYXZpdHkubm9ybWFsaXplKCk7XG5cblx0dGhpcy5tZWFzdXJlZEdyYXZpdHkuY29weSh0aGlzLmN1cnJlbnRBY2NlbE1lYXN1cmVtZW50LnNhbXBsZSk7XG5cdHRoaXMubWVhc3VyZWRHcmF2aXR5Lm5vcm1hbGl6ZSgpO1xuXG5cdC8vIENvbXBhcmUgZXN0aW1hdGVkIGdyYXZpdHkgd2l0aCBtZWFzdXJlZCBncmF2aXR5LCBnZXQgdGhlIGRlbHRhIHF1YXRlcm5pb25cblx0Ly8gYmV0d2VlbiB0aGUgdHdvLlxuXHRjb25zdCBkZWx0YVEgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuXG5cdGRlbHRhUS5zZXRGcm9tVW5pdFZlY3RvcnModGhpcy5lc3RpbWF0ZWRHcmF2aXR5LCB0aGlzLm1lYXN1cmVkR3Jhdml0eSk7XG5cdGRlbHRhUS5pbnZlcnNlKCk7XG5cblx0Ly8gQ2FsY3VsYXRlIHRoZSBTTEVSUCB0YXJnZXQ6IGN1cnJlbnQgb3JpZW50YXRpb24gcGx1cyB0aGUgbWVhc3VyZWQtZXN0aW1hdGVkXG5cdC8vIHF1YXRlcm5pb24gZGVsdGEuXG5cdGNvbnN0IHRhcmdldFEgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuXG5cdHRhcmdldFEuY29weSh0aGlzLmZpbHRlclEpO1xuXHR0YXJnZXRRLm11bHRpcGx5KGRlbHRhUSk7XG5cblx0Ly8gU0xFUlAgZmFjdG9yOiAwIGlzIHB1cmUgZ3lybywgMSBpcyBwdXJlIGFjY2VsLlxuXHR0aGlzLmZpbHRlclEuc2xlcnAodGFyZ2V0USwgMSAtIHRoaXMua0ZpbHRlcik7XG5cblx0dGhpcy5wcmV2aW91c0ZpbHRlclEuY29weSh0aGlzLmZpbHRlclEpO1xuXG5cdGlmICghdGhpcy5pc0ZpbHRlclF1YXRlcm5pb25Jbml0aWFsaXplZCkge1xuXHRcdHRoaXMuaXNGaWx0ZXJRdWF0ZXJuaW9uSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHR9XG59O1xuXG5Db21wbGVtZW50YXJ5RmlsdGVyLnByb3RvdHlwZS5nZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5pc0ZpbHRlclF1YXRlcm5pb25Jbml0aWFsaXplZCkge1xuXHRcdHJldHVybiB0aGlzLmZpbHRlclE7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBsZW1lbnRhcnlGaWx0ZXI7XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9ZYXdQaXRjaENvbnRyb2wvaW5wdXQvQ29tcGxlbWVudGFyeUZpbHRlci5qcyIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIkBlZ2pzL2NvbXBvbmVudFwiO1xuaW1wb3J0IEFnZW50IGZyb20gXCJAZWdqcy9hZ2VudFwiO1xuaW1wb3J0IHt2ZWMzfSBmcm9tIFwiLi4vLi4vdXRpbHMvbWF0aC11dGlsXCI7XG5pbXBvcnQge3dpbmRvd30gZnJvbSBcIi4uL2Jyb3dzZXJcIjtcblxuY29uc3QgU1RJTExORVNTX1RIUkVTSE9MRCA9IDIwMDsgLy8gbWlsbGlzZWNvbmRcblxuLyoqXG4gKiBJbiBDaHJvbWUgbTY1LCBgZGV2aWNlbW90aW9uYCBldmVudHMgYXJlIGJyb2tlbiBidXQgc3Vic2VxdWVudGx5IGZpeGVkXG4gKiBpbiA2NS4wLjMzMjUuMTQ4LiBTaW5jZSBtYW55IGJyb3dzZXJzIHVzZSBDaHJvbWl1bSwgZW5zdXJlIHRoYXRcbiAqIHdlIHNjb3BlIHRoaXMgZGV0ZWN0aW9uIGJ5IGJyYW5jaCBhbmQgYnVpbGQgbnVtYmVycyB0byBwcm92aWRlXG4gKiBhIHByb3BlciBmYWxsYmFjay5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9pbW1lcnNpdmUtd2ViL3dlYnZyLXBvbHlmaWxsL2lzc3Vlcy8zMDdcbiAqL1xuY29uc3QgaXNDaHJvbWVXaXRob3V0RGV2aWNlTW90aW9uID0gZnVuY3Rpb24oKSB7XG5cdGxldCB2YWx1ZSA9IGZhbHNlO1xuXHRjb25zdCBhZ2VudEluZm8gPSBBZ2VudCgpO1xuXHRjb25zdCBicm93c2VyVmVyc2lvbiA9IGFnZW50SW5mby5icm93c2VyLnZlcnNpb247XG5cblx0aWYgKGFnZW50SW5mby5icm93c2VyLm5hbWUgPT09IFwiY2hyb21lXCIgJiYgcGFyc2VJbnQoYnJvd3NlclZlcnNpb24sIDEwKSA9PT0gNjUpIHtcblx0XHRjb25zdCB2ZXJzaW9uVG9rZW4gPSBicm93c2VyVmVyc2lvbi5zcGxpdChcIi5cIik7XG5cdFx0Y29uc3QgYnJhbmNoID0gdmVyc2lvblRva2VuWzJdO1xuXHRcdGNvbnN0IGJ1aWxkID0gdmVyc2lvblRva2VuWzNdO1xuXG5cdFx0dmFsdWUgPSBwYXJzZUludChicmFuY2gsIDEwKSA9PT0gMzMyNSAmJiBwYXJzZUludChidWlsZCwgMTApIDwgMTQ4O1xuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERldmljZU1vdGlvbiBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5fb25EZXZpY2VNb3Rpb24gPSB0aGlzLl9vbkRldmljZU1vdGlvbi5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuX29uRGV2aWNlT3JpZW50YXRpb24gPSB0aGlzLl9vbkRldmljZU9yaWVudGF0aW9uLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5fb25DaHJvbWVXaXRob3V0RGV2aWNlTW90aW9uID0gdGhpcy5fb25DaHJvbWVXaXRob3V0RGV2aWNlTW90aW9uLmJpbmQodGhpcyk7XG5cblx0XHR0aGlzLmlzV2l0aG91dERldmljZU1vdGlvbiA9IGlzQ2hyb21lV2l0aG91dERldmljZU1vdGlvbigpO1xuXHRcdHRoaXMuaXNBbmRyb2lkID0gQWdlbnQoKS5vcy5uYW1lID09PSBcImFuZHJvaWRcIjtcblxuXHRcdHRoaXMuc3RpbGxHeXJvVmVjID0gdmVjMy5jcmVhdGUoKTtcblx0XHR0aGlzLnJhd0d5cm9WZWMgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHRoaXMuYWRqdXN0ZWRHeXJvVmVjID0gdmVjMy5jcmVhdGUoKTtcblxuXHRcdHRoaXMuX3RpbWVyID0gbnVsbDtcblxuXHRcdHRoaXMubGFzdERldmljZW1vdGlvblRpbWVzdGFtcCA9IDA7XG5cdFx0dGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5lbmFibGUoKTtcblx0fVxuXHRfb25DaHJvbWVXaXRob3V0RGV2aWNlTW90aW9uKGUpIHtcblx0XHRsZXQge2FscGhhLCBiZXRhLCBnYW1tYX0gPSBlO1xuXG5cdFx0Ly8gVGhlcmUgaXMgZGV2aWNlb3JpZW50YXRpb24gZXZlbnQgdHJpZ2dlZCB3aXRoIGVtcHR5IHZhbHVlc1xuXHRcdC8vIG9uIEhlYWRsZXNzIENocm9tZS5cblx0XHRpZiAoYWxwaGEgPT09IG51bGwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRvIHJhZGlhblxuXHRcdGFscGhhID0gKGFscGhhIHx8IDApICogTWF0aC5QSSAvIDE4MDtcblx0XHRiZXRhID0gKGJldGEgfHwgMCkgKiBNYXRoLlBJIC8gMTgwO1xuXHRcdGdhbW1hID0gKGdhbW1hIHx8IDApICogTWF0aC5QSSAvIDE4MDtcblxuXHRcdHRoaXMudHJpZ2dlcihcImRldmljZW1vdGlvblwiLCB7XG5cdFx0XHRpbnB1dEV2ZW50OiB7XG5cdFx0XHRcdGRldmljZW9yaWVudGF0aW9uOiB7XG5cdFx0XHRcdFx0YWxwaGEsXG5cdFx0XHRcdFx0YmV0YSxcblx0XHRcdFx0XHRnYW1tYTogLWdhbW1hXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXHRfb25EZXZpY2VPcmllbnRhdGlvbigpIHtcblx0XHR0aGlzLl90aW1lciAmJiBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuXHRcdHRoaXMuX3RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRpZiAoKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5sYXN0RGV2aWNlbW90aW9uVGltZXN0YW1wKSA8IFNUSUxMTkVTU19USFJFU0hPTEQpIHtcblx0XHRcdFx0dmVjMy5jb3B5KHRoaXMuc3RpbGxHeXJvVmVjLCB0aGlzLnJhd0d5cm9WZWMpO1xuXHRcdFx0fVxuXHRcdH0sIFNUSUxMTkVTU19USFJFU0hPTEQpO1xuXHR9XG5cdF9vbkRldmljZU1vdGlvbihlKSB7XG5cdFx0Ly8gZGVza3RvcCBjaHJvbWUgdHJpZ2dlcnMgZGV2aWNlbW90aW9uIGV2ZW50IHdpdGggZW1wdGh5IHNlbnNvciB2YWx1ZXMuXG5cdFx0Ly8gVGhvc2UgZXZlbnRzIHNob3VsZCBpZ25vcmVkLlxuXHRcdGNvbnN0IGlzR3lyb1NlbnNvckF2YWlsYWJsZSA9ICEoZS5yb3RhdGlvblJhdGUuYWxwaGEgPT0gbnVsbCk7XG5cdFx0Y29uc3QgaXNHcmF2aXR5U2Vuc29yQXZhaWxhYmxlID0gIShlLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkueCA9PSBudWxsKTtcblxuXHRcdGlmIChlLmludGVydmFsID09PSAwIHx8ICEoaXNHeXJvU2Vuc29yQXZhaWxhYmxlICYmIGlzR3Jhdml0eVNlbnNvckF2YWlsYWJsZSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBkZXZpY2Vtb3Rpb25FdmVudCA9IE9iamVjdC5hc3NpZ24oe30sIGUpO1xuXG5cdFx0ZGV2aWNlbW90aW9uRXZlbnQuaW50ZXJ2YWwgPSBlLmludGVydmFsO1xuXHRcdGRldmljZW1vdGlvbkV2ZW50LnRpbWVTdGFtcCA9IGUudGltZVN0YW1wO1xuXHRcdGRldmljZW1vdGlvbkV2ZW50LnR5cGUgPSBlLnR5cGU7XG5cdFx0ZGV2aWNlbW90aW9uRXZlbnQucm90YXRpb25SYXRlID0ge1xuXHRcdFx0YWxwaGE6IGUucm90YXRpb25SYXRlLmFscGhhLFxuXHRcdFx0YmV0YTogZS5yb3RhdGlvblJhdGUuYmV0YSxcblx0XHRcdGdhbW1hOiBlLnJvdGF0aW9uUmF0ZS5nYW1tYSxcblx0XHR9O1xuXHRcdGRldmljZW1vdGlvbkV2ZW50LmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkgPSB7XG5cdFx0XHR4OiBlLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkueCxcblx0XHRcdHk6IGUuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eS55LFxuXHRcdFx0ejogZS5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5LnosXG5cdFx0fTtcblx0XHRkZXZpY2Vtb3Rpb25FdmVudC5hY2NlbGVyYXRpb24gPSB7XG5cdFx0XHR4OiBlLmFjY2VsZXJhdGlvbi54LFxuXHRcdFx0eTogZS5hY2NlbGVyYXRpb24ueSxcblx0XHRcdHo6IGUuYWNjZWxlcmF0aW9uLnosXG5cdFx0fTtcblxuXHRcdGlmICh0aGlzLmlzQW5kcm9pZCkge1xuXHRcdFx0dmVjMy5zZXQoXG5cdFx0XHRcdHRoaXMucmF3R3lyb1ZlYyxcblx0XHRcdFx0ZS5yb3RhdGlvblJhdGUuYWxwaGEgfHwgMCxcblx0XHRcdFx0ZS5yb3RhdGlvblJhdGUuYmV0YSB8fCAwLFxuXHRcdFx0XHRlLnJvdGF0aW9uUmF0ZS5nYW1tYSB8fCAwKTtcblx0XHRcdHZlYzMuc3VidHJhY3QodGhpcy5hZGp1c3RlZEd5cm9WZWMsIHRoaXMucmF3R3lyb1ZlYywgdGhpcy5zdGlsbEd5cm9WZWMpO1xuXHRcdFx0dGhpcy5sYXN0RGV2aWNlbW90aW9uVGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cblx0XHRcdGRldmljZW1vdGlvbkV2ZW50LmFkanVzdGVkUm90YXRpb25SYXRlID0ge1xuXHRcdFx0XHRhbHBoYTogdGhpcy5hZGp1c3RlZEd5cm9WZWNbMF0sXG5cdFx0XHRcdGJldGE6IHRoaXMuYWRqdXN0ZWRHeXJvVmVjWzFdLFxuXHRcdFx0XHRnYW1tYTogdGhpcy5hZGp1c3RlZEd5cm9WZWNbMl19O1xuXHRcdH1cblxuXHRcdHRoaXMudHJpZ2dlcihcImRldmljZW1vdGlvblwiLCB7XG5cdFx0XHRpbnB1dEV2ZW50OiBkZXZpY2Vtb3Rpb25FdmVudFxuXHRcdH0pO1xuXHR9XG5cdGVuYWJsZSgpIHtcblx0XHRpZiAodGhpcy5pc0FuZHJvaWQpIHtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZGV2aWNlb3JpZW50YXRpb25cIiwgdGhpcy5fb25EZXZpY2VPcmllbnRhdGlvbik7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmlzV2l0aG91dERldmljZU1vdGlvbikge1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkZXZpY2VvcmllbnRhdGlvblwiLCB0aGlzLl9vbkNocm9tZVdpdGhvdXREZXZpY2VNb3Rpb24pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW1vdGlvblwiLCB0aGlzLl9vbkRldmljZU1vdGlvbik7XG5cdFx0fVxuXHRcdHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XG5cdH1cblx0ZGlzYWJsZSgpIHtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsIHRoaXMuX29uRGV2aWNlT3JpZW50YXRpb24pO1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGV2aWNlb3JpZW50YXRpb25cIiwgdGhpcy5fb25DaHJvbWVXaXRob3V0RGV2aWNlTW90aW9uKTtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRldmljZW1vdGlvblwiLCB0aGlzLl9vbkRldmljZU1vdGlvbik7XG5cdFx0dGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9ZYXdQaXRjaENvbnRyb2wvaW5wdXQvRGV2aWNlTW90aW9uLmpzIiwiaW1wb3J0IEF4ZXMsIHtQYW5JbnB1dH0gZnJvbSBcIkBlZ2pzL2F4ZXNcIjtcbmltcG9ydCBTY3JlZW5Sb3RhdGlvbkFuZ2xlIGZyb20gXCIuLi9TY3JlZW5Sb3RhdGlvbkFuZ2xlXCI7XG5cbi8qKlxuICogUm90YXRpb25QYW5JbnB1dCBpcyBleHRlbnNpb24gb2YgUGFuSW5wdXQgdG8gY29tcGVuc2F0ZSBjb29yZGluYXRlcyBieSBzY3JlZW4gcm90YXRpb24gYW5nbGUuXG4gKlxuICogVGhlIHJlYXNvbiBmb3IgdXNpbmcgdGhpcyBmdW5jdGlvbiBpcyB0aGF0IGluIFZSIG1vZGUsXG4gKiB0aGUgcm9sbCBhbmdsZSBpcyBhZGp1c3RlZCBpbiB0aGUgZGlyZWN0aW9uIG9wcG9zaXRlIHRvIHRoZSBzY3JlZW4gcm90YXRpb24gYW5nbGUuXG4gKlxuICogVGhlcmVmb3JlLCB0aGUgYW5nbGUgdGhhdCB0aGUgdXNlciB0b3VjaGVzIGFuZCBtb3ZlcyBkb2VzIG5vdCBtYXRjaCB0aGUgYW5nbGUgYXQgd2hpY2ggdGhlIGFjdHVhbCBvYmplY3Qgc2hvdWxkIG1vdmUuXG4gKiBAZXh0ZW5kcyBQYW5JbnB1dFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3RhdGlvblBhbklucHV0IGV4dGVuZHMgUGFuSW5wdXQge1xuXHQvKipcblx0ICogQ29uc3RydWN0b3Jcblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9uIG9iamVjdFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVzZVJvdGF0aW9uXSAgV2hldGhlciB0byB1c2Ugcm90YXRpb24ob3IgVlIpXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihlbCwgb3B0aW9ucykge1xuXHRcdHN1cGVyKGVsLCBvcHRpb25zKTtcblxuXHRcdHRoaXMuX3VzZVJvdGF0aW9uID0gZmFsc2U7XG5cdFx0dGhpcy5fc2NyZWVuUm90YXRpb25BbmdsZSA9IG51bGw7XG5cblx0XHR0aGlzLnNldFVzZVJvdGF0aW9uKCEhKG9wdGlvbnMgJiYgb3B0aW9ucy51c2VSb3RhdGlvbikpO1xuXG5cdFx0dGhpcy5fdXNlckRpcmVjdGlvbiA9IEF4ZXMuRElSRUNUSU9OX0FMTDtcblx0fVxuXG5cdHNldFVzZVJvdGF0aW9uKHVzZVJvdGF0aW9uKSB7XG5cdFx0dGhpcy5fdXNlUm90YXRpb24gPSB1c2VSb3RhdGlvbjtcblxuXHRcdGlmICh0aGlzLl9zY3JlZW5Sb3RhdGlvbkFuZ2xlKSB7XG5cdFx0XHR0aGlzLl9zY3JlZW5Sb3RhdGlvbkFuZ2xlLnVucmVmKCk7XG5cdFx0XHR0aGlzLl9zY3JlZW5Sb3RhdGlvbkFuZ2xlID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fdXNlUm90YXRpb24pIHtcblx0XHRcdHRoaXMuX3NjcmVlblJvdGF0aW9uQW5nbGUgPSBuZXcgU2NyZWVuUm90YXRpb25BbmdsZSgpO1xuXHRcdH1cblx0fVxuXG5cdGNvbm5lY3Qob2JzZXJ2ZXIpIHtcblx0XHQvLyBVc2VyIGludGV0ZW5lZCBkaXJlY3Rpb25cblx0XHR0aGlzLl91c2VyRGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uO1xuXG5cdFx0Ly8gSW4gVlIgTW9kZSwgVXNlIEFMTCBkaXJlY3Rpb24gaWYgZGlyZWN0aW9uIGlzIG5vdCBub25lXG5cdFx0Ly8gQmVjYXVzZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBpcyBjaGFuZ2VkIGR5bmFtaWNhbGx5IGJ5IHNjcmVlbiByb3RhdGlvbi5cblx0XHQvLyB0aGlzLl9kaXJlY3Rpb24gaXMgdXNlZCB0byBpbml0aWFsaXplIGhhbW1lcmpzXG5cdFx0aWYgKHRoaXMuX3VzZVJvdGF0aW9uICYmICh0aGlzLl9kaXJlY3Rpb24gJiBBeGVzLkRJUkVDVElPTl9BTEwpKSB7XG5cdFx0XHR0aGlzLl9kaXJlY3Rpb24gPSBBeGVzLkRJUkVDVElPTl9BTEw7XG5cdFx0fVxuXG5cdFx0c3VwZXIuY29ubmVjdChvYnNlcnZlcik7XG5cdH1cblxuXHRnZXRPZmZzZXQocHJvcGVydGllcywgdXNlRGlyZWN0aW9uKSB7XG5cdFx0aWYgKHRoaXMuX3VzZVJvdGF0aW9uID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuIHN1cGVyLmdldE9mZnNldChwcm9wZXJ0aWVzLCB1c2VEaXJlY3Rpb24pO1xuXHRcdH1cblxuXHRcdGNvbnN0IG9mZnNldCA9IHN1cGVyLmdldE9mZnNldChwcm9wZXJ0aWVzLCBbdHJ1ZSwgdHJ1ZV0pO1xuXHRcdGNvbnN0IG5ld09mZnNldCA9IFswLCAwXTtcblx0XHRjb25zdCB0aGV0YSA9IHRoaXMuX3NjcmVlblJvdGF0aW9uQW5nbGUuZ2V0UmFkaWFuKCk7XG5cdFx0Y29uc3QgY29zVGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XG5cdFx0Y29uc3Qgc2luVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XG5cblx0XHRuZXdPZmZzZXRbMF0gPSBvZmZzZXRbMF0gKiBjb3NUaGV0YSAtIG9mZnNldFsxXSAqIHNpblRoZXRhO1xuXHRcdG5ld09mZnNldFsxXSA9IG9mZnNldFsxXSAqIGNvc1RoZXRhICsgb2Zmc2V0WzBdICogc2luVGhldGE7XG5cblx0XHQvLyBVc2Ugb25seSB1c2VyIGFsbG93ZWQgZGlyZWN0aW9uLlxuXHRcdGlmICghKHRoaXMuX3VzZXJEaXJlY3Rpb24gJiBBeGVzLkRJUkVDVElPTl9IT1JJWk9OVEFMKSkge1xuXHRcdFx0bmV3T2Zmc2V0WzBdID0gMDtcblx0XHR9IGVsc2UgaWYgKCEodGhpcy5fdXNlckRpcmVjdGlvbiAmIEF4ZXMuRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuXHRcdFx0bmV3T2Zmc2V0WzFdID0gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3T2Zmc2V0O1xuXHR9XG5cblx0ZGVzdHJveSgpIHtcblx0XHRpZiAodGhpcy5fdXNlUm90YXRpb24pIHtcblx0XHRcdHRoaXMuX3NjcmVlblJvdGF0aW9uQW5nbGUgJiYgdGhpcy5fc2NyZWVuUm90YXRpb25BbmdsZS51bnJlZigpO1xuXHRcdH1cblxuXHRcdHN1cGVyLmRlc3Ryb3koKTtcblx0fVxufVxuXG4vKipcbiAqIE92ZXJyaWRlIGdldERpcmVjdGlvbkJ5QW5nbGUgdG8gcmV0dXJuIERJUkVDVElPTl9BTExcbiAqIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtYXhlcy9pc3N1ZXMvOTlcbiAqXG4gKiBCdXQgd2Ugb2JleSBheGVzJ3MgcnVsZS4gSWYgYXhlcydzIHJ1bGUgaXMgcHJvYmxlbSwgbGV0J3MgYXBwbHkgZm9sbG93aW5nIGNvZGUuXG4gKi9cbi8vIFBhbklucHV0LmdldERpcmVjdGlvbkJ5QW5nbGUgPSBmdW5jdGlvbiAoYW5nbGUsIHRocmVzaG9sZEFuZ2xlKSB7XG4vLyBcdHJldHVybiBESVJFQ1RJT05fQUxMO1xuLy8gfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9ZYXdQaXRjaENvbnRyb2wvaW5wdXQvUm90YXRpb25QYW5JbnB1dC5qcyIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIkBlZ2pzL2NvbXBvbmVudFwiO1xuaW1wb3J0IHt0b0F4aXN9IGZyb20gXCIuLi91dGlsc1wiO1xuaW1wb3J0IEZ1c2lvblBvc2VTZW5zb3IgZnJvbSBcIi4vRnVzaW9uUG9zZVNlbnNvclwiO1xuaW1wb3J0IHtcblx0dXRpbCxcblx0cXVhdCxcblx0Uk9UQVRFX0NPTlNUQU5ULFxufSBmcm9tIFwiLi4vLi4vdXRpbHMvbWF0aC11dGlsXCI7XG5cbmZ1bmN0aW9uIGdldERlbHRhWWF3KHBydlEsIGN1clEpIHtcblx0Y29uc3QgeWF3RGVsdGFCeVlhdyA9IHV0aWwuZ2V0Um90YXRpb25EZWx0YShwcnZRLCBjdXJRLCBST1RBVEVfQ09OU1RBTlQuWUFXX0RFTFRBX0JZX1lBVyk7XG5cdGNvbnN0IHlhd0RlbHRhQnlSb2xsID0gdXRpbC5nZXRSb3RhdGlvbkRlbHRhKHBydlEsIGN1clEsIFJPVEFURV9DT05TVEFOVC5ZQVdfREVMVEFfQllfUk9MTCkgKlxuXHRcdE1hdGguc2luKHV0aWwuZXh0cmFjdFBpdGNoRnJvbVF1YXQoY3VyUSkpO1xuXG5cdHJldHVybiB5YXdEZWx0YUJ5Um9sbCArIHlhd0RlbHRhQnlZYXc7XG59XG5cbmZ1bmN0aW9uIGdldERlbHRhUGl0Y2gocHJ2USwgY3VyUSkge1xuXHRjb25zdCBwaXRjaERlbHRhID0gdXRpbC5nZXRSb3RhdGlvbkRlbHRhKHBydlEsIGN1clEsIFJPVEFURV9DT05TVEFOVC5QSVRDSF9ERUxUQSk7XG5cblx0cmV0dXJuIHBpdGNoRGVsdGE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbHRNb3Rpb25JbnB1dCBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKGVsLCBvcHRpb25zKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLmVsZW1lbnQgPSBlbDtcblxuXHRcdHRoaXMuX3ByZXZRdWF0ZXJuaW9uID0gbnVsbDtcblx0XHR0aGlzLl9xdWF0ZXJuaW9uID0gbnVsbDtcblxuXHRcdHRoaXMuZnVzaW9uUG9zZVNlbnNvciA9IG51bGw7XG5cblx0XHR0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRcdHNjYWxlOiAxLFxuXHRcdFx0dGhyZXNob2xkOiAwLFxuXHRcdH0sIG9wdGlvbnMpO1xuXG5cdFx0dGhpcy5fb25Qb3NlQ2hhbmdlID0gdGhpcy5fb25Qb3NlQ2hhbmdlLmJpbmQodGhpcyk7XG5cdH1cblx0bWFwQXhlcyhheGVzKSB7XG5cdFx0dGhpcy5heGVzID0gYXhlcztcblx0fVxuXHRjb25uZWN0KG9ic2VydmVyKSB7XG5cdFx0aWYgKHRoaXMub2JzZXJ2ZXIpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHR0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG5cdFx0dGhpcy5mdXNpb25Qb3NlU2Vuc29yID0gbmV3IEZ1c2lvblBvc2VTZW5zb3IoKTtcblx0XHR0aGlzLmZ1c2lvblBvc2VTZW5zb3IuZW5hYmxlKCk7XG5cdFx0dGhpcy5fYXR0YWNoRXZlbnQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRkaXNjb25uZWN0KCkge1xuXHRcdGlmICghdGhpcy5vYnNlcnZlcikge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZGV0dGFjaEV2ZW50KCk7XG5cdFx0dGhpcy5mdXNpb25Qb3NlU2Vuc29yLmRpc2FibGUoKTtcblx0XHR0aGlzLmZ1c2lvblBvc2VTZW5zb3IuZGVzdHJveSgpO1xuXHRcdHRoaXMuZnVzaW9uUG9zZVNlbnNvciA9IG51bGw7XG5cdFx0dGhpcy5vYnNlcnZlciA9IG51bGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZGVzdHJveSgpIHtcblx0XHR0aGlzLmRpc2Nvbm5lY3QoKTtcblx0XHR0aGlzLmVsZW1lbnQgPSBudWxsO1xuXHRcdHRoaXMub3B0aW9ucyA9IG51bGw7XG5cdFx0dGhpcy5heGVzID0gbnVsbDtcblx0XHR0aGlzLl9wcmV2UXVhdGVybmlvbiA9IG51bGw7XG5cdFx0dGhpcy5fcXVhdGVybmlvbiA9IG51bGw7XG5cdH1cblx0X29uUG9zZUNoYW5nZShldmVudCkge1xuXHRcdGlmICghdGhpcy5fcHJldlF1YXRlcm5pb24pIHtcblx0XHRcdHRoaXMuX3ByZXZRdWF0ZXJuaW9uID0gcXVhdC5jbG9uZShldmVudC5xdWF0ZXJuaW9uKTtcblx0XHRcdHRoaXMuX3F1YXRlcm5pb24gPSBxdWF0LmNsb25lKGV2ZW50LnF1YXRlcm5pb24pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHF1YXQuY29weSh0aGlzLl9wcmV2UXVhdGVybmlvbiwgdGhpcy5fcXVhdGVybmlvbik7XG5cdFx0cXVhdC5jb3B5KHRoaXMuX3F1YXRlcm5pb24sIGV2ZW50LnF1YXRlcm5pb24pO1xuXG5cdFx0dGhpcy5vYnNlcnZlci5jaGFuZ2UodGhpcywgZXZlbnQsIHRvQXhpcyh0aGlzLmF4ZXMsIFtcblx0XHRcdGdldERlbHRhWWF3KHRoaXMuX3ByZXZRdWF0ZXJuaW9uLCB0aGlzLl9xdWF0ZXJuaW9uKSxcblx0XHRcdGdldERlbHRhUGl0Y2godGhpcy5fcHJldlF1YXRlcm5pb24sIHRoaXMuX3F1YXRlcm5pb24pXG5cdFx0XSkpO1xuXHR9XG5cdF9hdHRhY2hFdmVudCgpIHtcblx0XHR0aGlzLmZ1c2lvblBvc2VTZW5zb3Iub24oXCJjaGFuZ2VcIiwgdGhpcy5fb25Qb3NlQ2hhbmdlKTtcblx0fVxuXHRfZGV0dGFjaEV2ZW50KCkge1xuXHRcdHRoaXMuZnVzaW9uUG9zZVNlbnNvci5vZmYoXCJjaGFuZ2VcIiwgdGhpcy5fb25Qb3NlQ2hhbmdlKTtcblx0fVxufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvWWF3UGl0Y2hDb250cm9sL2lucHV0L1RpbHRNb3Rpb25JbnB1dC5qcyIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIkBlZ2pzL2NvbXBvbmVudFwiO1xuaW1wb3J0IHt0b0F4aXN9IGZyb20gXCIuLi91dGlsc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaGVlbElucHV0IGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoZWwsIG9wdGlvbnMpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuZWxlbWVudCA9IGVsO1xuXG5cdFx0dGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0XHRzY2FsZTogMSxcblx0XHRcdHRocmVzaG9sZDogMCxcblx0XHR9LCBvcHRpb25zKTtcblxuXHRcdHRoaXMuX29uV2hlZWwgPSB0aGlzLl9vbldoZWVsLmJpbmQodGhpcyk7XG5cdH1cblx0bWFwQXhlcyhheGVzKSB7XG5cdFx0dGhpcy5heGVzID0gYXhlcztcblx0fVxuXHRjb25uZWN0KG9ic2VydmVyKSB7XG5cdFx0aWYgKHRoaXMub2JzZXJ2ZXIpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHR0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG5cdFx0dGhpcy5fYXR0YWNoRXZlbnQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRkaXNjb25uZWN0KCkge1xuXHRcdGlmICghdGhpcy5vYnNlcnZlcikge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuXHRcdHRoaXMuX2RldHRhY2hFdmVudCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGRlc3Ryb3koKSB7XG5cdFx0dGhpcy5kaXNjb25uZWN0KCk7XG5cdFx0dGhpcy5lbGVtZW50ID0gbnVsbDtcblx0XHR0aGlzLm9wdGlvbnMgPSBudWxsO1xuXHRcdHRoaXMuYXhlcyA9IG51bGw7XG5cdH1cblx0X29uV2hlZWwoZXZlbnQpIHtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0aWYgKGV2ZW50LmRlbHRhWSA9PT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMub2JzZXJ2ZXIuY2hhbmdlKHRoaXMsIGV2ZW50LCB0b0F4aXModGhpcy5heGVzLCBbXG5cdFx0XHQoZXZlbnQuZGVsdGFZIDwgMCA/IC0xIDogMSkgKiB0aGlzLm9wdGlvbnMuc2NhbGVcblx0XHRdKSk7XG5cdH1cblx0X2F0dGFjaEV2ZW50KCkge1xuXHRcdHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5fb25XaGVlbCwgZmFsc2UpO1xuXHR9XG5cdF9kZXR0YWNoRXZlbnQoKSB7XG5cdFx0dGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB0aGlzLl9vbldoZWVsLCBmYWxzZSk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9ZYXdQaXRjaENvbnRyb2wvaW5wdXQvV2hlZWxJbnB1dC5qcyIsIi8qKlxuICogT3JpZ2luYWwgQ29kZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3RvamkvZ2wtbWF0cml4L2Jsb2IvdjIuMy4yL3NyYy9nbC1tYXRyaXgvbWF0NC5qc1xuICogNHg0IE1hdHJpeCB1dGlsXG4gKiBtb2RpZmllZCBieSBlZ2pzXG4gKi9cbmltcG9ydCBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcblxuLyoqXG4gKiBAY2xhc3MgNHg0IE1hdHJpeFxuICogQG5hbWUgbWF0NFxuICovXG52YXIgbWF0NCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbm1hdDQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzIG5vdCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGVYID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFswXSAgPSBhWzBdO1xuICAgICAgICBvdXRbMV0gID0gYVsxXTtcbiAgICAgICAgb3V0WzJdICA9IGFbMl07XG4gICAgICAgIG91dFszXSAgPSBhWzNdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFs0XSA9IGExMCAqIGMgKyBhMjAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgKyBhMjEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgKyBhMjMgKiBzO1xuICAgIG91dFs4XSA9IGEyMCAqIGMgLSBhMTAgKiBzO1xuICAgIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICAgIG91dFsxMF0gPSBhMjIgKiBjIC0gYTEyICogcztcbiAgICBvdXRbMTFdID0gYTIzICogYyAtIGExMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMgbm90IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZVkgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzRdICA9IGFbNF07XG4gICAgICAgIG91dFs1XSAgPSBhWzVdO1xuICAgICAgICBvdXRbNl0gID0gYVs2XTtcbiAgICAgICAgb3V0WzddICA9IGFbN107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyAtIGEyMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyAtIGEyMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyAtIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gICAgb3V0WzldID0gYTAxICogcyArIGEyMSAqIGM7XG4gICAgb3V0WzEwXSA9IGEwMiAqIHMgKyBhMjIgKiBjO1xuICAgIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgNHg0IG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4gKlxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21RdWF0ID0gZnVuY3Rpb24gKG91dCwgcSkge1xuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeXggPSB5ICogeDIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB6eCA9IHogKiB4MixcbiAgICAgICAgenkgPSB6ICogeTIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gICAgb3V0WzFdID0geXggKyB3ejtcbiAgICBvdXRbMl0gPSB6eCAtIHd5O1xuICAgIG91dFszXSA9IDA7XG5cbiAgICBvdXRbNF0gPSB5eCAtIHd6O1xuICAgIG91dFs1XSA9IDEgLSB4eCAtIHp6O1xuICAgIG91dFs2XSA9IHp5ICsgd3g7XG4gICAgb3V0WzddID0gMDtcblxuICAgIG91dFs4XSA9IHp4ICsgd3k7XG4gICAgb3V0WzldID0genkgLSB3eDtcbiAgICBvdXRbMTBdID0gMSAtIHh4IC0geXk7XG4gICAgb3V0WzExXSA9IDA7XG5cbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucGVyc3BlY3RpdmUgPSBmdW5jdGlvbiAob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICAgIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IGY7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoMiAqIGZhciAqIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0NDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9tYXRoVXRpbC9tYXQ0LmpzIiwiLyoqXG4gKiBPcmlnaW5hbCBDb2RlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdG9qaS9nbC1tYXRyaXgvYmxvYi92Mi4zLjIvc3JjL2dsLW1hdHJpeC9xdWF0LmpzXG4gKiBRdWF0ZXJuaW9uIHV0aWxcbiAqIG1vZGlmaWVkIGJ5IGVnanNcbiAqL1xuaW1wb3J0IGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuXG4vKipcbiAqIEBjbGFzcyBRdWF0ZXJuaW9uXG4gKiBAbmFtZSBxdWF0XG4gKi9cbnZhciBxdWF0ID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBxdWF0XG4gKlxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqL1xucXVhdC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gY2xvbmVcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSwgeiwgdykge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSB3O1xuICAgIHJldHVybiBvdXQ7XG59OztcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgcXVhdCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIHNvdXJjZSBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXRzIGEgcXVhdCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhbmQgcm90YXRpb24gYXhpcyxcbiAqIHRoZW4gcmV0dXJucyBpdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyBhcm91bmQgd2hpY2ggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiovXG5xdWF0LnNldEF4aXNBbmdsZSA9IGZ1bmN0aW9uKG91dCwgYXhpcywgcmFkKSB7XG4gICAgcmFkID0gcmFkICogMC41O1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBvdXRbMF0gPSBzICogYXhpc1swXTtcbiAgICBvdXRbMV0gPSBzICogYXhpc1sxXTtcbiAgICBvdXRbMl0gPSBzICogYXhpc1syXTtcbiAgICBvdXRbM10gPSBNYXRoLmNvcyhyYWQpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGVYID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTtcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYng7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF6ICogYng7XG4gICAgb3V0WzJdID0gYXogKiBidyAtIGF5ICogYng7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYng7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVkgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41O1xuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnkgPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3IC0gYXogKiBieTtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieTtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXggKiBieTtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXkgKiBieTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBjb25qdWdhdGUgb2YgYSBxdWF0XG4gKiBJZiB0aGUgcXVhdGVybmlvbiBpcyBub3JtYWxpemVkLCB0aGlzIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuIHF1YXQuaW52ZXJzZSBhbmQgcHJvZHVjZXMgdGhlIHNhbWUgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGNvbmp1Z2F0ZSBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSB4ICogbGVuO1xuICAgICAgICBvdXRbMV0gPSB5ICogbGVuO1xuICAgICAgICBvdXRbMl0gPSB6ICogbGVuO1xuICAgICAgICBvdXRbM10gPSB3ICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBxdWF0ZXJuaW9ucyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIFRoZSBmaXJzdCBxdWF0ZXJuaW9uLlxuICogQHBhcmFtIHtxdWF0fSBiIFRoZSBzZWNvbmQgcXVhdGVybmlvbi5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5xdWF0LmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgICBsZXQgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICAgIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpKTtcbiAgfVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgVGhlIGZpcnN0IHF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge3F1YXR9IGIgVGhlIHNlY29uZCBxdWF0ZXJuaW9uLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnF1YXQuZXhhY3RFcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBxdWF0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL21hdGhVdGlsL3F1YXQuanMiLCIvKipcbiAqIE9yaWdpbmFsIENvZGVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL2dsLW1hdHJpeC9ibG9iL3YyLjMuMi9zcmMvZ2wtbWF0cml4L3ZlYzIuanNcbiAqIDIgRGltZW5zaW9uYWwgVmVjdG9yIFV0aWxcbiAqIG1vZGlmaWVkIGJ5IGVnanNcbiAqL1xuaW1wb3J0IGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuXG4vKipcbiAqIEBjbGFzcyAyIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjMlxuICovXG52YXIgdmVjMiA9IHt9O1xuXG52ZWMyLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdmVjMjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9tYXRoVXRpbC92ZWMyLmpzIiwiLyoqXG4gKiBPcmlnaW5hbCBDb2RlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdG9qaS9nbC1tYXRyaXgvYmxvYi92Mi4zLjIvc3JjL2dsLW1hdHJpeC92ZWMzLmpzXG4gKiAzIERpbWVuc2lvbmFsIFZlY3RvciBVdGlsXG4gKiBtb2RpZmllZCBieSBlZ2pzXG4gKi9cbmltcG9ydCBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcblxuLyoqXG4gKiBAY2xhc3MgMyBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzNcbiAqL1xudmFyIHZlYzMgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXG4gKlxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG52ZWMzLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSwgeikge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG52ZWMzLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjMy5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6Kno7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgICAgICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzMuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmNyb3NzID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl07XG5cbiAgICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgICBvdXRbMV0gPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy50cmFuc2Zvcm1RdWF0ID0gZnVuY3Rpb24ob3V0LCBhLCBxKSB7XG4gICAgLy8gYmVuY2htYXJrczogaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnNcblxuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJvdGF0ZVogPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuXHR2YXIgcCA9IFtdLCByPVtdO1xuXHQvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG5cdHBbMF0gPSBhWzBdIC0gYlswXTtcblx0cFsxXSA9IGFbMV0gLSBiWzFdO1xuXHRwWzJdID0gYVsyXSAtIGJbMl07XG5cblx0Ly9wZXJmb3JtIHJvdGF0aW9uXG5cdHJbMF0gPSBwWzBdKk1hdGguY29zKGMpIC0gcFsxXSpNYXRoLnNpbihjKTtcblx0clsxXSA9IHBbMF0qTWF0aC5zaW4oYykgKyBwWzFdKk1hdGguY29zKGMpO1xuXHRyWzJdID0gcFsyXTtcblxuXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cdG91dFswXSA9IHJbMF0gKyBiWzBdO1xuXHRvdXRbMV0gPSByWzFdICsgYlsxXTtcblx0b3V0WzJdID0gclsyXSArIGJbMl07XG5cblx0cmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdmVjMztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9tYXRoVXRpbC92ZWMzLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYW5zaUhUTUxcblxuLy8gUmVmZXJlbmNlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvYW5zaS1yZWdleFxudmFyIF9yZWdBTlNJID0gLyg/Oig/OlxcdTAwMWJcXFspfFxcdTAwOWIpKD86KD86WzAtOV17MSwzfSk/KD86KD86O1swLTldezAsM30pKik/W0EtTXxmLW1dKXxcXHUwMDFiW0EtTV0vXG5cbnZhciBfZGVmQ29sb3JzID0ge1xuICByZXNldDogWydmZmYnLCAnMDAwJ10sIC8vIFtGT1JFR1JPVURfQ09MT1IsIEJBQ0tHUk9VTkRfQ09MT1JdXG4gIGJsYWNrOiAnMDAwJyxcbiAgcmVkOiAnZmYwMDAwJyxcbiAgZ3JlZW46ICcyMDk4MDUnLFxuICB5ZWxsb3c6ICdlOGJmMDMnLFxuICBibHVlOiAnMDAwMGZmJyxcbiAgbWFnZW50YTogJ2ZmMDBmZicsXG4gIGN5YW46ICcwMGZmZWUnLFxuICBsaWdodGdyZXk6ICdmMGYwZjAnLFxuICBkYXJrZ3JleTogJzg4OCdcbn1cbnZhciBfc3R5bGVzID0ge1xuICAzMDogJ2JsYWNrJyxcbiAgMzE6ICdyZWQnLFxuICAzMjogJ2dyZWVuJyxcbiAgMzM6ICd5ZWxsb3cnLFxuICAzNDogJ2JsdWUnLFxuICAzNTogJ21hZ2VudGEnLFxuICAzNjogJ2N5YW4nLFxuICAzNzogJ2xpZ2h0Z3JleSdcbn1cbnZhciBfb3BlblRhZ3MgPSB7XG4gICcxJzogJ2ZvbnQtd2VpZ2h0OmJvbGQnLCAvLyBib2xkXG4gICcyJzogJ29wYWNpdHk6MC41JywgLy8gZGltXG4gICczJzogJzxpPicsIC8vIGl0YWxpY1xuICAnNCc6ICc8dT4nLCAvLyB1bmRlcnNjb3JlXG4gICc4JzogJ2Rpc3BsYXk6bm9uZScsIC8vIGhpZGRlblxuICAnOSc6ICc8ZGVsPicgLy8gZGVsZXRlXG59XG52YXIgX2Nsb3NlVGFncyA9IHtcbiAgJzIzJzogJzwvaT4nLCAvLyByZXNldCBpdGFsaWNcbiAgJzI0JzogJzwvdT4nLCAvLyByZXNldCB1bmRlcnNjb3JlXG4gICcyOSc6ICc8L2RlbD4nIC8vIHJlc2V0IGRlbGV0ZVxufVxuXG47WzAsIDIxLCAyMiwgMjcsIDI4LCAzOSwgNDldLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgX2Nsb3NlVGFnc1tuXSA9ICc8L3NwYW4+J1xufSlcblxuLyoqXG4gKiBDb252ZXJ0cyB0ZXh0IHdpdGggQU5TSSBjb2xvciBjb2RlcyB0byBIVE1MIG1hcmt1cC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gYW5zaUhUTUwgKHRleHQpIHtcbiAgLy8gUmV0dXJucyB0aGUgdGV4dCBpZiB0aGUgc3RyaW5nIGhhcyBubyBBTlNJIGVzY2FwZSBjb2RlLlxuICBpZiAoIV9yZWdBTlNJLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgLy8gQ2FjaGUgb3BlbmVkIHNlcXVlbmNlLlxuICB2YXIgYW5zaUNvZGVzID0gW11cbiAgLy8gUmVwbGFjZSB3aXRoIG1hcmt1cC5cbiAgdmFyIHJldCA9IHRleHQucmVwbGFjZSgvXFwwMzNcXFsoXFxkKykqbS9nLCBmdW5jdGlvbiAobWF0Y2gsIHNlcSkge1xuICAgIHZhciBvdCA9IF9vcGVuVGFnc1tzZXFdXG4gICAgaWYgKG90KSB7XG4gICAgICAvLyBJZiBjdXJyZW50IHNlcXVlbmNlIGhhcyBiZWVuIG9wZW5lZCwgY2xvc2UgaXQuXG4gICAgICBpZiAoISF+YW5zaUNvZGVzLmluZGV4T2Yoc2VxKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV4dHJhLWJvb2xlYW4tY2FzdFxuICAgICAgICBhbnNpQ29kZXMucG9wKClcbiAgICAgICAgcmV0dXJuICc8L3NwYW4+J1xuICAgICAgfVxuICAgICAgLy8gT3BlbiB0YWcuXG4gICAgICBhbnNpQ29kZXMucHVzaChzZXEpXG4gICAgICByZXR1cm4gb3RbMF0gPT09ICc8JyA/IG90IDogJzxzcGFuIHN0eWxlPVwiJyArIG90ICsgJztcIj4nXG4gICAgfVxuXG4gICAgdmFyIGN0ID0gX2Nsb3NlVGFnc1tzZXFdXG4gICAgaWYgKGN0KSB7XG4gICAgICAvLyBQb3Agc2VxdWVuY2VcbiAgICAgIGFuc2lDb2Rlcy5wb3AoKVxuICAgICAgcmV0dXJuIGN0XG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9KVxuXG4gIC8vIE1ha2Ugc3VyZSB0YWdzIGFyZSBjbG9zZWQuXG4gIHZhciBsID0gYW5zaUNvZGVzLmxlbmd0aFxuICA7KGwgPiAwKSAmJiAocmV0ICs9IEFycmF5KGwgKyAxKS5qb2luKCc8L3NwYW4+JykpXG5cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIEN1c3RvbWl6ZSBjb2xvcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gY29sb3JzIHJlZmVyZW5jZSB0byBfZGVmQ29sb3JzXG4gKi9cbmFuc2lIVE1MLnNldENvbG9ycyA9IGZ1bmN0aW9uIChjb2xvcnMpIHtcbiAgaWYgKHR5cGVvZiBjb2xvcnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgY29sb3JzYCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBPYmplY3QuJylcbiAgfVxuXG4gIHZhciBfZmluYWxDb2xvcnMgPSB7fVxuICBmb3IgKHZhciBrZXkgaW4gX2RlZkNvbG9ycykge1xuICAgIHZhciBoZXggPSBjb2xvcnMuaGFzT3duUHJvcGVydHkoa2V5KSA/IGNvbG9yc1trZXldIDogbnVsbFxuICAgIGlmICghaGV4KSB7XG4gICAgICBfZmluYWxDb2xvcnNba2V5XSA9IF9kZWZDb2xvcnNba2V5XVxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKCdyZXNldCcgPT09IGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhleCA9IFtoZXhdXG4gICAgICB9XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGV4KSB8fCBoZXgubGVuZ3RoID09PSAwIHx8IGhleC5zb21lKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaCAhPT0gJ3N0cmluZydcbiAgICAgIH0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhbiBBcnJheSBhbmQgZWFjaCBpdGVtIGNvdWxkIG9ubHkgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKVxuICAgICAgfVxuICAgICAgdmFyIGRlZkhleENvbG9yID0gX2RlZkNvbG9yc1trZXldXG4gICAgICBpZiAoIWhleFswXSkge1xuICAgICAgICBoZXhbMF0gPSBkZWZIZXhDb2xvclswXVxuICAgICAgfVxuICAgICAgaWYgKGhleC5sZW5ndGggPT09IDEgfHwgIWhleFsxXSkge1xuICAgICAgICBoZXggPSBbaGV4WzBdXVxuICAgICAgICBoZXgucHVzaChkZWZIZXhDb2xvclsxXSlcbiAgICAgIH1cblxuICAgICAgaGV4ID0gaGV4LnNsaWNlKDAsIDIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGEgaGV4IHN0cmluZywgZS5nLjogRkYwMDAwJylcbiAgICB9XG4gICAgX2ZpbmFsQ29sb3JzW2tleV0gPSBoZXhcbiAgfVxuICBfc2V0VGFncyhfZmluYWxDb2xvcnMpXG59XG5cbi8qKlxuICogUmVzZXQgY29sb3JzLlxuICovXG5hbnNpSFRNTC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgX3NldFRhZ3MoX2RlZkNvbG9ycylcbn1cblxuLyoqXG4gKiBFeHBvc2UgdGFncywgaW5jbHVkaW5nIG9wZW4gYW5kIGNsb3NlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuYW5zaUhUTUwudGFncyA9IHt9XG5cbmlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdvcGVuJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX29wZW5UYWdzIH1cbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdjbG9zZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9jbG9zZVRhZ3MgfVxuICB9KVxufSBlbHNlIHtcbiAgYW5zaUhUTUwudGFncy5vcGVuID0gX29wZW5UYWdzXG4gIGFuc2lIVE1MLnRhZ3MuY2xvc2UgPSBfY2xvc2VUYWdzXG59XG5cbmZ1bmN0aW9uIF9zZXRUYWdzIChjb2xvcnMpIHtcbiAgLy8gcmVzZXQgYWxsXG4gIF9vcGVuVGFnc1snMCddID0gJ2ZvbnQtd2VpZ2h0Om5vcm1hbDtvcGFjaXR5OjE7Y29sb3I6IycgKyBjb2xvcnMucmVzZXRbMF0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMV1cbiAgLy8gaW52ZXJzZVxuICBfb3BlblRhZ3NbJzcnXSA9ICdjb2xvcjojJyArIGNvbG9ycy5yZXNldFsxXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFswXVxuICAvLyBkYXJrIGdyZXlcbiAgX29wZW5UYWdzWyc5MCddID0gJ2NvbG9yOiMnICsgY29sb3JzLmRhcmtncmV5XG5cbiAgZm9yICh2YXIgY29kZSBpbiBfc3R5bGVzKSB7XG4gICAgdmFyIGNvbG9yID0gX3N0eWxlc1tjb2RlXVxuICAgIHZhciBvcmlDb2xvciA9IGNvbG9yc1tjb2xvcl0gfHwgJzAwMCdcbiAgICBfb3BlblRhZ3NbY29kZV0gPSAnY29sb3I6IycgKyBvcmlDb2xvclxuICAgIGNvZGUgPSBwYXJzZUludChjb2RlKVxuICAgIF9vcGVuVGFnc1soY29kZSArIDEwKS50b1N0cmluZygpXSA9ICdiYWNrZ3JvdW5kOiMnICsgb3JpQ29sb3JcbiAgfVxufVxuXG5hbnNpSFRNTC5yZXNldCgpXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5zaS1odG1sL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIC9bXFx1MDAxYlxcdTAwOWJdW1soKSM7P10qKD86WzAtOV17MSw0fSg/OjtbMC05XXswLDR9KSopP1swLTlBLVBSWmNmLW5xcnk9PjxdL2c7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Fuc2ktcmVnZXgvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ldmVudHMvZXZlbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgWG1sRW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL3htbC1lbnRpdGllcy5qcycpLFxuICBIdG1sNEVudGl0aWVzOiByZXF1aXJlKCcuL2xpYi9odG1sNC1lbnRpdGllcy5qcycpLFxuICBIdG1sNUVudGl0aWVzOiByZXF1aXJlKCcuL2xpYi9odG1sNS1lbnRpdGllcy5qcycpLFxuICBBbGxIdG1sRW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw1LWVudGl0aWVzLmpzJylcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaHRtbC1lbnRpdGllcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEhUTUxfQUxQSEEgPSBbJ2Fwb3MnLCAnbmJzcCcsICdpZXhjbCcsICdjZW50JywgJ3BvdW5kJywgJ2N1cnJlbicsICd5ZW4nLCAnYnJ2YmFyJywgJ3NlY3QnLCAndW1sJywgJ2NvcHknLCAnb3JkZicsICdsYXF1bycsICdub3QnLCAnc2h5JywgJ3JlZycsICdtYWNyJywgJ2RlZycsICdwbHVzbW4nLCAnc3VwMicsICdzdXAzJywgJ2FjdXRlJywgJ21pY3JvJywgJ3BhcmEnLCAnbWlkZG90JywgJ2NlZGlsJywgJ3N1cDEnLCAnb3JkbScsICdyYXF1bycsICdmcmFjMTQnLCAnZnJhYzEyJywgJ2ZyYWMzNCcsICdpcXVlc3QnLCAnQWdyYXZlJywgJ0FhY3V0ZScsICdBY2lyYycsICdBdGlsZGUnLCAnQXVtbCcsICdBcmluZycsICdBZWxpZycsICdDY2VkaWwnLCAnRWdyYXZlJywgJ0VhY3V0ZScsICdFY2lyYycsICdFdW1sJywgJ0lncmF2ZScsICdJYWN1dGUnLCAnSWNpcmMnLCAnSXVtbCcsICdFVEgnLCAnTnRpbGRlJywgJ09ncmF2ZScsICdPYWN1dGUnLCAnT2NpcmMnLCAnT3RpbGRlJywgJ091bWwnLCAndGltZXMnLCAnT3NsYXNoJywgJ1VncmF2ZScsICdVYWN1dGUnLCAnVWNpcmMnLCAnVXVtbCcsICdZYWN1dGUnLCAnVEhPUk4nLCAnc3psaWcnLCAnYWdyYXZlJywgJ2FhY3V0ZScsICdhY2lyYycsICdhdGlsZGUnLCAnYXVtbCcsICdhcmluZycsICdhZWxpZycsICdjY2VkaWwnLCAnZWdyYXZlJywgJ2VhY3V0ZScsICdlY2lyYycsICdldW1sJywgJ2lncmF2ZScsICdpYWN1dGUnLCAnaWNpcmMnLCAnaXVtbCcsICdldGgnLCAnbnRpbGRlJywgJ29ncmF2ZScsICdvYWN1dGUnLCAnb2NpcmMnLCAnb3RpbGRlJywgJ291bWwnLCAnZGl2aWRlJywgJ29zbGFzaCcsICd1Z3JhdmUnLCAndWFjdXRlJywgJ3VjaXJjJywgJ3V1bWwnLCAneWFjdXRlJywgJ3Rob3JuJywgJ3l1bWwnLCAncXVvdCcsICdhbXAnLCAnbHQnLCAnZ3QnLCAnT0VsaWcnLCAnb2VsaWcnLCAnU2Nhcm9uJywgJ3NjYXJvbicsICdZdW1sJywgJ2NpcmMnLCAndGlsZGUnLCAnZW5zcCcsICdlbXNwJywgJ3RoaW5zcCcsICd6d25qJywgJ3p3aicsICdscm0nLCAncmxtJywgJ25kYXNoJywgJ21kYXNoJywgJ2xzcXVvJywgJ3JzcXVvJywgJ3NicXVvJywgJ2xkcXVvJywgJ3JkcXVvJywgJ2JkcXVvJywgJ2RhZ2dlcicsICdEYWdnZXInLCAncGVybWlsJywgJ2xzYXF1bycsICdyc2FxdW8nLCAnZXVybycsICdmbm9mJywgJ0FscGhhJywgJ0JldGEnLCAnR2FtbWEnLCAnRGVsdGEnLCAnRXBzaWxvbicsICdaZXRhJywgJ0V0YScsICdUaGV0YScsICdJb3RhJywgJ0thcHBhJywgJ0xhbWJkYScsICdNdScsICdOdScsICdYaScsICdPbWljcm9uJywgJ1BpJywgJ1JobycsICdTaWdtYScsICdUYXUnLCAnVXBzaWxvbicsICdQaGknLCAnQ2hpJywgJ1BzaScsICdPbWVnYScsICdhbHBoYScsICdiZXRhJywgJ2dhbW1hJywgJ2RlbHRhJywgJ2Vwc2lsb24nLCAnemV0YScsICdldGEnLCAndGhldGEnLCAnaW90YScsICdrYXBwYScsICdsYW1iZGEnLCAnbXUnLCAnbnUnLCAneGknLCAnb21pY3JvbicsICdwaScsICdyaG8nLCAnc2lnbWFmJywgJ3NpZ21hJywgJ3RhdScsICd1cHNpbG9uJywgJ3BoaScsICdjaGknLCAncHNpJywgJ29tZWdhJywgJ3RoZXRhc3ltJywgJ3Vwc2loJywgJ3BpdicsICdidWxsJywgJ2hlbGxpcCcsICdwcmltZScsICdQcmltZScsICdvbGluZScsICdmcmFzbCcsICd3ZWllcnAnLCAnaW1hZ2UnLCAncmVhbCcsICd0cmFkZScsICdhbGVmc3ltJywgJ2xhcnInLCAndWFycicsICdyYXJyJywgJ2RhcnInLCAnaGFycicsICdjcmFycicsICdsQXJyJywgJ3VBcnInLCAnckFycicsICdkQXJyJywgJ2hBcnInLCAnZm9yYWxsJywgJ3BhcnQnLCAnZXhpc3QnLCAnZW1wdHknLCAnbmFibGEnLCAnaXNpbicsICdub3RpbicsICduaScsICdwcm9kJywgJ3N1bScsICdtaW51cycsICdsb3dhc3QnLCAncmFkaWMnLCAncHJvcCcsICdpbmZpbicsICdhbmcnLCAnYW5kJywgJ29yJywgJ2NhcCcsICdjdXAnLCAnaW50JywgJ3RoZXJlNCcsICdzaW0nLCAnY29uZycsICdhc3ltcCcsICduZScsICdlcXVpdicsICdsZScsICdnZScsICdzdWInLCAnc3VwJywgJ25zdWInLCAnc3ViZScsICdzdXBlJywgJ29wbHVzJywgJ290aW1lcycsICdwZXJwJywgJ3Nkb3QnLCAnbGNlaWwnLCAncmNlaWwnLCAnbGZsb29yJywgJ3JmbG9vcicsICdsYW5nJywgJ3JhbmcnLCAnbG96JywgJ3NwYWRlcycsICdjbHVicycsICdoZWFydHMnLCAnZGlhbXMnXTtcbnZhciBIVE1MX0NPREVTID0gWzM5LCAxNjAsIDE2MSwgMTYyLCAxNjMsIDE2NCwgMTY1LCAxNjYsIDE2NywgMTY4LCAxNjksIDE3MCwgMTcxLCAxNzIsIDE3MywgMTc0LCAxNzUsIDE3NiwgMTc3LCAxNzgsIDE3OSwgMTgwLCAxODEsIDE4MiwgMTgzLCAxODQsIDE4NSwgMTg2LCAxODcsIDE4OCwgMTg5LCAxOTAsIDE5MSwgMTkyLCAxOTMsIDE5NCwgMTk1LCAxOTYsIDE5NywgMTk4LCAxOTksIDIwMCwgMjAxLCAyMDIsIDIwMywgMjA0LCAyMDUsIDIwNiwgMjA3LCAyMDgsIDIwOSwgMjEwLCAyMTEsIDIxMiwgMjEzLCAyMTQsIDIxNSwgMjE2LCAyMTcsIDIxOCwgMjE5LCAyMjAsIDIyMSwgMjIyLCAyMjMsIDIyNCwgMjI1LCAyMjYsIDIyNywgMjI4LCAyMjksIDIzMCwgMjMxLCAyMzIsIDIzMywgMjM0LCAyMzUsIDIzNiwgMjM3LCAyMzgsIDIzOSwgMjQwLCAyNDEsIDI0MiwgMjQzLCAyNDQsIDI0NSwgMjQ2LCAyNDcsIDI0OCwgMjQ5LCAyNTAsIDI1MSwgMjUyLCAyNTMsIDI1NCwgMjU1LCAzNCwgMzgsIDYwLCA2MiwgMzM4LCAzMzksIDM1MiwgMzUzLCAzNzYsIDcxMCwgNzMyLCA4MTk0LCA4MTk1LCA4MjAxLCA4MjA0LCA4MjA1LCA4MjA2LCA4MjA3LCA4MjExLCA4MjEyLCA4MjE2LCA4MjE3LCA4MjE4LCA4MjIwLCA4MjIxLCA4MjIyLCA4MjI0LCA4MjI1LCA4MjQwLCA4MjQ5LCA4MjUwLCA4MzY0LCA0MDIsIDkxMywgOTE0LCA5MTUsIDkxNiwgOTE3LCA5MTgsIDkxOSwgOTIwLCA5MjEsIDkyMiwgOTIzLCA5MjQsIDkyNSwgOTI2LCA5MjcsIDkyOCwgOTI5LCA5MzEsIDkzMiwgOTMzLCA5MzQsIDkzNSwgOTM2LCA5MzcsIDk0NSwgOTQ2LCA5NDcsIDk0OCwgOTQ5LCA5NTAsIDk1MSwgOTUyLCA5NTMsIDk1NCwgOTU1LCA5NTYsIDk1NywgOTU4LCA5NTksIDk2MCwgOTYxLCA5NjIsIDk2MywgOTY0LCA5NjUsIDk2NiwgOTY3LCA5NjgsIDk2OSwgOTc3LCA5NzgsIDk4MiwgODIyNiwgODIzMCwgODI0MiwgODI0MywgODI1NCwgODI2MCwgODQ3MiwgODQ2NSwgODQ3NiwgODQ4MiwgODUwMSwgODU5MiwgODU5MywgODU5NCwgODU5NSwgODU5NiwgODYyOSwgODY1NiwgODY1NywgODY1OCwgODY1OSwgODY2MCwgODcwNCwgODcwNiwgODcwNywgODcwOSwgODcxMSwgODcxMiwgODcxMywgODcxNSwgODcxOSwgODcyMSwgODcyMiwgODcyNywgODczMCwgODczMywgODczNCwgODczNiwgODc0MywgODc0NCwgODc0NSwgODc0NiwgODc0NywgODc1NiwgODc2NCwgODc3MywgODc3NiwgODgwMCwgODgwMSwgODgwNCwgODgwNSwgODgzNCwgODgzNSwgODgzNiwgODgzOCwgODgzOSwgODg1MywgODg1NSwgODg2OSwgODkwMSwgODk2OCwgODk2OSwgODk3MCwgODk3MSwgOTAwMSwgOTAwMiwgOTY3NCwgOTgyNCwgOTgyNywgOTgyOSwgOTgzMF07XG5cbnZhciBhbHBoYUluZGV4ID0ge307XG52YXIgbnVtSW5kZXggPSB7fTtcblxudmFyIGkgPSAwO1xudmFyIGxlbmd0aCA9IEhUTUxfQUxQSEEubGVuZ3RoO1xud2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICB2YXIgYSA9IEhUTUxfQUxQSEFbaV07XG4gICAgdmFyIGMgPSBIVE1MX0NPREVTW2ldO1xuICAgIGFscGhhSW5kZXhbYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgIG51bUluZGV4W2NdID0gYTtcbiAgICBpKys7XG59XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEh0bWw0RW50aXRpZXMoKSB7fVxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mKCM/W1xcd1xcZF0rKTs/L2csIGZ1bmN0aW9uKHMsIGVudGl0eSkge1xuICAgICAgICB2YXIgY2hyO1xuICAgICAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gZW50aXR5LmNoYXJBdCgxKS50b0xvd2VyQ2FzZSgpID09PSAneCcgP1xuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMiksIDE2KSA6XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigxKSk7XG5cbiAgICAgICAgICAgIGlmICghKGlzTmFOKGNvZGUpIHx8IGNvZGUgPCAtMzI3NjggfHwgY29kZSA+IDY1NTM1KSkge1xuICAgICAgICAgICAgICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIgPSBhbHBoYUluZGV4W2VudGl0eV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNociB8fCBzO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmRlY29kZShzdHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGFscGhhID0gbnVtSW5kZXhbc3RyLmNoYXJDb2RlQXQoaSldO1xuICAgICAgICByZXN1bHQgKz0gYWxwaGEgPyBcIiZcIiArIGFscGhhICsgXCI7XCIgOiBzdHIuY2hhckF0KGkpO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlKHN0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgY2MgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGFscGhhID0gbnVtSW5kZXhbY2NdO1xuICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY2MgPCAzMiB8fCBjYyA+IDEyNikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJiNcIiArIGNjICsgXCI7XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sNEVudGl0aWVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2h0bWwtZW50aXRpZXMvbGliL2h0bWw0LWVudGl0aWVzLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQUxQSEFfSU5ERVggPSB7XG4gICAgJyZsdCc6ICc8JyxcbiAgICAnJmd0JzogJz4nLFxuICAgICcmcXVvdCc6ICdcIicsXG4gICAgJyZhcG9zJzogJ1xcJycsXG4gICAgJyZhbXAnOiAnJicsXG4gICAgJyZsdDsnOiAnPCcsXG4gICAgJyZndDsnOiAnPicsXG4gICAgJyZxdW90Oyc6ICdcIicsXG4gICAgJyZhcG9zOyc6ICdcXCcnLFxuICAgICcmYW1wOyc6ICcmJ1xufTtcblxudmFyIENIQVJfSU5ERVggPSB7XG4gICAgNjA6ICdsdCcsXG4gICAgNjI6ICdndCcsXG4gICAgMzQ6ICdxdW90JyxcbiAgICAzOTogJ2Fwb3MnLFxuICAgIDM4OiAnYW1wJ1xufTtcblxudmFyIENIQVJfU19JTkRFWCA9IHtcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAnXFwnJzogJyZhcG9zOycsXG4gICAgJyYnOiAnJmFtcDsnXG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBYbWxFbnRpdGllcygpIHt9XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC88fD58XCJ8J3wmL2csIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIENIQVJfU19JTkRFWFtzXTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJiM/WzAtOWEtekEtWl0rOz8vZywgZnVuY3Rpb24ocykge1xuICAgICAgICBpZiAocy5jaGFyQXQoMSkgPT09ICcjJykge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBzLmNoYXJBdCgyKS50b0xvd2VyQ2FzZSgpID09PSAneCcgP1xuICAgICAgICAgICAgICAgIHBhcnNlSW50KHMuc3Vic3RyKDMpLCAxNikgOlxuICAgICAgICAgICAgICAgIHBhcnNlSW50KHMuc3Vic3RyKDIpKTtcblxuICAgICAgICAgICAgaWYgKGlzTmFOKGNvZGUpIHx8IGNvZGUgPCAtMzI3NjggfHwgY29kZSA+IDY1NTM1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFMUEhBX0lOREVYW3NdIHx8IHM7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBhbHBoYSA9IENIQVJfSU5ERVhbY107XG4gICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMzIgfHwgYyA+IDEyNikge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ2h0ID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ2h0KSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xuIH07XG5cbm1vZHVsZS5leHBvcnRzID0gWG1sRW50aXRpZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaHRtbC1lbnRpdGllcy9saWIveG1sLWVudGl0aWVzLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xuXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuXG4gICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWxcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyBcIldBUk5cIiA6IGRlZmF1bHRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wdW55Y29kZS9wdW55Y29kZS5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9xdWVyeXN0cmluZy1lczMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIHNvY2tqcy1jbGllbnQgdjEuMS40IHwgaHR0cDovL3NvY2tqcy5vcmcgfCBNSVQgbGljZW5zZSAqL1xuKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuU29ja0pTID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJhbnNwb3J0TGlzdCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0LWxpc3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21haW4nKSh0cmFuc3BvcnRMaXN0KTtcblxuLy8gVE9ETyBjYW4ndCBnZXQgcmlkIG9mIHRoaXMgdW50aWwgYWxsIHNlcnZlcnMgZG9cbmlmICgnX3NvY2tqc19vbmxvYWQnIGluIGdsb2JhbCkge1xuICBzZXRUaW1lb3V0KGdsb2JhbC5fc29ja2pzX29ubG9hZCwgMSk7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vbWFpblwiOjE0LFwiLi90cmFuc3BvcnQtbGlzdFwiOjE2fV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQnKVxuICA7XG5cbmZ1bmN0aW9uIENsb3NlRXZlbnQoKSB7XG4gIEV2ZW50LmNhbGwodGhpcyk7XG4gIHRoaXMuaW5pdEV2ZW50KCdjbG9zZScsIGZhbHNlLCBmYWxzZSk7XG4gIHRoaXMud2FzQ2xlYW4gPSBmYWxzZTtcbiAgdGhpcy5jb2RlID0gMDtcbiAgdGhpcy5yZWFzb24gPSAnJztcbn1cblxuaW5oZXJpdHMoQ2xvc2VFdmVudCwgRXZlbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsb3NlRXZlbnQ7XG5cbn0se1wiLi9ldmVudFwiOjQsXCJpbmhlcml0c1wiOjU3fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnR0YXJnZXQnKVxuICA7XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcbn1cblxuaW5oZXJpdHMoRXZlbnRFbWl0dGVyLCBFdmVudFRhcmdldCk7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodHlwZSkge1xuICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMub24odHlwZSwgZyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMF07XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XG4gIGlmICghbGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGVxdWl2YWxlbnQgb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncyA9IG5ldyBBcnJheShsIC0gMSk7XG4gIGZvciAodmFyIGFpID0gMTsgYWkgPCBsOyBhaSsrKSB7XG4gICAgYXJnc1thaSAtIDFdID0gYXJndW1lbnRzW2FpXTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBFdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxubW9kdWxlLmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG59LHtcIi4vZXZlbnR0YXJnZXRcIjo1LFwiaW5oZXJpdHNcIjo1N31dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBFdmVudChldmVudFR5cGUpIHtcbiAgdGhpcy50eXBlID0gZXZlbnRUeXBlO1xufVxuXG5FdmVudC5wcm90b3R5cGUuaW5pdEV2ZW50ID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBjYW5CdWJibGUsIGNhbmNlbGFibGUpIHtcbiAgdGhpcy50eXBlID0gZXZlbnRUeXBlO1xuICB0aGlzLmJ1YmJsZXMgPSBjYW5CdWJibGU7XG4gIHRoaXMuY2FuY2VsYWJsZSA9IGNhbmNlbGFibGU7XG4gIHRoaXMudGltZVN0YW1wID0gK25ldyBEYXRlKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge307XG5FdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHt9O1xuXG5FdmVudC5DQVBUVVJJTkdfUEhBU0UgPSAxO1xuRXZlbnQuQVRfVEFSR0VUID0gMjtcbkV2ZW50LkJVQkJMSU5HX1BIQVNFID0gMztcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudDtcblxufSx7fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qIFNpbXBsaWZpZWQgaW1wbGVtZW50YXRpb24gb2YgRE9NMiBFdmVudFRhcmdldC5cbiAqICAgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItRXZlbnRzL2V2ZW50cy5odG1sI0V2ZW50cy1FdmVudFRhcmdldFxuICovXG5cbmZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge1xuICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbn1cblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghKGV2ZW50VHlwZSBpbiB0aGlzLl9saXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0gPSBbXTtcbiAgfVxuICB2YXIgYXJyID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gIC8vICM0XG4gIGlmIChhcnIuaW5kZXhPZihsaXN0ZW5lcikgPT09IC0xKSB7XG4gICAgLy8gTWFrZSBhIGNvcHkgc28gYXMgbm90IHRvIGludGVyZmVyZSB3aXRoIGEgY3VycmVudCBkaXNwYXRjaEV2ZW50LlxuICAgIGFyciA9IGFyci5jb25jYXQoW2xpc3RlbmVyXSk7XG4gIH1cbiAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0gPSBhcnI7XG59O1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICBpZiAoIWFycikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaWR4ID0gYXJyLmluZGV4T2YobGlzdGVuZXIpO1xuICBpZiAoaWR4ICE9PSAtMSkge1xuICAgIGlmIChhcnIubGVuZ3RoID4gMSkge1xuICAgICAgLy8gTWFrZSBhIGNvcHkgc28gYXMgbm90IHRvIGludGVyZmVyZSB3aXRoIGEgY3VycmVudCBkaXNwYXRjaEV2ZW50LlxuICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0gPSBhcnIuc2xpY2UoMCwgaWR4KS5jb25jYXQoYXJyLnNsaWNlKGlkeCArIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbn07XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBldmVudCA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIHQgPSBldmVudC50eXBlO1xuICAvLyBlcXVpdmFsZW50IG9mIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IFtldmVudF0gOiBBcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAvLyBUT0RPOiBUaGlzIGRvZXNuJ3QgbWF0Y2ggdGhlIHJlYWwgYmVoYXZpb3I7IHBlciBzcGVjLCBvbmZvbyBnZXRcbiAgLy8gdGhlaXIgcGxhY2UgaW4gbGluZSBmcm9tIHRoZSAvZmlyc3QvIHRpbWUgdGhleSdyZSBzZXQgZnJvbVxuICAvLyBub24tbnVsbC4gQWx0aG91Z2ggV2ViS2l0IGJ1bXBzIGl0IHRvIHRoZSBlbmQgZXZlcnkgdGltZSBpdCdzXG4gIC8vIHNldC5cbiAgaWYgKHRoaXNbJ29uJyArIHRdKSB7XG4gICAgdGhpc1snb24nICsgdF0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cbiAgaWYgKHQgaW4gdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgLy8gR3JhYiBhIHJlZmVyZW5jZSB0byB0aGUgbGlzdGVuZXJzIGxpc3QuIHJlbW92ZUV2ZW50TGlzdGVuZXIgbWF5IGFsdGVyIHRoZSBsaXN0LlxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbdF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRUYXJnZXQ7XG5cbn0se31dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgO1xuXG5mdW5jdGlvbiBUcmFuc3BvcnRNZXNzYWdlRXZlbnQoZGF0YSkge1xuICBFdmVudC5jYWxsKHRoaXMpO1xuICB0aGlzLmluaXRFdmVudCgnbWVzc2FnZScsIGZhbHNlLCBmYWxzZSk7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG59XG5cbmluaGVyaXRzKFRyYW5zcG9ydE1lc3NhZ2VFdmVudCwgRXZlbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydE1lc3NhZ2VFdmVudDtcblxufSx7XCIuL2V2ZW50XCI6NCxcImluaGVyaXRzXCI6NTd9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pZnJhbWUnKVxuICA7XG5cbmZ1bmN0aW9uIEZhY2FkZUpTKHRyYW5zcG9ydCkge1xuICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRyYW5zcG9ydC5vbignbWVzc2FnZScsIHRoaXMuX3RyYW5zcG9ydE1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gIHRyYW5zcG9ydC5vbignY2xvc2UnLCB0aGlzLl90cmFuc3BvcnRDbG9zZS5iaW5kKHRoaXMpKTtcbn1cblxuRmFjYWRlSlMucHJvdG90eXBlLl90cmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgnYycsIEpTT04zLnN0cmluZ2lmeShbY29kZSwgcmVhc29uXSkpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fdHJhbnNwb3J0TWVzc2FnZSA9IGZ1bmN0aW9uKGZyYW1lKSB7XG4gIGlmcmFtZVV0aWxzLnBvc3RNZXNzYWdlKCd0JywgZnJhbWUpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoZGF0YSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgdGhpcy5fdHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWNhZGVKUztcblxufSx7XCIuL3V0aWxzL2lmcmFtZVwiOjQ3LFwianNvbjNcIjo1OH1dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50JylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBGYWNhZGVKUyA9IHJlcXVpcmUoJy4vZmFjYWRlJylcbiAgLCBJbmZvSWZyYW1lUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2luZm8taWZyYW1lLXJlY2VpdmVyJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaWZyYW1lJylcbiAgLCBsb2MgPSByZXF1aXJlKCcuL2xvY2F0aW9uJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmlmcmFtZS1ib290c3RyYXAnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihTb2NrSlMsIGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgdmFyIHRyYW5zcG9ydE1hcCA9IHt9O1xuICBhdmFpbGFibGVUcmFuc3BvcnRzLmZvckVhY2goZnVuY3Rpb24oYXQpIHtcbiAgICBpZiAoYXQuZmFjYWRlVHJhbnNwb3J0KSB7XG4gICAgICB0cmFuc3BvcnRNYXBbYXQuZmFjYWRlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWVdID0gYXQuZmFjYWRlVHJhbnNwb3J0O1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gaGFyZC1jb2RlZCBmb3IgdGhlIGluZm8gaWZyYW1lXG4gIC8vIFRPRE8gc2VlIGlmIHdlIGNhbiBtYWtlIHRoaXMgbW9yZSBkeW5hbWljXG4gIHRyYW5zcG9ydE1hcFtJbmZvSWZyYW1lUmVjZWl2ZXIudHJhbnNwb3J0TmFtZV0gPSBJbmZvSWZyYW1lUmVjZWl2ZXI7XG4gIHZhciBwYXJlbnRPcmlnaW47XG5cbiAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gIFNvY2tKUy5ib290c3RyYXBfaWZyYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbiAgICB2YXIgZmFjYWRlO1xuICAgIGlmcmFtZVV0aWxzLmN1cnJlbnRXaW5kb3dJZCA9IGxvYy5oYXNoLnNsaWNlKDEpO1xuICAgIHZhciBvbk1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5zb3VyY2UgIT09IHBhcmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhcmVudE9yaWdpbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGFyZW50T3JpZ2luID0gZS5vcmlnaW47XG4gICAgICB9XG4gICAgICBpZiAoZS5vcmlnaW4gIT09IHBhcmVudE9yaWdpbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpZnJhbWVNZXNzYWdlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWZyYW1lTWVzc2FnZSA9IEpTT04zLnBhcnNlKGUuZGF0YSk7XG4gICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgIGRlYnVnKCdiYWQganNvbicsIGUuZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlmcmFtZU1lc3NhZ2Uud2luZG93SWQgIT09IGlmcmFtZVV0aWxzLmN1cnJlbnRXaW5kb3dJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGlmcmFtZU1lc3NhZ2UudHlwZSkge1xuICAgICAgY2FzZSAncyc6XG4gICAgICAgIHZhciBwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHAgPSBKU09OMy5wYXJzZShpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmVyc2lvbiA9IHBbMF07XG4gICAgICAgIHZhciB0cmFuc3BvcnQgPSBwWzFdO1xuICAgICAgICB2YXIgdHJhbnNVcmwgPSBwWzJdO1xuICAgICAgICB2YXIgYmFzZVVybCA9IHBbM107XG4gICAgICAgIGRlYnVnKHZlcnNpb24sIHRyYW5zcG9ydCwgdHJhbnNVcmwsIGJhc2VVcmwpO1xuICAgICAgICAvLyBjaGFuZ2UgdGhpcyB0byBzZW12ZXIgbG9naWNcbiAgICAgICAgaWYgKHZlcnNpb24gIT09IFNvY2tKUy52ZXJzaW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBhdGlibGUgU29ja0pTISBNYWluIHNpdGUgdXNlczonICtcbiAgICAgICAgICAgICAgICAgICAgJyBcIicgKyB2ZXJzaW9uICsgJ1wiLCB0aGUgaWZyYW1lOicgK1xuICAgICAgICAgICAgICAgICAgICAnIFwiJyArIFNvY2tKUy52ZXJzaW9uICsgJ1wiLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1cmxVdGlscy5pc09yaWdpbkVxdWFsKHRyYW5zVXJsLCBsb2MuaHJlZikgfHxcbiAgICAgICAgICAgICF1cmxVdGlscy5pc09yaWdpbkVxdWFsKGJhc2VVcmwsIGxvYy5ocmVmKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBjb25uZWN0IHRvIGRpZmZlcmVudCBkb21haW4gZnJvbSB3aXRoaW4gYW4gJyArXG4gICAgICAgICAgICAgICAgICAgICdpZnJhbWUuICgnICsgbG9jLmhyZWYgKyAnLCAnICsgdHJhbnNVcmwgKyAnLCAnICsgYmFzZVVybCArICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgZmFjYWRlID0gbmV3IEZhY2FkZUpTKG5ldyB0cmFuc3BvcnRNYXBbdHJhbnNwb3J0XSh0cmFuc1VybCwgYmFzZVVybCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ20nOlxuICAgICAgICBmYWNhZGUuX3NlbmQoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjJzpcbiAgICAgICAgaWYgKGZhY2FkZSkge1xuICAgICAgICAgIGZhY2FkZS5fY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBmYWNhZGUgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbWVzc2FnZScsIG9uTWVzc2FnZSk7XG5cbiAgICAvLyBTdGFydFxuICAgIGlmcmFtZVV0aWxzLnBvc3RNZXNzYWdlKCdzJyk7XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi9mYWNhZGVcIjo3LFwiLi9pbmZvLWlmcmFtZS1yZWNlaXZlclwiOjEwLFwiLi9sb2NhdGlvblwiOjEzLFwiLi91dGlscy9ldmVudFwiOjQ2LFwiLi91dGlscy9pZnJhbWVcIjo0NyxcIi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwianNvbjNcIjo1OH1dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3QnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1hamF4Jyk7XG59XG5cbmZ1bmN0aW9uIEluZm9BamF4KHVybCwgQWpheE9iamVjdCkge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0MCA9ICtuZXcgRGF0ZSgpO1xuICB0aGlzLnhvID0gbmV3IEFqYXhPYmplY3QoJ0dFVCcsIHVybCk7XG5cbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgICB2YXIgaW5mbywgcnR0O1xuICAgIGlmIChzdGF0dXMgPT09IDIwMCkge1xuICAgICAgcnR0ID0gKCtuZXcgRGF0ZSgpKSAtIHQwO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbmZvID0gSlNPTjMucGFyc2UodGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW9iamVjdFV0aWxzLmlzT2JqZWN0KGluZm8pKSB7XG4gICAgICAgIGluZm8gPSB7fTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICAgIHNlbGYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhJbmZvQWpheCwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb0FqYXgucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMueG8uY2xvc2UoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb0FqYXg7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL3V0aWxzL29iamVjdFwiOjQ5LFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OH1dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgSW5mb0FqYXggPSByZXF1aXJlKCcuL2luZm8tYWpheCcpXG4gIDtcblxuZnVuY3Rpb24gSW5mb1JlY2VpdmVySWZyYW1lKHRyYW5zVXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5pciA9IG5ldyBJbmZvQWpheCh0cmFuc1VybCwgWEhSTG9jYWxPYmplY3QpO1xuICB0aGlzLmlyLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICAgIHNlbGYuaXIgPSBudWxsO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIEpTT04zLnN0cmluZ2lmeShbaW5mbywgcnR0XSkpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSW5mb1JlY2VpdmVySWZyYW1lLCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvUmVjZWl2ZXJJZnJhbWUudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUtaW5mby1yZWNlaXZlcic7XG5cbkluZm9SZWNlaXZlcklmcmFtZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXIpIHtcbiAgICB0aGlzLmlyLmNsb3NlKCk7XG4gICAgdGhpcy5pciA9IG51bGw7XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb1JlY2VpdmVySWZyYW1lO1xuXG59LHtcIi4vaW5mby1hamF4XCI6OSxcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWxcIjozNyxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OH1dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50JylcbiAgLCBJZnJhbWVUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9pZnJhbWUnKVxuICAsIEluZm9SZWNlaXZlcklmcmFtZSA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUtcmVjZWl2ZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1pZnJhbWUnKTtcbn1cblxuZnVuY3Rpb24gSW5mb0lmcmFtZShiYXNlVXJsLCB1cmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaWZyID0gc2VsZi5pZnIgPSBuZXcgSWZyYW1lVHJhbnNwb3J0KEluZm9SZWNlaXZlcklmcmFtZS50cmFuc3BvcnROYW1lLCB1cmwsIGJhc2VVcmwpO1xuXG4gICAgaWZyLm9uY2UoJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICAgIGlmIChtc2cpIHtcbiAgICAgICAgdmFyIGQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZCA9IEpTT04zLnBhcnNlKG1zZyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBtc2cpO1xuICAgICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmZvID0gZFswXSwgcnR0ID0gZFsxXTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICAgICAgfVxuICAgICAgc2VsZi5jbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgaWZyLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgc2VsZi5jbG9zZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRPRE8gdGhpcyBzZWVtcyB0aGUgc2FtZSBhcyB0aGUgJ25lZWRCb2R5JyBmcm9tIHRyYW5zcG9ydHNcbiAgaWYgKCFnbG9iYWwuZG9jdW1lbnQuYm9keSkge1xuICAgIHV0aWxzLmF0dGFjaEV2ZW50KCdsb2FkJywgZ28pO1xuICB9IGVsc2Uge1xuICAgIGdvKCk7XG4gIH1cbn1cblxuaW5oZXJpdHMoSW5mb0lmcmFtZSwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb0lmcmFtZS5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xufTtcblxuSW5mb0lmcmFtZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaWZyKSB7XG4gICAgdGhpcy5pZnIuY2xvc2UoKTtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLmlmciA9IG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9JZnJhbWU7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vaW5mby1pZnJhbWUtcmVjZWl2ZXJcIjoxMCxcIi4vdHJhbnNwb3J0L2lmcmFtZVwiOjIyLFwiLi91dGlscy9ldmVudFwiOjQ2LFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OH1dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBYRFIgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGRyJylcbiAgLCBYSFJDb3JzID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwnKVxuICAsIFhIUkZha2UgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWZha2UnKVxuICAsIEluZm9JZnJhbWUgPSByZXF1aXJlKCcuL2luZm8taWZyYW1lJylcbiAgLCBJbmZvQWpheCA9IHJlcXVpcmUoJy4vaW5mby1hamF4JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8tcmVjZWl2ZXInKTtcbn1cblxuZnVuY3Rpb24gSW5mb1JlY2VpdmVyKGJhc2VVcmwsIHVybEluZm8pIHtcbiAgZGVidWcoYmFzZVVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmRvWGhyKGJhc2VVcmwsIHVybEluZm8pO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoSW5mb1JlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG4vLyBUT0RPIHRoaXMgaXMgY3VycmVudGx5IGlnbm9yaW5nIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSB0cmFuc3BvcnRzIGFuZCB0aGUgd2hpdGVsaXN0XG5cbkluZm9SZWNlaXZlci5fZ2V0UmVjZWl2ZXIgPSBmdW5jdGlvbihiYXNlVXJsLCB1cmwsIHVybEluZm8pIHtcbiAgLy8gZGV0ZXJtaW5lIG1ldGhvZCBvZiBDT1JTIHN1cHBvcnQgKGlmIG5lZWRlZClcbiAgaWYgKHVybEluZm8uc2FtZU9yaWdpbikge1xuICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJMb2NhbCk7XG4gIH1cbiAgaWYgKFhIUkNvcnMuZW5hYmxlZCkge1xuICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJDb3JzKTtcbiAgfVxuICBpZiAoWERSLmVuYWJsZWQgJiYgdXJsSW5mby5zYW1lU2NoZW1lKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhEUik7XG4gIH1cbiAgaWYgKEluZm9JZnJhbWUuZW5hYmxlZCgpKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvSWZyYW1lKGJhc2VVcmwsIHVybCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkZha2UpO1xufTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5kb1hociA9IGZ1bmN0aW9uKGJhc2VVcmwsIHVybEluZm8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCB1cmwgPSB1cmxVdGlscy5hZGRQYXRoKGJhc2VVcmwsICcvaW5mbycpXG4gICAgO1xuICBkZWJ1ZygnZG9YaHInLCB1cmwpO1xuXG4gIHRoaXMueG8gPSBJbmZvUmVjZWl2ZXIuX2dldFJlY2VpdmVyKGJhc2VVcmwsIHVybCwgdXJsSW5mbyk7XG5cbiAgdGhpcy50aW1lb3V0UmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndGltZW91dCcpO1xuICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gIH0sIEluZm9SZWNlaXZlci50aW1lb3V0KTtcblxuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICAgIGRlYnVnKCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICB9KTtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbih3YXNDbGVhbikge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFJlZik7XG4gIHRoaXMudGltZW91dFJlZiA9IG51bGw7XG4gIGlmICghd2FzQ2xlYW4gJiYgdGhpcy54bykge1xuICAgIHRoaXMueG8uY2xvc2UoKTtcbiAgfVxuICB0aGlzLnhvID0gbnVsbDtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xufTtcblxuSW5mb1JlY2VpdmVyLnRpbWVvdXQgPSA4MDAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9SZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vaW5mby1hamF4XCI6OSxcIi4vaW5mby1pZnJhbWVcIjoxMSxcIi4vdHJhbnNwb3J0L3NlbmRlci94ZHJcIjozNCxcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItY29yc1wiOjM1LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1mYWtlXCI6MzYsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCIuL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5sb2NhdGlvbiB8fCB7XG4gIG9yaWdpbjogJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAnXG4sIHByb3RvY29sOiAnaHR0cCdcbiwgaG9zdDogJ2xvY2FsaG9zdCdcbiwgcG9ydDogODBcbiwgaHJlZjogJ2h0dHA6Ly9sb2NhbGhvc3QvJ1xuLCBoYXNoOiAnJ1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL3NoaW1zJyk7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4vdXRpbHMvcmFuZG9tJylcbiAgLCBlc2NhcGUgPSByZXF1aXJlKCcuL3V0aWxzL2VzY2FwZScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIHRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdXRpbHMvdHJhbnNwb3J0JylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0JylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi91dGlscy9icm93c2VyJylcbiAgLCBsb2cgPSByZXF1aXJlKCcuL3V0aWxzL2xvZycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L2V2ZW50JylcbiAgLCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnQvZXZlbnR0YXJnZXQnKVxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxuICAsIENsb3NlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L2Nsb3NlJylcbiAgLCBUcmFuc3BvcnRNZXNzYWdlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L3RyYW5zLW1lc3NhZ2UnKVxuICAsIEluZm9SZWNlaXZlciA9IHJlcXVpcmUoJy4vaW5mby1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDptYWluJyk7XG59XG5cbnZhciB0cmFuc3BvcnRzO1xuXG4vLyBmb2xsb3cgY29uc3RydWN0b3Igc3RlcHMgZGVmaW5lZCBhdCBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJzb2NrZXRzLyN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuZnVuY3Rpb24gU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrSlMpKSB7XG4gICAgcmV0dXJuIG5ldyBTb2NrSlModXJsLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdTb2NrSlM6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudFwiKTtcbiAgfVxuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DT05ORUNUSU5HO1xuICB0aGlzLmV4dGVuc2lvbnMgPSAnJztcbiAgdGhpcy5wcm90b2NvbCA9ICcnO1xuXG4gIC8vIG5vbi1zdGFuZGFyZCBleHRlbnNpb25cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChvcHRpb25zLnByb3RvY29sc193aGl0ZWxpc3QpIHtcbiAgICBsb2cud2FybihcIidwcm90b2NvbHNfd2hpdGVsaXN0JyBpcyBERVBSRUNBVEVELiBVc2UgJ3RyYW5zcG9ydHMnIGluc3RlYWQuXCIpO1xuICB9XG4gIHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QgPSBvcHRpb25zLnRyYW5zcG9ydHM7XG4gIHRoaXMuX3RyYW5zcG9ydE9wdGlvbnMgPSBvcHRpb25zLnRyYW5zcG9ydE9wdGlvbnMgfHwge307XG5cbiAgdmFyIHNlc3Npb25JZCA9IG9wdGlvbnMuc2Vzc2lvbklkIHx8IDg7XG4gIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJhbmRvbS5zdHJpbmcoc2Vzc2lvbklkKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lmIHNlc3Npb25JZCBpcyB1c2VkIGluIHRoZSBvcHRpb25zLCBpdCBuZWVkcyB0byBiZSBhIG51bWJlciBvciBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXIgfHwgcmFuZG9tLm51bWJlclN0cmluZygxMDAwKTtcblxuICAvLyBTdGVwIDEgb2YgV1Mgc3BlYyAtIHBhcnNlIGFuZCB2YWxpZGF0ZSB0aGUgdXJsLiBJc3N1ZSAjOFxuICB2YXIgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpO1xuICBpZiAoIXBhcnNlZFVybC5ob3N0IHx8ICFwYXJzZWRVcmwucHJvdG9jb2wpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMICdcIiArIHVybCArIFwiJyBpcyBpbnZhbGlkXCIpO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5oYXNoKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUaGUgVVJMIG11c3Qgbm90IGNvbnRhaW4gYSBmcmFnbWVudCcpO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ2h0dHA6JyAmJiBwYXJzZWRVcmwucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIFVSTCdzIHNjaGVtZSBtdXN0IGJlIGVpdGhlciAnaHR0cDonIG9yICdodHRwczonLiAnXCIgKyBwYXJzZWRVcmwucHJvdG9jb2wgKyBcIicgaXMgbm90IGFsbG93ZWQuXCIpO1xuICB9XG5cbiAgdmFyIHNlY3VyZSA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gIC8vIFN0ZXAgMiAtIGRvbid0IGFsbG93IHNlY3VyZSBvcmlnaW4gd2l0aCBhbiBpbnNlY3VyZSBwcm90b2NvbFxuICBpZiAobG9jLnByb3RvY29sID09PSAnaHR0cHMnICYmICFzZWN1cmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3VyaXR5RXJyb3I6IEFuIGluc2VjdXJlIFNvY2tKUyBjb25uZWN0aW9uIG1heSBub3QgYmUgaW5pdGlhdGVkIGZyb20gYSBwYWdlIGxvYWRlZCBvdmVyIEhUVFBTJyk7XG4gIH1cblxuICAvLyBTdGVwIDMgLSBjaGVjayBwb3J0IGFjY2VzcyAtIG5vIG5lZWQgaGVyZVxuICAvLyBTdGVwIDQgLSBwYXJzZSBwcm90b2NvbHMgYXJndW1lbnRcbiAgaWYgKCFwcm90b2NvbHMpIHtcbiAgICBwcm90b2NvbHMgPSBbXTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gIH1cblxuICAvLyBTdGVwIDUgLSBjaGVjayBwcm90b2NvbHMgYXJndW1lbnRcbiAgdmFyIHNvcnRlZFByb3RvY29scyA9IHByb3RvY29scy5zb3J0KCk7XG4gIHNvcnRlZFByb3RvY29scy5mb3JFYWNoKGZ1bmN0aW9uKHByb3RvLCBpKSB7XG4gICAgaWYgKCFwcm90bykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG4gICAgaWYgKGkgPCAoc29ydGVkUHJvdG9jb2xzLmxlbmd0aCAtIDEpICYmIHByb3RvID09PSBzb3J0ZWRQcm90b2NvbHNbaSArIDFdKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgcHJvdG9jb2xzIGVudHJ5ICdcIiArIHByb3RvICsgXCInIGlzIGR1cGxpY2F0ZWQuXCIpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gU3RlcCA2IC0gY29udmVydCBvcmlnaW5cbiAgdmFyIG8gPSB1cmxVdGlscy5nZXRPcmlnaW4obG9jLmhyZWYpO1xuICB0aGlzLl9vcmlnaW4gPSBvID8gby50b0xvd2VyQ2FzZSgpIDogbnVsbDtcblxuICAvLyByZW1vdmUgdGhlIHRyYWlsaW5nIHNsYXNoXG4gIHBhcnNlZFVybC5zZXQoJ3BhdGhuYW1lJywgcGFyc2VkVXJsLnBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgJycpKTtcblxuICAvLyBzdG9yZSB0aGUgc2FuaXRpemVkIHVybFxuICB0aGlzLnVybCA9IHBhcnNlZFVybC5ocmVmO1xuICBkZWJ1ZygndXNpbmcgdXJsJywgdGhpcy51cmwpO1xuXG4gIC8vIFN0ZXAgNyAtIHN0YXJ0IGNvbm5lY3Rpb24gaW4gYmFja2dyb3VuZFxuICAvLyBvYnRhaW4gc2VydmVyIGluZm9cbiAgLy8gaHR0cDovL3NvY2tqcy5naXRodWIuaW8vc29ja2pzLXByb3RvY29sL3NvY2tqcy1wcm90b2NvbC0wLjMuMy5odG1sI3NlY3Rpb24tMjZcbiAgdGhpcy5fdXJsSW5mbyA9IHtcbiAgICBudWxsT3JpZ2luOiAhYnJvd3Nlci5oYXNEb21haW4oKVxuICAsIHNhbWVPcmlnaW46IHVybFV0aWxzLmlzT3JpZ2luRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxuICAsIHNhbWVTY2hlbWU6IHVybFV0aWxzLmlzU2NoZW1lRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxuICB9O1xuXG4gIHRoaXMuX2lyID0gbmV3IEluZm9SZWNlaXZlcih0aGlzLnVybCwgdGhpcy5fdXJsSW5mbyk7XG4gIHRoaXMuX2lyLm9uY2UoJ2ZpbmlzaCcsIHRoaXMuX3JlY2VpdmVJbmZvLmJpbmQodGhpcykpO1xufVxuXG5pbmhlcml0cyhTb2NrSlMsIEV2ZW50VGFyZ2V0KTtcblxuZnVuY3Rpb24gdXNlclNldENvZGUoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAwMCB8fCAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSk7XG59XG5cblNvY2tKUy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgLy8gU3RlcCAxXG4gIGlmIChjb2RlICYmICF1c2VyU2V0Q29kZShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZEFjY2Vzc0Vycm9yOiBJbnZhbGlkIGNvZGUnKTtcbiAgfVxuICAvLyBTdGVwIDIuNCBzdGF0ZXMgdGhlIG1heCBpcyAxMjMgYnl0ZXMsIGJ1dCB3ZSBhcmUganVzdCBjaGVja2luZyBsZW5ndGhcbiAgaWYgKHJlYXNvbiAmJiByZWFzb24ubGVuZ3RoID4gMTIzKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdyZWFzb24gYXJndW1lbnQgaGFzIGFuIGludmFsaWQgbGVuZ3RoJyk7XG4gIH1cblxuICAvLyBTdGVwIDMuMVxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0lORyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUT0RPIGxvb2sgYXQgZG9jcyB0byBkZXRlcm1pbmUgaG93IHRvIHNldCB0aGlzXG4gIHZhciB3YXNDbGVhbiA9IHRydWU7XG4gIHRoaXMuX2Nsb3NlKGNvZGUgfHwgMTAwMCwgcmVhc29uIHx8ICdOb3JtYWwgY2xvc3VyZScsIHdhc0NsZWFuKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgLy8gIzEzIC0gY29udmVydCBhbnl0aGluZyBub24tc3RyaW5nIHRvIHN0cmluZ1xuICAvLyBUT0RPIHRoaXMgY3VycmVudGx5IHR1cm5zIG9iamVjdHMgaW50byBbb2JqZWN0IE9iamVjdF1cbiAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yOiBUaGUgY29ubmVjdGlvbiBoYXMgbm90IGJlZW4gZXN0YWJsaXNoZWQgeWV0Jyk7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gU29ja0pTLk9QRU4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoZXNjYXBlLnF1b3RlKGRhdGEpKTtcbn07XG5cblNvY2tKUy52ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cblNvY2tKUy5DT05ORUNUSU5HID0gMDtcblNvY2tKUy5PUEVOID0gMTtcblNvY2tKUy5DTE9TSU5HID0gMjtcblNvY2tKUy5DTE9TRUQgPSAzO1xuXG5Tb2NrSlMucHJvdG90eXBlLl9yZWNlaXZlSW5mbyA9IGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICBkZWJ1ZygnX3JlY2VpdmVJbmZvJywgcnR0KTtcbiAgdGhpcy5faXIgPSBudWxsO1xuICBpZiAoIWluZm8pIHtcbiAgICB0aGlzLl9jbG9zZSgxMDAyLCAnQ2Fubm90IGNvbm5lY3QgdG8gc2VydmVyJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZXN0YWJsaXNoIGEgcm91bmQtdHJpcCB0aW1lb3V0IChSVE8pIGJhc2VkIG9uIHRoZVxuICAvLyByb3VuZC10cmlwIHRpbWUgKFJUVClcbiAgdGhpcy5fcnRvID0gdGhpcy5jb3VudFJUTyhydHQpO1xuICAvLyBhbGxvdyBzZXJ2ZXIgdG8gb3ZlcnJpZGUgdXJsIHVzZWQgZm9yIHRoZSBhY3R1YWwgdHJhbnNwb3J0XG4gIHRoaXMuX3RyYW5zVXJsID0gaW5mby5iYXNlX3VybCA/IGluZm8uYmFzZV91cmwgOiB0aGlzLnVybDtcbiAgaW5mbyA9IG9iamVjdFV0aWxzLmV4dGVuZChpbmZvLCB0aGlzLl91cmxJbmZvKTtcbiAgZGVidWcoJ2luZm8nLCBpbmZvKTtcbiAgLy8gZGV0ZXJtaW5lIGxpc3Qgb2YgZGVzaXJlZCBhbmQgc3VwcG9ydGVkIHRyYW5zcG9ydHNcbiAgdmFyIGVuYWJsZWRUcmFuc3BvcnRzID0gdHJhbnNwb3J0cy5maWx0ZXJUb0VuYWJsZWQodGhpcy5fdHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbyk7XG4gIHRoaXMuX3RyYW5zcG9ydHMgPSBlbmFibGVkVHJhbnNwb3J0cy5tYWluO1xuICBkZWJ1Zyh0aGlzLl90cmFuc3BvcnRzLmxlbmd0aCArICcgZW5hYmxlZCB0cmFuc3BvcnRzJyk7XG5cbiAgdGhpcy5fY29ubmVjdCgpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBUcmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnRzLnNoaWZ0KCk7IFRyYW5zcG9ydDsgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpKSB7XG4gICAgZGVidWcoJ2F0dGVtcHQnLCBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSk7XG4gICAgaWYgKFRyYW5zcG9ydC5uZWVkQm9keSkge1xuICAgICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQuYm9keSB8fFxuICAgICAgICAgICh0eXBlb2YgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBnbG9iYWwuZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJyAmJlxuICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdpbnRlcmFjdGl2ZScpKSB7XG4gICAgICAgIGRlYnVnKCd3YWl0aW5nIGZvciBib2R5Jyk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydHMudW5zaGlmdChUcmFuc3BvcnQpO1xuICAgICAgICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdsb2FkJywgdGhpcy5fY29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSB0aW1lb3V0IGJhc2VkIG9uIFJUTyBhbmQgcm91bmQgdHJpcHMuIERlZmF1bHQgdG8gNXNcbiAgICB2YXIgdGltZW91dE1zID0gKHRoaXMuX3J0byAqIFRyYW5zcG9ydC5yb3VuZFRyaXBzKSB8fCA1MDAwO1xuICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dC5iaW5kKHRoaXMpLCB0aW1lb3V0TXMpO1xuICAgIGRlYnVnKCd1c2luZyB0aW1lb3V0JywgdGltZW91dE1zKTtcblxuICAgIHZhciB0cmFuc3BvcnRVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHRoaXMuX3RyYW5zVXJsLCAnLycgKyB0aGlzLl9zZXJ2ZXIgKyAnLycgKyB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCgpKTtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX3RyYW5zcG9ydE9wdGlvbnNbVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWVdO1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgdXJsJywgdHJhbnNwb3J0VXJsKTtcbiAgICB2YXIgdHJhbnNwb3J0T2JqID0gbmV3IFRyYW5zcG9ydCh0cmFuc3BvcnRVcmwsIHRoaXMuX3RyYW5zVXJsLCBvcHRpb25zKTtcbiAgICB0cmFuc3BvcnRPYmoub24oJ21lc3NhZ2UnLCB0aGlzLl90cmFuc3BvcnRNZXNzYWdlLmJpbmQodGhpcykpO1xuICAgIHRyYW5zcG9ydE9iai5vbmNlKCdjbG9zZScsIHRoaXMuX3RyYW5zcG9ydENsb3NlLmJpbmQodGhpcykpO1xuICAgIHRyYW5zcG9ydE9iai50cmFuc3BvcnROYW1lID0gVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0T2JqO1xuXG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2Nsb3NlKDIwMDAsICdBbGwgdHJhbnNwb3J0cyBmYWlsZWQnLCBmYWxzZSk7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0VGltZW91dCcpO1xuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIHRoaXMuX3RyYW5zcG9ydENsb3NlKDIwMDcsICdUcmFuc3BvcnQgdGltZWQgb3V0Jyk7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgZGVidWcoJ190cmFuc3BvcnRNZXNzYWdlJywgbXNnKTtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCB0eXBlID0gbXNnLnNsaWNlKDAsIDEpXG4gICAgLCBjb250ZW50ID0gbXNnLnNsaWNlKDEpXG4gICAgLCBwYXlsb2FkXG4gICAgO1xuXG4gIC8vIGZpcnN0IGNoZWNrIGZvciBtZXNzYWdlcyB0aGF0IGRvbid0IG5lZWQgYSBwYXlsb2FkXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ28nOlxuICAgICAgdGhpcy5fb3BlbigpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ2gnOlxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaGVhcnRiZWF0JykpO1xuICAgICAgZGVidWcoJ2hlYXJ0YmVhdCcsIHRoaXMudHJhbnNwb3J0KTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb250ZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIHBheWxvYWQgPSBKU09OMy5wYXJzZShjb250ZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygnYmFkIGpzb24nLCBjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGVidWcoJ2VtcHR5IHBheWxvYWQnLCBjb250ZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdhJzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICAgIHBheWxvYWQuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgZGVidWcoJ21lc3NhZ2UnLCBzZWxmLnRyYW5zcG9ydCwgcCk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ20nOlxuICAgICAgZGVidWcoJ21lc3NhZ2UnLCB0aGlzLnRyYW5zcG9ydCwgcGF5bG9hZCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IFRyYW5zcG9ydE1lc3NhZ2VFdmVudChwYXlsb2FkKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjJzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpICYmIHBheWxvYWQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlKHBheWxvYWRbMF0sIHBheWxvYWRbMV0sIHRydWUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydENsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0Q2xvc2UnLCB0aGlzLnRyYW5zcG9ydCwgY29kZSwgcmVhc29uKTtcbiAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdXNlclNldENvZGUoY29kZSkgJiYgY29kZSAhPT0gMjAwMCAmJiB0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgdGhpcy5fY29ubmVjdCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2Nsb3NlKGNvZGUsIHJlYXNvbik7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfb3BlbicsIHRoaXMuX3RyYW5zcG9ydC50cmFuc3BvcnROYW1lLCB0aGlzLnJlYWR5U3RhdGUpO1xuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQpO1xuICAgICAgdGhpcy5fdHJhbnNwb3J0VGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLk9QRU47XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdvcGVuJykpO1xuICAgIGRlYnVnKCdjb25uZWN0ZWQnLCB0aGlzLnRyYW5zcG9ydCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIHNlcnZlciBtaWdodCBoYXZlIGJlZW4gcmVzdGFydGVkLCBhbmQgbG9zdCB0cmFjayBvZiBvdXJcbiAgICAvLyBjb25uZWN0aW9uLlxuICAgIHRoaXMuX2Nsb3NlKDEwMDYsICdTZXJ2ZXIgbG9zdCBzZXNzaW9uJyk7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uLCB3YXNDbGVhbikge1xuICBkZWJ1ZygnX2Nsb3NlJywgdGhpcy50cmFuc3BvcnQsIGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4sIHRoaXMucmVhZHlTdGF0ZSk7XG4gIHZhciBmb3JjZUZhaWwgPSBmYWxzZTtcblxuICBpZiAodGhpcy5faXIpIHtcbiAgICBmb3JjZUZhaWwgPSB0cnVlO1xuICAgIHRoaXMuX2lyLmNsb3NlKCk7XG4gICAgdGhpcy5faXIgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yOiBTb2NrSlMgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQnKTtcbiAgfVxuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DTE9TSU5HO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DTE9TRUQ7XG5cbiAgICBpZiAoZm9yY2VGYWlsKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKTtcbiAgICB9XG5cbiAgICB2YXIgZSA9IG5ldyBDbG9zZUV2ZW50KCdjbG9zZScpO1xuICAgIGUud2FzQ2xlYW4gPSB3YXNDbGVhbiB8fCBmYWxzZTtcbiAgICBlLmNvZGUgPSBjb2RlIHx8IDEwMDA7XG4gICAgZS5yZWFzb24gPSByZWFzb247XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgdGhpcy5vbm1lc3NhZ2UgPSB0aGlzLm9uY2xvc2UgPSB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgIGRlYnVnKCdkaXNjb25uZWN0ZWQnKTtcbiAgfS5iaW5kKHRoaXMpLCAwKTtcbn07XG5cbi8vIFNlZTogaHR0cDovL3d3dy5lcmcuYWJkbi5hYy51ay9+Z2Vycml0L2RjY3Avbm90ZXMvY2NpZDIvcnRvX2VzdGltYXRvci9cbi8vIGFuZCBSRkMgMjk4OC5cblNvY2tKUy5wcm90b3R5cGUuY291bnRSVE8gPSBmdW5jdGlvbihydHQpIHtcbiAgLy8gSW4gYSBsb2NhbCBlbnZpcm9ubWVudCwgd2hlbiB1c2luZyBJRTgvOSBhbmQgdGhlIGBqc29ucC1wb2xsaW5nYFxuICAvLyB0cmFuc3BvcnQgdGhlIHRpbWUgbmVlZGVkIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gKHRoZSB0aW1lIHRoYXQgcGFzc1xuICAvLyBmcm9tIHRoZSBvcGVuaW5nIG9mIHRoZSB0cmFuc3BvcnQgdG8gdGhlIGNhbGwgb2YgYF9kaXNwYXRjaE9wZW5gKSBpc1xuICAvLyBhcm91bmQgMjAwbXNlYyAodGhlIGxvd2VyIGJvdW5kIHVzZWQgaW4gdGhlIGFydGljbGUgYWJvdmUpIGFuZCB0aGlzXG4gIC8vIGNhdXNlcyBzcHVyaW91cyB0aW1lb3V0cy4gRm9yIHRoaXMgcmVhc29uIHdlIGNhbGN1bGF0ZSBhIHZhbHVlIHNsaWdodGx5XG4gIC8vIGxhcmdlciB0aGFuIHRoYXQgdXNlZCBpbiB0aGUgYXJ0aWNsZS5cbiAgaWYgKHJ0dCA+IDEwMCkge1xuICAgIHJldHVybiA0ICogcnR0OyAvLyBydG8gPiA0MDBtc2VjXG4gIH1cbiAgcmV0dXJuIDMwMCArIHJ0dDsgLy8gMzAwbXNlYyA8IHJ0byA8PSA0MDBtc2VjXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgdHJhbnNwb3J0cyA9IHRyYW5zcG9ydChhdmFpbGFibGVUcmFuc3BvcnRzKTtcbiAgcmVxdWlyZSgnLi9pZnJhbWUtYm9vdHN0cmFwJykoU29ja0pTLCBhdmFpbGFibGVUcmFuc3BvcnRzKTtcbiAgcmV0dXJuIFNvY2tKUztcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vZXZlbnQvY2xvc2VcIjoyLFwiLi9ldmVudC9ldmVudFwiOjQsXCIuL2V2ZW50L2V2ZW50dGFyZ2V0XCI6NSxcIi4vZXZlbnQvdHJhbnMtbWVzc2FnZVwiOjYsXCIuL2lmcmFtZS1ib290c3RyYXBcIjo4LFwiLi9pbmZvLXJlY2VpdmVyXCI6MTIsXCIuL2xvY2F0aW9uXCI6MTMsXCIuL3NoaW1zXCI6MTUsXCIuL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4vdXRpbHMvZXNjYXBlXCI6NDUsXCIuL3V0aWxzL2V2ZW50XCI6NDYsXCIuL3V0aWxzL2xvZ1wiOjQ4LFwiLi91dGlscy9vYmplY3RcIjo0OSxcIi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuL3V0aWxzL3RyYW5zcG9ydFwiOjUxLFwiLi91dGlscy91cmxcIjo1MixcIi4vdmVyc2lvblwiOjUzLFwiZGVidWdcIjo1NSxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4LFwidXJsLXBhcnNlXCI6NjF9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoganNjczogZGlzYWJsZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBwdWxsZWQgc3BlY2lmaWMgc2hpbXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cblxudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgU3RyaW5nUHJvdG90eXBlID0gU3RyaW5nLnByb3RvdHlwZTtcbnZhciBhcnJheV9zbGljZSA9IEFycmF5UHJvdG90eXBlLnNsaWNlO1xuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIE9iamVjdFByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xudmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn07XG5cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHt9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIEVTMyAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSgpKTtcblxuLy8gRGVmaW5lIGNvbmZpZ3VyYWJsZSwgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BzXG4vLyBpZiB0aGV5IGRvbid0IGV4aXN0LlxudmFyIGRlZmluZVByb3BlcnR5O1xuaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG1ldGhvZFxuICAgICAgICB9KTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICBvYmplY3RbbmFtZV0gPSBtZXRob2Q7XG4gICAgfTtcbn1cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwLCBmb3JjZUFzc2lnbikge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbWFwKSB7XG4gICAgICAgIGlmIChPYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIG5hbWUpKSB7XG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBtYXBbbmFtZV0sIGZvcmNlQXNzaWduKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciB0b09iamVjdCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKG8gPT0gbnVsbCkgeyAvLyB0aGlzIG1hdGNoZXMgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyBvICsgJyB0byBvYmplY3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdChvKTtcbn07XG5cbi8vXG4vLyBVdGlsXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSA5LjRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuNFxuLy8gaHR0cDovL2pzcGVyZi5jb20vdG8taW50ZWdlclxuXG5mdW5jdGlvbiB0b0ludGVnZXIobnVtKSB7XG4gICAgdmFyIG4gPSArbnVtO1xuICAgIGlmIChuICE9PSBuKSB7IC8vIGlzTmFOXG4gICAgICAgIG4gPSAwO1xuICAgIH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSAoMSAvIDApICYmIG4gIT09IC0oMSAvIDApKSB7XG4gICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBUb1VpbnQzMih4KSB7XG4gICAgcmV0dXJuIHggPj4+IDA7XG59XG5cbi8vXG4vLyBGdW5jdGlvblxuLy8gPT09PT09PT1cbi8vXG5cbi8vIEVTLTUgMTUuMy40LjVcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjMuNC41XG5cbmZ1bmN0aW9uIEVtcHR5KCkge31cblxuZGVmaW5lUHJvcGVydGllcyhGdW5jdGlvblByb3RvdHlwZSwge1xuICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQodGhhdCkgeyAvLyAubGVuZ3RoIGlzIDFcbiAgICAgICAgLy8gMS4gTGV0IFRhcmdldCBiZSB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgICAgIC8vIDIuIElmIElzQ2FsbGFibGUoVGFyZ2V0KSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnICsgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBMZXQgQSBiZSBhIG5ldyAocG9zc2libHkgZW1wdHkpIGludGVybmFsIGxpc3Qgb2YgYWxsIG9mIHRoZVxuICAgICAgICAvLyAgIGFyZ3VtZW50IHZhbHVlcyBwcm92aWRlZCBhZnRlciB0aGlzQXJnIChhcmcxLCBhcmcyIGV0YyksIGluIG9yZGVyLlxuICAgICAgICAvLyBYWFggc2xpY2VkQXJncyB3aWxsIHN0YW5kIGluIGZvciBcIkFcIiBpZiB1c2VkXG4gICAgICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBmb3Igbm9ybWFsIGNhbGxcbiAgICAgICAgLy8gNC4gTGV0IEYgYmUgYSBuZXcgbmF0aXZlIEVDTUFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAvLyAxMS4gU2V0IHRoZSBbW1Byb3RvdHlwZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdGhlIHN0YW5kYXJkXG4gICAgICAgIC8vICAgYnVpbHQtaW4gRnVuY3Rpb24gcHJvdG90eXBlIG9iamVjdCBhcyBzcGVjaWZpZWQgaW4gMTUuMy4zLjEuXG4gICAgICAgIC8vIDEyLiBTZXQgdGhlIFtbQ2FsbF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMS5cbiAgICAgICAgLy8gMTMuIFNldCB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjIuXG4gICAgICAgIC8vIDE0LiBTZXQgdGhlIFtbSGFzSW5zdGFuY2VdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjMuXG4gICAgICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4yIFtbQ29uc3RydWN0XV1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCxcbiAgICAgICAgICAgICAgICAvLyBGIHRoYXQgd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgIC8vIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXVxuICAgICAgICAgICAgICAgIC8vICAgaW50ZXJuYWwgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMi4gSWYgdGFyZ2V0IGhhcyBubyBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCwgYVxuICAgICAgICAgICAgICAgIC8vICAgVHlwZUVycm9yIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgICAgICAgICAgICAgLy8gMy4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBtZXRob2Qgb2YgdGFyZ2V0IHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4xIFtbQ2FsbF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LCBGLFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHZhbHVlIGFuZCBhIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgICAgICAgIC8vIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAvLyAxLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMi4gTGV0IGJvdW5kVGhpcyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRUaGlzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyAgIG9mIHRhcmdldCBwcm92aWRpbmcgYm91bmRUaGlzIGFzIHRoZSB0aGlzIHZhbHVlIGFuZFxuICAgICAgICAgICAgICAgIC8vICAgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cblxuICAgICAgICAgICAgICAgIC8vIGVxdWl2OiB0YXJnZXQuY2FsbCh0aGlzLCAuLi5ib3VuZEFyZ3MsIC4uLmFyZ3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIDE1LiBJZiB0aGUgW1tDbGFzc11dIGludGVybmFsIHByb3BlcnR5IG9mIFRhcmdldCBpcyBcIkZ1bmN0aW9uXCIsIHRoZW5cbiAgICAgICAgLy8gICAgIGEuIExldCBMIGJlIHRoZSBsZW5ndGggcHJvcGVydHkgb2YgVGFyZ2V0IG1pbnVzIHRoZSBsZW5ndGggb2YgQS5cbiAgICAgICAgLy8gICAgIGIuIFNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIGVpdGhlciAwIG9yIEwsIHdoaWNoZXZlciBpc1xuICAgICAgICAvLyAgICAgICBsYXJnZXIuXG4gICAgICAgIC8vIDE2LiBFbHNlIHNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIDAuXG5cbiAgICAgICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcblxuICAgICAgICAvLyAxNy4gU2V0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gdGhlIHZhbHVlc1xuICAgICAgICAvLyAgIHNwZWNpZmllZCBpbiAxNS4zLjUuMS5cbiAgICAgICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWFhYIEJ1aWxkIGEgZHluYW1pYyBmdW5jdGlvbiB3aXRoIGRlc2lyZWQgYW1vdW50IG9mIGFyZ3VtZW50cyBpcyB0aGUgb25seVxuICAgICAgICAvLyB3YXkgdG8gc2V0IHRoZSBsZW5ndGggcHJvcGVydHkgb2YgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gSW4gZW52aXJvbm1lbnRzIHdoZXJlIENvbnRlbnQgU2VjdXJpdHkgUG9saWNpZXMgZW5hYmxlZCAoQ2hyb21lIGV4dGVuc2lvbnMsXG4gICAgICAgIC8vIGZvciBleC4pIGFsbCB1c2Ugb2YgZXZhbCBvciBGdW5jdGlvbiBjb3N0cnVjdG9yIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgIC8vIEhvd2V2ZXIgaW4gYWxsIG9mIHRoZXNlIGVudmlyb25tZW50cyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBleGlzdHNcbiAgICAgICAgLy8gYW5kIHNvIHRoaXMgY29kZSB3aWxsIG5ldmVyIGJlIGV4ZWN1dGVkLlxuICAgICAgICB2YXIgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgICAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZGFuZ2xpbmcgcmVmZXJlbmNlcy5cbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE4LiBTZXQgdGhlIFtbRXh0ZW5zaWJsZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdHJ1ZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE5LiBMZXQgdGhyb3dlciBiZSB0aGUgW1tUaHJvd1R5cGVFcnJvcl1dIGZ1bmN0aW9uIE9iamVjdCAoMTMuMi4zKS5cbiAgICAgICAgLy8gMjAuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiY2FsbGVyXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlciwgW1tTZXRdXTpcbiAgICAgICAgLy8gICB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSwgYW5kXG4gICAgICAgIC8vICAgZmFsc2UuXG4gICAgICAgIC8vIDIxLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImFyZ3VtZW50c1wiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsXG4gICAgICAgIC8vICAgW1tTZXRdXTogdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sXG4gICAgICAgIC8vICAgYW5kIGZhbHNlLlxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gTk9URSBGdW5jdGlvbiBvYmplY3RzIGNyZWF0ZWQgdXNpbmcgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZG8gbm90XG4gICAgICAgIC8vIGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgb3IgdGhlIFtbQ29kZV1dLCBbW0Zvcm1hbFBhcmFtZXRlcnNdXSwgYW5kXG4gICAgICAgIC8vIFtbU2NvcGVdXSBpbnRlcm5hbCBwcm9wZXJ0aWVzLlxuICAgICAgICAvLyBYWFggY2FuJ3QgZGVsZXRlIHByb3RvdHlwZSBpbiBwdXJlLWpzLlxuXG4gICAgICAgIC8vIDIyLiBSZXR1cm4gRi5cbiAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cbn0pO1xuXG4vL1xuLy8gQXJyYXlcbi8vID09PT09XG4vL1xuXG4vLyBFUzUgMTUuNC4zLjJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuMy4yXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5LCB7IGlzQXJyYXk6IGlzQXJyYXkgfSk7XG5cblxudmFyIGJveGVkU3RyaW5nID0gT2JqZWN0KCdhJyk7XG52YXIgc3BsaXRTdHJpbmcgPSBib3hlZFN0cmluZ1swXSAhPT0gJ2EnIHx8ICEoMCBpbiBib3hlZFN0cmluZyk7XG5cbnZhciBwcm9wZXJseUJveGVzQ29udGV4dCA9IGZ1bmN0aW9uIHByb3Blcmx5Qm94ZWQobWV0aG9kKSB7XG4gICAgLy8gQ2hlY2sgbm9kZSAwLjYuMjEgYnVnIHdoZXJlIHRoaXJkIHBhcmFtZXRlciBpcyBub3QgYm94ZWRcbiAgICB2YXIgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IHRydWU7XG4gICAgdmFyIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0cnVlO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmNhbGwoJ2ZvbycsIGZ1bmN0aW9uIChfLCBfXywgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JykgeyBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gZmFsc2U7IH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWV0aG9kLmNhbGwoWzFdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgICAgICBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHlwZW9mIHRoaXMgPT09ICdzdHJpbmcnO1xuICAgICAgICB9LCAneCcpO1xuICAgIH1cbiAgICByZXR1cm4gISFtZXRob2QgJiYgcHJvcGVybHlCb3hlc05vblN0cmljdCAmJiBwcm9wZXJseUJveGVzU3RyaWN0O1xufTtcblxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZnVuIC8qLCB0aGlzcCovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogb2JqZWN0LFxuICAgICAgICAgICAgdGhpc3AgPSBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyAvLyBUT0RPIG1lc3NhZ2VcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggY2FsbCwgcGFzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dCwgcHJvcGVydHkgdmFsdWUsIHByb3BlcnR5IGtleSwgdGhpc0FyZyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0XG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc3AsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZm9yRWFjaCkpO1xuXG4vLyBFUzUgMTUuNC40LjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTRcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2ZcbnZhciBoYXNGaXJlZm94MkluZGV4T2ZCdWcgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAmJiBbMCwgMV0uaW5kZXhPZigxLCAyKSAhPT0gLTE7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzb3VnaHQgLyosIGZyb21JbmRleCAqLyApIHtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGkgPSB0b0ludGVnZXIoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBuZWdhdGl2ZSBpbmRpY2VzXG4gICAgICAgIGkgPSBpID49IDAgPyBpIDogTWF0aC5tYXgoMCwgbGVuZ3RoICsgaSk7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgc2VsZltpXSA9PT0gc291Z2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn0sIGhhc0ZpcmVmb3gySW5kZXhPZkJ1Zyk7XG5cbi8vXG4vLyBTdHJpbmdcbi8vID09PT09PVxuLy9cblxuLy8gRVM1IDE1LjUuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNS40LjE0XG5cbi8vIFtidWdmaXgsIElFIGx0IDksIGZpcmVmb3ggNCwgS29ucXVlcm9yLCBPcGVyYSwgb2JzY3VyZSBicm93c2Vyc11cbi8vIE1hbnkgYnJvd3NlcnMgZG8gbm90IHNwbGl0IHByb3Blcmx5IHdpdGggcmVndWxhciBleHByZXNzaW9ucyBvciB0aGV5XG4vLyBkbyBub3QgcGVyZm9ybSB0aGUgc3BsaXQgY29ycmVjdGx5IHVuZGVyIG9ic2N1cmUgY29uZGl0aW9ucy5cbi8vIFNlZSBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvY3Jvc3MtYnJvd3Nlci1zcGxpdFxuLy8gSSd2ZSB0ZXN0ZWQgaW4gbWFueSBicm93c2VycyBhbmQgdGhpcyBzZWVtcyB0byBjb3ZlciB0aGUgZGV2aWFudCBvbmVzOlxuLy8gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pIHNob3VsZCBiZSBbXCJcIiwgXCJcIl0sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKC4/KSguPykvKSBzaG91bGQgYmUgW1wiXCIsIFwiLlwiLCBcIlwiLCBcIlwiXSwgbm90IFtcIlwiLCBcIlwiXVxuLy8gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pIHNob3VsZCBiZSBbXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIFwic1wiLCBcInRcIl0sIG5vdFxuLy8gICAgICAgW3VuZGVmaW5lZCwgXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIC4uLl1cbi8vICAgICcnLnNwbGl0KC8uPy8pIHNob3VsZCBiZSBbXSwgbm90IFtcIlwiXVxuLy8gICAgJy4nLnNwbGl0KC8oKSgpLykgc2hvdWxkIGJlIFtcIi5cIl0sIG5vdCBbXCJcIiwgXCJcIiwgXCIuXCJdXG5cbnZhciBzdHJpbmdfc3BsaXQgPSBTdHJpbmdQcm90b3R5cGUuc3BsaXQ7XG5pZiAoXG4gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aCAhPT0gMiB8fFxuICAgICcuJy5zcGxpdCgvKC4/KSguPykvKS5sZW5ndGggIT09IDQgfHxcbiAgICAndGVzc3QnLnNwbGl0KC8ocykqLylbMV0gPT09ICd0JyB8fFxuICAgICd0ZXN0Jy5zcGxpdCgvKD86KS8sIC0xKS5sZW5ndGggIT09IDQgfHxcbiAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGggfHxcbiAgICAnLicuc3BsaXQoLygpKCkvKS5sZW5ndGggPiAxXG4pIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcGxpYW50RXhlY05wY2cgPSAvKCk/Py8uZXhlYygnJylbMV0gPT09IHZvaWQgMDsgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcblxuICAgICAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAgICAgdmFyIHN0cmluZyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICAgICAgICBpZiAoX3RvU3RyaW5nLmNhbGwoc2VwYXJhdG9yKSAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgICAgICAgICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSAgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5leHRlbmRlZCAgID8gJ3gnIDogJycpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgICAgID8gJ3knIDogJycpLCAvLyBGaXJlZm94IDMrXG4gICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICAgICAgICBzdHJpbmcgKz0gJyc7IC8vIFR5cGUtY29udmVydFxuICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgICAgICAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKCdeJyArIHNlcGFyYXRvci5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFZhbHVlcyBmb3IgYGxpbWl0YCwgcGVyIHRoZSBzcGVjOlxuICAgICAgICAgICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgICAgICAgICAqIElmIDAsIEluZmluaXR5LCBvciBOYU46IDBcbiAgICAgICAgICAgICAqIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBNYXRoLmZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID4gNDI5NDk2NzI5NSkgbGltaXQgLT0gNDI5NDk2NzI5NjtcbiAgICAgICAgICAgICAqIElmIG5lZ2F0aXZlIG51bWJlcjogNDI5NDk2NzI5NiAtIE1hdGguZmxvb3IoTWF0aC5hYnMobGltaXQpKVxuICAgICAgICAgICAgICogSWYgb3RoZXI6IFR5cGUtY29udmVydCwgdGhlbiB1c2UgdGhlIGFib3ZlIHJ1bGVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxpbWl0ID0gbGltaXQgPT09IHZvaWQgMCA/XG4gICAgICAgICAgICAgICAgLTEgPj4+IDAgOiAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICAgICAgICAgICAgVG9VaW50MzIobGltaXQpO1xuICAgICAgICAgICAgd2hpbGUgKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIC8vIGBzZXBhcmF0b3IubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbaV0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5UHJvdG90eXBlLnB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3IudGVzdCgnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgbGltaXQpIDogb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH0oKSk7XG5cbi8vIFtidWdmaXgsIGNocm9tZV1cbi8vIElmIHNlcGFyYXRvciBpcyB1bmRlZmluZWQsIHRoZW4gdGhlIHJlc3VsdCBhcnJheSBjb250YWlucyBqdXN0IG9uZSBTdHJpbmcsXG4vLyB3aGljaCBpcyB0aGUgdGhpcyB2YWx1ZSAoY29udmVydGVkIHRvIGEgU3RyaW5nKS4gSWYgbGltaXQgaXMgbm90IHVuZGVmaW5lZCxcbi8vIHRoZW4gdGhlIG91dHB1dCBhcnJheSBpcyB0cnVuY2F0ZWQgc28gdGhhdCBpdCBjb250YWlucyBubyBtb3JlIHRoYW4gbGltaXRcbi8vIGVsZW1lbnRzLlxuLy8gXCIwXCIuc3BsaXQodW5kZWZpbmVkLCAwKSAtPiBbXVxufSBlbHNlIGlmICgnMCcuc3BsaXQodm9pZCAwLCAwKS5sZW5ndGgpIHtcbiAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCAmJiBsaW1pdCA9PT0gMCkgeyByZXR1cm4gW107IH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG59XG5cbi8vIEVDTUEtMjYyLCAzcmQgQi4yLjNcbi8vIE5vdCBhbiBFQ01BU2NyaXB0IHN0YW5kYXJkLCBhbHRob3VnaCBFQ01BU2NyaXB0IDNyZCBFZGl0aW9uIGhhcyBhXG4vLyBub24tbm9ybWF0aXZlIHNlY3Rpb24gc3VnZ2VzdGluZyB1bmlmb3JtIHNlbWFudGljcyBhbmQgaXQgc2hvdWxkIGJlXG4vLyBub3JtYWxpemVkIGFjcm9zcyBhbGwgYnJvd3NlcnNcbi8vIFtidWdmaXgsIElFIGx0IDldIElFIDwgOSBzdWJzdHIoKSB3aXRoIG5lZ2F0aXZlIHZhbHVlIG5vdCB3b3JraW5nIGluIElFXG52YXIgc3RyaW5nX3N1YnN0ciA9IFN0cmluZ1Byb3RvdHlwZS5zdWJzdHI7XG52YXIgaGFzTmVnYXRpdmVTdWJzdHJCdWcgPSAnJy5zdWJzdHIgJiYgJzBiJy5zdWJzdHIoLTEpICE9PSAnYic7XG5kZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgIHN1YnN0cjogZnVuY3Rpb24gc3Vic3RyKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ19zdWJzdHIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBzdGFydCA8IDAgPyAoKHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydCkgPCAwID8gMCA6IHN0YXJ0KSA6IHN0YXJ0LFxuICAgICAgICAgICAgbGVuZ3RoXG4gICAgICAgICk7XG4gICAgfVxufSwgaGFzTmVnYXRpdmVTdWJzdHJCdWcpO1xuXG59LHt9XSwxNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAvLyBzdHJlYW1pbmcgdHJhbnNwb3J0c1xuICByZXF1aXJlKCcuL3RyYW5zcG9ydC93ZWJzb2NrZXQnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItc3RyZWFtaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGRyLXN0cmVhbWluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2V2ZW50c291cmNlJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvZXZlbnRzb3VyY2UnKSlcblxuICAvLyBwb2xsaW5nIHRyYW5zcG9ydHNcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvaHRtbGZpbGUnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC9odG1sZmlsZScpKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItcG9sbGluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1wb2xsaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXBvbGxpbmcnKSlcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvanNvbnAtcG9sbGluZycpXG5dO1xuXG59LHtcIi4vdHJhbnNwb3J0L2V2ZW50c291cmNlXCI6MjAsXCIuL3RyYW5zcG9ydC9odG1sZmlsZVwiOjIxLFwiLi90cmFuc3BvcnQvanNvbnAtcG9sbGluZ1wiOjIzLFwiLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwXCI6MjYsXCIuL3RyYW5zcG9ydC93ZWJzb2NrZXRcIjozOCxcIi4vdHJhbnNwb3J0L3hkci1wb2xsaW5nXCI6MzksXCIuL3RyYW5zcG9ydC94ZHItc3RyZWFtaW5nXCI6NDAsXCIuL3RyYW5zcG9ydC94aHItcG9sbGluZ1wiOjQxLFwiLi90cmFuc3BvcnQveGhyLXN0cmVhbWluZ1wiOjQyfV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2V2ZW50JylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgWEhSID0gZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0XG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpicm93c2VyOnhocicpO1xufVxuXG5mdW5jdGlvbiBBYnN0cmFjdFhIUk9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICBkZWJ1ZyhtZXRob2QsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoQWJzdHJhY3RYSFJPYmplY3QsIEV2ZW50RW1pdHRlcik7XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLnhociA9IG5ldyBYSFIoKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgfVxuXG4gIGlmICghdGhpcy54aHIpIHtcbiAgICBkZWJ1Zygnbm8geGhyJyk7XG4gICAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnbm8geGhyIHN1cHBvcnQnKTtcbiAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2V2ZXJhbCBicm93c2VycyBjYWNoZSBQT1NUc1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICd0PScgKyAoK25ldyBEYXRlKCkpKTtcblxuICAvLyBFeHBsb3JlciB0ZW5kcyB0byBrZWVwIGNvbm5lY3Rpb24gb3BlbiwgZXZlbiBhZnRlciB0aGVcbiAgLy8gdGFiIGdldHMgY2xvc2VkOiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC81MjgwXG4gIHRoaXMudW5sb2FkUmVmID0gdXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd1bmxvYWQgY2xlYW51cCcpO1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gIH0pO1xuICB0cnkge1xuICAgIHRoaXMueGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgIGlmICh0aGlzLnRpbWVvdXQgJiYgJ3RpbWVvdXQnIGluIHRoaXMueGhyKSB7XG4gICAgICB0aGlzLnhoci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgdGhpcy54aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlYnVnKCd4aHIgdGltZW91dCcpO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKCdleGNlcHRpb24nLCBlKTtcbiAgICAvLyBJRSByYWlzZXMgYW4gZXhjZXB0aW9uIG9uIHdyb25nIHBvcnQuXG4gICAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCghb3B0cyB8fCAhb3B0cy5ub0NyZWRlbnRpYWxzKSAmJiBBYnN0cmFjdFhIUk9iamVjdC5zdXBwb3J0c0NPUlMpIHtcbiAgICBkZWJ1Zygnd2l0aENyZWRlbnRpYWxzJyk7XG4gICAgLy8gTW96aWxsYSBkb2NzIHNheXMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vWE1MSHR0cFJlcXVlc3QgOlxuICAgIC8vIFwiVGhpcyBuZXZlciBhZmZlY3RzIHNhbWUtc2l0ZSByZXF1ZXN0cy5cIlxuXG4gICAgdGhpcy54aHIud2l0aENyZWRlbnRpYWxzID0gJ3RydWUnO1xuICB9XG4gIGlmIChvcHRzICYmIG9wdHMuaGVhZGVycykge1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBvcHRzLmhlYWRlcnNba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYueGhyKSB7XG4gICAgICB2YXIgeCA9IHNlbGYueGhyO1xuICAgICAgdmFyIHRleHQsIHN0YXR1cztcbiAgICAgIGRlYnVnKCdyZWFkeVN0YXRlJywgeC5yZWFkeVN0YXRlKTtcbiAgICAgIHN3aXRjaCAoeC5yZWFkeVN0YXRlKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIC8vIElFIGRvZXNuJ3QgbGlrZSBwZWVraW5nIGludG8gcmVzcG9uc2VUZXh0IG9yIHN0YXR1c1xuICAgICAgICAvLyBvbiBNaWNyb3NvZnQuWE1MSFRUUCBhbmQgcmVhZHlzdGF0ZT0zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhdHVzID0geC5zdGF0dXM7XG4gICAgICAgICAgdGV4dCA9IHgucmVzcG9uc2VUZXh0O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICB9XG4gICAgICAgIGRlYnVnKCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAvLyBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgICAgICAgc3RhdHVzID0gMjA0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSUUgZG9lcyByZXR1cm4gcmVhZHlzdGF0ZSA9PSAzIGZvciA0MDQgYW5zd2Vycy5cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMjAwICYmIHRleHQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZGVidWcoJ2NodW5rJyk7XG4gICAgICAgICAgc2VsZi5lbWl0KCdjaHVuaycsIHN0YXR1cywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHN0YXR1cyA9IHguc3RhdHVzO1xuICAgICAgICBkZWJ1Zygnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgLy8gSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTBcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgICAgICAgIHN0YXR1cyA9IDIwNDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJRSByZXR1cm5zIHRoaXMgZm9yIGEgYmFkIHBvcnRcbiAgICAgICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9hYTM4Mzc3MCh2PXZzLjg1KS5hc3B4XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMDA1IHx8IHN0YXR1cyA9PT0gMTIwMjkpIHtcbiAgICAgICAgICBzdGF0dXMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cywgeC5yZXNwb25zZVRleHQpO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIHN0YXR1cywgeC5yZXNwb25zZVRleHQpO1xuICAgICAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHRyeSB7XG4gICAgc2VsZi54aHIuc2VuZChwYXlsb2FkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICB9XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbihhYm9ydCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuICBpZiAoIXRoaXMueGhyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG5cbiAgLy8gSUUgbmVlZHMgdGhpcyBmaWVsZCB0byBiZSBhIGZ1bmN0aW9uXG4gIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge307XG4gIGlmICh0aGlzLnhoci5vbnRpbWVvdXQpIHtcbiAgICB0aGlzLnhoci5vbnRpbWVvdXQgPSBudWxsO1xuICB9XG5cbiAgaWYgKGFib3J0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgfVxuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMueGhyID0gbnVsbDtcbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgPSAhIVhIUjtcbi8vIG92ZXJyaWRlIFhNTEh0dHBSZXF1ZXN0IGZvciBJRTYvN1xuLy8gb2JmdXNjYXRlIHRvIGF2b2lkIGZpcmV3YWxsc1xudmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG5pZiAoIUFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgJiYgKGF4byBpbiBnbG9iYWwpKSB7XG4gIGRlYnVnKCdvdmVycmlkaW5nIHhtbGh0dHByZXF1ZXN0Jyk7XG4gIFhIUiA9IGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IGdsb2JhbFtheG9dKCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcbiAgQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCA9ICEhbmV3IFhIUigpO1xufVxuXG52YXIgY29ycyA9IGZhbHNlO1xudHJ5IHtcbiAgY29ycyA9ICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYSFIoKTtcbn0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxufVxuXG5BYnN0cmFjdFhIUk9iamVjdC5zdXBwb3J0c0NPUlMgPSBjb3JzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0WEhST2JqZWN0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9ldmVudFwiOjQ2LFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwxODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5FdmVudFNvdXJjZTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIERyaXZlciA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcbmlmIChEcml2ZXIpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBXZWJTb2NrZXRCcm93c2VyRHJpdmVyKHVybCkge1xuXHRcdHJldHVybiBuZXcgRHJpdmVyKHVybCk7XG5cdH07XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHVuZGVmaW5lZDtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDIwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIEV2ZW50U291cmNlUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2V2ZW50c291cmNlJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIEV2ZW50U291cmNlRHJpdmVyID0gcmVxdWlyZSgnZXZlbnRzb3VyY2UnKVxuICA7XG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghRXZlbnRTb3VyY2VUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cblxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9ldmVudHNvdXJjZScsIEV2ZW50U291cmNlUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhFdmVudFNvdXJjZVRyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuRXZlbnRTb3VyY2VUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISFFdmVudFNvdXJjZURyaXZlcjtcbn07XG5cbkV2ZW50U291cmNlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnZXZlbnRzb3VyY2UnO1xuRXZlbnRTb3VyY2VUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRTb3VyY2VUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci9ldmVudHNvdXJjZVwiOjI5LFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcImV2ZW50c291cmNlXCI6MTgsXCJpbmhlcml0c1wiOjU3fV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSHRtbGZpbGVSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIvaHRtbGZpbGUnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgO1xuXG5mdW5jdGlvbiBIdG1sRmlsZVRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2h0bWxmaWxlJywgSHRtbGZpbGVSZWNlaXZlciwgWEhSTG9jYWxPYmplY3QpO1xufVxuXG5pbmhlcml0cyhIdG1sRmlsZVRyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuSHRtbEZpbGVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgcmV0dXJuIEh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCAmJiBpbmZvLnNhbWVPcmlnaW47XG59O1xuXG5IdG1sRmlsZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2h0bWxmaWxlJztcbkh0bWxGaWxlVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxGaWxlVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIvaHRtbGZpbGVcIjozMCxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbi8vIEZldyBjb29sIHRyYW5zcG9ydHMgZG8gd29yayBvbmx5IGZvciBzYW1lLW9yaWdpbi4gSW4gb3JkZXIgdG8gbWFrZVxuLy8gdGhlbSB3b3JrIGNyb3NzLWRvbWFpbiB3ZSBzaGFsbCB1c2UgaWZyYW1lLCBzZXJ2ZWQgZnJvbSB0aGVcbi8vIHJlbW90ZSBkb21haW4uIE5ldyBicm93c2VycyBoYXZlIGNhcGFiaWxpdGllcyB0byBjb21tdW5pY2F0ZSB3aXRoXG4vLyBjcm9zcyBkb21haW4gaWZyYW1lIHVzaW5nIHBvc3RNZXNzYWdlKCkuIEluIElFIGl0IHdhcyBpbXBsZW1lbnRlZFxuLy8gZnJvbSBJRSA4KywgYnV0IG9mIGNvdXJzZSwgSUUgZ290IHNvbWUgZGV0YWlscyB3cm9uZzpcbi8vICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzE5NzAxNSh2PVZTLjg1KS5hc3B4XG4vLyAgICBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCB2ZXJzaW9uID0gcmVxdWlyZSgnLi4vdmVyc2lvbicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91cmwnKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvaWZyYW1lJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnQnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uL3V0aWxzL3JhbmRvbScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp0cmFuc3BvcnQ6aWZyYW1lJyk7XG59XG5cbmZ1bmN0aW9uIElmcmFtZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKSB7XG4gIGlmICghSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5vcmlnaW4gPSB1cmxVdGlscy5nZXRPcmlnaW4oYmFzZVVybCk7XG4gIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gIHRoaXMudHJhbnNVcmwgPSB0cmFuc1VybDtcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRoaXMud2luZG93SWQgPSByYW5kb20uc3RyaW5nKDgpO1xuXG4gIHZhciBpZnJhbWVVcmwgPSB1cmxVdGlscy5hZGRQYXRoKGJhc2VVcmwsICcvaWZyYW1lLmh0bWwnKSArICcjJyArIHRoaXMud2luZG93SWQ7XG4gIGRlYnVnKHRyYW5zcG9ydCwgdHJhbnNVcmwsIGlmcmFtZVVybCk7XG5cbiAgdGhpcy5pZnJhbWVPYmogPSBpZnJhbWVVdGlscy5jcmVhdGVJZnJhbWUoaWZyYW1lVXJsLCBmdW5jdGlvbihyKSB7XG4gICAgZGVidWcoJ2VyciBjYWxsYmFjaycpO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCAxMDA2LCAnVW5hYmxlIHRvIGxvYWQgYW4gaWZyYW1lICgnICsgciArICcpJyk7XG4gICAgc2VsZi5jbG9zZSgpO1xuICB9KTtcblxuICB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrID0gdGhpcy5fbWVzc2FnZS5iaW5kKHRoaXMpO1xuICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdtZXNzYWdlJywgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayk7XG59XG5cbmluaGVyaXRzKElmcmFtZVRyYW5zcG9ydCwgRXZlbnRFbWl0dGVyKTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgaWYgKHRoaXMuaWZyYW1lT2JqKSB7XG4gICAgZXZlbnRVdGlscy5kZXRhY2hFdmVudCgnbWVzc2FnZScsIHRoaXMub25tZXNzYWdlQ2FsbGJhY2spO1xuICAgIHRyeSB7XG4gICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgdGhpcy5wb3N0TWVzc2FnZSgnYycpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gICAgdGhpcy5pZnJhbWVPYmouY2xlYW51cCgpO1xuICAgIHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgICB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrID0gdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLl9tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICBkZWJ1ZygnbWVzc2FnZScsIGUuZGF0YSk7XG4gIGlmICghdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChlLm9yaWdpbiwgdGhpcy5vcmlnaW4pKSB7XG4gICAgZGVidWcoJ25vdCBzYW1lIG9yaWdpbicsIGUub3JpZ2luLCB0aGlzLm9yaWdpbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGlmcmFtZU1lc3NhZ2U7XG4gIHRyeSB7XG4gICAgaWZyYW1lTWVzc2FnZSA9IEpTT04zLnBhcnNlKGUuZGF0YSk7XG4gIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpZnJhbWVNZXNzYWdlLndpbmRvd0lkICE9PSB0aGlzLndpbmRvd0lkKSB7XG4gICAgZGVidWcoJ21pc21hdGNoZWQgd2luZG93IGlkJywgaWZyYW1lTWVzc2FnZS53aW5kb3dJZCwgdGhpcy53aW5kb3dJZCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcbiAgY2FzZSAncyc6XG4gICAgdGhpcy5pZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgLy8gd2luZG93IGdsb2JhbCBkZXBlbmRlbmN5XG4gICAgdGhpcy5wb3N0TWVzc2FnZSgncycsIEpTT04zLnN0cmluZ2lmeShbXG4gICAgICB2ZXJzaW9uXG4gICAgLCB0aGlzLnRyYW5zcG9ydFxuICAgICwgdGhpcy50cmFuc1VybFxuICAgICwgdGhpcy5iYXNlVXJsXG4gICAgXSkpO1xuICAgIGJyZWFrO1xuICBjYXNlICd0JzpcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgIGJyZWFrO1xuICBjYXNlICdjJzpcbiAgICB2YXIgY2RhdGE7XG4gICAgdHJ5IHtcbiAgICAgIGNkYXRhID0gSlNPTjMucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICBkZWJ1ZygnYmFkIGpzb24nLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgY2RhdGFbMF0sIGNkYXRhWzFdKTtcbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgYnJlYWs7XG4gIH1cbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gIGRlYnVnKCdwb3N0TWVzc2FnZScsIHR5cGUsIGRhdGEpO1xuICB0aGlzLmlmcmFtZU9iai5wb3N0KEpTT04zLnN0cmluZ2lmeSh7XG4gICAgd2luZG93SWQ6IHRoaXMud2luZG93SWRcbiAgLCB0eXBlOiB0eXBlXG4gICwgZGF0YTogZGF0YSB8fCAnJ1xuICB9KSwgdGhpcy5vcmlnaW4pO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICBkZWJ1Zygnc2VuZCcsIG1lc3NhZ2UpO1xuICB0aGlzLnBvc3RNZXNzYWdlKCdtJywgbWVzc2FnZSk7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gaWZyYW1lVXRpbHMuaWZyYW1lRW5hYmxlZDtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2lmcmFtZSc7XG5JZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gSWZyYW1lVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi91dGlscy91cmxcIjo1MixcIi4uL3ZlcnNpb25cIjo1MyxcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBzaW1wbGVzdCBhbmQgbW9zdCByb2J1c3QgdHJhbnNwb3J0LCB1c2luZyB0aGUgd2VsbC1rbm93IGNyb3NzXG4vLyBkb21haW4gaGFjayAtIEpTT05QLiBUaGlzIHRyYW5zcG9ydCBpcyBxdWl0ZSBpbmVmZmljaWVudCAtIG9uZVxuLy8gbWVzc2FnZSBjb3VsZCB1c2UgdXAgdG8gb25lIGh0dHAgcmVxdWVzdC4gQnV0IGF0IGxlYXN0IGl0IHdvcmtzIGFsbW9zdFxuLy8gZXZlcnl3aGVyZS5cbi8vIEtub3duIGxpbWl0YXRpb25zOlxuLy8gICBvIHlvdSB3aWxsIGdldCBhIHNwaW5uaW5nIGN1cnNvclxuLy8gICBvIGZvciBLb25xdWVyb3IgYSBkdW1iIHRpbWVyIGlzIG5lZWRlZCB0byBkZXRlY3QgZXJyb3JzXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vbGliL3NlbmRlci1yZWNlaXZlcicpXG4gICwgSnNvbnBSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIvanNvbnAnKVxuICAsIGpzb25wU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXIvanNvbnAnKVxuICA7XG5cbmZ1bmN0aW9uIEpzb25QVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghSnNvblBUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgU2VuZGVyUmVjZWl2ZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9qc29ucCcsIGpzb25wU2VuZGVyLCBKc29ucFJlY2VpdmVyKTtcbn1cblxuaW5oZXJpdHMoSnNvblBUcmFuc3BvcnQsIFNlbmRlclJlY2VpdmVyKTtcblxuSnNvblBUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQ7XG59O1xuXG5Kc29uUFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2pzb25wLXBvbGxpbmcnO1xuSnNvblBUcmFuc3BvcnQucm91bmRUcmlwcyA9IDE7XG5Kc29uUFRyYW5zcG9ydC5uZWVkQm9keSA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gSnNvblBUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vbGliL3NlbmRlci1yZWNlaXZlclwiOjI4LFwiLi9yZWNlaXZlci9qc29ucFwiOjMxLFwiLi9zZW5kZXIvanNvbnBcIjozMyxcImluaGVyaXRzXCI6NTd9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIFNlbmRlclJlY2VpdmVyID0gcmVxdWlyZSgnLi9zZW5kZXItcmVjZWl2ZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YWpheC1iYXNlZCcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBamF4U2VuZGVyKEFqYXhPYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHVybCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICBkZWJ1ZygnY3JlYXRlIGFqYXggc2VuZGVyJywgdXJsLCBwYXlsb2FkKTtcbiAgICB2YXIgb3B0ID0ge307XG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0LmhlYWRlcnMgPSB7J0NvbnRlbnQtdHlwZSc6ICd0ZXh0L3BsYWluJ307XG4gICAgfVxuICAgIHZhciBhamF4VXJsID0gdXJsVXRpbHMuYWRkUGF0aCh1cmwsICcveGhyX3NlbmQnKTtcbiAgICB2YXIgeG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIGFqYXhVcmwsIHBheWxvYWQsIG9wdCk7XG4gICAgeG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzKTtcbiAgICAgIHhvID0gbnVsbDtcblxuICAgICAgaWYgKHN0YXR1cyAhPT0gMjAwICYmIHN0YXR1cyAhPT0gMjA0KSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ2h0dHAgc3RhdHVzICcgKyBzdGF0dXMpKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2Fib3J0Jyk7XG4gICAgICB4by5jbG9zZSgpO1xuICAgICAgeG8gPSBudWxsO1xuXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdBYm9ydGVkJyk7XG4gICAgICBlcnIuY29kZSA9IDEwMDA7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIEFqYXhCYXNlZFRyYW5zcG9ydCh0cmFuc1VybCwgdXJsU3VmZml4LCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xuICBTZW5kZXJSZWNlaXZlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCB1cmxTdWZmaXgsIGNyZWF0ZUFqYXhTZW5kZXIoQWpheE9iamVjdCksIFJlY2VpdmVyLCBBamF4T2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoQWpheEJhc2VkVHJhbnNwb3J0LCBTZW5kZXJSZWNlaXZlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gQWpheEJhc2VkVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCIuL3NlbmRlci1yZWNlaXZlclwiOjI4LFwiZGVidWdcIjo1NSxcImluaGVyaXRzXCI6NTd9XSwyNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpidWZmZXJlZC1zZW5kZXInKTtcbn1cblxuZnVuY3Rpb24gQnVmZmVyZWRTZW5kZXIodXJsLCBzZW5kZXIpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRlciA9IHNlbmRlcjtcbiAgdGhpcy51cmwgPSB1cmw7XG59XG5cbmluaGVyaXRzKEJ1ZmZlcmVkU2VuZGVyLCBFdmVudEVtaXR0ZXIpO1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgZGVidWcoJ3NlbmQnLCBtZXNzYWdlKTtcbiAgdGhpcy5zZW5kQnVmZmVyLnB1c2gobWVzc2FnZSk7XG4gIGlmICghdGhpcy5zZW5kU3RvcCkge1xuICAgIHRoaXMuc2VuZFNjaGVkdWxlKCk7XG4gIH1cbn07XG5cbi8vIEZvciBwb2xsaW5nIHRyYW5zcG9ydHMgaW4gYSBzaXR1YXRpb24gd2hlbiBpbiB0aGUgbWVzc2FnZSBjYWxsYmFjayxcbi8vIG5ldyBtZXNzYWdlIGlzIGJlaW5nIHNlbmQuIElmIHRoZSBzZW5kaW5nIGNvbm5lY3Rpb24gd2FzIHN0YXJ0ZWRcbi8vIGJlZm9yZSByZWNlaXZpbmcgb25lLCBpdCBpcyBwb3NzaWJsZSB0byBzYXR1cmF0ZSB0aGUgbmV0d29yayBhbmRcbi8vIHRpbWVvdXQgZHVlIHRvIHRoZSBsYWNrIG9mIHJlY2VpdmluZyBzb2NrZXQuIFRvIGF2b2lkIHRoYXQgd2UgZGVsYXlcbi8vIHNlbmRpbmcgbWVzc2FnZXMgYnkgc29tZSBzbWFsbCB0aW1lLCBpbiBvcmRlciB0byBsZXQgcmVjZWl2aW5nXG4vLyBjb25uZWN0aW9uIGJlIHN0YXJ0ZWQgYmVmb3JlaGFuZC4gVGhpcyBpcyBvbmx5IGEgaGFsZm1lYXN1cmUgYW5kXG4vLyBkb2VzIG5vdCBmaXggdGhlIGJpZyBwcm9ibGVtLCBidXQgaXQgZG9lcyBtYWtlIHRoZSB0ZXN0cyBnbyBtb3JlXG4vLyBzdGFibGUgb24gc2xvdyBuZXR3b3Jrcy5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kU2NoZWR1bGVXYWl0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdzZW5kU2NoZWR1bGVXYWl0Jyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRyZWY7XG4gIHRoaXMuc2VuZFN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnc2VuZFN0b3AnKTtcbiAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcbiAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gIH07XG4gIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgc2VsZi5zZW5kU2NoZWR1bGUoKTtcbiAgfSwgMjUpO1xufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRTY2hlZHVsZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1Zygnc2VuZFNjaGVkdWxlJywgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHBheWxvYWQgPSAnWycgKyB0aGlzLnNlbmRCdWZmZXIuam9pbignLCcpICsgJ10nO1xuICAgIHRoaXMuc2VuZFN0b3AgPSB0aGlzLnNlbmRlcih0aGlzLnVybCwgcGF5bG9hZCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIGVyci5jb2RlIHx8IDEwMDYsICdTZW5kaW5nIGVycm9yOiAnICsgZXJyKTtcbiAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5zZW5kU2NoZWR1bGVXYWl0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIH1cbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICBpZiAodGhpcy5zZW5kU3RvcCkge1xuICAgIHRoaXMuc2VuZFN0b3AoKTtcbiAgICB0aGlzLnNlbmRTdG9wID0gbnVsbDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJlZFNlbmRlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIElmcmFtZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL2lmcmFtZScpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QnKVxuICA7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cbiAgZnVuY3Rpb24gSWZyYW1lV3JhcFRyYW5zcG9ydCh0cmFuc1VybCwgYmFzZVVybCkge1xuICAgIElmcmFtZVRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zcG9ydC50cmFuc3BvcnROYW1lLCB0cmFuc1VybCwgYmFzZVVybCk7XG4gIH1cblxuICBpbmhlcml0cyhJZnJhbWVXcmFwVHJhbnNwb3J0LCBJZnJhbWVUcmFuc3BvcnQpO1xuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKHVybCwgaW5mbykge1xuICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGlmcmFtZUluZm8gPSBvYmplY3RVdGlscy5leHRlbmQoe30sIGluZm8pO1xuICAgIGlmcmFtZUluZm8uc2FtZU9yaWdpbiA9IHRydWU7XG4gICAgcmV0dXJuIHRyYW5zcG9ydC5lbmFibGVkKGlmcmFtZUluZm8pICYmIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG4gIH07XG5cbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2lmcmFtZS0nICsgdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gIElmcmFtZVdyYXBUcmFuc3BvcnQubmVlZEJvZHkgPSB0cnVlO1xuICBJZnJhbWVXcmFwVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSBJZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyArIHRyYW5zcG9ydC5yb3VuZFRyaXBzIC0gMTsgLy8gaHRtbCwgamF2YXNjcmlwdCAoMikgKyB0cmFuc3BvcnQgLSBubyBDT1JTICgxKVxuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQuZmFjYWRlVHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIHJldHVybiBJZnJhbWVXcmFwVHJhbnNwb3J0O1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvb2JqZWN0XCI6NDksXCIuLi9pZnJhbWVcIjoyMixcImluaGVyaXRzXCI6NTd9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpwb2xsaW5nJyk7XG59XG5cbmZ1bmN0aW9uIFBvbGxpbmcoUmVjZWl2ZXIsIHJlY2VpdmVVcmwsIEFqYXhPYmplY3QpIHtcbiAgZGVidWcocmVjZWl2ZVVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB0aGlzLlJlY2VpdmVyID0gUmVjZWl2ZXI7XG4gIHRoaXMucmVjZWl2ZVVybCA9IHJlY2VpdmVVcmw7XG4gIHRoaXMuQWpheE9iamVjdCA9IEFqYXhPYmplY3Q7XG4gIHRoaXMuX3NjaGVkdWxlUmVjZWl2ZXIoKTtcbn1cblxuaW5oZXJpdHMoUG9sbGluZywgRXZlbnRFbWl0dGVyKTtcblxuUG9sbGluZy5wcm90b3R5cGUuX3NjaGVkdWxlUmVjZWl2ZXIgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19zY2hlZHVsZVJlY2VpdmVyJyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHBvbGwgPSB0aGlzLnBvbGwgPSBuZXcgdGhpcy5SZWNlaXZlcih0aGlzLnJlY2VpdmVVcmwsIHRoaXMuQWpheE9iamVjdCk7XG5cbiAgcG9sbC5vbignbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgbXNnKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICB9KTtcblxuICBwb2xsLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gICAgZGVidWcoJ2Nsb3NlJywgY29kZSwgcmVhc29uLCBzZWxmLnBvbGxJc0Nsb3NpbmcpO1xuICAgIHNlbGYucG9sbCA9IHBvbGwgPSBudWxsO1xuXG4gICAgaWYgKCFzZWxmLnBvbGxJc0Nsb3NpbmcpIHtcbiAgICAgIGlmIChyZWFzb24gPT09ICduZXR3b3JrJykge1xuICAgICAgICBzZWxmLl9zY2hlZHVsZVJlY2VpdmVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgY29kZSB8fCAxMDA2LCByZWFzb24pO1xuICAgICAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5wb2xsSXNDbG9zaW5nID0gdHJ1ZTtcbiAgaWYgKHRoaXMucG9sbCkge1xuICAgIHRoaXMucG9sbC5hYm9ydCgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwyODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIEJ1ZmZlcmVkU2VuZGVyID0gcmVxdWlyZSgnLi9idWZmZXJlZC1zZW5kZXInKVxuICAsIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyLXJlY2VpdmVyJyk7XG59XG5cbmZ1bmN0aW9uIFNlbmRlclJlY2VpdmVyKHRyYW5zVXJsLCB1cmxTdWZmaXgsIHNlbmRlckZ1bmMsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XG4gIHZhciBwb2xsVXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0cmFuc1VybCwgdXJsU3VmZml4KTtcbiAgZGVidWcocG9sbFVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgQnVmZmVyZWRTZW5kZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgc2VuZGVyRnVuYyk7XG5cbiAgdGhpcy5wb2xsID0gbmV3IFBvbGxpbmcoUmVjZWl2ZXIsIHBvbGxVcmwsIEFqYXhPYmplY3QpO1xuICB0aGlzLnBvbGwub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICBkZWJ1ZygncG9sbCBtZXNzYWdlJywgbXNnKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICB9KTtcbiAgdGhpcy5wb2xsLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gICAgZGVidWcoJ3BvbGwgY2xvc2UnLCBjb2RlLCByZWFzb24pO1xuICAgIHNlbGYucG9sbCA9IG51bGw7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIGNvZGUsIHJlYXNvbik7XG4gICAgc2VsZi5jbG9zZSgpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoU2VuZGVyUmVjZWl2ZXIsIEJ1ZmZlcmVkU2VuZGVyKTtcblxuU2VuZGVyUmVjZWl2ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIEJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5jbG9zZS5jYWxsKHRoaXMpO1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgaWYgKHRoaXMucG9sbCkge1xuICAgIHRoaXMucG9sbC5hYm9ydCgpO1xuICAgIHRoaXMucG9sbCA9IG51bGw7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuLi8uLi91dGlscy91cmxcIjo1MixcIi4vYnVmZmVyZWQtc2VuZGVyXCI6MjUsXCIuL3BvbGxpbmdcIjoyNyxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3fV0sMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIEV2ZW50U291cmNlRHJpdmVyID0gcmVxdWlyZSgnZXZlbnRzb3VyY2UnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6ZXZlbnRzb3VyY2UnKTtcbn1cblxuZnVuY3Rpb24gRXZlbnRTb3VyY2VSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZXMgPSB0aGlzLmVzID0gbmV3IEV2ZW50U291cmNlRHJpdmVyKHVybCk7XG4gIGVzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIGUuZGF0YSk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZGVjb2RlVVJJKGUuZGF0YSkpO1xuICB9O1xuICBlcy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdlcnJvcicsIGVzLnJlYWR5U3RhdGUsIGUpO1xuICAgIC8vIEVTIG9uIHJlY29ubmVjdGlvbiBoYXMgcmVhZHlTdGF0ZSA9IDAgb3IgMS5cbiAgICAvLyBvbiBuZXR3b3JrIGVycm9yIGl0J3MgQ0xPU0VEID0gMlxuICAgIHZhciByZWFzb24gPSAoZXMucmVhZHlTdGF0ZSAhPT0gMiA/ICduZXR3b3JrJyA6ICdwZXJtYW5lbnQnKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgc2VsZi5fY2xvc2UocmVhc29uKTtcbiAgfTtcbn1cblxuaW5oZXJpdHMoRXZlbnRTb3VyY2VSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5fY2xvc2UoJ3VzZXInKTtcbn07XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG4gIHZhciBlcyA9IHRoaXMuZXM7XG4gIGlmIChlcykge1xuICAgIGVzLm9ubWVzc2FnZSA9IGVzLm9uZXJyb3IgPSBudWxsO1xuICAgIGVzLmNsb3NlKCk7XG4gICAgdGhpcy5lcyA9IG51bGw7XG4gIH1cbn07XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICBkZWJ1ZygnY2xvc2UnLCByZWFzb24pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIC8vIFNhZmFyaSBhbmQgY2hyb21lIDwgMTUgY3Jhc2ggaWYgd2UgY2xvc2Ugd2luZG93IGJlZm9yZVxuICAvLyB3YWl0aW5nIGZvciBFUyBjbGVhbnVwLiBTZWU6XG4gIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04OTE1NVxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICAgIHNlbGYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH0sIDIwMCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImV2ZW50c291cmNlXCI6MTgsXCJpbmhlcml0c1wiOjU3fV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lmcmFtZScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpodG1sZmlsZScpO1xufVxuXG5mdW5jdGlvbiBIdG1sZmlsZVJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZnJhbWVVdGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlKCk7XG5cbiAgdGhpcy5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoNik7XG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ2M9JyArIGRlY29kZVVSSUNvbXBvbmVudChpZnJhbWVVdGlscy5XUHJlZml4ICsgJy4nICsgdGhpcy5pZCkpO1xuXG4gIGRlYnVnKCd1c2luZyBodG1sZmlsZScsIEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkKTtcbiAgdmFyIGNvbnN0cnVjdEZ1bmMgPSBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA/XG4gICAgICBpZnJhbWVVdGlscy5jcmVhdGVIdG1sZmlsZSA6IGlmcmFtZVV0aWxzLmNyZWF0ZUlmcmFtZTtcblxuICBnbG9iYWxbaWZyYW1lVXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0gPSB7XG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ3N0YXJ0Jyk7XG4gICAgICBzZWxmLmlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICB9XG4gICwgbWVzc2FnZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgZGVidWcoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xuICAgIH1cbiAgLCBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdzdG9wJyk7XG4gICAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgICBzZWxmLl9jbG9zZSgnbmV0d29yaycpO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5pZnJhbWVPYmogPSBjb25zdHJ1Y3RGdW5jKHVybCwgZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2NhbGxiYWNrJyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICAgIHNlbGYuX2Nsb3NlKCdwZXJtYW5lbnQnKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEh0bWxmaWxlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuX2Nsb3NlKCd1c2VyJyk7XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgaWYgKHRoaXMuaWZyYW1lT2JqKSB7XG4gICAgdGhpcy5pZnJhbWVPYmouY2xlYW51cCgpO1xuICAgIHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgfVxuICBkZWxldGUgZ2xvYmFsW2lmcmFtZVV0aWxzLldQcmVmaXhdW3RoaXMuaWRdO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gIGRlYnVnKCdfY2xvc2UnLCByZWFzb24pO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID0gZmFsc2U7XG5cbi8vIG9iZnVzY2F0ZSB0byBhdm9pZCBmaXJld2FsbHNcbnZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuaWYgKGF4byBpbiBnbG9iYWwpIHtcbiAgdHJ5IHtcbiAgICBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA9ICEhbmV3IGdsb2JhbFtheG9dKCdodG1sZmlsZScpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICB9XG59XG5cbkh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCA9IEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkIHx8IGlmcmFtZVV0aWxzLmlmcmFtZUVuYWJsZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbGZpbGVSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuLi8uLi91dGlscy9yYW5kb21cIjo1MCxcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lmcmFtZScpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3NlcicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6anNvbnAnKTtcbn1cblxuZnVuY3Rpb24gSnNvbnBSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB1dGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlKCk7XG5cbiAgdGhpcy5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoNik7XG4gIHZhciB1cmxXaXRoSWQgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBlbmNvZGVVUklDb21wb25lbnQodXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcblxuICBnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0gPSB0aGlzLl9jYWxsYmFjay5iaW5kKHRoaXMpO1xuICB0aGlzLl9jcmVhdGVTY3JpcHQodXJsV2l0aElkKTtcblxuICAvLyBGYWxsYmFjayBtb3N0bHkgZm9yIEtvbnF1ZXJvciAtIHN0dXBpZCB0aW1lciwgMzUgc2Vjb25kcyBzaGFsbCBiZSBwbGVudHkuXG4gIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndGltZW91dCcpO1xuICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5ICh0aW1lb3V0KScpKTtcbiAgfSwgSnNvbnBSZWNlaXZlci50aW1lb3V0KTtcbn1cblxuaW5oZXJpdHMoSnNvbnBSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIGlmIChnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0pIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdKU09OUCB1c2VyIGFib3J0ZWQgcmVhZCcpO1xuICAgIGVyci5jb2RlID0gMTAwMDtcbiAgICB0aGlzLl9hYm9ydChlcnIpO1xuICB9XG59O1xuXG5Kc29ucFJlY2VpdmVyLnRpbWVvdXQgPSAzNTAwMDtcbkpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0ID0gMTAwMDtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NhbGxiYWNrID0gZnVuY3Rpb24oZGF0YSkge1xuICBkZWJ1ZygnX2NhbGxiYWNrJywgZGF0YSk7XG4gIHRoaXMuX2NsZWFudXAoKTtcblxuICBpZiAodGhpcy5hYm9ydGluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChkYXRhKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgfVxuICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgJ25ldHdvcmsnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9hYm9ydCA9IGZ1bmN0aW9uKGVycikge1xuICBkZWJ1ZygnX2Fib3J0JywgZXJyKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLmFib3J0aW5nID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdjbG9zZScsIGVyci5jb2RlLCBlcnIubWVzc2FnZSk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgaWYgKHRoaXMuc2NyaXB0Mikge1xuICAgIHRoaXMuc2NyaXB0Mi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0Mik7XG4gICAgdGhpcy5zY3JpcHQyID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQ7XG4gICAgLy8gVW5mb3J0dW5hdGVseSwgeW91IGNhbid0IHJlYWxseSBhYm9ydCBzY3JpcHQgbG9hZGluZyBvZlxuICAgIC8vIHRoZSBzY3JpcHQuXG4gICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gc2NyaXB0Lm9uZXJyb3IgPVxuICAgICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9uY2xpY2sgPSBudWxsO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuICBkZWxldGUgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX3NjcmlwdEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfc2NyaXB0RXJyb3InKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5lcnJvclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5lcnJvclRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBpZiAoIXNlbGYubG9hZGVkT2theSkge1xuICAgICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9uZXJyb3IpJykpO1xuICAgIH1cbiAgfSwgSnNvbnBSZWNlaXZlci5zY3JpcHRFcnJvclRpbWVvdXQpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NyZWF0ZVNjcmlwdCA9IGZ1bmN0aW9uKHVybCkge1xuICBkZWJ1ZygnX2NyZWF0ZVNjcmlwdCcsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IHRoaXMuc2NyaXB0ID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICB2YXIgc2NyaXB0MjsgIC8vIE9wZXJhIHN5bmNocm9ub3VzIGxvYWQgdHJpY2suXG5cbiAgc2NyaXB0LmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg4KTtcbiAgc2NyaXB0LnNyYyA9IHVybDtcbiAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgc2NyaXB0LmNoYXJzZXQgPSAnVVRGLTgnO1xuICBzY3JpcHQub25lcnJvciA9IHRoaXMuX3NjcmlwdEVycm9yLmJpbmQodGhpcyk7XG4gIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25sb2FkJyk7XG4gICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ubG9hZCknKSk7XG4gIH07XG5cbiAgLy8gSUU5IGZpcmVzICdlcnJvcicgZXZlbnQgYWZ0ZXIgb25yZWFkeXN0YXRlY2hhbmdlIG9yIGJlZm9yZSwgaW4gcmFuZG9tIG9yZGVyLlxuICAvLyBVc2UgbG9hZGVkT2theSB0byBkZXRlcm1pbmUgaWYgYWN0dWFsbHkgZXJyb3JlZFxuICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIHNjcmlwdC5yZWFkeVN0YXRlKTtcbiAgICBpZiAoL2xvYWRlZHxjbG9zZWQvLnRlc3Qoc2NyaXB0LnJlYWR5U3RhdGUpKSB7XG4gICAgICBpZiAoc2NyaXB0ICYmIHNjcmlwdC5odG1sRm9yICYmIHNjcmlwdC5vbmNsaWNrKSB7XG4gICAgICAgIHNlbGYubG9hZGVkT2theSA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSW4gSUUsIGFjdHVhbGx5IGV4ZWN1dGUgdGhlIHNjcmlwdC5cbiAgICAgICAgICBzY3JpcHQub25jbGljaygpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbnJlYWR5c3RhdGVjaGFuZ2UpJykpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gSUU6IGV2ZW50L2h0bWxGb3Ivb25jbGljayB0cmljay5cbiAgLy8gT25lIGNhbid0IHJlbHkgb24gcHJvcGVyIG9yZGVyIGZvciBvbnJlYWR5c3RhdGVjaGFuZ2UuIEluIG9yZGVyIHRvXG4gIC8vIG1ha2Ugc3VyZSwgc2V0IGEgJ2h0bWxGb3InIGFuZCAnZXZlbnQnIHByb3BlcnRpZXMsIHNvIHRoYXRcbiAgLy8gc2NyaXB0IGNvZGUgd2lsbCBiZSBpbnN0YWxsZWQgYXMgJ29uY2xpY2snIGhhbmRsZXIgZm9yIHRoZVxuICAvLyBzY3JpcHQgb2JqZWN0LiBMYXRlciwgb25yZWFkeXN0YXRlY2hhbmdlLCBtYW51YWxseSBleGVjdXRlIHRoaXNcbiAgLy8gY29kZS4gRkYgYW5kIENocm9tZSBkb2Vzbid0IHdvcmsgd2l0aCAnZXZlbnQnIGFuZCAnaHRtbEZvcidcbiAgLy8gc2V0LiBGb3IgcmVmZXJlbmNlIHNlZTpcbiAgLy8gICBodHRwOi8vamF1Ym91cmcubmV0LzIwMTAvMDcvbG9hZGluZy1zY3JpcHQtYXMtb25jbGljay1oYW5kbGVyLW9mLmh0bWxcbiAgLy8gQWxzbywgcmVhZCBvbiB0aGF0IGFib3V0IHNjcmlwdCBvcmRlcmluZzpcbiAgLy8gICBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvRHluYW1pY19TY3JpcHRfRXhlY3V0aW9uX09yZGVyXG4gIGlmICh0eXBlb2Ygc2NyaXB0LmFzeW5jID09PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuZG9jdW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICAvLyBBY2NvcmRpbmcgdG8gbW96aWxsYSBkb2NzLCBpbiByZWNlbnQgYnJvd3NlcnMgc2NyaXB0LmFzeW5jIGRlZmF1bHRzXG4gICAgLy8gdG8gJ3RydWUnLCBzbyB3ZSBtYXkgdXNlIGl0IHRvIGRldGVjdCBhIGdvb2QgYnJvd3NlcjpcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9IVE1ML0VsZW1lbnQvc2NyaXB0XG4gICAgaWYgKCFicm93c2VyLmlzT3BlcmEoKSkge1xuICAgICAgLy8gTmFpdmVseSBhc3N1bWUgd2UncmUgaW4gSUVcbiAgICAgIHRyeSB7XG4gICAgICAgIHNjcmlwdC5odG1sRm9yID0gc2NyaXB0LmlkO1xuICAgICAgICBzY3JpcHQuZXZlbnQgPSAnb25jbGljayc7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9wZXJhLCBzZWNvbmQgc3luYyBzY3JpcHQgaGFja1xuICAgICAgc2NyaXB0MiA9IHRoaXMuc2NyaXB0MiA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHNjcmlwdDIudGV4dCA9IFwidHJ5e3ZhciBhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1wiICsgc2NyaXB0LmlkICsgXCInKTsgaWYoYSlhLm9uZXJyb3IoKTt9Y2F0Y2goeCl7fTtcIjtcbiAgICAgIHNjcmlwdC5hc3luYyA9IHNjcmlwdDIuYXN5bmMgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBzY3JpcHQuYXN5bmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBoZWFkID0gZ2xvYmFsLmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcbiAgaWYgKHNjcmlwdDIpIHtcbiAgICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQyLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25wUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4uLy4uL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOnhocicpO1xufVxuXG5mdW5jdGlvbiBYaHJSZWNlaXZlcih1cmwsIEFqYXhPYmplY3QpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLmJ1ZmZlclBvc2l0aW9uID0gMDtcblxuICB0aGlzLnhvID0gbmV3IEFqYXhPYmplY3QoJ1BPU1QnLCB1cmwsIG51bGwpO1xuICB0aGlzLnhvLm9uKCdjaHVuaycsIHRoaXMuX2NodW5rSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzLCB0ZXh0KTtcbiAgICBzZWxmLl9jaHVua0hhbmRsZXIoc3RhdHVzLCB0ZXh0KTtcbiAgICBzZWxmLnhvID0gbnVsbDtcbiAgICB2YXIgcmVhc29uID0gc3RhdHVzID09PSAyMDAgPyAnbmV0d29yaycgOiAncGVybWFuZW50JztcbiAgICBkZWJ1ZygnY2xvc2UnLCByZWFzb24pO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKFhoclJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuX2NodW5rSGFuZGxlciA9IGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICBkZWJ1ZygnX2NodW5rSGFuZGxlcicsIHN0YXR1cyk7XG4gIGlmIChzdGF0dXMgIT09IDIwMCB8fCAhdGV4dCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIGlkeCA9IC0xOyA7IHRoaXMuYnVmZmVyUG9zaXRpb24gKz0gaWR4ICsgMSkge1xuICAgIHZhciBidWYgPSB0ZXh0LnNsaWNlKHRoaXMuYnVmZmVyUG9zaXRpb24pO1xuICAgIGlkeCA9IGJ1Zi5pbmRleE9mKCdcXG4nKTtcbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBtc2cgPSBidWYuc2xpY2UoMCwgaWR4KTtcbiAgICBpZiAobXNnKSB7XG4gICAgICBkZWJ1ZygnbWVzc2FnZScsIG1zZyk7XG4gICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICAgIH1cbiAgfVxufTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICBpZiAodGhpcy54bykge1xuICAgIHRoaXMueG8uY2xvc2UoKTtcbiAgICBkZWJ1ZygnY2xvc2UnKTtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgJ3VzZXInKTtcbiAgICB0aGlzLnhvID0gbnVsbDtcbiAgfVxuICB0aGlzLl9jbGVhbnVwKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlcjpqc29ucCcpO1xufVxuXG52YXIgZm9ybSwgYXJlYTtcblxuZnVuY3Rpb24gY3JlYXRlSWZyYW1lKGlkKSB7XG4gIGRlYnVnKCdjcmVhdGVJZnJhbWUnLCBpZCk7XG4gIHRyeSB7XG4gICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgcmV0dXJuIGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8aWZyYW1lIG5hbWU9XCInICsgaWQgKyAnXCI+Jyk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICB2YXIgaWZyYW1lID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmcmFtZS5uYW1lID0gaWQ7XG4gICAgcmV0dXJuIGlmcmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGb3JtKCkge1xuICBkZWJ1ZygnY3JlYXRlRm9ybScpO1xuICBmb3JtID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gIGZvcm0uZW5jdHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICBmb3JtLmFjY2VwdENoYXJzZXQgPSAnVVRGLTgnO1xuXG4gIGFyZWEgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgYXJlYS5uYW1lID0gJ2QnO1xuICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuXG4gIGdsb2JhbC5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVybCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgZGVidWcodXJsLCBwYXlsb2FkKTtcbiAgaWYgKCFmb3JtKSB7XG4gICAgY3JlYXRlRm9ybSgpO1xuICB9XG4gIHZhciBpZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoOCk7XG4gIGZvcm0udGFyZ2V0ID0gaWQ7XG4gIGZvcm0uYWN0aW9uID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsVXRpbHMuYWRkUGF0aCh1cmwsICcvanNvbnBfc2VuZCcpLCAnaT0nICsgaWQpO1xuXG4gIHZhciBpZnJhbWUgPSBjcmVhdGVJZnJhbWUoaWQpO1xuICBpZnJhbWUuaWQgPSBpZDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblxuICB0cnkge1xuICAgIGFyZWEudmFsdWUgPSBwYXlsb2FkO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gc2VyaW91c2x5IGJyb2tlbiBicm93c2VycyBnZXQgaGVyZVxuICB9XG4gIGZvcm0uc3VibWl0KCk7XG5cbiAgdmFyIGNvbXBsZXRlZCA9IGZ1bmN0aW9uKGVycikge1xuICAgIGRlYnVnKCdjb21wbGV0ZWQnLCBpZCwgZXJyKTtcbiAgICBpZiAoIWlmcmFtZS5vbmVycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBpZnJhbWUub25lcnJvciA9IGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgIC8vIE9wZXJhIG1pbmkgZG9lc24ndCBsaWtlIGlmIHdlIEdDIGlmcmFtZVxuICAgIC8vIGltbWVkaWF0ZWx5LCB0aHVzIHRoaXMgdGltZW91dC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2NsZWFuaW5nIHVwJywgaWQpO1xuICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGlmcmFtZSA9IG51bGw7XG4gICAgfSwgNTAwKTtcbiAgICBhcmVhLnZhbHVlID0gJyc7XG4gICAgLy8gSXQgaXMgbm90IHBvc3NpYmxlIHRvIGRldGVjdCBpZiB0aGUgaWZyYW1lIHN1Y2NlZWRlZCBvclxuICAgIC8vIGZhaWxlZCB0byBzdWJtaXQgb3VyIGZvcm0uXG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfTtcbiAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGlkKTtcbiAgICBjb21wbGV0ZWQoKTtcbiAgfTtcbiAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmxvYWQnLCBpZCk7XG4gICAgY29tcGxldGVkKCk7XG4gIH07XG4gIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIGlkLCBpZnJhbWUucmVhZHlTdGF0ZSwgZSk7XG4gICAgaWYgKGlmcmFtZS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygnYWJvcnRlZCcsIGlkKTtcbiAgICBjb21wbGV0ZWQobmV3IEVycm9yKCdBYm9ydGVkJykpO1xuICB9O1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTV9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Jyb3dzZXInKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlcjp4ZHInKTtcbn1cblxuLy8gUmVmZXJlbmNlczpcbi8vICAgaHR0cDovL2FqYXhpYW4uY29tL2FyY2hpdmVzLzEwMC1saW5lLWFqYXgtd3JhcHBlclxuLy8gICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MyODgwNjAodj1WUy44NSkuYXNweFxuXG5mdW5jdGlvbiBYRFJPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQpIHtcbiAgZGVidWcobWV0aG9kLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQpO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoWERST2JqZWN0LCBFdmVudEVtaXR0ZXIpO1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gIGRlYnVnKCdfc3RhcnQnKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgeGRyID0gbmV3IGdsb2JhbC5YRG9tYWluUmVxdWVzdCgpO1xuICAvLyBJRSBjYWNoZXMgZXZlbiBQT1NUc1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICd0PScgKyAoK25ldyBEYXRlKCkpKTtcblxuICB4ZHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmVycm9yJyk7XG4gICAgc2VsZi5fZXJyb3IoKTtcbiAgfTtcbiAgeGRyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbnRpbWVvdXQnKTtcbiAgICBzZWxmLl9lcnJvcigpO1xuICB9O1xuICB4ZHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdwcm9ncmVzcycsIHhkci5yZXNwb25zZVRleHQpO1xuICAgIHNlbGYuZW1pdCgnY2h1bmsnLCAyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICB9O1xuICB4ZHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2xvYWQnKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gIH07XG4gIHRoaXMueGRyID0geGRyO1xuICB0aGlzLnVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gIH0pO1xuICB0cnkge1xuICAgIC8vIEZhaWxzIHdpdGggQWNjZXNzRGVuaWVkIGlmIHBvcnQgbnVtYmVyIGlzIGJvZ3VzXG4gICAgdGhpcy54ZHIub3BlbihtZXRob2QsIHVybCk7XG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgdGhpcy54ZHIudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICB9XG4gICAgdGhpcy54ZHIuc2VuZChwYXlsb2FkKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHRoaXMuX2Vycm9yKCk7XG4gIH1cbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbihhYm9ydCkge1xuICBkZWJ1ZygnY2xlYW51cCcsIGFib3J0KTtcbiAgaWYgKCF0aGlzLnhkcikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBldmVudFV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG5cbiAgdGhpcy54ZHIub250aW1lb3V0ID0gdGhpcy54ZHIub25lcnJvciA9IHRoaXMueGRyLm9ucHJvZ3Jlc3MgPSB0aGlzLnhkci5vbmxvYWQgPSBudWxsO1xuICBpZiAoYWJvcnQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54ZHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICB9XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy54ZHIgPSBudWxsO1xufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbn07XG5cbi8vIElFIDgvOSBpZiB0aGUgcmVxdWVzdCB0YXJnZXQgdXNlcyB0aGUgc2FtZSBzY2hlbWUgLSAjNzlcblhEUk9iamVjdC5lbmFibGVkID0gISEoZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmIGJyb3dzZXIuaGFzRG9tYWluKCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhEUk9iamVjdDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi4vLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgWGhyRHJpdmVyID0gcmVxdWlyZSgnLi4vZHJpdmVyL3hocicpXG4gIDtcblxuZnVuY3Rpb24gWEhSQ29yc09iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICBYaHJEcml2ZXIuY2FsbCh0aGlzLCBtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cyk7XG59XG5cbmluaGVyaXRzKFhIUkNvcnNPYmplY3QsIFhockRyaXZlcik7XG5cblhIUkNvcnNPYmplY3QuZW5hYmxlZCA9IFhockRyaXZlci5lbmFibGVkICYmIFhockRyaXZlci5zdXBwb3J0c0NPUlM7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSQ29yc09iamVjdDtcblxufSx7XCIuLi9kcml2ZXIveGhyXCI6MTcsXCJpbmhlcml0c1wiOjU3fV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gIDtcblxuZnVuY3Rpb24gWEhSRmFrZSgvKiBtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cyAqLykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMudG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMjAwLCAne30nKTtcbiAgfSwgWEhSRmFrZS50aW1lb3V0KTtcbn1cblxuaW5oZXJpdHMoWEhSRmFrZSwgRXZlbnRFbWl0dGVyKTtcblxuWEhSRmFrZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgY2xlYXJUaW1lb3V0KHRoaXMudG8pO1xufTtcblxuWEhSRmFrZS50aW1lb3V0ID0gMjAwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJGYWtlO1xuXG59LHtcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgWGhyRHJpdmVyID0gcmVxdWlyZSgnLi4vZHJpdmVyL3hocicpXG4gIDtcblxuZnVuY3Rpb24gWEhSTG9jYWxPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQgLyosIG9wdHMgKi8pIHtcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIHtcbiAgICBub0NyZWRlbnRpYWxzOiB0cnVlXG4gIH0pO1xufVxuXG5pbmhlcml0cyhYSFJMb2NhbE9iamVjdCwgWGhyRHJpdmVyKTtcblxuWEhSTG9jYWxPYmplY3QuZW5hYmxlZCA9IFhockRyaXZlci5lbmFibGVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkxvY2FsT2JqZWN0O1xuXG59LHtcIi4uL2RyaXZlci94aHJcIjoxNyxcImluaGVyaXRzXCI6NTd9XSwzODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9ldmVudCcpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91cmwnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIFdlYnNvY2tldERyaXZlciA9IHJlcXVpcmUoJy4vZHJpdmVyL3dlYnNvY2tldCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp3ZWJzb2NrZXQnKTtcbn1cblxuZnVuY3Rpb24gV2ViU29ja2V0VHJhbnNwb3J0KHRyYW5zVXJsLCBpZ25vcmUsIG9wdGlvbnMpIHtcbiAgaWYgKCFXZWJTb2NrZXRUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cblxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgZGVidWcoJ2NvbnN0cnVjdG9yJywgdHJhbnNVcmwpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHVybCA9IHVybFV0aWxzLmFkZFBhdGgodHJhbnNVcmwsICcvd2Vic29ja2V0Jyk7XG4gIGlmICh1cmwuc2xpY2UoMCwgNSkgPT09ICdodHRwcycpIHtcbiAgICB1cmwgPSAnd3NzJyArIHVybC5zbGljZSg1KTtcbiAgfSBlbHNlIHtcbiAgICB1cmwgPSAnd3MnICsgdXJsLnNsaWNlKDQpO1xuICB9XG4gIHRoaXMudXJsID0gdXJsO1xuXG4gIHRoaXMud3MgPSBuZXcgV2Vic29ja2V0RHJpdmVyKHRoaXMudXJsLCBbXSwgb3B0aW9ucyk7XG4gIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdtZXNzYWdlIGV2ZW50JywgZS5kYXRhKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICB9O1xuICAvLyBGaXJlZm94IGhhcyBhbiBpbnRlcmVzdGluZyBidWcuIElmIGEgd2Vic29ja2V0IGNvbm5lY3Rpb24gaXNcbiAgLy8gY3JlYXRlZCBhZnRlciBvbnVubG9hZCwgaXQgc3RheXMgYWxpdmUgZXZlbiB3aGVuIHVzZXJcbiAgLy8gbmF2aWdhdGVzIGF3YXkgZnJvbSB0aGUgcGFnZS4gSW4gc3VjaCBzaXR1YXRpb24gbGV0J3MgbGllIC1cbiAgLy8gbGV0J3Mgbm90IG9wZW4gdGhlIHdzIGNvbm5lY3Rpb24gYXQgYWxsLiBTZWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NranMvc29ja2pzLWNsaWVudC9pc3N1ZXMvMjhcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk2MDg1XG4gIHRoaXMudW5sb2FkUmVmID0gdXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd1bmxvYWQnKTtcbiAgICBzZWxmLndzLmNsb3NlKCk7XG4gIH0pO1xuICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Nsb3NlIGV2ZW50JywgZS5jb2RlLCBlLnJlYXNvbik7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIGUuY29kZSwgZS5yZWFzb24pO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfTtcbiAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdlcnJvciBldmVudCcsIGUpO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCAxMDA2LCAnV2ViU29ja2V0IGNvbm5lY3Rpb24gYnJva2VuJyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9O1xufVxuXG5pbmhlcml0cyhXZWJTb2NrZXRUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIG1zZyA9ICdbJyArIGRhdGEgKyAnXSc7XG4gIGRlYnVnKCdzZW5kJywgbXNnKTtcbiAgdGhpcy53cy5zZW5kKG1zZyk7XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB2YXIgd3MgPSB0aGlzLndzO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIGlmICh3cykge1xuICAgIHdzLmNsb3NlKCk7XG4gIH1cbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHZhciB3cyA9IHRoaXMud3M7XG4gIGlmICh3cykge1xuICAgIHdzLm9ubWVzc2FnZSA9IHdzLm9uY2xvc2UgPSB3cy5vbmVycm9yID0gbnVsbDtcbiAgfVxuICB1dGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMud3MgPSBudWxsO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2VuYWJsZWQnKTtcbiAgcmV0dXJuICEhV2Vic29ja2V0RHJpdmVyO1xufTtcbldlYlNvY2tldFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3dlYnNvY2tldCc7XG5cbi8vIEluIHRoZW9yeSwgd3Mgc2hvdWxkIHJlcXVpcmUgMSByb3VuZCB0cmlwLiBCdXQgaW4gY2hyb21lLCB0aGlzIGlzXG4vLyBub3QgdmVyeSBzdGFibGUgb3ZlciBTU0wuIE1vc3QgbGlrZWx5IGEgd3MgY29ubmVjdGlvbiByZXF1aXJlcyBhXG4vLyBzZXBhcmF0ZSBTU0wgY29ubmVjdGlvbiwgaW4gd2hpY2ggY2FzZSAyIHJvdW5kIHRyaXBzIGFyZSBhblxuLy8gYWJzb2x1dGUgbWludW11bS5cbldlYlNvY2tldFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuLi91dGlscy9ldmVudFwiOjQ2LFwiLi4vdXRpbHMvdXJsXCI6NTIsXCIuL2RyaXZlci93ZWJzb2NrZXRcIjoxOSxcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDM5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhkclN0cmVhbWluZ1RyYW5zcG9ydCA9IHJlcXVpcmUoJy4veGRyLXN0cmVhbWluZycpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWERST2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGRyJylcbiAgO1xuXG5mdW5jdGlvbiBYZHJQb2xsaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWERST2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGRyUG9sbGluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGRyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQ7XG5YZHJQb2xsaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGRyLXBvbGxpbmcnO1xuWGRyUG9sbGluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGRyUG9sbGluZ1RyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGRyXCI6MzQsXCIuL3hkci1zdHJlYW1pbmdcIjo0MCxcImluaGVyaXRzXCI6NTd9XSw0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYRFJPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94ZHInKVxuICA7XG5cbi8vIEFjY29yZGluZyB0bzpcbi8vICAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjQxNTA3L2RldGVjdC1icm93c2VyLXN1cHBvcnQtZm9yLWNyb3NzLWRvbWFpbi14bWxodHRwcmVxdWVzdHNcbi8vICAgaHR0cDovL2hhY2tzLm1vemlsbGEub3JnLzIwMDkvMDcvY3Jvc3Mtc2l0ZS14bWxodHRwcmVxdWVzdC13aXRoLWNvcnMvXG5cbmZ1bmN0aW9uIFhkclN0cmVhbWluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhEUk9iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyX3N0cmVhbWluZycsIFhoclJlY2VpdmVyLCBYRFJPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYZHJTdHJlYW1pbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5jb29raWVfbmVlZGVkIHx8IGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gWERST2JqZWN0LmVuYWJsZWQgJiYgaW5mby5zYW1lU2NoZW1lO1xufTtcblxuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGRyLXN0cmVhbWluZyc7XG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGRyXCI6MzQsXCJpbmhlcml0c1wiOjU3fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gIDtcblxuZnVuY3Rpb24gWGhyUG9sbGluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgIVhIUkNvcnNPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocicsIFhoclJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGhyUG9sbGluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGhyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgaW5mby5zYW1lT3JpZ2luKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIFhIUkNvcnNPYmplY3QuZW5hYmxlZDtcbn07XG5cblhoclBvbGxpbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItcG9sbGluZyc7XG5YaHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJQb2xsaW5nVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94aHItY29yc1wiOjM1LFwiLi9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJpbmhlcml0c1wiOjU3fV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWxzL2Jyb3dzZXInKVxuICA7XG5cbmZ1bmN0aW9uIFhoclN0cmVhbWluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgIVhIUkNvcnNPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKFhoclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gT3BlcmEgZG9lc24ndCBzdXBwb3J0IHhoci1zdHJlYW1pbmcgIzYwXG4gIC8vIEJ1dCBpdCBtaWdodCBiZSBhYmxlIHRvICM5MlxuICBpZiAoYnJvd3Nlci5pc09wZXJhKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gWEhSQ29yc09iamVjdC5lbmFibGVkO1xufTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGhyLXN0cmVhbWluZyc7XG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG4vLyBTYWZhcmkgZ2V0cyBjb25mdXNlZCB3aGVuIGEgc3RyZWFtaW5nIGFqYXggcmVxdWVzdCBpcyBzdGFydGVkXG4vLyBiZWZvcmUgb25sb2FkLiBUaGlzIGNhdXNlcyB0aGUgbG9hZCBpbmRpY2F0b3IgdG8gc3BpbiBpbmRlZmluZXRlbHkuXG4vLyBPbmx5IHJlcXVpcmUgYm9keSB3aGVuIHVzZWQgaW4gYSBicm93c2VyXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQubmVlZEJvZHkgPSAhIWdsb2JhbC5kb2N1bWVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJTdHJlYW1pbmdUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94aHItY29yc1wiOjM1LFwiLi9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJpbmhlcml0c1wiOjU3fV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5pZiAoZ2xvYmFsLmNyeXB0byAmJiBnbG9iYWwuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZ2xvYmFsLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBieXRlcztcbiAgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnl0ZXNbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw0NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc09wZXJhOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ2xvYmFsLm5hdmlnYXRvciAmJlxuICAgICAgL29wZXJhL2kudGVzdChnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuLCBpc0tvbnF1ZXJvcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5uYXZpZ2F0b3IgJiZcbiAgICAgIC9rb25xdWVyb3IvaS50ZXN0KGdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8vICMxODcgd3JhcCBkb2N1bWVudC5kb21haW4gaW4gdHJ5L2NhdGNoIGJlY2F1c2Ugb2YgV1A4IGZyb20gZmlsZTovLy9cbiwgaGFzRG9tYWluOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbm9uLWJyb3dzZXIgY2xpZW50IGFsd2F5cyBoYXMgYSBkb21haW5cbiAgICBpZiAoIWdsb2JhbC5kb2N1bWVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAhIWdsb2JhbC5kb2N1bWVudC5kb21haW47XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKTtcblxuLy8gU29tZSBleHRyYSBjaGFyYWN0ZXJzIHRoYXQgQ2hyb21lIGdldHMgd3JvbmcsIGFuZCBzdWJzdGl0dXRlcyB3aXRoXG4vLyBzb21ldGhpbmcgZWxzZSBvbiB0aGUgd2lyZS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG52YXIgZXh0cmFFc2NhcGFibGUgPSAvW1xceDAwLVxceDFmXFx1ZDgwMC1cXHVkZmZmXFx1ZmZmZVxcdWZmZmZcXHUwMzAwLVxcdTAzMzNcXHUwMzNkLVxcdTAzNDZcXHUwMzRhLVxcdTAzNGNcXHUwMzUwLVxcdTAzNTJcXHUwMzU3LVxcdTAzNThcXHUwMzVjLVxcdTAzNjJcXHUwMzc0XFx1MDM3ZVxcdTAzODdcXHUwNTkxLVxcdTA1YWZcXHUwNWM0XFx1MDYxMC1cXHUwNjE3XFx1MDY1My1cXHUwNjU0XFx1MDY1Ny1cXHUwNjViXFx1MDY1ZC1cXHUwNjVlXFx1MDZkZi1cXHUwNmUyXFx1MDZlYi1cXHUwNmVjXFx1MDczMFxcdTA3MzItXFx1MDczM1xcdTA3MzUtXFx1MDczNlxcdTA3M2FcXHUwNzNkXFx1MDczZi1cXHUwNzQxXFx1MDc0M1xcdTA3NDVcXHUwNzQ3XFx1MDdlYi1cXHUwN2YxXFx1MDk1MVxcdTA5NTgtXFx1MDk1ZlxcdTA5ZGMtXFx1MDlkZFxcdTA5ZGZcXHUwYTMzXFx1MGEzNlxcdTBhNTktXFx1MGE1YlxcdTBhNWVcXHUwYjVjLVxcdTBiNWRcXHUwZTM4LVxcdTBlMzlcXHUwZjQzXFx1MGY0ZFxcdTBmNTJcXHUwZjU3XFx1MGY1Y1xcdTBmNjlcXHUwZjcyLVxcdTBmNzZcXHUwZjc4XFx1MGY4MC1cXHUwZjgzXFx1MGY5M1xcdTBmOWRcXHUwZmEyXFx1MGZhN1xcdTBmYWNcXHUwZmI5XFx1MTkzOS1cXHUxOTNhXFx1MWExN1xcdTFiNmJcXHUxY2RhLVxcdTFjZGJcXHUxZGMwLVxcdTFkY2ZcXHUxZGZjXFx1MWRmZVxcdTFmNzFcXHUxZjczXFx1MWY3NVxcdTFmNzdcXHUxZjc5XFx1MWY3YlxcdTFmN2RcXHUxZmJiXFx1MWZiZVxcdTFmYzlcXHUxZmNiXFx1MWZkM1xcdTFmZGJcXHUxZmUzXFx1MWZlYlxcdTFmZWUtXFx1MWZlZlxcdTFmZjlcXHUxZmZiXFx1MWZmZFxcdTIwMDAtXFx1MjAwMVxcdTIwZDAtXFx1MjBkMVxcdTIwZDQtXFx1MjBkN1xcdTIwZTctXFx1MjBlOVxcdTIxMjZcXHUyMTJhLVxcdTIxMmJcXHUyMzI5LVxcdTIzMmFcXHUyYWRjXFx1MzAyYi1cXHUzMDJjXFx1YWFiMi1cXHVhYWIzXFx1ZjkwMC1cXHVmYTBkXFx1ZmExMFxcdWZhMTJcXHVmYTE1LVxcdWZhMWVcXHVmYTIwXFx1ZmEyMlxcdWZhMjUtXFx1ZmEyNlxcdWZhMmEtXFx1ZmEyZFxcdWZhMzAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMWRcXHVmYjFmXFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDAtXFx1ZmI0MVxcdWZiNDMtXFx1ZmI0NFxcdWZiNDYtXFx1ZmI0ZVxcdWZmZjAtXFx1ZmZmZl0vZ1xuICAsIGV4dHJhTG9va3VwO1xuXG4vLyBUaGlzIG1heSBiZSBxdWl0ZSBzbG93LCBzbyBsZXQncyBkZWxheSB1bnRpbCB1c2VyIGFjdHVhbGx5IHVzZXMgYmFkXG4vLyBjaGFyYWN0ZXJzLlxudmFyIHVucm9sbExvb2t1cCA9IGZ1bmN0aW9uKGVzY2FwYWJsZSkge1xuICB2YXIgaTtcbiAgdmFyIHVucm9sbGVkID0ge307XG4gIHZhciBjID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCA2NTUzNjsgaSsrKSB7XG4gICAgYy5wdXNoKCBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpICk7XG4gIH1cbiAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gIGMuam9pbignJykucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICB1bnJvbGxlZFsgYSBdID0gJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgcmV0dXJuICcnO1xuICB9KTtcbiAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gIHJldHVybiB1bnJvbGxlZDtcbn07XG5cbi8vIFF1b3RlIHN0cmluZywgYWxzbyB0YWtpbmcgY2FyZSBvZiB1bmljb2RlIGNoYXJhY3RlcnMgdGhhdCBicm93c2Vyc1xuLy8gb2Z0ZW4gYnJlYWsuIEVzcGVjaWFsbHksIHRha2UgY2FyZSBvZiB1bmljb2RlIHN1cnJvZ2F0ZXM6XG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcHBpbmdfb2ZfVW5pY29kZV9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBxdW90ZTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIHF1b3RlZCA9IEpTT04zLnN0cmluZ2lmeShzdHJpbmcpO1xuXG4gICAgLy8gSW4gbW9zdCBjYXNlcyB0aGlzIHNob3VsZCBiZSB2ZXJ5IGZhc3QgYW5kIGdvb2QgZW5vdWdoLlxuICAgIGV4dHJhRXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgaWYgKCFleHRyYUVzY2FwYWJsZS50ZXN0KHF1b3RlZCkpIHtcbiAgICAgIHJldHVybiBxdW90ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFleHRyYUxvb2t1cCkge1xuICAgICAgZXh0cmFMb29rdXAgPSB1bnJvbGxMb29rdXAoZXh0cmFFc2NhcGFibGUpO1xuICAgIH1cblxuICAgIHJldHVybiBxdW90ZWQucmVwbGFjZShleHRyYUVzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIGV4dHJhTG9va3VwW2FdO1xuICAgIH0pO1xuICB9XG59O1xuXG59LHtcImpzb24zXCI6NTh9XSw0NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciByYW5kb20gPSByZXF1aXJlKCcuL3JhbmRvbScpO1xuXG52YXIgb25VbmxvYWQgPSB7fVxuICAsIGFmdGVyVW5sb2FkID0gZmFsc2VcbiAgICAvLyBkZXRlY3QgZ29vZ2xlIGNocm9tZSBwYWNrYWdlZCBhcHBzIGJlY2F1c2UgdGhleSBkb24ndCBhbGxvdyB0aGUgJ3VubG9hZCcgZXZlbnRcbiAgLCBpc0Nocm9tZVBhY2thZ2VkQXBwID0gZ2xvYmFsLmNocm9tZSAmJiBnbG9iYWwuY2hyb21lLmFwcCAmJiBnbG9iYWwuY2hyb21lLmFwcC5ydW50aW1lXG4gIDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGF0dGFjaEV2ZW50OiBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgICAvLyBJRSBxdWlya3MuXG4gICAgICAvLyBBY2NvcmRpbmcgdG86IGh0dHA6Ly9zdGV2ZXNvdWRlcnMuY29tL21pc2MvdGVzdC1wb3N0bWVzc2FnZS5waHBcbiAgICAgIC8vIHRoZSBtZXNzYWdlIGdldHMgZGVsaXZlcmVkIG9ubHkgdG8gJ2RvY3VtZW50Jywgbm90ICd3aW5kb3cnLlxuICAgICAgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgLy8gSSBnZXQgJ3dpbmRvdycgZm9yIGllOC5cbiAgICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuLCBkZXRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5kZXRhY2hFdmVudCkge1xuICAgICAgZ2xvYmFsLmRvY3VtZW50LmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgZ2xvYmFsLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4sIHVubG9hZEFkZDogZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICBpZiAoaXNDaHJvbWVQYWNrYWdlZEFwcCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHJhbmRvbS5zdHJpbmcoOCk7XG4gICAgb25VbmxvYWRbcmVmXSA9IGxpc3RlbmVyO1xuICAgIGlmIChhZnRlclVubG9hZCkge1xuICAgICAgc2V0VGltZW91dCh0aGlzLnRyaWdnZXJVbmxvYWRDYWxsYmFja3MsIDApO1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xuICB9XG5cbiwgdW5sb2FkRGVsOiBmdW5jdGlvbihyZWYpIHtcbiAgICBpZiAocmVmIGluIG9uVW5sb2FkKSB7XG4gICAgICBkZWxldGUgb25VbmxvYWRbcmVmXTtcbiAgICB9XG4gIH1cblxuLCB0cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzOiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciByZWYgaW4gb25VbmxvYWQpIHtcbiAgICAgIG9uVW5sb2FkW3JlZl0oKTtcbiAgICAgIGRlbGV0ZSBvblVubG9hZFtyZWZdO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHVubG9hZFRyaWdnZXJlZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoYWZ0ZXJVbmxvYWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWZ0ZXJVbmxvYWQgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cy50cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzKCk7XG59O1xuXG4vLyAndW5sb2FkJyBhbG9uZSBpcyBub3QgcmVsaWFibGUgaW4gb3BlcmEgd2l0aGluIGFuIGlmcmFtZSwgYnV0IHdlXG4vLyBjYW4ndCB1c2UgYGJlZm9yZXVubG9hZGAgYXMgSUUgZmlyZXMgaXQgb24gamF2YXNjcmlwdDogbGlua3MuXG5pZiAoIWlzQ2hyb21lUGFja2FnZWRBcHApIHtcbiAgbW9kdWxlLmV4cG9ydHMuYXR0YWNoRXZlbnQoJ3VubG9hZCcsIHVubG9hZFRyaWdnZXJlZCk7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vcmFuZG9tXCI6NTB9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi9icm93c2VyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOmlmcmFtZScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV1ByZWZpeDogJ19qcCdcbiwgY3VycmVudFdpbmRvd0lkOiBudWxsXG5cbiwgcG9sbHV0ZUdsb2JhbE5hbWVzcGFjZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEobW9kdWxlLmV4cG9ydHMuV1ByZWZpeCBpbiBnbG9iYWwpKSB7XG4gICAgICBnbG9iYWxbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF0gPSB7fTtcbiAgICB9XG4gIH1cblxuLCBwb3N0TWVzc2FnZTogZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgIGlmIChnbG9iYWwucGFyZW50ICE9PSBnbG9iYWwpIHtcbiAgICAgIGdsb2JhbC5wYXJlbnQucG9zdE1lc3NhZ2UoSlNPTjMuc3RyaW5naWZ5KHtcbiAgICAgICAgd2luZG93SWQ6IG1vZHVsZS5leHBvcnRzLmN1cnJlbnRXaW5kb3dJZFxuICAgICAgLCB0eXBlOiB0eXBlXG4gICAgICAsIGRhdGE6IGRhdGEgfHwgJydcbiAgICAgIH0pLCAnKicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnQ2Fubm90IHBvc3RNZXNzYWdlLCBubyBwYXJlbnQgd2luZG93LicsIHR5cGUsIGRhdGEpO1xuICAgIH1cbiAgfVxuXG4sIGNyZWF0ZUlmcmFtZTogZnVuY3Rpb24oaWZyYW1lVXJsLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIGlmcmFtZSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICB2YXIgdHJlZiwgdW5sb2FkUmVmO1xuICAgIHZhciB1bmF0dGFjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ3VuYXR0YWNoJyk7XG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICAvLyBFeHBsb3JlciBoYWQgcHJvYmxlbXMgd2l0aCB0aGF0LlxuICAgICAgdHJ5IHtcbiAgICAgICAgaWZyYW1lLm9ubG9hZCA9IG51bGw7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICAgIGlmcmFtZS5vbmVycm9yID0gbnVsbDtcbiAgICB9O1xuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICB1bmF0dGFjaCgpO1xuICAgICAgICAvLyBUaGlzIHRpbWVvdXQgbWFrZXMgY2hyb21lIGZpcmUgb25iZWZvcmV1bmxvYWQgZXZlbnRcbiAgICAgICAgLy8gd2l0aGluIGlmcmFtZS4gV2l0aG91dCB0aGUgdGltZW91dCBpdCBnb2VzIHN0cmFpZ2h0IHRvXG4gICAgICAgIC8vIG9udW5sb2FkLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmcmFtZSA9IG51bGw7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBldmVudFV0aWxzLnVubG9hZERlbCh1bmxvYWRSZWYpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGRlYnVnKCdvbmVycm9yJywgZXJyKTtcbiAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBlcnJvckNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcG9zdCA9IGZ1bmN0aW9uKG1zZywgb3JpZ2luKSB7XG4gICAgICBkZWJ1ZygncG9zdCcsIG1zZywgb3JpZ2luKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaWZyYW1lICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lVXJsO1xuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGlmcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ29uZXJyb3InKTtcbiAgICB9O1xuICAgIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdvbmxvYWQnKTtcbiAgICAgIC8vIGBvbmxvYWRgIGlzIHRyaWdnZXJlZCBiZWZvcmUgc2NyaXB0cyBvbiB0aGUgaWZyYW1lIGFyZVxuICAgICAgLy8gZXhlY3V0ZWQuIEdpdmUgaXQgZmV3IHNlY29uZHMgdG8gYWN0dWFsbHkgbG9hZCBzdHVmZi5cbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBvbmVycm9yKCdvbmxvYWQgdGltZW91dCcpO1xuICAgICAgfSwgMjAwMCk7XG4gICAgfTtcbiAgICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcigndGltZW91dCcpO1xuICAgIH0sIDE1MDAwKTtcbiAgICB1bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChjbGVhbnVwKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zdDogcG9zdFxuICAgICwgY2xlYW51cDogY2xlYW51cFxuICAgICwgbG9hZGVkOiB1bmF0dGFjaFxuICAgIH07XG4gIH1cblxuLyogZXNsaW50IG5vLXVuZGVmOiBcIm9mZlwiLCBuZXctY2FwOiBcIm9mZlwiICovXG4sIGNyZWF0ZUh0bWxmaWxlOiBmdW5jdGlvbihpZnJhbWVVcmwsIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbiAgICB2YXIgZG9jID0gbmV3IGdsb2JhbFtheG9dKCdodG1sZmlsZScpO1xuICAgIHZhciB0cmVmLCB1bmxvYWRSZWY7XG4gICAgdmFyIGlmcmFtZTtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIGlmcmFtZS5vbmVycm9yID0gbnVsbDtcbiAgICB9O1xuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHVuYXR0YWNoKCk7XG4gICAgICAgIGV2ZW50VXRpbHMudW5sb2FkRGVsKHVubG9hZFJlZik7XG4gICAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgIGlmcmFtZSA9IGRvYyA9IG51bGw7XG4gICAgICAgIENvbGxlY3RHYXJiYWdlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgIGRlYnVnKCdvbmVycm9yJywgcik7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwb3N0ID0gZnVuY3Rpb24obXNnLCBvcmlnaW4pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaWZyYW1lICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1zZywgb3JpZ2luKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRvYy5vcGVuKCk7XG4gICAgZG9jLndyaXRlKCc8aHRtbD48cycgKyAnY3JpcHQ+JyArXG4gICAgICAgICAgICAgICdkb2N1bWVudC5kb21haW49XCInICsgZ2xvYmFsLmRvY3VtZW50LmRvbWFpbiArICdcIjsnICtcbiAgICAgICAgICAgICAgJzwvcycgKyAnY3JpcHQ+PC9odG1sPicpO1xuICAgIGRvYy5jbG9zZSgpO1xuICAgIGRvYy5wYXJlbnRXaW5kb3dbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF0gPSBnbG9iYWxbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF07XG4gICAgdmFyIGMgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoYyk7XG4gICAgaWZyYW1lID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGMuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lVXJsO1xuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCdvbmVycm9yJyk7XG4gICAgfTtcbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ3RpbWVvdXQnKTtcbiAgICB9LCAxNTAwMCk7XG4gICAgdW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoY2xlYW51cCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3Q6IHBvc3RcbiAgICAsIGNsZWFudXA6IGNsZWFudXBcbiAgICAsIGxvYWRlZDogdW5hdHRhY2hcbiAgICB9O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5pZnJhbWVFbmFibGVkID0gZmFsc2U7XG5pZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gIC8vIHBvc3RNZXNzYWdlIG1pc2JlaGF2ZXMgaW4ga29ucXVlcm9yIDQuNi41IC0gdGhlIG1lc3NhZ2VzIGFyZSBkZWxpdmVyZWQgd2l0aFxuICAvLyBodWdlIGRlbGF5LCBvciBub3QgYXQgYWxsLlxuICBtb2R1bGUuZXhwb3J0cy5pZnJhbWVFbmFibGVkID0gKHR5cGVvZiBnbG9iYWwucG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicgfHxcbiAgICB0eXBlb2YgZ2xvYmFsLnBvc3RNZXNzYWdlID09PSAnb2JqZWN0JykgJiYgKCFicm93c2VyLmlzS29ucXVlcm9yKCkpO1xufVxuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2Jyb3dzZXJcIjo0NCxcIi4vZXZlbnRcIjo0NixcImRlYnVnXCI6NTUsXCJqc29uM1wiOjU4fV0sNDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbG9nT2JqZWN0ID0ge307XG5bJ2xvZycsICdkZWJ1ZycsICd3YXJuJ10uZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgdmFyIGxldmVsRXhpc3RzO1xuXG4gIHRyeSB7XG4gICAgbGV2ZWxFeGlzdHMgPSBnbG9iYWwuY29uc29sZSAmJiBnbG9iYWwuY29uc29sZVtsZXZlbF0gJiYgZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdLmFwcGx5O1xuICB9IGNhdGNoKGUpIHtcbiAgICAvLyBkbyBub3RoaW5nXG4gIH1cblxuICBsb2dPYmplY3RbbGV2ZWxdID0gbGV2ZWxFeGlzdHMgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5jb25zb2xlW2xldmVsXS5hcHBseShnbG9iYWwuY29uc29sZSwgYXJndW1lbnRzKTtcbiAgfSA6IChsZXZlbCA9PT0gJ2xvZycgPyBmdW5jdGlvbiAoKSB7fSA6IGxvZ09iamVjdC5sb2cpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbG9nT2JqZWN0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfVxuXG4sIGV4dGVuZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCF0aGlzLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHZhciBzb3VyY2UsIHByb3A7XG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yIChwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufTtcblxufSx7fV0sNTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgY3J5cHRvOnRydWUgKi9cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuLy8gVGhpcyBzdHJpbmcgaGFzIGxlbmd0aCAzMiwgYSBwb3dlciBvZiAyLCBzbyB0aGUgbW9kdWx1cyBkb2Vzbid0IGludHJvZHVjZSBhXG4vLyBiaWFzLlxudmFyIF9yYW5kb21TdHJpbmdDaGFycyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NSc7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RyaW5nOiBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgbWF4ID0gX3JhbmRvbVN0cmluZ0NoYXJzLmxlbmd0aDtcbiAgICB2YXIgYnl0ZXMgPSBjcnlwdG8ucmFuZG9tQnl0ZXMobGVuZ3RoKTtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmV0LnB1c2goX3JhbmRvbVN0cmluZ0NoYXJzLnN1YnN0cihieXRlc1tpXSAlIG1heCwgMSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICB9XG5cbiwgbnVtYmVyOiBmdW5jdGlvbihtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KTtcbiAgfVxuXG4sIG51bWJlclN0cmluZzogZnVuY3Rpb24obWF4KSB7XG4gICAgdmFyIHQgPSAoJycgKyAobWF4IC0gMSkpLmxlbmd0aDtcbiAgICB2YXIgcCA9IG5ldyBBcnJheSh0ICsgMSkuam9pbignMCcpO1xuICAgIHJldHVybiAocCArIHRoaXMubnVtYmVyKG1heCkpLnNsaWNlKC10KTtcbiAgfVxufTtcblxufSx7XCJjcnlwdG9cIjo0M31dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6dHJhbnNwb3J0Jyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICByZXR1cm4ge1xuICAgIGZpbHRlclRvRW5hYmxlZDogZnVuY3Rpb24odHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbykge1xuICAgICAgdmFyIHRyYW5zcG9ydHMgPSB7XG4gICAgICAgIG1haW46IFtdXG4gICAgICAsIGZhY2FkZTogW11cbiAgICAgIH07XG4gICAgICBpZiAoIXRyYW5zcG9ydHNXaGl0ZWxpc3QpIHtcbiAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFtdO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHJhbnNwb3J0c1doaXRlbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFt0cmFuc3BvcnRzV2hpdGVsaXN0XTtcbiAgICAgIH1cblxuICAgICAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zKSB7XG4gICAgICAgIGlmICghdHJhbnMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnMudHJhbnNwb3J0TmFtZSA9PT0gJ3dlYnNvY2tldCcgJiYgaW5mby53ZWJzb2NrZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZGVidWcoJ2Rpc2FibGVkIGZyb20gc2VydmVyJywgJ3dlYnNvY2tldCcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc3BvcnRzV2hpdGVsaXN0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdC5pbmRleE9mKHRyYW5zLnRyYW5zcG9ydE5hbWUpID09PSAtMSkge1xuICAgICAgICAgIGRlYnVnKCdub3QgaW4gd2hpdGVsaXN0JywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zLmVuYWJsZWQoaW5mbykpIHtcbiAgICAgICAgICBkZWJ1ZygnZW5hYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICAgIHRyYW5zcG9ydHMubWFpbi5wdXNoKHRyYW5zKTtcbiAgICAgICAgICBpZiAodHJhbnMuZmFjYWRlVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0cmFuc3BvcnRzLmZhY2FkZS5wdXNoKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cmFuc3BvcnRzO1xuICAgIH1cbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1fV0sNTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIFVSTCA9IHJlcXVpcmUoJ3VybC1wYXJzZScpO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOnVybCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0T3JpZ2luOiBmdW5jdGlvbih1cmwpIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHAgPSBuZXcgVVJMKHVybCk7XG4gICAgaWYgKHAucHJvdG9jb2wgPT09ICdmaWxlOicpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwb3J0ID0gcC5wb3J0O1xuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IChwLnByb3RvY29sID09PSAnaHR0cHM6JykgPyAnNDQzJyA6ICc4MCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHAucHJvdG9jb2wgKyAnLy8nICsgcC5ob3N0bmFtZSArICc6JyArIHBvcnQ7XG4gIH1cblxuLCBpc09yaWdpbkVxdWFsOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMuZ2V0T3JpZ2luKGEpID09PSB0aGlzLmdldE9yaWdpbihiKTtcbiAgICBkZWJ1Zygnc2FtZScsIGEsIGIsIHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4sIGlzU2NoZW1lRXF1YWw6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gKGEuc3BsaXQoJzonKVswXSA9PT0gYi5zcGxpdCgnOicpWzBdKTtcbiAgfVxuXG4sIGFkZFBhdGg6IGZ1bmN0aW9uICh1cmwsIHBhdGgpIHtcbiAgICB2YXIgcXMgPSB1cmwuc3BsaXQoJz8nKTtcbiAgICByZXR1cm4gcXNbMF0gKyBwYXRoICsgKHFzWzFdID8gJz8nICsgcXNbMV0gOiAnJyk7XG4gIH1cblxuLCBhZGRRdWVyeTogZnVuY3Rpb24gKHVybCwgcSkge1xuICAgIHJldHVybiB1cmwgKyAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAoJz8nICsgcSkgOiAoJyYnICsgcSkpO1xuICB9XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcInVybC1wYXJzZVwiOjYxfV0sNTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSAnMS4xLjQnO1xuXG59LHt9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwXG52YXIgbSA9IHMgKiA2MFxudmFyIGggPSBtICogNjBcbnZhciBkID0gaCAqIDI0XG52YXIgeSA9IGQgKiAzNjUuMjVcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbFxuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/XG5cdFx0XHRmbXRMb25nKHZhbCkgOlxuXHRcdFx0Zm10U2hvcnQodmFsKVxuICB9XG4gIHRocm93IG5ldyBFcnJvcigndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICsgSlNPTi5zdHJpbmdpZnkodmFsKSlcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpXG4gIGlmIChzdHIubGVuZ3RoID4gMTAwMDApIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cilcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSlcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHlcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkXG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoXG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtXG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzXG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJ1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJ1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJ1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJ1xuICB9XG4gIHJldHVybiBtcyArICdtcydcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcydcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZVxuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncydcbn1cblxufSx7fV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vZGVidWdcIjo1Nn1dLDU2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICByZXR1cm4gZGVidWc7XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG5cbn0se1wibXNcIjo1NH1dLDU3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG59LHt9XSw1ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKiEgSlNPTiB2My4zLjIgfCBodHRwOi8vYmVzdGllanMuZ2l0aHViLmlvL2pzb24zIHwgQ29weXJpZ2h0IDIwMTItMjAxNCwgS2l0IENhbWJyaWRnZSB8IGh0dHA6Ly9raXQubWl0LWxpY2Vuc2Uub3JnICovXG47KGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG4gIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG4gIC8vIEEgc2V0IG9mIHR5cGVzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggb2JqZWN0cyBmcm9tIHByaW1pdGl2ZXMuXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgXCJvYmplY3RcIjogdHJ1ZVxuICB9O1xuXG4gIC8vIERldGVjdCB0aGUgYGV4cG9ydHNgIG9iamVjdCBleHBvc2VkIGJ5IENvbW1vbkpTIGltcGxlbWVudGF0aW9ucy5cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvLyBVc2UgdGhlIGBnbG9iYWxgIG9iamVjdCBleHBvc2VkIGJ5IE5vZGUgKGluY2x1ZGluZyBCcm93c2VyaWZ5IHZpYVxuICAvLyBgaW5zZXJ0LW1vZHVsZS1nbG9iYWxzYCksIE5hcndoYWwsIGFuZCBSaW5nbyBhcyB0aGUgZGVmYXVsdCBjb250ZXh0LFxuICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXG4gIC8vIGluc3RlYWQuXG4gIHZhciByb290ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93IHx8IHRoaXMsXG4gICAgICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbDtcblxuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbFtcImdsb2JhbFwiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wid2luZG93XCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJzZWxmXCJdID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcbiAgLy8gYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgZnVuY3Rpb25zIHRvIHRoZSBzcGVjaWZpZWQgYGV4cG9ydHNgIG9iamVjdC5cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQsIGV4cG9ydHMpIHtcbiAgICBjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcbiAgICBleHBvcnRzIHx8IChleHBvcnRzID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcblxuICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxuICAgIHZhciBOdW1iZXIgPSBjb250ZXh0W1wiTnVtYmVyXCJdIHx8IHJvb3RbXCJOdW1iZXJcIl0sXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHRbXCJTdHJpbmdcIl0gfHwgcm9vdFtcIlN0cmluZ1wiXSxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxuICAgICAgICBEYXRlID0gY29udGV4dFtcIkRhdGVcIl0gfHwgcm9vdFtcIkRhdGVcIl0sXG4gICAgICAgIFN5bnRheEVycm9yID0gY29udGV4dFtcIlN5bnRheEVycm9yXCJdIHx8IHJvb3RbXCJTeW50YXhFcnJvclwiXSxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxuICAgICAgICBNYXRoID0gY29udGV4dFtcIk1hdGhcIl0gfHwgcm9vdFtcIk1hdGhcIl0sXG4gICAgICAgIG5hdGl2ZUpTT04gPSBjb250ZXh0W1wiSlNPTlwiXSB8fCByb290W1wiSlNPTlwiXTtcblxuICAgIC8vIERlbGVnYXRlIHRvIHRoZSBuYXRpdmUgYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgaW1wbGVtZW50YXRpb25zLlxuICAgIGlmICh0eXBlb2YgbmF0aXZlSlNPTiA9PSBcIm9iamVjdFwiICYmIG5hdGl2ZUpTT04pIHtcbiAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XG4gICAgICBleHBvcnRzLnBhcnNlID0gbmF0aXZlSlNPTi5wYXJzZTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIGdldENsYXNzID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXG4gICAgICAgIGlzUHJvcGVydHksIGZvckVhY2gsIHVuZGVmO1xuXG4gICAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICAgIHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgICAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cbiAgICAgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcbiAgICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcbiAgICAgICAgLy8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2ZcbiAgICAgICAgLy8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxuICAgICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cbiAgICBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcbiAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuICAgICAgICByZXR1cm4gaGFzW25hbWVdO1xuICAgICAgfVxuICAgICAgdmFyIGlzU3VwcG9ydGVkO1xuICAgICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuICAgICAgICAvLyBJRSA8PSA3IGRvZXNuJ3Qgc3VwcG9ydCBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgdXNpbmcgc3F1YXJlXG4gICAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwianNvblwiKSB7XG4gICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuICAgICAgICAvLyBzdXBwb3J0ZWQuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gaGFzKFwianNvbi1zdHJpbmdpZnlcIikgJiYgaGFzKFwianNvbi1wYXJzZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuICAgICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuICAgICAgICAgIHZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSwgc3RyaW5naWZ5U3VwcG9ydGVkID0gdHlwZW9mIHN0cmluZ2lmeSA9PSBcImZ1bmN0aW9uXCIgJiYgaXNFeHRlbmRlZDtcbiAgICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuICAgICAgICAgICAgKHZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG4gICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlcyBhcyBvYmplY3QgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvclxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aXRoaW4gYW4gb2JqZWN0IG9yIGFycmF5KS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMyBwYXNzIHRoaXMgdGVzdC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3JgcyxcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlbHksIGlmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBhcnJheSwgb2JqZWN0LCBCb29sZWFuLCBvciBgbnVsbGAgbGl0ZXJhbC4gVGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuICAgICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoWzEsIDJdLCBudWxsLCAxKSA9PSBcIltcXG4gMSxcXG4gMlxcbl1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC04LjY0ZTE1KSkgPT0gJ1wiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0gMTEuMCBpbmNvcnJlY3RseSBzZXJpYWxpemVzIHllYXJzIHByaW9yIHRvIDAgYXMgbmVnYXRpdmVcbiAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjUgYW5kIE9wZXJhID49IDEwLjUzIGluY29ycmVjdGx5IHNlcmlhbGl6ZSBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3QgYEpTT04ucGFyc2VgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xuICAgICAgICAgIHZhciBwYXJzZSA9IGV4cG9ydHMucGFyc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhIGJhcmUgbGl0ZXJhbCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG4gICAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXG4gICAgICAgICAgICAgIGlmIChwYXJzZShcIjBcIikgPT09IDAgJiYgIXBhcnNlKGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VTdXBwb3J0ZWQgPSB2YWx1ZVtcImFcIl0ubGVuZ3RoID09IDUgJiYgdmFsdWVbXCJhXCJdWzBdID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhbGxvdyB0cmFpbGluZyBjb21tYXMgaW4gSlNPTiBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFoYXMoXCJqc29uXCIpKSB7XG4gICAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuICAgICAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsXG4gICAgICAgICAgZGF0ZUNsYXNzID0gXCJbb2JqZWN0IERhdGVdXCIsXG4gICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiLFxuICAgICAgICAgIHN0cmluZ0NsYXNzID0gXCJbb2JqZWN0IFN0cmluZ11cIixcbiAgICAgICAgICBhcnJheUNsYXNzID0gXCJbb2JqZWN0IEFycmF5XVwiLFxuICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG4gICAgICAvLyBEZXRlY3QgaW5jb21wbGV0ZSBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XG5cbiAgICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuICAgICAgaWYgKCFpc0V4dGVuZGVkKSB7XG4gICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG4gICAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXG4gICAgICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuICAgICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXG4gICAgICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG4gICAgICAvLyBvYmplY3QuIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIG1ldGhvZC5cbiAgICAgIGlmICghKGlzUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSkpIHtcbiAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmICgobWVtYmVycy5fX3Byb3RvX18gPSBudWxsLCBtZW1iZXJzLl9fcHJvdG9fXyA9IHtcbiAgICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG4gICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG4gICAgICAgICAgICBcInRvU3RyaW5nXCI6IDFcbiAgICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC4zIGRvZXNuJ3QgaW1wbGVtZW50IGBPYmplY3QjaGFzT3duUHJvcGVydHlgLCBidXRcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIC8vIENhcHR1cmUgYW5kIGJyZWFrIHRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gKHNlZSBzZWN0aW9uIDguNi4yXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cbiAgICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9fcHJvdG9fXywgcmVzdWx0ID0gcHJvcGVydHkgaW4gKHRoaXMuX19wcm90b19fID0gbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuICAgICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVtYmVycyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXG4gICAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG4gICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcblxuICAgICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcbiAgICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cbiAgICAgICAgLy8gYE9iamVjdC5wcm90b3R5cGVgIGluIG9sZGVyIHZlcnNpb25zIG9mIElFLCBOZXRzY2FwZSwgYW5kIE1vemlsbGEuXG4gICAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XG4gICAgICAgIH0pLnByb3RvdHlwZS52YWx1ZU9mID0gMDtcblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cbiAgICAgICAgbWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gbWVtYmVycykge1xuICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgaWYgKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG4gICAgICAgICAgLy8gSUUgPD0gOCwgTW96aWxsYSAxLjAsIGFuZCBOZXRzY2FwZSA2LjIgaWdub3JlIHNoYWRvd2VkIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XG4gICAgICAgICAgICB2YXIgaGFzUHJvcGVydHkgPSAhaXNGdW5jdGlvbiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yICE9IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5XSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgaXNQcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcbiAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXG4gICAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cbiAgICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAgICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuICAgICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gICAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG4gICAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBFc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICAgIDg6IFwiXFxcXGJcIixcbiAgICAgICAgICAxMjogXCJcXFxcZlwiLFxuICAgICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgICAgMTM6IFwiXFxcXHJcIixcbiAgICAgICAgICA5OiBcIlxcXFx0XCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cbiAgICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG4gICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgICAgICAgIHJldHVybiAobGVhZGluZ1plcm9lcyArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIHVzZUNoYXJJbmRleCA9ICFjaGFySW5kZXhCdWdneSB8fCBsZW5ndGggPiAxMDtcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1c2VDaGFySW5kZXggPyBzeW1ib2xzW2luZGV4XSA6IHZhbHVlLmNoYXJBdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXCInO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcbiAgICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gICAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBgRGF0ZSN0b0pTT05gIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgICAgaWYgKGdldERheSkge1xuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgICAvLyBidWdneS4gQWRhcHRlZCBmcm9tIEBZYWZmbGUncyBgZGF0ZS1zaGltYCBwcm9qZWN0LlxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xuICAgICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG4gICAgICAgICAgICAgICAgICBmb3IgKG1vbnRoID0gZmxvb3IoKGRhdGUgLSBnZXREYXkoeWVhciwgMCkpIC8gMzAuNDIpOyBnZXREYXkoeWVhciwgbW9udGggKyAxKSA8PSBkYXRlOyBtb250aCsrKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgICAvLyA1LjEgc2VjdGlvbiAxNS45LjEuMikuIFRoZSBmb3JtdWxhIGAoQSAlIEIgKyBCKSAlIEJgIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICB0aW1lID0gKHZhbHVlICUgODY0ZTUgKyA4NjRlNSkgJSA4NjRlNTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgICBob3VycyA9IGZsb29yKHRpbWUgLyAzNmU1KSAlIDI0O1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRpbWUgJSAxZTM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgbW9udGggPSB2YWx1ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuICAgICAgICAgICAgICAgICAgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBtb250aCArIDEpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXG4gICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICAgIFwiVFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBtaW51dGVzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xuICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgKChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG4gICAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuICAgICAgICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcbiAgICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoaXMgaXMgYSBsaW5lYXIgc2VhcmNoOyBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICAgICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcbiAgICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcbiAgICAgICAgICBpZiAob2JqZWN0VHlwZXNbdHlwZW9mIGZpbHRlcl0gJiYgZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZpbHRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGB3aWR0aGAgdG8gYW4gaW50ZWdlciBhbmQgY3JlYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAod2hpdGVzcGFjZSA9IFwiXCIsIHdpZHRoID4gMTAgJiYgKHdpZHRoID0gMTApOyB3aGl0ZXNwYWNlLmxlbmd0aCA8IHdpZHRoOyB3aGl0ZXNwYWNlICs9IFwiIFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSA9IHdpZHRoLmxlbmd0aCA8PSAxMCA/IHdpZHRoIDogd2lkdGguc2xpY2UoMCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgZGlzY2FyZHMgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZW1wdHkgc3RyaW5nIGtleXNcbiAgICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShcIlwiLCAodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSBzb3VyY2UsIHZhbHVlKSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIFwiXCIsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUHVibGljOiBQYXJzZXMgYSBKU09OIHNvdXJjZSBzdHJpbmcuXG4gICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcbiAgICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBVbmVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXCInLFxuICAgICAgICAgIDQ3OiBcIi9cIixcbiAgICAgICAgICA5ODogXCJcXGJcIixcbiAgICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgICAgMTEwOiBcIlxcblwiLFxuICAgICAgICAgIDEwMjogXCJcXGZcIixcbiAgICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogU3RvcmVzIHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXNldHMgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3dzIGEgYFN5bnRheEVycm9yYC5cbiAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXR1cm5zIHRoZSBuZXh0IHRva2VuLCBvciBgXCIkXCJgIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWRcbiAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG4gICAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XG4gICAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSB0b2tlbnMsIGluY2x1ZGluZyB0YWJzLCBjYXJyaWFnZSByZXR1cm5zLCBsaW5lXG4gICAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgICAgIC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcbiAgICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjogY2FzZSAzNDogY2FzZSA0NzogY2FzZSA5ODogY2FzZSAxMTY6IGNhc2UgMTEwOiBjYXNlIDEwMjogY2FzZSAxMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYFxcdWAgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgdmFsaWQgc2VxdWVuY2UgY29tcHJpc2VzIGZvdXIgaGV4ZGlnaXRzIChjYXNlLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbiBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ4ICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCArIDEpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgSW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdHMsIGhhc01lbWJlcnM7XG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSA9PSBcIkBcIikge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBhcnJheSwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0LlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5zIG1lbWJlcnMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdG9rZW4gZW5jb3VudGVyZWQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmKSB7XG4gICAgICAgICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5XSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgSlNPTiBvYmplY3QsIGludm9raW5nIHRoZVxuICAgICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGBmb3JFYWNoYCBjYW4ndCBiZSB1c2VkIHRvIHRyYXZlcnNlIGFuIGFycmF5IGluIE9wZXJhIDw9IDguNTRcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFwiMFwiKWApLlxuICAgICAgICAgICAgaWYgKGdldENsYXNzLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuICAgICAgICAgIEluZGV4ID0gMDtcbiAgICAgICAgICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuICAgICAgICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XG4gICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG4gICAgICAgICAgaWYgKGxleCgpICE9IFwiJFwiKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzW1wicnVuSW5Db250ZXh0XCJdID0gcnVuSW5Db250ZXh0O1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9XG5cbiAgaWYgKGZyZWVFeHBvcnRzICYmICFpc0xvYWRlcikge1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgZW52aXJvbm1lbnRzLlxuICAgIHJ1bkluQ29udGV4dChyb290LCBmcmVlRXhwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgZW5naW5lcy5cbiAgICB2YXIgbmF0aXZlSlNPTiA9IHJvb3QuSlNPTixcbiAgICAgICAgcHJldmlvdXNKU09OID0gcm9vdFtcIkpTT04zXCJdLFxuICAgICAgICBpc1Jlc3RvcmVkID0gZmFsc2U7XG5cbiAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXCJKU09OM1wiXSA9IHtcbiAgICAgIC8vIFB1YmxpYzogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBnbG9iYWwgYEpTT05gIG9iamVjdCBhbmRcbiAgICAgIC8vIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBKU09OM2Agb2JqZWN0LlxuICAgICAgXCJub0NvbmZsaWN0XCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc3RvcmVkKSB7XG4gICAgICAgICAgaXNSZXN0b3JlZCA9IHRydWU7XG4gICAgICAgICAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcbiAgICAgICAgICByb290W1wiSlNPTjNcIl0gPSBwcmV2aW91c0pTT047XG4gICAgICAgICAgbmF0aXZlSlNPTiA9IHByZXZpb3VzSlNPTiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04zO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJvb3QuSlNPTiA9IHtcbiAgICAgIFwicGFyc2VcIjogSlNPTjMucGFyc2UsXG4gICAgICBcInN0cmluZ2lmeVwiOiBKU09OMy5zdHJpbmdpZnlcbiAgICB9O1xuICB9XG5cbiAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXG4gIGlmIChpc0xvYWRlcikge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTjM7XG4gICAgfSk7XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFNpbXBsZSBxdWVyeSBzdHJpbmcgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5KSB7XG4gIHZhciBwYXJzZXIgPSAvKFtePT8mXSspPT8oW14mXSopL2dcbiAgICAsIHJlc3VsdCA9IHt9XG4gICAgLCBwYXJ0O1xuXG4gIC8vXG4gIC8vIExpdHRsZSBuaWZ0eSBwYXJzaW5nIGhhY2ssIGxldmVyYWdlIHRoZSBmYWN0IHRoYXQgUmVnRXhwLmV4ZWMgaW5jcmVtZW50c1xuICAvLyB0aGUgbGFzdEluZGV4IHByb3BlcnR5IHNvIHdlIGNhbiBjb250aW51ZSBleGVjdXRpbmcgdGhpcyBsb29wIHVudGlsIHdlJ3ZlXG4gIC8vIHBhcnNlZCBhbGwgcmVzdWx0cy5cbiAgLy9cbiAgZm9yICg7XG4gICAgcGFydCA9IHBhcnNlci5leGVjKHF1ZXJ5KTtcbiAgICByZXN1bHRbZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRbMV0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYXJ0WzJdKVxuICApO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcXVlcnkgc3RyaW5nIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwgcHJlZml4LlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5naWZ5KG9iaiwgcHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICB2YXIgcGFpcnMgPSBbXTtcblxuICAvL1xuICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxuICAvL1xuICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcmVmaXgpIHByZWZpeCA9ICc/JztcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArJz0nKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2tleV0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFpcnMubGVuZ3RoID8gcHJlZml4ICsgcGFpcnMuam9pbignJicpIDogJyc7XG59XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5leHBvcnRzLnN0cmluZ2lmeSA9IHF1ZXJ5c3RyaW5naWZ5O1xuZXhwb3J0cy5wYXJzZSA9IHF1ZXJ5c3RyaW5nO1xuXG59LHt9XSw2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UncmUgcmVxdWlyZWQgdG8gYWRkIGEgcG9ydCBudW1iZXIuXG4gKlxuICogQHNlZSBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RlZmF1bHQtcG9ydFxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBwb3J0IFBvcnQgbnVtYmVyIHdlIG5lZWQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSXMgaXQgYSBkZWZhdWx0IHBvcnQgZm9yIHRoZSBnaXZlbiBwcm90b2NvbFxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVxdWlyZWQocG9ydCwgcHJvdG9jb2wpIHtcbiAgcHJvdG9jb2wgPSBwcm90b2NvbC5zcGxpdCgnOicpWzBdO1xuICBwb3J0ID0gK3BvcnQ7XG5cbiAgaWYgKCFwb3J0KSByZXR1cm4gZmFsc2U7XG5cbiAgc3dpdGNoIChwcm90b2NvbCkge1xuICAgIGNhc2UgJ2h0dHAnOlxuICAgIGNhc2UgJ3dzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gODA7XG5cbiAgICBjYXNlICdodHRwcyc6XG4gICAgY2FzZSAnd3NzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNDQzO1xuXG4gICAgY2FzZSAnZnRwJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gMjE7XG5cbiAgICBjYXNlICdnb3BoZXInOlxuICAgIHJldHVybiBwb3J0ICE9PSA3MDtcblxuICAgIGNhc2UgJ2ZpbGUnOlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBwb3J0ICE9PSAwO1xufTtcblxufSx7fV0sNjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZWQgPSByZXF1aXJlKCdyZXF1aXJlcy1wb3J0JylcbiAgLCBsb2xjYXRpb24gPSByZXF1aXJlKCcuL2xvbGNhdGlvbicpXG4gICwgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZ2lmeScpXG4gICwgcHJvdG9jb2xyZSA9IC9eKFthLXpdW2EtejAtOS4rLV0qOik/KFxcL1xcLyk/KFtcXFNcXHNdKikvaTtcblxuLyoqXG4gKiBUaGVzZSBhcmUgdGhlIHBhcnNlIHJ1bGVzIGZvciB0aGUgVVJMIHBhcnNlciwgaXQgaW5mb3JtcyB0aGUgcGFyc2VyXG4gKiBhYm91dDpcbiAqXG4gKiAwLiBUaGUgY2hhciBpdCBOZWVkcyB0byBwYXJzZSwgaWYgaXQncyBhIHN0cmluZyBpdCBzaG91bGQgYmUgZG9uZSB1c2luZ1xuICogICAgaW5kZXhPZiwgUmVnRXhwIHVzaW5nIGV4ZWMgYW5kIE5hTiBtZWFucyBzZXQgYXMgY3VycmVudCB2YWx1ZS5cbiAqIDEuIFRoZSBwcm9wZXJ0eSB3ZSBzaG91bGQgc2V0IHdoZW4gcGFyc2luZyB0aGlzIHZhbHVlLlxuICogMi4gSW5kaWNhdGlvbiBpZiBpdCdzIGJhY2t3YXJkcyBvciBmb3J3YXJkIHBhcnNpbmcsIHdoZW4gc2V0IGFzIG51bWJlciBpdCdzXG4gKiAgICB0aGUgdmFsdWUgb2YgZXh0cmEgY2hhcnMgdGhhdCBzaG91bGQgYmUgc3BsaXQgb2ZmLlxuICogMy4gSW5oZXJpdCBmcm9tIGxvY2F0aW9uIGlmIG5vbiBleGlzdGluZyBpbiB0aGUgcGFyc2VyLlxuICogNC4gYHRvTG93ZXJDYXNlYCB0aGUgcmVzdWx0aW5nIHZhbHVlLlxuICovXG52YXIgcnVsZXMgPSBbXG4gIFsnIycsICdoYXNoJ10sICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJz8nLCAncXVlcnknXSwgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWycvJywgJ3BhdGhuYW1lJ10sICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnQCcsICdhdXRoJywgMV0sICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBmcm9udC5cbiAgW05hTiwgJ2hvc3QnLCB1bmRlZmluZWQsIDEsIDFdLCAgICAgICAvLyBTZXQgbGVmdCBvdmVyIHZhbHVlLlxuICBbLzooXFxkKykkLywgJ3BvcnQnLCB1bmRlZmluZWQsIDFdLCAgICAvLyBSZWdFeHAgdGhlIGJhY2suXG4gIFtOYU4sICdob3N0bmFtZScsIHVuZGVmaW5lZCwgMSwgMV0gICAgLy8gU2V0IGxlZnQgb3Zlci5cbl07XG5cbi8qKlxuICogQHR5cGVkZWYgUHJvdG9jb2xFeHRyYWN0XG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCBtYXRjaGVkIGluIHRoZSBVUkwsIGluIGxvd2VyY2FzZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2xhc2hlcyBgdHJ1ZWAgaWYgcHJvdG9jb2wgaXMgZm9sbG93ZWQgYnkgXCIvL1wiLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmVzdCBSZXN0IG9mIHRoZSBVUkwgdGhhdCBpcyBub3QgcGFydCBvZiB0aGUgcHJvdG9jb2wuXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGZyb20gYSBVUkwgd2l0aC93aXRob3V0IGRvdWJsZSBzbGFzaCAoXCIvL1wiKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBleHRyYWN0IGZyb20uXG4gKiBAcmV0dXJuIHtQcm90b2NvbEV4dHJhY3R9IEV4dHJhY3RlZCBpbmZvcm1hdGlvbi5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBleHRyYWN0UHJvdG9jb2woYWRkcmVzcykge1xuICB2YXIgbWF0Y2ggPSBwcm90b2NvbHJlLmV4ZWMoYWRkcmVzcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogbWF0Y2hbMV0gPyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIDogJycsXG4gICAgc2xhc2hlczogISFtYXRjaFsyXSxcbiAgICByZXN0OiBtYXRjaFszXVxuICB9O1xufVxuXG4vKipcbiAqIFJlc29sdmUgYSByZWxhdGl2ZSBVUkwgcGF0aG5hbWUgYWdhaW5zdCBhIGJhc2UgVVJMIHBhdGhuYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWxhdGl2ZSBQYXRobmFtZSBvZiB0aGUgcmVsYXRpdmUgVVJMLlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2UgUGF0aG5hbWUgb2YgdGhlIGJhc2UgVVJMLlxuICogQHJldHVybiB7U3RyaW5nfSBSZXNvbHZlZCBwYXRobmFtZS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlKHJlbGF0aXZlLCBiYXNlKSB7XG4gIHZhciBwYXRoID0gKGJhc2UgfHwgJy8nKS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5jb25jYXQocmVsYXRpdmUuc3BsaXQoJy8nKSlcbiAgICAsIGkgPSBwYXRoLmxlbmd0aFxuICAgICwgbGFzdCA9IHBhdGhbaSAtIDFdXG4gICAgLCB1bnNoaWZ0ID0gZmFsc2VcbiAgICAsIHVwID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHBhdGhbaV0gPT09ICcuJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXRoW2ldID09PSAnLi4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgaWYgKGkgPT09IDApIHVuc2hpZnQgPSB0cnVlO1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bnNoaWZ0KSBwYXRoLnVuc2hpZnQoJycpO1xuICBpZiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHBhdGgucHVzaCgnJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbignLycpO1xufVxuXG4vKipcbiAqIFRoZSBhY3R1YWwgVVJMIGluc3RhbmNlLiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBvYmplY3Qgd2UndmUgb3B0ZWQtaW4gdG9cbiAqIGNyZWF0ZSBhbiBhY3R1YWwgY29uc3RydWN0b3IgYXMgaXQncyBtdWNoIG1vcmUgbWVtb3J5IGVmZmljaWVudCBhbmRcbiAqIGZhc3RlciBhbmQgaXQgcGxlYXNlcyBteSBPQ0QuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBwYXJzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jYXRpb24gTG9jYXRpb24gZGVmYXVsdHMgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBwYXJzZXIgUGFyc2VyIGZvciB0aGUgcXVlcnkgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gVVJMKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICByZXR1cm4gbmV3IFVSTChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKTtcbiAgfVxuXG4gIHZhciByZWxhdGl2ZSwgZXh0cmFjdGVkLCBwYXJzZSwgaW5zdHJ1Y3Rpb24sIGluZGV4LCBrZXlcbiAgICAsIGluc3RydWN0aW9ucyA9IHJ1bGVzLnNsaWNlKClcbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jYXRpb25cbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIGkgPSAwO1xuXG4gIC8vXG4gIC8vIFRoZSBmb2xsb3dpbmcgaWYgc3RhdGVtZW50cyBhbGxvd3MgdGhpcyBtb2R1bGUgdHdvIGhhdmUgY29tcGF0aWJpbGl0eSB3aXRoXG4gIC8vIDIgZGlmZmVyZW50IEFQSTpcbiAgLy9cbiAgLy8gMS4gTm9kZS5qcydzIGB1cmwucGFyc2VgIGFwaSB3aGljaCBhY2NlcHRzIGEgVVJMLCBib29sZWFuIGFzIGFyZ3VtZW50c1xuICAvLyAgICB3aGVyZSB0aGUgYm9vbGVhbiBpbmRpY2F0ZXMgdGhhdCB0aGUgcXVlcnkgc3RyaW5nIHNob3VsZCBhbHNvIGJlIHBhcnNlZC5cbiAgLy9cbiAgLy8gMi4gVGhlIGBVUkxgIGludGVyZmFjZSBvZiB0aGUgYnJvd3NlciB3aGljaCBhY2NlcHRzIGEgVVJMLCBvYmplY3QgYXNcbiAgLy8gICAgYXJndW1lbnRzLiBUaGUgc3VwcGxpZWQgb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0IHZhbHVlcyAvIGZhbGwtYmFja1xuICAvLyAgICBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gIC8vXG4gIGlmICgnb2JqZWN0JyAhPT0gdHlwZSAmJiAnc3RyaW5nJyAhPT0gdHlwZSkge1xuICAgIHBhcnNlciA9IGxvY2F0aW9uO1xuICAgIGxvY2F0aW9uID0gbnVsbDtcbiAgfVxuXG4gIGlmIChwYXJzZXIgJiYgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHBhcnNlcikgcGFyc2VyID0gcXMucGFyc2U7XG5cbiAgbG9jYXRpb24gPSBsb2xjYXRpb24obG9jYXRpb24pO1xuXG4gIC8vXG4gIC8vIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gYmVmb3JlIHJ1bm5pbmcgdGhlIGluc3RydWN0aW9ucy5cbiAgLy9cbiAgZXh0cmFjdGVkID0gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MgfHwgJycpO1xuICByZWxhdGl2ZSA9ICFleHRyYWN0ZWQucHJvdG9jb2wgJiYgIWV4dHJhY3RlZC5zbGFzaGVzO1xuICB1cmwuc2xhc2hlcyA9IGV4dHJhY3RlZC5zbGFzaGVzIHx8IHJlbGF0aXZlICYmIGxvY2F0aW9uLnNsYXNoZXM7XG4gIHVybC5wcm90b2NvbCA9IGV4dHJhY3RlZC5wcm90b2NvbCB8fCBsb2NhdGlvbi5wcm90b2NvbCB8fCAnJztcbiAgYWRkcmVzcyA9IGV4dHJhY3RlZC5yZXN0O1xuXG4gIC8vXG4gIC8vIFdoZW4gdGhlIGF1dGhvcml0eSBjb21wb25lbnQgaXMgYWJzZW50IHRoZSBVUkwgc3RhcnRzIHdpdGggYSBwYXRoXG4gIC8vIGNvbXBvbmVudC5cbiAgLy9cbiAgaWYgKCFleHRyYWN0ZWQuc2xhc2hlcykgaW5zdHJ1Y3Rpb25zWzJdID0gWy8oLiopLywgJ3BhdGhuYW1lJ107XG5cbiAgZm9yICg7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1tpXTtcbiAgICBwYXJzZSA9IGluc3RydWN0aW9uWzBdO1xuICAgIGtleSA9IGluc3RydWN0aW9uWzFdO1xuXG4gICAgaWYgKHBhcnNlICE9PSBwYXJzZSkge1xuICAgICAgdXJsW2tleV0gPSBhZGRyZXNzO1xuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBwYXJzZSkge1xuICAgICAgaWYgKH4oaW5kZXggPSBhZGRyZXNzLmluZGV4T2YocGFyc2UpKSkge1xuICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBpbnN0cnVjdGlvblsyXSkge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoaW5kZXggKyBpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChpbmRleCA9IHBhcnNlLmV4ZWMoYWRkcmVzcykpKSB7XG4gICAgICB1cmxba2V5XSA9IGluZGV4WzFdO1xuICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXguaW5kZXgpO1xuICAgIH1cblxuICAgIHVybFtrZXldID0gdXJsW2tleV0gfHwgKFxuICAgICAgcmVsYXRpdmUgJiYgaW5zdHJ1Y3Rpb25bM10gPyBsb2NhdGlvbltrZXldIHx8ICcnIDogJydcbiAgICApO1xuXG4gICAgLy9cbiAgICAvLyBIb3N0bmFtZSwgaG9zdCBhbmQgcHJvdG9jb2wgc2hvdWxkIGJlIGxvd2VyY2FzZWQgc28gdGhleSBjYW4gYmUgdXNlZCB0b1xuICAgIC8vIGNyZWF0ZSBhIHByb3BlciBgb3JpZ2luYC5cbiAgICAvL1xuICAgIGlmIChpbnN0cnVjdGlvbls0XSkgdXJsW2tleV0gPSB1cmxba2V5XS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcbiAgLy8gd2l0aCBhIGN1c3RvbSBwYXJzZXIgYXMgZnVuY3Rpb24gdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBidWlsZC1pblxuICAvLyBwYXJzZXIuXG4gIC8vXG4gIGlmIChwYXJzZXIpIHVybC5xdWVyeSA9IHBhcnNlcih1cmwucXVlcnkpO1xuXG4gIC8vXG4gIC8vIElmIHRoZSBVUkwgaXMgcmVsYXRpdmUsIHJlc29sdmUgdGhlIHBhdGhuYW1lIGFnYWluc3QgdGhlIGJhc2UgVVJMLlxuICAvL1xuICBpZiAoXG4gICAgICByZWxhdGl2ZVxuICAgICYmIGxvY2F0aW9uLnNsYXNoZXNcbiAgICAmJiB1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLydcbiAgICAmJiAodXJsLnBhdGhuYW1lICE9PSAnJyB8fCBsb2NhdGlvbi5wYXRobmFtZSAhPT0gJycpXG4gICkge1xuICAgIHVybC5wYXRobmFtZSA9IHJlc29sdmUodXJsLnBhdGhuYW1lLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH1cblxuICAvL1xuICAvLyBXZSBzaG91bGQgbm90IGFkZCBwb3J0IG51bWJlcnMgaWYgdGhleSBhcmUgYWxyZWFkeSB0aGUgZGVmYXVsdCBwb3J0IG51bWJlclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXG4gIC8vXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICB1cmwucG9ydCA9ICcnO1xuICB9XG5cbiAgLy9cbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAvL1xuICB1cmwudXNlcm5hbWUgPSB1cmwucGFzc3dvcmQgPSAnJztcbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSB1cmwuYXV0aC5zcGxpdCgnOicpO1xuICAgIHVybC51c2VybmFtZSA9IGluc3RydWN0aW9uWzBdIHx8ICcnO1xuICAgIHVybC5wYXNzd29yZCA9IGluc3RydWN0aW9uWzFdIHx8ICcnO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFydCAgICAgICAgICBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIHBhcnNlIHRoZSBxdWVyeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICogQHJldHVybnMge1VSTH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHNldChwYXJ0LCB2YWx1ZSwgZm4pIHtcbiAgdmFyIHVybCA9IHRoaXM7XG5cbiAgc3dpdGNoIChwYXJ0KSB7XG4gICAgY2FzZSAncXVlcnknOlxuICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdmFsdWUgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gKGZuIHx8IHFzLnBhcnNlKSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwb3J0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoIXJlcXVpcmVkKHZhbHVlLCB1cmwucHJvdG9jb2wpKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICB1cmxbcGFydF0gPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWUgKyc6JysgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdG5hbWUnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICh1cmwucG9ydCkgdmFsdWUgKz0gJzonKyB1cmwucG9ydDtcbiAgICAgIHVybC5ob3N0ID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3QnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICgvOlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCc6Jyk7XG4gICAgICAgIHVybC5wb3J0ID0gdmFsdWUucG9wKCk7XG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlLmpvaW4oJzonKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlO1xuICAgICAgICB1cmwucG9ydCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3Byb3RvY29sJzpcbiAgICAgIHVybC5wcm90b2NvbCA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB1cmwuc2xhc2hlcyA9ICFmbjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncGF0aG5hbWUnOlxuICAgICAgdXJsLnBhdGhuYW1lID0gdmFsdWUubGVuZ3RoICYmIHZhbHVlLmNoYXJBdCgwKSAhPT0gJy8nID8gJy8nICsgdmFsdWUgOiB2YWx1ZTtcblxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucyA9IHJ1bGVzW2ldO1xuXG4gICAgaWYgKGluc1s0XSkgdXJsW2luc1sxXV0gPSB1cmxbaW5zWzFdXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xuXG4gIHJldHVybiB1cmw7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBiYWNrIGluIHRvIGEgdmFsaWQgYW5kIGZ1bGwgVVJMIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmdpZnkgT3B0aW9uYWwgcXVlcnkgc3RyaW5naWZ5IGZ1bmN0aW9uLlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmeSkge1xuICBpZiAoIXN0cmluZ2lmeSB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2Ygc3RyaW5naWZ5KSBzdHJpbmdpZnkgPSBxcy5zdHJpbmdpZnk7XG5cbiAgdmFyIHF1ZXJ5XG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBwcm90b2NvbCA9IHVybC5wcm90b2NvbDtcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuY2hhckF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICB2YXIgcmVzdWx0ID0gcHJvdG9jb2wgKyAodXJsLnNsYXNoZXMgPyAnLy8nIDogJycpO1xuXG4gIGlmICh1cmwudXNlcm5hbWUpIHtcbiAgICByZXN1bHQgKz0gdXJsLnVzZXJuYW1lO1xuICAgIGlmICh1cmwucGFzc3dvcmQpIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5ob3N0ICsgdXJsLnBhdGhuYW1lO1xuXG4gIHF1ZXJ5ID0gJ29iamVjdCcgPT09IHR5cGVvZiB1cmwucXVlcnkgPyBzdHJpbmdpZnkodXJsLnF1ZXJ5KSA6IHVybC5xdWVyeTtcbiAgaWYgKHF1ZXJ5KSByZXN1bHQgKz0gJz8nICE9PSBxdWVyeS5jaGFyQXQoMCkgPyAnPycrIHF1ZXJ5IDogcXVlcnk7XG5cbiAgaWYgKHVybC5oYXNoKSByZXN1bHQgKz0gdXJsLmhhc2g7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuVVJMLnByb3RvdHlwZSA9IHsgc2V0OiBzZXQsIHRvU3RyaW5nOiB0b1N0cmluZyB9O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBVUkwgcGFyc2VyIGFuZCBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlIHVzZWZ1bCBmb3Jcbi8vIG90aGVycyBvciB0ZXN0aW5nLlxuLy9cblVSTC5leHRyYWN0UHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2w7XG5VUkwubG9jYXRpb24gPSBsb2xjYXRpb247XG5VUkwucXMgPSBxcztcblxubW9kdWxlLmV4cG9ydHMgPSBVUkw7XG5cbn0se1wiLi9sb2xjYXRpb25cIjo2MixcInF1ZXJ5c3RyaW5naWZ5XCI6NTksXCJyZXF1aXJlcy1wb3J0XCI6NjB9XSw2MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBzbGFzaGVzID0gL15bQS1aYS16XVtBLVphLXowLTkrLS5dKjpcXC9cXC8vO1xuXG4vKipcbiAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIG5vdCBiZSBjb3BpZWQgb3IgaW5oZXJpdGVkIGZyb20uIFRoaXMgaXMgb25seSBuZWVkZWRcbiAqIGZvciBhbGwgbm9uIGJsb2IgVVJMJ3MgYXMgYSBibG9iIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaGFzaCwgb25seSB0aGVcbiAqIG9yaWdpbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGlnbm9yZSA9IHsgaGFzaDogMSwgcXVlcnk6IDEgfVxuICAsIFVSTDtcblxuLyoqXG4gKiBUaGUgbG9jYXRpb24gb2JqZWN0IGRpZmZlcnMgd2hlbiB5b3VyIGNvZGUgaXMgbG9hZGVkIHRocm91Z2ggYSBub3JtYWwgcGFnZSxcbiAqIFdvcmtlciBvciB0aHJvdWdoIGEgd29ya2VyIHVzaW5nIGEgYmxvYi4gQW5kIHdpdGggdGhlIGJsb2JibGUgYmVnaW5zIHRoZVxuICogdHJvdWJsZSBhcyB0aGUgbG9jYXRpb24gb2JqZWN0IHdpbGwgY29udGFpbiB0aGUgVVJMIG9mIHRoZSBibG9iLCBub3QgdGhlXG4gKiBsb2NhdGlvbiBvZiB0aGUgcGFnZSB3aGVyZSBvdXIgY29kZSBpcyBsb2FkZWQgaW4uIFRoZSBhY3R1YWwgb3JpZ2luIGlzXG4gKiBlbmNvZGVkIGluIHRoZSBgcGF0aG5hbWVgIHNvIHdlIGNhbiB0aGFua2Z1bGx5IGdlbmVyYXRlIGEgZ29vZCBcImRlZmF1bHRcIlxuICogbG9jYXRpb24gZnJvbSBpdCBzbyB3ZSBjYW4gZ2VuZXJhdGUgcHJvcGVyIHJlbGF0aXZlIFVSTCdzIGFnYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jIE9wdGlvbmFsIGRlZmF1bHQgbG9jYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gbG9sY2F0aW9uIG9iamVjdC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbG9sY2F0aW9uKGxvYykge1xuICBsb2MgPSBsb2MgfHwgZ2xvYmFsLmxvY2F0aW9uIHx8IHt9O1xuICBVUkwgPSBVUkwgfHwgcmVxdWlyZSgnLi8nKTtcblxuICB2YXIgZmluYWxkZXN0aW5hdGlvbiA9IHt9XG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY1xuICAgICwga2V5O1xuXG4gIGlmICgnYmxvYjonID09PSBsb2MucHJvdG9jb2wpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVSTCh1bmVzY2FwZShsb2MucGF0aG5hbWUpLCB7fSk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGUpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVSTChsb2MsIHt9KTtcbiAgICBmb3IgKGtleSBpbiBpZ25vcmUpIGRlbGV0ZSBmaW5hbGRlc3RpbmF0aW9uW2tleV07XG4gIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGUpIHtcbiAgICBmb3IgKGtleSBpbiBsb2MpIHtcbiAgICAgIGlmIChrZXkgaW4gaWdub3JlKSBjb250aW51ZTtcbiAgICAgIGZpbmFsZGVzdGluYXRpb25ba2V5XSA9IGxvY1trZXldO1xuICAgIH1cblxuICAgIGlmIChmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID0gc2xhc2hlcy50ZXN0KGxvYy5ocmVmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmluYWxkZXN0aW5hdGlvbjtcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vXCI6NjF9XX0se30sWzFdKSgxKVxufSk7XG5cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ja2pzLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4JykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKGFuc2lSZWdleCwgJycpIDogc3RyO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHJpcC1hbnNpL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi91cmwvdXJsLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdXJsL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIGVycm9yIG92ZXJsYXkgaXMgaW5zcGlyZWQgKGFuZCBtb3N0bHkgY29waWVkKSBmcm9tIENyZWF0ZSBSZWFjdCBBcHAgKGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2luY3ViYXRvci9jcmVhdGUtcmVhY3QtYXBwKVxuLy8gVGhleSwgaW4gdHVybiwgZ290IGluc3BpcmVkIGJ5IHdlYnBhY2staG90LW1pZGRsZXdhcmUgKGh0dHBzOi8vZ2l0aHViLmNvbS9nbGVuamFtaW4vd2VicGFjay1ob3QtbWlkZGxld2FyZSkuXG5cbnZhciBhbnNpSFRNTCA9IHJlcXVpcmUoJ2Fuc2ktaHRtbCcpO1xudmFyIEVudGl0aWVzID0gcmVxdWlyZSgnaHRtbC1lbnRpdGllcycpLkFsbEh0bWxFbnRpdGllcztcblxudmFyIGVudGl0aWVzID0gbmV3IEVudGl0aWVzKCk7XG5cbnZhciBjb2xvcnMgPSB7XG4gIHJlc2V0OiBbJ3RyYW5zcGFyZW50JywgJ3RyYW5zcGFyZW50J10sXG4gIGJsYWNrOiAnMTgxODE4JyxcbiAgcmVkOiAnRTM2MDQ5JyxcbiAgZ3JlZW46ICdCM0NCNzQnLFxuICB5ZWxsb3c6ICdGRkQwODAnLFxuICBibHVlOiAnN0NBRkMyJyxcbiAgbWFnZW50YTogJzdGQUNDQScsXG4gIGN5YW46ICdDM0MyRUYnLFxuICBsaWdodGdyZXk6ICdFQkU3RTMnLFxuICBkYXJrZ3JleTogJzZENzg5MSdcbn07XG5hbnNpSFRNTC5zZXRDb2xvcnMoY29sb3JzKTtcblxuZnVuY3Rpb24gY3JlYXRlT3ZlcmxheUlmcmFtZShvbklmcmFtZUxvYWQpIHtcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICBpZnJhbWUuaWQgPSAnd2VicGFjay1kZXYtc2VydmVyLWNsaWVudC1vdmVybGF5JztcbiAgaWZyYW1lLnNyYyA9ICdhYm91dDpibGFuayc7XG4gIGlmcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gIGlmcmFtZS5zdHlsZS5sZWZ0ID0gMDtcbiAgaWZyYW1lLnN0eWxlLnRvcCA9IDA7XG4gIGlmcmFtZS5zdHlsZS5yaWdodCA9IDA7XG4gIGlmcmFtZS5zdHlsZS5ib3R0b20gPSAwO1xuICBpZnJhbWUuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICBpZnJhbWUuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgaWZyYW1lLnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgaWZyYW1lLnN0eWxlLnpJbmRleCA9IDk5OTk5OTk5OTk7XG4gIGlmcmFtZS5vbmxvYWQgPSBvbklmcmFtZUxvYWQ7XG4gIHJldHVybiBpZnJhbWU7XG59XG5cbmZ1bmN0aW9uIGFkZE92ZXJsYXlEaXZUbyhpZnJhbWUpIHtcbiAgdmFyIGRpdiA9IGlmcmFtZS5jb250ZW50RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pZCA9ICd3ZWJwYWNrLWRldi1zZXJ2ZXItY2xpZW50LW92ZXJsYXktZGl2JztcbiAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgZGl2LnN0eWxlLmJveFNpemluZyA9ICdib3JkZXItYm94JztcbiAgZGl2LnN0eWxlLmxlZnQgPSAwO1xuICBkaXYuc3R5bGUudG9wID0gMDtcbiAgZGl2LnN0eWxlLnJpZ2h0ID0gMDtcbiAgZGl2LnN0eWxlLmJvdHRvbSA9IDA7XG4gIGRpdi5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gIGRpdi5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwgMCwgMCwgMC44NSknO1xuICBkaXYuc3R5bGUuY29sb3IgPSAnI0U4RThFOCc7XG4gIGRpdi5zdHlsZS5mb250RmFtaWx5ID0gJ01lbmxvLCBDb25zb2xhcywgbW9ub3NwYWNlJztcbiAgZGl2LnN0eWxlLmZvbnRTaXplID0gJ2xhcmdlJztcbiAgZGl2LnN0eWxlLnBhZGRpbmcgPSAnMnJlbSc7XG4gIGRpdi5zdHlsZS5saW5lSGVpZ2h0ID0gJzEuMic7XG4gIGRpdi5zdHlsZS53aGl0ZVNwYWNlID0gJ3ByZS13cmFwJztcbiAgZGl2LnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xuICBpZnJhbWUuY29udGVudERvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgcmV0dXJuIGRpdjtcbn1cblxudmFyIG92ZXJsYXlJZnJhbWUgPSBudWxsO1xudmFyIG92ZXJsYXlEaXYgPSBudWxsO1xudmFyIGxhc3RPbk92ZXJsYXlEaXZSZWFkeSA9IG51bGw7XG5cbmZ1bmN0aW9uIGVuc3VyZU92ZXJsYXlEaXZFeGlzdHMob25PdmVybGF5RGl2UmVhZHkpIHtcbiAgaWYgKG92ZXJsYXlEaXYpIHtcbiAgICAvLyBFdmVyeXRoaW5nIGlzIHJlYWR5LCBjYWxsIHRoZSBjYWxsYmFjayByaWdodCBhd2F5LlxuICAgIG9uT3ZlcmxheURpdlJlYWR5KG92ZXJsYXlEaXYpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENyZWF0aW5nIGFuIGlmcmFtZSBtYXkgYmUgYXN5bmNocm9ub3VzIHNvIHdlJ2xsIHNjaGVkdWxlIHRoZSBjYWxsYmFjay5cbiAgLy8gSW4gY2FzZSBvZiBtdWx0aXBsZSBjYWxscywgbGFzdCBjYWxsYmFjayB3aW5zLlxuICBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBvbk92ZXJsYXlEaXZSZWFkeTtcblxuICBpZiAob3ZlcmxheUlmcmFtZSkge1xuICAgIC8vIFdlJ3JlIGFscmVhZHkgY3JlYXRpbmcgaXQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGlmcmFtZSBhbmQsIHdoZW4gaXQgaXMgcmVhZHksIGEgZGl2IGluc2lkZSBpdC5cbiAgb3ZlcmxheUlmcmFtZSA9IGNyZWF0ZU92ZXJsYXlJZnJhbWUoZnVuY3Rpb24gKCkge1xuICAgIG92ZXJsYXlEaXYgPSBhZGRPdmVybGF5RGl2VG8ob3ZlcmxheUlmcmFtZSk7XG4gICAgLy8gTm93IHdlIGNhbiB0YWxrIVxuICAgIGxhc3RPbk92ZXJsYXlEaXZSZWFkeShvdmVybGF5RGl2KTtcbiAgfSk7XG5cbiAgLy8gWmFsZ28gYWxlcnQ6IG9uSWZyYW1lTG9hZCgpIHdpbGwgYmUgY2FsbGVkIGVpdGhlciBzeW5jaHJvbm91c2x5XG4gIC8vIG9yIGFzeW5jaHJvbm91c2x5IGRlcGVuZGluZyBvbiB0aGUgYnJvd3Nlci5cbiAgLy8gV2UgZGVsYXkgYWRkaW5nIGl0IHNvIGBvdmVybGF5SWZyYW1lYCBpcyBzZXQgd2hlbiBgb25JZnJhbWVMb2FkYCBmaXJlcy5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdmVybGF5SWZyYW1lKTtcbn1cblxuZnVuY3Rpb24gc2hvd01lc3NhZ2VPdmVybGF5KG1lc3NhZ2UpIHtcbiAgZW5zdXJlT3ZlcmxheURpdkV4aXN0cyhmdW5jdGlvbiAoZGl2KSB7XG4gICAgLy8gTWFrZSBpdCBsb29rIHNpbWlsYXIgdG8gb3VyIHRlcm1pbmFsLlxuICAgIGRpdi5pbm5lckhUTUwgPSAnPHNwYW4gc3R5bGU9XCJjb2xvcjogIycgKyBjb2xvcnMucmVkICsgJ1wiPkZhaWxlZCB0byBjb21waWxlLjwvc3Bhbj48YnI+PGJyPicgKyBhbnNpSFRNTChlbnRpdGllcy5lbmNvZGUobWVzc2FnZSkpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVzdHJveUVycm9yT3ZlcmxheSgpIHtcbiAgaWYgKCFvdmVybGF5RGl2KSB7XG4gICAgLy8gSXQgaXMgbm90IHRoZXJlIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbmQgcmVzZXQgaW50ZXJuYWwgc3RhdGUuXG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQob3ZlcmxheUlmcmFtZSk7XG4gIG92ZXJsYXlEaXYgPSBudWxsO1xuICBvdmVybGF5SWZyYW1lID0gbnVsbDtcbiAgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gbnVsbDtcbn1cblxuLy8gU3VjY2Vzc2Z1bCBjb21waWxhdGlvbi5cbmV4cG9ydHMuY2xlYXIgPSBmdW5jdGlvbiBoYW5kbGVTdWNjZXNzKCkge1xuICBkZXN0cm95RXJyb3JPdmVybGF5KCk7XG59O1xuXG4vLyBDb21waWxhdGlvbiB3aXRoIGVycm9ycyAoZS5nLiBzeW50YXggZXJyb3Igb3IgbWlzc2luZyBtb2R1bGVzKS5cbmV4cG9ydHMuc2hvd01lc3NhZ2UgPSBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKG1lc3NhZ2VzKSB7XG4gIHNob3dNZXNzYWdlT3ZlcmxheShtZXNzYWdlc1swXSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5LmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBTb2NrSlMgPSByZXF1aXJlKCdzb2NranMtY2xpZW50L2Rpc3Qvc29ja2pzJyk7XG5cbnZhciByZXRyaWVzID0gMDtcbnZhciBzb2NrID0gbnVsbDtcblxudmFyIHNvY2tldCA9IGZ1bmN0aW9uIGluaXRTb2NrZXQodXJsLCBoYW5kbGVycykge1xuICBzb2NrID0gbmV3IFNvY2tKUyh1cmwpO1xuXG4gIHNvY2sub25vcGVuID0gZnVuY3Rpb24gb25vcGVuKCkge1xuICAgIHJldHJpZXMgPSAwO1xuICB9O1xuXG4gIHNvY2sub25jbG9zZSA9IGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKHJldHJpZXMgPT09IDApIHtcbiAgICAgIGhhbmRsZXJzLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgLy8gVHJ5IHRvIHJlY29ubmVjdC5cbiAgICBzb2NrID0gbnVsbDtcblxuICAgIC8vIEFmdGVyIDEwIHJldHJpZXMgc3RvcCB0cnlpbmcsIHRvIHByZXZlbnQgbG9nc3BhbS5cbiAgICBpZiAocmV0cmllcyA8PSAxMCkge1xuICAgICAgLy8gRXhwb25lbnRpYWxseSBpbmNyZWFzZSB0aW1lb3V0IHRvIHJlY29ubmVjdC5cbiAgICAgIC8vIFJlc3BlY3RmdWxseSBjb3BpZWQgZnJvbSB0aGUgcGFja2FnZSBgZ290YC5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXhlZC1vcGVyYXRvcnMsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuICAgICAgdmFyIHJldHJ5SW5NcyA9IDEwMDAgKiBNYXRoLnBvdygyLCByZXRyaWVzKSArIE1hdGgucmFuZG9tKCkgKiAxMDA7XG4gICAgICByZXRyaWVzICs9IDE7XG5cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzb2NrZXQodXJsLCBoYW5kbGVycyk7XG4gICAgICB9LCByZXRyeUluTXMpO1xuICAgIH1cbiAgfTtcblxuICBzb2NrLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIG9ubWVzc2FnZShlKSB7XG4gICAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgYWxsIGRhdGEgc2VudCB2aWEgdGhlIHdlYnNvY2tldCBpcyBKU09OLlxuICAgIHZhciBtc2cgPSBKU09OLnBhcnNlKGUuZGF0YSk7XG4gICAgaWYgKGhhbmRsZXJzW21zZy50eXBlXSkge1xuICAgICAgaGFuZGxlcnNbbXNnLnR5cGVdKG1zZy5kYXRhKTtcbiAgICB9XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvY2tldDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvc29ja2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2hvdC9lbWl0dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgU2Vuc29yU2FtcGxlID0gcmVxdWlyZSgnLi9zZW5zb3Itc2FtcGxlLmpzJyk7XG52YXIgTWF0aFV0aWwgPSByZXF1aXJlKCcuLi9tYXRoLXV0aWwuanMnKTtcbnZhciBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbC5qcycpO1xuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgc2ltcGxlIGNvbXBsZW1lbnRhcnkgZmlsdGVyLCB3aGljaCBmdXNlcyBneXJvc2NvcGUgYW5kXG4gKiBhY2NlbGVyb21ldGVyIGRhdGEgZnJvbSB0aGUgJ2RldmljZW1vdGlvbicgZXZlbnQuXG4gKlxuICogQWNjZWxlcm9tZXRlciBkYXRhIGlzIHZlcnkgbm9pc3ksIGJ1dCBzdGFibGUgb3ZlciB0aGUgbG9uZyB0ZXJtLlxuICogR3lyb3Njb3BlIGRhdGEgaXMgc21vb3RoLCBidXQgdGVuZHMgdG8gZHJpZnQgb3ZlciB0aGUgbG9uZyB0ZXJtLlxuICpcbiAqIFRoaXMgZnVzaW9uIGlzIHJlbGF0aXZlbHkgc2ltcGxlOlxuICogMS4gR2V0IG9yaWVudGF0aW9uIGVzdGltYXRlcyBmcm9tIGFjY2VsZXJvbWV0ZXIgYnkgYXBwbHlpbmcgYSBsb3ctcGFzcyBmaWx0ZXJcbiAqICAgIG9uIHRoYXQgZGF0YS5cbiAqIDIuIEdldCBvcmllbnRhdGlvbiBlc3RpbWF0ZXMgZnJvbSBneXJvc2NvcGUgYnkgaW50ZWdyYXRpbmcgb3ZlciB0aW1lLlxuICogMy4gQ29tYmluZSB0aGUgdHdvIGVzdGltYXRlcywgd2VpZ2hpbmcgKDEpIGluIHRoZSBsb25nIHRlcm0sIGJ1dCAoMikgZm9yIHRoZVxuICogICAgc2hvcnQgdGVybS5cbiAqL1xuZnVuY3Rpb24gQ29tcGxlbWVudGFyeUZpbHRlcihrRmlsdGVyKSB7XG4gIHRoaXMua0ZpbHRlciA9IGtGaWx0ZXI7XG5cbiAgLy8gUmF3IHNlbnNvciBtZWFzdXJlbWVudHMuXG4gIHRoaXMuY3VycmVudEFjY2VsTWVhc3VyZW1lbnQgPSBuZXcgU2Vuc29yU2FtcGxlKCk7XG4gIHRoaXMuY3VycmVudEd5cm9NZWFzdXJlbWVudCA9IG5ldyBTZW5zb3JTYW1wbGUoKTtcbiAgdGhpcy5wcmV2aW91c0d5cm9NZWFzdXJlbWVudCA9IG5ldyBTZW5zb3JTYW1wbGUoKTtcblxuICAvLyBTZXQgZGVmYXVsdCBsb29rIGRpcmVjdGlvbiB0byBiZSBpbiB0aGUgY29ycmVjdCBkaXJlY3Rpb24uXG4gIGlmIChVdGlsLmlzSU9TKCkpIHtcbiAgICB0aGlzLmZpbHRlclEgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigtMSwgMCwgMCwgMSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5maWx0ZXJRID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oMSwgMCwgMCwgMSk7XG4gIH1cbiAgdGhpcy5wcmV2aW91c0ZpbHRlclEgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuICB0aGlzLnByZXZpb3VzRmlsdGVyUS5jb3B5KHRoaXMuZmlsdGVyUSk7XG5cbiAgLy8gT3JpZW50YXRpb24gYmFzZWQgb24gdGhlIGFjY2VsZXJvbWV0ZXIuXG4gIHRoaXMuYWNjZWxRID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcbiAgLy8gV2hldGhlciBvciBub3QgdGhlIG9yaWVudGF0aW9uIGhhcyBiZWVuIGluaXRpYWxpemVkLlxuICB0aGlzLmlzT3JpZW50YXRpb25Jbml0aWFsaXplZCA9IGZhbHNlO1xuICAvLyBSdW5uaW5nIGVzdGltYXRlIG9mIGdyYXZpdHkgYmFzZWQgb24gdGhlIGN1cnJlbnQgb3JpZW50YXRpb24uXG4gIHRoaXMuZXN0aW1hdGVkR3Jhdml0eSA9IG5ldyBNYXRoVXRpbC5WZWN0b3IzKCk7XG4gIC8vIE1lYXN1cmVkIGdyYXZpdHkgYmFzZWQgb24gYWNjZWxlcm9tZXRlci5cbiAgdGhpcy5tZWFzdXJlZEdyYXZpdHkgPSBuZXcgTWF0aFV0aWwuVmVjdG9yMygpO1xuXG4gIC8vIERlYnVnIG9ubHkgcXVhdGVybmlvbiBvZiBneXJvLWJhc2VkIG9yaWVudGF0aW9uLlxuICB0aGlzLmd5cm9JbnRlZ3JhbFEgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xufVxuXG5Db21wbGVtZW50YXJ5RmlsdGVyLnByb3RvdHlwZS5hZGRBY2NlbE1lYXN1cmVtZW50ID0gZnVuY3Rpb24odmVjdG9yLCB0aW1lc3RhbXBTKSB7XG4gIHRoaXMuY3VycmVudEFjY2VsTWVhc3VyZW1lbnQuc2V0KHZlY3RvciwgdGltZXN0YW1wUyk7XG59O1xuXG5Db21wbGVtZW50YXJ5RmlsdGVyLnByb3RvdHlwZS5hZGRHeXJvTWVhc3VyZW1lbnQgPSBmdW5jdGlvbih2ZWN0b3IsIHRpbWVzdGFtcFMpIHtcbiAgdGhpcy5jdXJyZW50R3lyb01lYXN1cmVtZW50LnNldCh2ZWN0b3IsIHRpbWVzdGFtcFMpO1xuXG4gIHZhciBkZWx0YVQgPSB0aW1lc3RhbXBTIC0gdGhpcy5wcmV2aW91c0d5cm9NZWFzdXJlbWVudC50aW1lc3RhbXBTO1xuICBpZiAoVXRpbC5pc1RpbWVzdGFtcERlbHRhVmFsaWQoZGVsdGFUKSkge1xuICAgIHRoaXMucnVuXygpO1xuICB9XG5cbiAgdGhpcy5wcmV2aW91c0d5cm9NZWFzdXJlbWVudC5jb3B5KHRoaXMuY3VycmVudEd5cm9NZWFzdXJlbWVudCk7XG59O1xuXG5Db21wbGVtZW50YXJ5RmlsdGVyLnByb3RvdHlwZS5ydW5fID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKCF0aGlzLmlzT3JpZW50YXRpb25Jbml0aWFsaXplZCkge1xuICAgIHRoaXMuYWNjZWxRID0gdGhpcy5hY2NlbFRvUXVhdGVybmlvbl8odGhpcy5jdXJyZW50QWNjZWxNZWFzdXJlbWVudC5zYW1wbGUpO1xuICAgIHRoaXMucHJldmlvdXNGaWx0ZXJRLmNvcHkodGhpcy5hY2NlbFEpO1xuICAgIHRoaXMuaXNPcmllbnRhdGlvbkluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGVsdGFUID0gdGhpcy5jdXJyZW50R3lyb01lYXN1cmVtZW50LnRpbWVzdGFtcFMgLVxuICAgICAgdGhpcy5wcmV2aW91c0d5cm9NZWFzdXJlbWVudC50aW1lc3RhbXBTO1xuXG4gIC8vIENvbnZlcnQgZ3lybyByb3RhdGlvbiB2ZWN0b3IgdG8gYSBxdWF0ZXJuaW9uIGRlbHRhLlxuICB2YXIgZ3lyb0RlbHRhUSA9IHRoaXMuZ3lyb1RvUXVhdGVybmlvbkRlbHRhXyh0aGlzLmN1cnJlbnRHeXJvTWVhc3VyZW1lbnQuc2FtcGxlLCBkZWx0YVQpO1xuICB0aGlzLmd5cm9JbnRlZ3JhbFEubXVsdGlwbHkoZ3lyb0RlbHRhUSk7XG5cbiAgLy8gZmlsdGVyXzEgPSBLICogKGZpbHRlcl8wICsgZ3lybyAqIGRUKSArICgxIC0gSykgKiBhY2NlbC5cbiAgdGhpcy5maWx0ZXJRLmNvcHkodGhpcy5wcmV2aW91c0ZpbHRlclEpO1xuICB0aGlzLmZpbHRlclEubXVsdGlwbHkoZ3lyb0RlbHRhUSk7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBkZWx0YSBiZXR3ZWVuIHRoZSBjdXJyZW50IGVzdGltYXRlZCBncmF2aXR5IGFuZCB0aGUgcmVhbFxuICAvLyBncmF2aXR5IHZlY3RvciBmcm9tIGFjY2VsZXJvbWV0ZXIuXG4gIHZhciBpbnZGaWx0ZXJRID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcbiAgaW52RmlsdGVyUS5jb3B5KHRoaXMuZmlsdGVyUSk7XG4gIGludkZpbHRlclEuaW52ZXJzZSgpO1xuXG4gIHRoaXMuZXN0aW1hdGVkR3Jhdml0eS5zZXQoMCwgMCwgLTEpO1xuICB0aGlzLmVzdGltYXRlZEdyYXZpdHkuYXBwbHlRdWF0ZXJuaW9uKGludkZpbHRlclEpO1xuICB0aGlzLmVzdGltYXRlZEdyYXZpdHkubm9ybWFsaXplKCk7XG5cbiAgdGhpcy5tZWFzdXJlZEdyYXZpdHkuY29weSh0aGlzLmN1cnJlbnRBY2NlbE1lYXN1cmVtZW50LnNhbXBsZSk7XG4gIHRoaXMubWVhc3VyZWRHcmF2aXR5Lm5vcm1hbGl6ZSgpO1xuXG4gIC8vIENvbXBhcmUgZXN0aW1hdGVkIGdyYXZpdHkgd2l0aCBtZWFzdXJlZCBncmF2aXR5LCBnZXQgdGhlIGRlbHRhIHF1YXRlcm5pb25cbiAgLy8gYmV0d2VlbiB0aGUgdHdvLlxuICB2YXIgZGVsdGFRID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcbiAgZGVsdGFRLnNldEZyb21Vbml0VmVjdG9ycyh0aGlzLmVzdGltYXRlZEdyYXZpdHksIHRoaXMubWVhc3VyZWRHcmF2aXR5KTtcbiAgZGVsdGFRLmludmVyc2UoKTtcblxuICBpZiAoVXRpbC5pc0RlYnVnKCkpIHtcbiAgICBjb25zb2xlLmxvZygnRGVsdGE6ICVkIGRlZywgR19lc3Q6ICglcywgJXMsICVzKSwgR19tZWFzOiAoJXMsICVzLCAlcyknLFxuICAgICAgICAgICAgICAgIE1hdGhVdGlsLnJhZFRvRGVnICogVXRpbC5nZXRRdWF0ZXJuaW9uQW5nbGUoZGVsdGFRKSxcbiAgICAgICAgICAgICAgICAodGhpcy5lc3RpbWF0ZWRHcmF2aXR5LngpLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgICAgKHRoaXMuZXN0aW1hdGVkR3Jhdml0eS55KS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICAgICh0aGlzLmVzdGltYXRlZEdyYXZpdHkueikudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgICAodGhpcy5tZWFzdXJlZEdyYXZpdHkueCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgICAodGhpcy5tZWFzdXJlZEdyYXZpdHkueSkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgICAodGhpcy5tZWFzdXJlZEdyYXZpdHkueikudG9GaXhlZCgxKSk7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgdGhlIFNMRVJQIHRhcmdldDogY3VycmVudCBvcmllbnRhdGlvbiBwbHVzIHRoZSBtZWFzdXJlZC1lc3RpbWF0ZWRcbiAgLy8gcXVhdGVybmlvbiBkZWx0YS5cbiAgdmFyIHRhcmdldFEgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuICB0YXJnZXRRLmNvcHkodGhpcy5maWx0ZXJRKTtcbiAgdGFyZ2V0US5tdWx0aXBseShkZWx0YVEpO1xuXG4gIC8vIFNMRVJQIGZhY3RvcjogMCBpcyBwdXJlIGd5cm8sIDEgaXMgcHVyZSBhY2NlbC5cbiAgdGhpcy5maWx0ZXJRLnNsZXJwKHRhcmdldFEsIDEgLSB0aGlzLmtGaWx0ZXIpO1xuXG4gIHRoaXMucHJldmlvdXNGaWx0ZXJRLmNvcHkodGhpcy5maWx0ZXJRKTtcbn07XG5cbkNvbXBsZW1lbnRhcnlGaWx0ZXIucHJvdG90eXBlLmdldE9yaWVudGF0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmZpbHRlclE7XG59O1xuXG5Db21wbGVtZW50YXJ5RmlsdGVyLnByb3RvdHlwZS5hY2NlbFRvUXVhdGVybmlvbl8gPSBmdW5jdGlvbihhY2NlbCkge1xuICB2YXIgbm9ybUFjY2VsID0gbmV3IE1hdGhVdGlsLlZlY3RvcjMoKTtcbiAgbm9ybUFjY2VsLmNvcHkoYWNjZWwpO1xuICBub3JtQWNjZWwubm9ybWFsaXplKCk7XG4gIHZhciBxdWF0ID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcbiAgcXVhdC5zZXRGcm9tVW5pdFZlY3RvcnMobmV3IE1hdGhVdGlsLlZlY3RvcjMoMCwgMCwgLTEpLCBub3JtQWNjZWwpO1xuICBxdWF0LmludmVyc2UoKTtcbiAgcmV0dXJuIHF1YXQ7XG59O1xuXG5Db21wbGVtZW50YXJ5RmlsdGVyLnByb3RvdHlwZS5neXJvVG9RdWF0ZXJuaW9uRGVsdGFfID0gZnVuY3Rpb24oZ3lybywgZHQpIHtcbiAgLy8gRXh0cmFjdCBheGlzIGFuZCBhbmdsZSBmcm9tIHRoZSBneXJvc2NvcGUgZGF0YS5cbiAgdmFyIHF1YXQgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuICB2YXIgYXhpcyA9IG5ldyBNYXRoVXRpbC5WZWN0b3IzKCk7XG4gIGF4aXMuY29weShneXJvKTtcbiAgYXhpcy5ub3JtYWxpemUoKTtcbiAgcXVhdC5zZXRGcm9tQXhpc0FuZ2xlKGF4aXMsIGd5cm8ubGVuZ3RoKCkgKiBkdCk7XG4gIHJldHVybiBxdWF0O1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBsZW1lbnRhcnlGaWx0ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vd2VidnItcG9seWZpbGwvc3JjL3NlbnNvci1mdXNpb24vY29tcGxlbWVudGFyeS1maWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgTWF0aFV0aWwgPSByZXF1aXJlKCcuLi9tYXRoLXV0aWwnKTtcbnZhciBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG4vKipcbiAqIEdpdmVuIGFuIG9yaWVudGF0aW9uIGFuZCB0aGUgZ3lyb3Njb3BlIGRhdGEsIHByZWRpY3RzIHRoZSBmdXR1cmUgb3JpZW50YXRpb25cbiAqIG9mIHRoZSBoZWFkLiBUaGlzIG1ha2VzIHJlbmRlcmluZyBhcHBlYXIgZmFzdGVyLlxuICpcbiAqIEFsc28gc2VlOiBodHRwOi8vbXNsLmNzLnVpdWMuZWR1L35sYXZhbGxlL3BhcGVycy9MYXZZZXJLYXRBbnQxNC5wZGZcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gcHJlZGljdGlvblRpbWVTIHRpbWUgZnJvbSBoZWFkIG1vdmVtZW50IHRvIHRoZSBhcHBlYXJhbmNlIG9mXG4gKiB0aGUgY29ycmVzcG9uZGluZyBpbWFnZS5cbiAqL1xuZnVuY3Rpb24gUG9zZVByZWRpY3RvcihwcmVkaWN0aW9uVGltZVMpIHtcbiAgdGhpcy5wcmVkaWN0aW9uVGltZVMgPSBwcmVkaWN0aW9uVGltZVM7XG5cbiAgLy8gVGhlIHF1YXRlcm5pb24gY29ycmVzcG9uZGluZyB0byB0aGUgcHJldmlvdXMgc3RhdGUuXG4gIHRoaXMucHJldmlvdXNRID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcbiAgLy8gUHJldmlvdXMgdGltZSBhIHByZWRpY3Rpb24gb2NjdXJyZWQuXG4gIHRoaXMucHJldmlvdXNUaW1lc3RhbXBTID0gbnVsbDtcblxuICAvLyBUaGUgZGVsdGEgcXVhdGVybmlvbiB0aGF0IGFkanVzdHMgdGhlIGN1cnJlbnQgcG9zZS5cbiAgdGhpcy5kZWx0YVEgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuICAvLyBUaGUgb3V0cHV0IHF1YXRlcm5pb24uXG4gIHRoaXMub3V0USA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG59XG5cblBvc2VQcmVkaWN0b3IucHJvdG90eXBlLmdldFByZWRpY3Rpb24gPSBmdW5jdGlvbihjdXJyZW50USwgZ3lybywgdGltZXN0YW1wUykge1xuICBpZiAoIXRoaXMucHJldmlvdXNUaW1lc3RhbXBTKSB7XG4gICAgdGhpcy5wcmV2aW91c1EuY29weShjdXJyZW50USk7XG4gICAgdGhpcy5wcmV2aW91c1RpbWVzdGFtcFMgPSB0aW1lc3RhbXBTO1xuICAgIHJldHVybiBjdXJyZW50UTtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBheGlzIGFuZCBhbmdsZSBiYXNlZCBvbiBneXJvc2NvcGUgcm90YXRpb24gcmF0ZSBkYXRhLlxuICB2YXIgYXhpcyA9IG5ldyBNYXRoVXRpbC5WZWN0b3IzKCk7XG4gIGF4aXMuY29weShneXJvKTtcbiAgYXhpcy5ub3JtYWxpemUoKTtcblxuICB2YXIgYW5ndWxhclNwZWVkID0gZ3lyby5sZW5ndGgoKTtcblxuICAvLyBJZiB3ZSdyZSByb3RhdGluZyBzbG93bHksIGRvbid0IGRvIHByZWRpY3Rpb24uXG4gIGlmIChhbmd1bGFyU3BlZWQgPCBNYXRoVXRpbC5kZWdUb1JhZCAqIDIwKSB7XG4gICAgaWYgKFV0aWwuaXNEZWJ1ZygpKSB7XG4gICAgICBjb25zb2xlLmxvZygnTW92aW5nIHNsb3dseSwgYXQgJXMgZGVnL3M6IG5vIHByZWRpY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgKE1hdGhVdGlsLnJhZFRvRGVnICogYW5ndWxhclNwZWVkKS50b0ZpeGVkKDEpKTtcbiAgICB9XG4gICAgdGhpcy5vdXRRLmNvcHkoY3VycmVudFEpO1xuICAgIHRoaXMucHJldmlvdXNRLmNvcHkoY3VycmVudFEpO1xuICAgIHJldHVybiB0aGlzLm91dFE7XG4gIH1cblxuICAvLyBHZXQgdGhlIHByZWRpY3RlZCBhbmdsZSBiYXNlZCBvbiB0aGUgdGltZSBkZWx0YSBhbmQgbGF0ZW5jeS5cbiAgdmFyIGRlbHRhVCA9IHRpbWVzdGFtcFMgLSB0aGlzLnByZXZpb3VzVGltZXN0YW1wUztcbiAgdmFyIHByZWRpY3RBbmdsZSA9IGFuZ3VsYXJTcGVlZCAqIHRoaXMucHJlZGljdGlvblRpbWVTO1xuXG4gIHRoaXMuZGVsdGFRLnNldEZyb21BeGlzQW5nbGUoYXhpcywgcHJlZGljdEFuZ2xlKTtcbiAgdGhpcy5vdXRRLmNvcHkodGhpcy5wcmV2aW91c1EpO1xuICB0aGlzLm91dFEubXVsdGlwbHkodGhpcy5kZWx0YVEpO1xuXG4gIHRoaXMucHJldmlvdXNRLmNvcHkoY3VycmVudFEpO1xuICB0aGlzLnByZXZpb3VzVGltZXN0YW1wUyA9IHRpbWVzdGFtcFM7XG5cbiAgcmV0dXJuIHRoaXMub3V0UTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQb3NlUHJlZGljdG9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3dlYnZyLXBvbHlmaWxsL3NyYy9zZW5zb3ItZnVzaW9uL3Bvc2UtcHJlZGljdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBTZW5zb3JTYW1wbGUoc2FtcGxlLCB0aW1lc3RhbXBTKSB7XG4gIHRoaXMuc2V0KHNhbXBsZSwgdGltZXN0YW1wUyk7XG59O1xuXG5TZW5zb3JTYW1wbGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHNhbXBsZSwgdGltZXN0YW1wUykge1xuICB0aGlzLnNhbXBsZSA9IHNhbXBsZTtcbiAgdGhpcy50aW1lc3RhbXBTID0gdGltZXN0YW1wUztcbn07XG5cblNlbnNvclNhbXBsZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKHNlbnNvclNhbXBsZSkge1xuICB0aGlzLnNldChzZW5zb3JTYW1wbGUuc2FtcGxlLCBzZW5zb3JTYW1wbGUudGltZXN0YW1wUyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbnNvclNhbXBsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi93ZWJ2ci1wb2x5ZmlsbC9zcmMvc2Vuc29yLWZ1c2lvbi9zZW5zb3Itc2FtcGxlLmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiB3ZWJwYWNrRW1wdHlDb250ZXh0KHJlcSkge1xuXHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInLlwiKTtcbn1cbndlYnBhY2tFbXB0eUNvbnRleHQua2V5cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH07XG53ZWJwYWNrRW1wdHlDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xud2VicGFja0VtcHR5Q29udGV4dC5pZCA9IDY4O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9ob3Qgbm9ucmVjdXJzaXZlIF5cXC5cXC9sb2ckXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9