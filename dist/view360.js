(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("@egjs/component"), require("@egjs/axes"));
	else if(typeof define === 'function' && define.amd)
		define("view360", ["@egjs/component", "@egjs/axes"], factory);
	else if(typeof exports === 'object')
		exports["view360"] = factory(require("@egjs/component"), require("@egjs/axes"));
	else
		root["eg"] = root["eg"] || {}, root["eg"]["view360"] = factory(root["eg"]["Component"], root["eg"]["Axes"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_11__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 69);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.ROTATE_CONSTANT = exports.vec3 = exports.vec2 = exports.quat = exports.mat4 = exports.glMatrix = exports.util = undefined;

var _common = __webpack_require__(2);

var _common2 = _interopRequireDefault(_common);

var _vec = __webpack_require__(44);

var _vec2 = _interopRequireDefault(_vec);

var _vec3 = __webpack_require__(43);

var _vec4 = _interopRequireDefault(_vec3);

var _quat = __webpack_require__(42);

var _quat2 = _interopRequireDefault(_quat);

var _mat = __webpack_require__(41);

var _mat2 = _interopRequireDefault(_mat);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function quatToVec3(quaternion) {
	var baseV = _vec2["default"].fromValues(0, 0, 1);

	_vec2["default"].transformQuat(baseV, baseV, quaternion);
	return baseV;
} /**
   * Original Code
   * https://github.com/toji/gl-matrix/blob/v2.3.2/src/gl-matrix.js
   * Math Util
   * modified by egjs
   */
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.2
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

// Some minimal math functionality borrowed from gl-Matrix and stripped down
// for the purposes of this library.

var util = {};

util.isPowerOfTwo = function (n) {
	return n && (n & n - 1) === 0;
};

util.extractPitchFromQuat = function (quaternion) {
	var baseV = quatToVec3(quaternion);

	return -1 * Math.atan2(baseV[1], Math.sqrt(Math.pow(baseV[0], 2) + Math.pow(baseV[2], 2)));
};

// implement reference
// the general equation of a plane : http://www.gisdeveloper.co.kr/entry/평면의-공식
// calculating angle between two vectors : http://darkpgmr.tistory.com/121
var ROTATE_CONSTANT = {
	PITCH_DELTA: 1,
	YAW_DELTA_BY_ROLL: 2,
	YAW_DELTA_BY_YAW: 3
};

ROTATE_CONSTANT[ROTATE_CONSTANT.PITCH_DELTA] = {
	targetAxis: [0, 1, 0],
	meshPoint: [0, 0, 1]
};
ROTATE_CONSTANT[ROTATE_CONSTANT.YAW_DELTA_BY_ROLL] = {
	targetAxis: [0, 1, 0],
	meshPoint: [1, 0, 0]
};
ROTATE_CONSTANT[ROTATE_CONSTANT.YAW_DELTA_BY_YAW] = {
	targetAxis: [1, 0, 0],
	meshPoint: [0, 0, 1]
};

function getRotationDelta(prevQ, curQ, rotateKind) {
	var targetAxis = _vec2["default"].fromValues(ROTATE_CONSTANT[rotateKind].targetAxis[0], ROTATE_CONSTANT[rotateKind].targetAxis[1], ROTATE_CONSTANT[rotateKind].targetAxis[2]);
	var meshPoint = ROTATE_CONSTANT[rotateKind].meshPoint;

	var prevQuaternion = _quat2["default"].clone(prevQ);
	var curQuaternion = _quat2["default"].clone(curQ);

	_quat2["default"].normalize(prevQuaternion, prevQuaternion);
	_quat2["default"].normalize(curQuaternion, curQuaternion);

	var prevPoint = _vec2["default"].fromValues(0, 0, 1);
	var curPoint = _vec2["default"].fromValues(0, 0, 1);

	_vec2["default"].transformQuat(prevPoint, prevPoint, prevQuaternion);
	_vec2["default"].transformQuat(curPoint, curPoint, curQuaternion);
	_vec2["default"].transformQuat(targetAxis, targetAxis, curQuaternion);

	var rotateDistance = _vec2["default"].dot(targetAxis, _vec2["default"].cross(_vec2["default"].create(), prevPoint, curPoint));
	var rotateDirection = rotateDistance > 0 ? 1 : -1;

	// when counter clock wise, use vec3.fromValues(0,1,0)
	// when clock wise, use vec3.fromValues(0,-1,0)
	// const meshPoint1 = vec3.fromValues(0, 0, 0);
	var meshPoint2 = _vec2["default"].fromValues(meshPoint[0], meshPoint[1], meshPoint[2]);

	var meshPoint3 = void 0;

	if (rotateKind !== ROTATE_CONSTANT.YAW_DELTA_BY_YAW) {
		meshPoint3 = _vec2["default"].fromValues(0, rotateDirection, 0);
	} else {
		meshPoint3 = _vec2["default"].fromValues(rotateDirection, 0, 0);
	}

	_vec2["default"].transformQuat(meshPoint2, meshPoint2, curQuaternion);
	_vec2["default"].transformQuat(meshPoint3, meshPoint3, curQuaternion);

	var vecU = meshPoint2;
	var vecV = meshPoint3;
	var vecN = _vec2["default"].create();

	_vec2["default"].cross(vecN, vecU, vecV);
	_vec2["default"].normalize(vecN, vecN);

	var coefficientA = vecN[0];
	var coefficientB = vecN[1];
	var coefficientC = vecN[2];
	//	const coefficientD = -1 * vec3.dot(vecN, meshPoint1);

	// a point on the plane
	curPoint = _vec2["default"].fromValues(meshPoint[0], meshPoint[1], meshPoint[2]);
	_vec2["default"].transformQuat(curPoint, curPoint, curQuaternion);

	// a point should project on the plane
	prevPoint = _vec2["default"].fromValues(meshPoint[0], meshPoint[1], meshPoint[2]);
	_vec2["default"].transformQuat(prevPoint, prevPoint, prevQuaternion);

	// distance between prevPoint and the plane
	var distance = Math.abs(prevPoint[0] * coefficientA + prevPoint[1] * coefficientB + prevPoint[2] * coefficientC);

	var projectedPrevPoint = _vec2["default"].create();

	_vec2["default"].subtract(projectedPrevPoint, prevPoint, _vec2["default"].scale(_vec2["default"].create(), vecN, distance));

	var trigonometricRatio = (projectedPrevPoint[0] * curPoint[0] + projectedPrevPoint[1] * curPoint[1] + projectedPrevPoint[2] * curPoint[2]) / (_vec2["default"].length(projectedPrevPoint) * _vec2["default"].length(curPoint));

	// defensive block
	if (trigonometricRatio > 1) {
		trigonometricRatio = 1;
	}

	var theta = Math.acos(trigonometricRatio);

	var crossVec = _vec2["default"].cross(_vec2["default"].create(), curPoint, projectedPrevPoint);

	distance = coefficientA * crossVec[0] + coefficientB * crossVec[1] + coefficientC * crossVec[2];

	var thetaDirection = void 0;

	if (rotateKind !== ROTATE_CONSTANT.YAW_DELTA_BY_YAW) {
		thetaDirection = distance > 0 ? 1 : -1;
	} else {
		thetaDirection = distance < 0 ? 1 : -1;
	}

	var deltaRadian = theta * thetaDirection * rotateDirection;

	return _common2["default"].toDegree(deltaRadian);
}

util.getRotationDelta = getRotationDelta;

exports.util = util;
exports.glMatrix = _common2["default"];
exports.mat4 = _mat2["default"];
exports.quat = _quat2["default"];
exports.vec2 = _vec4["default"];
exports.vec3 = _vec2["default"];
exports.ROTATE_CONSTANT = ROTATE_CONSTANT;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Original Code
 * https://github.com/toji/gl-matrix/blob/v2.3.2/src/gl-matrix/common.js
 * Common utilities
 * modified by egjs
 */
var glMatrix = {};

glMatrix.ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;

var degree = Math.PI / 180;

glMatrix.toRadian = function (a) {
     return a * degree;
};

glMatrix.toDegree = function (a) {
     return a / degree;
};

// glMatrix.EPSILON = 0.000001;
glMatrix.EPSILON = 0.0001;

module.exports = glMatrix;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/* eslint-disable no-new-func */
/* eslint-disable no-nested-ternary */
var win = typeof window !== "undefined" && window.Math === Math ? window : typeof self !== "undefined" && self.Math === Math ? self : Function("return this")();
/* eslint-enable no-nested-ternary */
/* eslint-enable no-new-func */

win.Float32Array = typeof win.Float32Array !== "undefined" ? win.Float32Array : win.Array;

exports.window = win;
var screen = exports.screen = win.screen;
var orientation = exports.orientation = win.orientation;
var document = exports.document = win.document;
var Float32Array = exports.Float32Array = win.Float32Array;
var getComputedStyle = exports.getComputedStyle = win.getComputedStyle;
var userAgent = exports.userAgent = win.navigator.userAgent;
var SUPPORT_TOUCH = exports.SUPPORT_TOUCH = "ontouchstart" in win;
var SUPPORT_DEVICEMOTION = exports.SUPPORT_DEVICEMOTION = "ondevicemotion" in win;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Copyright (c) 2017 NAVER Corp.
 * @egjs/agent project is licensed under the MIT license
 * 
 * @egjs/agent JavaScript library
 * 
 * 
 * @version 2.1.2
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["agent"] = factory();
	else
		root["eg"] = root["eg"] || {}, root["eg"]["agent"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _agent = __webpack_require__(1);

var _agent2 = _interopRequireDefault(_agent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

module.exports = _agent2["default"]; /**
                                      * Copyright (c) NAVER Corp.
                                      * egjs-agent projects are licensed under the MIT license
                                      */

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _browser = __webpack_require__(2);

var _Parser = __webpack_require__(3);

var _Parser2 = _interopRequireDefault(_Parser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @namespace eg
 */

/**
 * Extracts browser and operating system information from the user agent string.
 * @ko 유저 에이전트 문자열에서 브라우저와 운영체제 정보를 추출한다.
 * @function eg#agent
 * @param {String} [userAgent=navigator.userAgent] user agent string to parse <ko>파싱할 유저에이전트 문자열</ko>
 * @return {Object} agentInfo
 * @return {Object} agentInfo.os os Operating system information <ko>운영체제 정보</ko>
 * @return {String} agentInfo.os.name Operating system name (android, ios, window, mac, unknown) <ko>운영체제 이름 (android, ios, window, mac, unknown)</ko>
 * @return {String} agentInfo.os.version Operating system version <ko>운영체제 버전</ko>
 * @return {String} agentInfo.browser Browser information <ko>브라우저 정보</ko>
 * @return {String} agentInfo.browser.name Browser name (safari, chrome, sbrowser, ie, firefox, unknown) <ko>브라우저 이름 (safari, chrome, sbrowser, ie, firefox, unknown)</ko>
 * @return {String} agentInfo.browser.version Browser version <ko>브라우저 버전 </ko>
 * @return {Boolean} agentInfo.browser.webview Indicates whether the browser is inapp<ko>웹뷰 브라우저 여부</ko>
 * @return {Boolean} agentInfo.isMobile Indicates whether the browser is for mobile<ko>모바일 브라우저 여부</ko>
 */
/**
 * Copyright (c) NAVER Corp.
 * egjs-agent projects are licensed under the MIT license
 */
function agent() {
  var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _browser.navigator.userAgent;

  _Parser2["default"].setUa(ua);

  var agentInfo = {
    os: _Parser2["default"].getOs(),
    browser: _Parser2["default"].getBrowser(),
    isMobile: _Parser2["default"].getIsMobile()
  };

  agentInfo.browser.name = agentInfo.browser.name.toLowerCase();
  agentInfo.os.name = agentInfo.os.name.toLowerCase();
  agentInfo.os.version = agentInfo.os.version.toLowerCase();

  if (agentInfo.os.name === "ios" && agentInfo.browser.webview) {
    agentInfo.browser.version = "-1";
  }

  return agentInfo;
}
agent.VERSION = "2.1.2";
exports["default"] = agent;
module.exports = exports["default"];

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var win = typeof window !== "undefined" && window || {};

var RegExp = exports.RegExp = win.RegExp;
var navigator = exports.navigator = win.navigator;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _parseRules = __webpack_require__(4);

var _parseRules2 = _interopRequireDefault(_parseRules);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var UA = void 0;

function setUa(ua) {
	UA = ua;
}

function isMatched(base, target) {
	return target && target.test ? !!target.test(base) : base.indexOf(target) > -1;
}

function getIdentityStringFromArray(rules, defaultStrings) {
	var matchedRule = rules.filter(function (rule) {
		return isMatched(UA, rule.criteria);
	})[0];

	return matchedRule && matchedRule.identity || defaultStrings.name;
}

function getRule(rules, targetIdentity) {
	return rules.filter(function (rule) {
		var criteria = rule.criteria;
		var identityMatched = new RegExp(rule.identity, "i").test(targetIdentity);

		if (criteria ? identityMatched && isMatched(UA, criteria) : identityMatched) {
			return true;
		} else {
			return false;
		}
	})[0];
}

function getBrowserName() {
	return getIdentityStringFromArray(_parseRules2["default"].browser, _parseRules2["default"].defaultString.browser);
}

function getBrowserRule(browserName) {
	var rule = getRule(_parseRules2["default"].browser, browserName);

	if (!rule) {
		rule = {
			criteria: browserName,
			versionSearch: browserName,
			identity: browserName
		};
	}

	return rule;
}

function extractBrowserVersion(versionToken, ua) {
	var browserVersion = _parseRules2["default"].defaultString.browser.version;
	var versionRegexResult = new RegExp("(" + versionToken + ")", "i").exec(ua);

	if (!versionRegexResult) {
		return browserVersion;
	}

	var versionTokenIndex = versionRegexResult.index;
	var verTkn = versionRegexResult[0];

	if (versionTokenIndex > -1) {
		var versionIndex = versionTokenIndex + verTkn.length + 1;

		browserVersion = ua.substring(versionIndex).split(" ")[0].replace(/_/g, ".").replace(/;|\)/g, "");
	}
	return browserVersion;
}

function getBrowserVersion(browserName) {
	if (!browserName) {
		return undefined;
	}

	// console.log(browserRule);
	// const versionToken = browserRule ? browserRule.versionSearch : browserName;
	var browserRule = getBrowserRule(browserName);
	var versionToken = browserRule.versionSearch || browserName;
	var browserVersion = extractBrowserVersion(versionToken, UA);

	return browserVersion;
}

function isWebview() {
	var webviewRules = _parseRules2["default"].webview;
	var browserVersion = void 0;

	return webviewRules.filter(function (rule) {
		return isMatched(UA, rule.criteria);
	}).some(function (rule) {
		browserVersion = extractBrowserVersion(rule.browserVersionSearch, UA);
		if (isMatched(UA, rule.webviewToken) || isMatched(browserVersion, rule.webviewBrowserVersion)) {
			return true;
		} else {
			return false;
		}
	});
}

function getOSRule(osName) {
	return getRule(_parseRules2["default"].os, osName);
}

function getOsName() {
	return getIdentityStringFromArray(_parseRules2["default"].os, _parseRules2["default"].defaultString.os);
}

function getOsVersion(osName) {
	var osRule = getOSRule(osName) || {};
	var defaultOSVersion = _parseRules2["default"].defaultString.os.version;
	var osVersion = void 0;

	if (!osName) {
		return undefined;
	}
	if (osRule.versionAlias) {
		return osRule.versionAlias;
	}
	var osVersionToken = osRule.versionSearch || osName;
	var osVersionRegex = new RegExp("(" + osVersionToken + ")\\s([\\d_\\.]+|\\d_0)", "i");
	var osVersionRegexResult = osVersionRegex.exec(UA);

	if (osVersionRegexResult) {
		osVersion = osVersionRegex.exec(UA)[2].replace(/_/g, ".").replace(/;|\)/g, "");
	}
	return osVersion || defaultOSVersion;
}

function getOs() {
	var name = getOsName();
	var version = getOsVersion(name);

	return { name: name, version: version };
}

function getBrowser() {
	var name = getBrowserName();
	var version = getBrowserVersion(name);

	return { name: name, version: version, webview: isWebview() };
}

function getIsMobile() {
	return UA.indexOf("Mobi") !== -1;
}

exports["default"] = {
	getOs: getOs,
	getBrowser: getBrowser,
	getIsMobile: getIsMobile,
	setUa: setUa
};
module.exports = exports["default"];

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var parseRules = {
	browser: [{
		criteria: "PhantomJS",
		identity: "PhantomJS"
	}, {
		criteria: /Whale/,
		identity: "Whale",
		versionSearch: "Whale"
	}, {
		criteria: /Edge/,
		identity: "Edge",
		versionSearch: "Edge"
	}, {
		criteria: /MSIE|Trident|Windows Phone/,
		identity: "IE",
		versionSearch: "IEMobile|MSIE|rv"
	}, {
		criteria: /MiuiBrowser/,
		identity: "MIUI Browser",
		versionSearch: "MiuiBrowser"
	}, {
		criteria: /SamsungBrowser/,
		identity: "Samsung Internet",
		versionSearch: "SamsungBrowser"
	}, {
		criteria: /SAMSUNG /,
		identity: "Samsung Internet",
		versionSearch: "Version"
	}, {
		criteria: /Chrome|CriOS/,
		identity: "Chrome"
	}, {
		criteria: /Android/,
		identity: "Android Browser",
		versionSearch: "Version"
	}, {
		criteria: /iPhone|iPad/,
		identity: "Safari",
		versionSearch: "Version"
	}, {
		criteria: "Apple",
		identity: "Safari",
		versionSearch: "Version"
	}, {
		criteria: "Firefox",
		identity: "Firefox"
	}],
	os: [{
		criteria: /Windows Phone/,
		identity: "Windows Phone",
		versionSearch: "Windows Phone"
	}, {
		criteria: "Windows 2000",
		identity: "Window",
		versionAlias: "5.0"
	}, {
		criteria: /Windows NT/,
		identity: "Window",
		versionSearch: "Windows NT"
	}, {
		criteria: /iPhone|iPad/,
		identity: "iOS",
		versionSearch: "iPhone OS|CPU OS"
	}, {
		criteria: "Mac",
		versionSearch: "OS X",
		identity: "MAC"
	}, {
		criteria: /Android/,
		identity: "Android"
	}, {
		criteria: /Tizen/,
		identity: "Tizen"
	}, {
		criteria: /Web0S/,
		identity: "WebOS"
	}],

	// Webview check condition
	// ios: If has no version information
	// Android 5.0 && chrome 40+: Presence of "; wv" in userAgent
	// Under android 5.0: Presence of "NAVER" or "Daum" in userAgent
	webview: [{
		criteria: /iPhone|iPad/,
		browserVersionSearch: "Version",
		webviewBrowserVersion: /-1/
	}, {
		criteria: /iPhone|iPad|Android/,
		webviewToken: /NAVER|DAUM|; wv/

	}],
	defaultString: {
		browser: {
			version: "-1",
			name: "unknown"
		},
		os: {
			version: "-1",
			name: "unknown"
		}
	}
};

exports["default"] = parseRules;
module.exports = exports["default"];

/***/ })
/******/ ]);
});

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.4+314e4831
 */

(function (global, factory) {
	 true ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && "function" === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var TRY_CATCH_ERROR = { error: null };

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    TRY_CATCH_ERROR.error = error;
    return TRY_CATCH_ERROR;
  }
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === TRY_CATCH_ERROR) {
      reject(promise, TRY_CATCH_ERROR.error);
      TRY_CATCH_ERROR.error = null;
    } else if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = void 0,
      failed = void 0;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value.error = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (failed) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = getThen(entry);

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        handleMaybeThenable(promise, entry, _then);
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    return promise.then(function (value) {
      return constructor.resolve(callback()).then(function () {
        return value;
      });
    }, function (reason) {
      return constructor.resolve(callback()).then(function () {
        throw reason;
      });
    });
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));



//# sourceMappingURL=es6-promise.map

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(52), __webpack_require__(9)))

/***/ }),
/* 6 */
/***/ (function(module, exports) {

/*
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MathUtil = window.MathUtil || {};

MathUtil.degToRad = Math.PI / 180;
MathUtil.radToDeg = 180 / Math.PI;

// Some minimal math functionality borrowed from THREE.Math and stripped down
// for the purposes of this library.


MathUtil.Vector2 = function ( x, y ) {
  this.x = x || 0;
  this.y = y || 0;
};

MathUtil.Vector2.prototype = {
  constructor: MathUtil.Vector2,

  set: function ( x, y ) {
    this.x = x;
    this.y = y;

    return this;
  },

  copy: function ( v ) {
    this.x = v.x;
    this.y = v.y;

    return this;
  },

  subVectors: function ( a, b ) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;

    return this;
  },
};

MathUtil.Vector3 = function ( x, y, z ) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
};

MathUtil.Vector3.prototype = {
  constructor: MathUtil.Vector3,

  set: function ( x, y, z ) {
    this.x = x;
    this.y = y;
    this.z = z;

    return this;
  },

  copy: function ( v ) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;

    return this;
  },

  length: function () {
    return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
  },

  normalize: function () {
    var scalar = this.length();

    if ( scalar !== 0 ) {
      var invScalar = 1 / scalar;

      this.multiplyScalar(invScalar);
    } else {
      this.x = 0;
      this.y = 0;
      this.z = 0;
    }

    return this;
  },

  multiplyScalar: function ( scalar ) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
  },

  applyQuaternion: function ( q ) {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;

    // calculate quat * vector
    var ix =  qw * x + qy * z - qz * y;
    var iy =  qw * y + qz * x - qx * z;
    var iz =  qw * z + qx * y - qy * x;
    var iw = - qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
    this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
    this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

    return this;
  },

  dot: function ( v ) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  },

  crossVectors: function ( a, b ) {
    var ax = a.x, ay = a.y, az = a.z;
    var bx = b.x, by = b.y, bz = b.z;

    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;

    return this;
  },
};

MathUtil.Quaternion = function ( x, y, z, w ) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = ( w !== undefined ) ? w : 1;
};

MathUtil.Quaternion.prototype = {
  constructor: MathUtil.Quaternion,

  set: function ( x, y, z, w ) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;

    return this;
  },

  copy: function ( quaternion ) {
    this.x = quaternion.x;
    this.y = quaternion.y;
    this.z = quaternion.z;
    this.w = quaternion.w;

    return this;
  },

  setFromEulerXYZ: function( x, y, z ) {
    var c1 = Math.cos( x / 2 );
    var c2 = Math.cos( y / 2 );
    var c3 = Math.cos( z / 2 );
    var s1 = Math.sin( x / 2 );
    var s2 = Math.sin( y / 2 );
    var s3 = Math.sin( z / 2 );

    this.x = s1 * c2 * c3 + c1 * s2 * s3;
    this.y = c1 * s2 * c3 - s1 * c2 * s3;
    this.z = c1 * c2 * s3 + s1 * s2 * c3;
    this.w = c1 * c2 * c3 - s1 * s2 * s3;

    return this;
  },

  setFromEulerYXZ: function( x, y, z ) {
    var c1 = Math.cos( x / 2 );
    var c2 = Math.cos( y / 2 );
    var c3 = Math.cos( z / 2 );
    var s1 = Math.sin( x / 2 );
    var s2 = Math.sin( y / 2 );
    var s3 = Math.sin( z / 2 );

    this.x = s1 * c2 * c3 + c1 * s2 * s3;
    this.y = c1 * s2 * c3 - s1 * c2 * s3;
    this.z = c1 * c2 * s3 - s1 * s2 * c3;
    this.w = c1 * c2 * c3 + s1 * s2 * s3;

    return this;
  },

  setFromAxisAngle: function ( axis, angle ) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
    // assumes axis is normalized

    var halfAngle = angle / 2, s = Math.sin( halfAngle );

    this.x = axis.x * s;
    this.y = axis.y * s;
    this.z = axis.z * s;
    this.w = Math.cos( halfAngle );

    return this;
  },

  multiply: function ( q ) {
    return this.multiplyQuaternions( this, q );
  },

  multiplyQuaternions: function ( a, b ) {
    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

    var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
    var qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;

    this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    return this;
  },

  inverse: function () {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;

    this.normalize();

    return this;
  },

  normalize: function () {
    var l = Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

    if ( l === 0 ) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;
    } else {
      l = 1 / l;

      this.x = this.x * l;
      this.y = this.y * l;
      this.z = this.z * l;
      this.w = this.w * l;
    }

    return this;
  },

  slerp: function ( qb, t ) {
    if ( t === 0 ) return this;
    if ( t === 1 ) return this.copy( qb );

    var x = this.x, y = this.y, z = this.z, w = this.w;

    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;

    if ( cosHalfTheta < 0 ) {
      this.w = - qb.w;
      this.x = - qb.x;
      this.y = - qb.y;
      this.z = - qb.z;

      cosHalfTheta = - cosHalfTheta;
    } else {
      this.copy( qb );
    }

    if ( cosHalfTheta >= 1.0 ) {
      this.w = w;
      this.x = x;
      this.y = y;
      this.z = z;

      return this;
    }

    var halfTheta = Math.acos( cosHalfTheta );
    var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

    if ( Math.abs( sinHalfTheta ) < 0.001 ) {
      this.w = 0.5 * ( w + this.w );
      this.x = 0.5 * ( x + this.x );
      this.y = 0.5 * ( y + this.y );
      this.z = 0.5 * ( z + this.z );

      return this;
    }

    var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
    ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

    this.w = ( w * ratioA + this.w * ratioB );
    this.x = ( x * ratioA + this.x * ratioB );
    this.y = ( y * ratioA + this.y * ratioB );
    this.z = ( z * ratioA + this.z * ratioB );

    return this;
  },

  setFromUnitVectors: function () {
    // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
    // assumes direction vectors vFrom and vTo are normalized

    var v1, r;
    var EPS = 0.000001;

    return function ( vFrom, vTo ) {
      if ( v1 === undefined ) v1 = new MathUtil.Vector3();

      r = vFrom.dot( vTo ) + 1;

      if ( r < EPS ) {
        r = 0;

        if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
          v1.set( - vFrom.y, vFrom.x, 0 );
        } else {
          v1.set( 0, - vFrom.z, vFrom.y );
        }
      } else {
        v1.crossVectors( vFrom, vTo );
      }

      this.x = v1.x;
      this.y = v1.y;
      this.z = v1.z;
      this.w = r;

      this.normalize();

      return this;
    }
  }(),
};

module.exports = MathUtil;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _agent = __webpack_require__(4);

var _agent2 = _interopRequireDefault(_agent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WEBGL_ERROR_CODE = {
	"0": "NO_ERROR",
	"1280": "INVALID_ENUM",
	"1281": "INVALID_VALUE",
	"1282": "INVALID_OPERATION",
	"1285": "OUT_OF_MEMORY",
	"1286": "INVALID_FRAMEBUFFER_OPERATION",
	"37442": "CONTEXT_LOST_WEBGL"
};

var webglAvailability = null;

var WebGLUtils = function () {
	function WebGLUtils() {
		_classCallCheck(this, WebGLUtils);
	}

	WebGLUtils.createShader = function createShader(gl, type, source) {
		var shader = gl.createShader(type);

		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

		if (success) {
			return shader;
		}

		gl.deleteShader(shader);
		return null;
	};

	WebGLUtils.createProgram = function createProgram(gl, vertexShader, fragmentShader) {
		var program = gl.createProgram();

		gl.attachShader(program, vertexShader);
		gl.attachShader(program, fragmentShader);
		gl.linkProgram(program);
		var success = gl.getProgramParameter(program, gl.LINK_STATUS);

		if (success) {
			return program;
		}

		gl.deleteProgram(program);
		return null;
	};

	WebGLUtils.initBuffer = function initBuffer(gl, target /* bind point */, data, itemSize, attr) {
		var buffer = gl.createBuffer();

		gl.bindBuffer(target, buffer);
		gl.bufferData(target, data, gl.STATIC_DRAW);

		if (buffer) {
			buffer.itemSize = itemSize;
			buffer.numItems = data.length / itemSize;
		}

		if (attr !== undefined) {
			gl.enableVertexAttribArray(attr);
			gl.vertexAttribPointer(attr, buffer.itemSize, gl.FLOAT, false, 0, 0);
		}

		return buffer;
	};

	WebGLUtils.bindBufferToAttribute = function bindBufferToAttribute(gl, buffer, attr) {
		if (buffer === null || attr === null) {
			return;
		}

		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.vertexAttribPointer(attr, buffer.itemSize, gl.FLOAT, false, 0, 0);
	};

	WebGLUtils.getWebglContext = function getWebglContext(canvas, userContextAttributes) {
		var webglIdentifiers = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
		var context = null;
		var contextAttributes = _extends({
			preserveDrawingBuffer: false,
			antialias: false
		}, userContextAttributes);

		function onWebglcontextcreationerror(e) {
			return e.statusMessage;
		}

		canvas.addEventListener("webglcontextcreationerror", onWebglcontextcreationerror);

		for (var i = 0; i < webglIdentifiers.length; i++) {
			try {
				context = canvas.getContext(webglIdentifiers[i], contextAttributes);
			} catch (t) {}
			if (context) {
				break;
			}
		}

		canvas.removeEventListener("webglcontextcreationerror", onWebglcontextcreationerror);

		return context;
	};

	WebGLUtils.createTexture = function createTexture(gl, textureTarget) {
		var texture = gl.createTexture();

		gl.bindTexture(textureTarget, texture);
		gl.texParameteri(textureTarget, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(textureTarget, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(textureTarget, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(textureTarget, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.bindTexture(textureTarget, null);

		return texture;
	};

	/**
  * Returns the webgl availability of the current browser.
  * @method WebGLUtils#isWebGLAvailable
  * @retuen {Boolean} isWebGLAvailable
  */


	WebGLUtils.isWebGLAvailable = function isWebGLAvailable() {
		if (webglAvailability === null) {
			var canvas = document.createElement("canvas");
			var webglContext = WebGLUtils.getWebglContext(canvas);

			webglAvailability = !!webglContext;

			// webglContext Resource forced collection
			if (webglContext) {
				var loseContextExtension = webglContext.getExtension("WEBGL_lose_context");

				loseContextExtension && loseContextExtension.loseContext();
			}
		}
		return webglAvailability;
	};

	/**
  * Returns whether webgl is stable in the current browser.
  * @method WebGLUtils#isStableWebGL
  * @retuen {Boolean} isStableWebGL
  */


	WebGLUtils.isStableWebGL = function isStableWebGL() {
		var agentInfo = (0, _agent2["default"])();
		var isStableWebgl = true;

		if (agentInfo.os.name === "android" && parseFloat(agentInfo.os.version) <= 4.3) {
			isStableWebgl = false;
		} else if (agentInfo.os.name === "android" && parseFloat(agentInfo.os.version) === 4.4) {
			if (agentInfo.browser.name !== "chrome") {
				isStableWebgl = false;
			}
		}
		return isStableWebgl;
	};

	WebGLUtils.getErrorNameFromWebGLErrorCode = function getErrorNameFromWebGLErrorCode(code) {
		if (!(code in WEBGL_ERROR_CODE)) {
			return "UNKNOWN_ERROR";
		}

		return WEBGL_ERROR_CODE[code];
	};

	return WebGLUtils;
}();

exports["default"] = WebGLUtils;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var CONTROL_MODE_VR = 1;
var CONTROL_MODE_YAWPITCH = 2;

var TOUCH_DIRECTION_NONE = 1;
var TOUCH_DIRECTION_YAW = 2;
var TOUCH_DIRECTION_PITCH = 4;
var TOUCH_DIRECTION_ALL = TOUCH_DIRECTION_YAW | TOUCH_DIRECTION_PITCH;

/* Const for MovableCoord */
var MC_DECELERATION = 0.0014;
var MC_MAXIMUM_DURATION = 1000;
var MC_BIND_SCALE = [0.20, 0.20];

var MIN_FIELD_OF_VIEW = 20;
var MAX_FIELD_OF_VIEW = 110;
var PAN_SCALE = 320;

// const DELTA_THRESHOLD = 0.015;
// const DELTA_THRESHOLD = 0.09; // Note4
// const DELTA_THRESHOLD = 0.0825;
// const DELTA_THRESHOLD = 0.075;
// const DELTA_THRESHOLD = 0.06;
// const DELTA_THRESHOLD = 0.045;
var DELTA_THRESHOLD = 0.0375; // Note2

var YAW_RANGE_HALF = 180;
var PITCH_RANGE_HALF = 90;
var CIRCULAR_PITCH_RANGE_HALF = 180;
var PINCH_EVENTS = "pinchstart pinchmove pinchend";

var KEYMAP = {
	LEFT_ARROW: 37,
	A: 65,
	UP_ARROW: 38,
	W: 87,
	RIGHT_ARROW: 39,
	D: 68,
	DOWN_ARROW: 40,
	S: 83
};

var GYRO_MODE = {
	NONE: "none",
	YAWPITCH: "yawPitch",
	VR: "VR"
};

exports.GYRO_MODE = GYRO_MODE;
exports.CONTROL_MODE_VR = CONTROL_MODE_VR;
exports.CONTROL_MODE_YAWPITCH = CONTROL_MODE_YAWPITCH;
exports.TOUCH_DIRECTION_NONE = TOUCH_DIRECTION_NONE;
exports.TOUCH_DIRECTION_YAW = TOUCH_DIRECTION_YAW;
exports.TOUCH_DIRECTION_PITCH = TOUCH_DIRECTION_PITCH;
exports.TOUCH_DIRECTION_ALL = TOUCH_DIRECTION_ALL;
exports.MC_DECELERATION = MC_DECELERATION;
exports.MC_MAXIMUM_DURATION = MC_MAXIMUM_DURATION;
exports.MC_BIND_SCALE = MC_BIND_SCALE;
exports.MIN_FIELD_OF_VIEW = MIN_FIELD_OF_VIEW;
exports.MAX_FIELD_OF_VIEW = MAX_FIELD_OF_VIEW;
exports.PAN_SCALE = PAN_SCALE;
exports.DELTA_THRESHOLD = DELTA_THRESHOLD;
exports.YAW_RANGE_HALF = YAW_RANGE_HALF;
exports.PITCH_RANGE_HALF = PITCH_RANGE_HALF;
exports.CIRCULAR_PITCH_RANGE_HALF = CIRCULAR_PITCH_RANGE_HALF;
exports.PINCH_EVENTS = PINCH_EVENTS;
exports.KEYMAP = KEYMAP;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 10 */
/***/ (function(module, exports) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Util = window.Util || {};

Util.MIN_TIMESTEP = 0.001;
Util.MAX_TIMESTEP = 1;

Util.base64 = function(mimeType, base64) {
  return 'data:' + mimeType + ';base64,' + base64;
};

Util.clamp = function(value, min, max) {
  return Math.min(Math.max(min, value), max);
};

Util.lerp = function(a, b, t) {
  return a + ((b - a) * t);
};

/**
 * Light polyfill for `Promise.race`. Returns
 * a promise that resolves when the first promise
 * provided resolves.
 *
 * @param {Array<Promise>} promises
 */
Util.race = function(promises) {
  if (Promise.race) {
    return Promise.race(promises);
  }

  return new Promise(function (resolve, reject) {
    for (var i = 0; i < promises.length; i++) {
      promises[i].then(resolve, reject);
    }
  });
};

Util.isIOS = (function() {
  var isIOS = /iPad|iPhone|iPod/.test(navigator.platform);
  return function() {
    return isIOS;
  };
})();

Util.isWebViewAndroid = (function() {
  var isWebViewAndroid = navigator.userAgent.indexOf('Version') !== -1 &&
      navigator.userAgent.indexOf('Android') !== -1 &&
      navigator.userAgent.indexOf('Chrome') !== -1;
  return function() {
    return isWebViewAndroid;
  };
})();

Util.isSafari = (function() {
  var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  return function() {
    return isSafari;
  };
})();

Util.isFirefoxAndroid = (function() {
  var isFirefoxAndroid = navigator.userAgent.indexOf('Firefox') !== -1 &&
      navigator.userAgent.indexOf('Android') !== -1;
  return function() {
    return isFirefoxAndroid;
  };
})();

Util.isR7 = (function() {
  var isR7 = navigator.userAgent.indexOf('R7 Build') !== -1;
  return function() {
    return isR7;
  };
})();

Util.isLandscapeMode = function() {
  var rtn = (window.orientation == 90 || window.orientation == -90);
  return Util.isR7() ? !rtn : rtn;
};

// Helper method to validate the time steps of sensor timestamps.
Util.isTimestampDeltaValid = function(timestampDeltaS) {
  if (isNaN(timestampDeltaS)) {
    return false;
  }
  if (timestampDeltaS <= Util.MIN_TIMESTEP) {
    return false;
  }
  if (timestampDeltaS > Util.MAX_TIMESTEP) {
    return false;
  }
  return true;
};

Util.getScreenWidth = function() {
  return Math.max(window.screen.width, window.screen.height) *
      window.devicePixelRatio;
};

Util.getScreenHeight = function() {
  return Math.min(window.screen.width, window.screen.height) *
      window.devicePixelRatio;
};

Util.requestFullscreen = function(element) {
  if (Util.isWebViewAndroid()) {
      return false;
  }
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element.webkitRequestFullscreen) {
    element.webkitRequestFullscreen();
  } else if (element.mozRequestFullScreen) {
    element.mozRequestFullScreen();
  } else if (element.msRequestFullscreen) {
    element.msRequestFullscreen();
  } else {
    return false;
  }

  return true;
};

Util.exitFullscreen = function() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen();
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen();
  } else {
    return false;
  }

  return true;
};

Util.getFullscreenElement = function() {
  return document.fullscreenElement ||
      document.webkitFullscreenElement ||
      document.mozFullScreenElement ||
      document.msFullscreenElement;
};

Util.linkProgram = function(gl, vertexSource, fragmentSource, attribLocationMap) {
  // No error checking for brevity.
  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertexShader, vertexSource);
  gl.compileShader(vertexShader);

  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragmentShader, fragmentSource);
  gl.compileShader(fragmentShader);

  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);

  for (var attribName in attribLocationMap)
    gl.bindAttribLocation(program, attribLocationMap[attribName], attribName);

  gl.linkProgram(program);

  gl.deleteShader(vertexShader);
  gl.deleteShader(fragmentShader);

  return program;
};

Util.getProgramUniforms = function(gl, program) {
  var uniforms = {};
  var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  var uniformName = '';
  for (var i = 0; i < uniformCount; i++) {
    var uniformInfo = gl.getActiveUniform(program, i);
    uniformName = uniformInfo.name.replace('[0]', '');
    uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
  }
  return uniforms;
};

Util.orthoMatrix = function (out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right),
      bt = 1 / (bottom - top),
      nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
};

Util.copyArray = function (source, dest) {
  for (var i = 0, n = source.length; i < n; i++) {
    dest[i] = source[i];
  }
};

Util.isMobile = function() {
  var check = false;
  (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true})(navigator.userAgent||navigator.vendor||window.opera);
  return check;
};

Util.extend = function(dest, src) {
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      dest[key] = src[key];
    }
  }

  return dest;
}

Util.safariCssSizeWorkaround = function(canvas) {
  // TODO(smus): Remove this workaround when Safari for iOS is fixed.
  // iOS only workaround (for https://bugs.webkit.org/show_bug.cgi?id=152556).
  //
  // "To the last I grapple with thee;
  //  from hell's heart I stab at thee;
  //  for hate's sake I spit my last breath at thee."
  // -- Moby Dick, by Herman Melville
  if (Util.isIOS()) {
    var width = canvas.style.width;
    var height = canvas.style.height;
    canvas.style.width = (parseInt(width) + 1) + 'px';
    canvas.style.height = (parseInt(height)) + 'px';
    setTimeout(function() {
      canvas.style.width = width;
      canvas.style.height = height;
    }, 100);
  }

  // Debug only.
  window.Util = Util;
  window.canvas = canvas;
};

Util.isDebug = function() {
  return Util.getQueryParameter('debug');
};

Util.getQueryParameter = function(name) {
  var name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
  var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
      results = regex.exec(location.search);
  return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
};

Util.frameDataFromPose = (function() {
  var piOver180 = Math.PI / 180.0;
  var rad45 = Math.PI * 0.25;

  // Borrowed from glMatrix.
  function mat4_perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov ? (fov.upDegrees * piOver180) : rad45),
    downTan = Math.tan(fov ? (fov.downDegrees * piOver180) : rad45),
    leftTan = Math.tan(fov ? (fov.leftDegrees * piOver180) : rad45),
    rightTan = Math.tan(fov ? (fov.rightDegrees * piOver180) : rad45),
    xScale = 2.0 / (leftTan + rightTan),
    yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
  }

  function mat4_fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
  };

  function mat4_translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
      a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
      a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

      out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
      out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
      out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
  };

  function mat4_invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
  };

  var defaultOrientation = new Float32Array([0, 0, 0, 1]);
  var defaultPosition = new Float32Array([0, 0, 0]);

  function updateEyeMatrices(projection, view, pose, parameters, vrDisplay) {
    mat4_perspectiveFromFieldOfView(projection, parameters ? parameters.fieldOfView : null, vrDisplay.depthNear, vrDisplay.depthFar);

    var orientation = pose.orientation || defaultOrientation;
    var position = pose.position || defaultPosition;

    mat4_fromRotationTranslation(view, orientation, position);
    if (parameters)
      mat4_translate(view, view, parameters.offset);
    mat4_invert(view, view);
  }

  return function(frameData, pose, vrDisplay) {
    if (!frameData || !pose)
      return false;

    frameData.pose = pose;
    frameData.timestamp = pose.timestamp;

    updateEyeMatrices(
        frameData.leftProjectionMatrix, frameData.leftViewMatrix,
        pose, vrDisplay.getEyeParameters("left"), vrDisplay);
    updateEyeMatrices(
        frameData.rightProjectionMatrix, frameData.rightViewMatrix,
        pose, vrDisplay.getEyeParameters("right"), vrDisplay);

    return true;
  };
})();

Util.isInsideCrossDomainIFrame = function() {
  var isFramed = (window.self !== window.top);
  var refDomain = Util.getDomainFromUrl(document.referrer);
  var thisDomain = Util.getDomainFromUrl(window.location.href);

  return isFramed && (refDomain !== thisDomain);
};

// From http://stackoverflow.com/a/23945027.
Util.getDomainFromUrl = function(url) {
  var domain;
  // Find & remove protocol (http, ftp, etc.) and get domain.
  if (url.indexOf("://") > -1) {
    domain = url.split('/')[2];
  }
  else {
    domain = url.split('/')[0];
  }

  //find & remove port number
  domain = domain.split(':')[0];

  return domain;
}

module.exports = Util;


/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_11__;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Renderer = function Renderer() {
	_classCallCheck(this, Renderer);
};

exports["default"] = Renderer;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _consts = __webpack_require__(8);

var ERROR_TYPE = {
	INVALID_DEVICE: 10,
	NO_WEBGL: 11,
	FAIL_IMAGE_LOAD: 12,
	FAIL_BIND_TEXTURE: 13,
	INVALID_RESOURCE: 14,
	RENDERING_CONTEXT_LOST: 15
};

var EVENTS = {
	READY: "ready",
	VIEW_CHANGE: "viewChange",
	ANIMATION_END: "animationEnd",
	ERROR: "error"
};

var PROJECTION_TYPE = {
	EQUIRECTANGULAR: "equirectangular",
	CUBEMAP: "cubemap"
};

module.exports = {
	GYRO_MODE: _consts.GYRO_MODE,
	EVENTS: EVENTS,
	ERROR_TYPE: ERROR_TYPE,
	PROJECTION_TYPE: PROJECTION_TYPE
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class eg.view360.SpriteImage
 * @classdesc A module that displays a single or continuous image of any one of the "sprite images". SpinViewer internally uses SpriteImage to show each frame of the sprite image.
 * @ko 스프라이트 이미지 중 임의의 한 프레임을 단발성 혹은 연속적으로 보여주는 컴포넌트입니다. SpinViewer 는 내부적으로 SpriteImage 를 사용하여 스프라이트 이미지의 각 프레임을 보여줍니다.
 * @extends eg.Component
 *
 * @param {HTMLElement} element The element to show the image <ko>이미지를 보여줄 대상 요소</ko>
 * @param {Object} options The option object<ko>파라미터 객체</ko>
 * @param {String} options.imageUrl The url of the sprite image <ko>스프라이트 이미지의 url</ko>
 * @param {Number} [options.rowCount=1] Number of horizontal frames in the sprite image <ko>스프라이트 이미지의 가로 프레임 갯수</ko>
 * @param {Number} [options.colCount=1] Number of vertical frames in the sprite image <ko>스프라이트 이미지의 세로 프레임 갯수</ko>
 * @param {Number|String} [options.width="auto"] The width of the target element to show the image <ko>이미지를 보여줄 대상 요소의 너비</ko>
 * @param {Number|String} [options.height="auto"] The height of the target element to show the image <ko>이미지를 보여줄 대상 요소의 높이</ko>
 * @param {Boolean} [options.autoHeight=true] Whether to automatically set the height of the image area to match the original image's proportion <ko>원본 이미지 비율에 맞게 이미지 영역의 높이를 자동으로 설정할지 여부</ko>
 * @param {Number[]} [options.colRow=[0, 0]] The column, row coordinates of the first frame of the sprite image (based on 0 index) <ko> 스프라이트 이미지 중 처음 보여줄 프레임의 (column, row) 좌표 (0 index 기반)</ko>
 * @param {Number} [options.frameIndex=0] frameIndex specifies the index of the frame to be displayed in the "Sprite image". The frameIndex order is zero-based and indexed in Z form (left-to-right, top-to-bottom, and newline again from left to right).<br>- colRow is equivalent to frameIndex. However, if colRow is specified at the same time, colRow takes precedence.<ko>스프라이트 이미지 중에서 보여질 프레임의 인덱스를 지정합니다. frameIndex 순서는 0부터 시작하며 Z 형태(왼쪽에서 오른쪽, 위에서 아래, 개행 시 다시 왼쪽 부터)로 인덱싱합니다.<br>- colRow 는 frameIndex 와 동일한 기능을 합니다. 단, colRow 가 동시에 지정된 경우 colRow 가 우선합니다.</ko>
 * @param {Number} [options.scale=1] Spin scale (The larger the spin, the more).<ko>Spin 배율 (클 수록 더 많이 움직임)</ko>
 *
 * @support {"ie": "9+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.3+ (except 3.x)"}
 * @example
 *
 * // Initialize SpriteImage
 *
 * var el = document.getElementById("image-div");
 * var sprites = new eg.view360.SpriteImage(el, {
 * 	imageUrl: "/img/bag360.jpg", // required
 * 	rowCount: 24
 * });
 */
var SpriteImage = function (_Component) {
	_inherits(SpriteImage, _Component);

	function SpriteImage(element, options) {
		_classCallCheck(this, SpriteImage);

		var _this = _possibleConstructorReturn(this, _Component.call(this));

		var opt = options || {};

		_this._el = element;
		_this._rowCount = opt.rowCount || 1;
		_this._colCount = opt.colCount || 1;
		_this._totalCount = _this._rowCount * _this._colCount; // total frames
		_this._width = opt.width || "auto";
		_this._height = opt.height || "auto";
		_this._autoHeight = opt.autoHeight != null ? opt.autoHeight : "true"; // If autoHeight is specified, _height will be overwritten.
		_this._colRow = [0, 0];

		if (opt.colRow) {
			_this._colRow = opt.colRow;
		} else if (opt.frameIndex) {
			_this.setFrameIndex(opt.frameIndex);
		}

		_this._el.style.width = SpriteImage._getSizeString(_this._width);
		_this._el.style.height = SpriteImage._getSizeString(_this._height);

		if (!opt.imageUrl) {
			setTimeout(function () {
				_this.trigger("imageError", {
					imageUrl: opt.imageUrl
				});
			}, 0);
			return _possibleConstructorReturn(_this);
		}

		_this._image = new Image();
		/**
   * Event
   */
		_this._image.onload = function () {
			_this._bg = SpriteImage._createBgDiv(_this._image, _this._rowCount, _this._colCount, _this._autoHeight);
			_this._el.appendChild(_this._bg);
			_this.setColRow(_this._colRow[0], _this._colRow[1]);

			/**
    * Events that occur when component loading is complete
    * @ko 컴포넌트 로딩이 완료되면 발생하는 이벤트
    * @name eg.view360.SpriteImage#load
    * @event
    * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
    * @param {HTMLElement} param.target The target element for which to display the image <ko>이미지를 보여줄 대상 엘리먼트</ko>
    * @param {HTMLElement} param.bgElement Generated background image element <ko>생성된 background 이미지 엘리먼트</ko>
    *
    * @example
    *
    * sprites.on({
    *	"load" : function(evt) {
    *		console.log("load event fired - e.target", e.target, "e.bgElement", e.bgElement);
    *	}
    * });
    */
			_this.trigger("load", {
				target: _this._el,
				bgElement: _this._bg
			});

			if (_this._autoPlayReservedInfo) {
				_this.play(_this._autoPlayReservedInfo);
				_this._autoPlayReservedInfo = null;
			}
		};

		_this._image.onerror = function (e) {
			/**
    * An event that occurs when the image index is changed by the user's left / right panning
    * @ko 사용자의 좌우 Panning 에 의해 이미지 인덱스가 변경되었을때 발생하는 이벤트
    * @name eg.view360.SpriteImage#imageError
    * @event
    * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
    * @param {String} param.imageUrl User-specified image URL <ko>사용자가 지정한 이미지 URL</ko>
    *
    * @example
    *
    * sprites.on({
    *	"imageError" : function(evt) {
    *		// Error handling
    *		console.log(e.imageUrl);
    *	}
    * });
    */
			_this.trigger("imageError", {
				imageUrl: opt.imageUrl
			});
		};

		_this._image.src = opt.imageUrl;
		return _this;
	}

	SpriteImage._createBgDiv = function _createBgDiv(img, rowCount, colCount, autoHeight) {
		var el = document.createElement("div");

		el.style.backgroundImage = "url(" + img.src + ")";
		el.style.backgroundSize = colCount * 100 + "% " + rowCount * 100 + "%";

		var unitWidth = img.width / colCount;
		var unitHeight = img.height / rowCount;

		if (autoHeight) {
			var r = unitHeight / unitWidth;

			el.style.paddingBottom = r * 100 + "%";
		} else {
			el.style.height = "100%";
		}

		return el;
	};

	/**
  * Specifies the frameIndex of the frame to be shown in the sprite image.
  * @ko 스프라이트 이미지 중 보여질 프레임의 frameIndex 값을 지정
  * @method eg.view360.SpriteImage#setFrameIndex
  * @param {Number} frameIndex frame index of a frame<ko>프레임의 인덱스</ko>
  *
  * @example
  *
  * sprites.setFrameIndex(0, 1);// col = 0, row = 1
  */


	SpriteImage.prototype.setFrameIndex = function setFrameIndex(index) {
		var colRow = this.toColRow(index);

		this.setColRow(colRow[0], colRow[1]);
	};

	/**
  * Returns the frameIndex of the frame to be shown in the sprite image.
  * @ko 스프라이트 이미지 중 보여지는 프레임의 index 값을 반환
  * @method eg.view360.SpriteImage#getFrameIndex
  * @return {Number} frame index <ko>frame 인덱스</ko>
  *
  * @example
  *
  * var frameIndex = sprites.getFrameIndex(); // eg. frameIndex = 1
  *
  */


	SpriteImage.prototype.getFrameIndex = function getFrameIndex() {
		return this._colRow[1] * this._colCount + this._colRow[0];
	};

	/**
  * Specifies the col and row values of the frame to be shown in the sprite image.
  * @ko 스프라이트 이미지 중 보여질 프레임의 col, row 값을 지정
  * @method eg.view360.SpriteImage#setColRow
  * @param {Number} col Column number of a frame<ko>프레임의 행값</ko>
  * @param {Number} row Row number of a frame<ko>프레임의 열값</ko>
  *
  * @example
  *
  * sprites.setlColRow(1, 2); // col = 1, row = 2
  */


	SpriteImage.prototype.setColRow = function setColRow(col, row) {
		if (row > this._rowCount - 1 || col > this._colCount - 1) {
			return;
		}

		if (this._bg) {
			this._bg.style.backgroundPosition = -col * 100 + "% " + -row * 100 + "%";
		}

		this._colRow = [col, row];
	};

	/**
  * Returns the col and row values of the frame to be shown in the sprite image.
  * @ko 스프라이트 이미지 중 보여지는 프레임의 col, row 값을환반환
  * @method eg.view360.SpriteImage#gelColRow
  * @return {Number[]} Array containing col, row<ko>col, row 정보를 담는 배열</ko>
  *
  * @example
  *
  * var colRow = sprites.getlColRow();
  * // colRow = [1, 2] - index of col is 1, index of row is 2
  *
  */


	SpriteImage.prototype.getColRow = function getColRow() {
		return this._colRow;
	};

	SpriteImage._getSizeString = function _getSizeString(size) {
		if (typeof size === "number") {
			return size + "px";
		}

		return size;
	};

	/**
  * Stop playing
  * @ko play 되고 있던 프레임 재생을 중지합니다.
  * @method eg.view360.SpriteImage#stop
  *
  * @example
  *
  * viewer.stop();
  *
  */


	SpriteImage.prototype.stop = function stop() {
		if (this._autoPlayTimer) {
			clearInterval(this._autoPlayTimer);
			this._autoPlayTimer = null;
		}
	};

	/**
  * Switches frames sequentially in the 'interval' starting from the currently displayed frame and plays all frames by 'playCount'.
  * @ko 현재 보여지고 있는 프레임을 시작으로 'interval' 간격으로 순차적으로 프레임을 전환하며 모든 프레임을 'playCount' 만큼 재생한다.
  * @method eg.view360.SpriteImage#play
  * @param {Object} param The parameter object<ko>파라미터 객체</ko>
  * @param {Number} [param.interval=1000 / totalFrameCount] Interframe Interval - in milliseconds<ko>프레임간 간격 - 밀리세컨드 단위</ko>
  * @param {Number} [param.playCount=0] PlayCount = 1 in which all frames are reproduced once, and playCount = n in which all frames are repeated n times. playCount = 0 in which all frames are repeated infinitely<ko>모든 프레임을 1회씩 재생한 것이 playCount = 1, 모든 프레임을 n 회 재상한 것이 playCount = n 이 된다. 0 dms 무한반복</ko>
  *
  * @example
  *
  * viewer.play({angle: 16, playCount: 1});
  *
  */


	SpriteImage.prototype.play = function play() {
		var _this2 = this;

		var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { interval: 1000 / this._totalCount, playCount: 0 },
		    interval = _ref.interval,
		    playCount = _ref.playCount;

		if (!this._bg) {
			this._autoPlayReservedInfo = { interval: interval, playCount: playCount };
			return;
		}

		if (this._autoPlayTimer) {
			clearInterval(this._autoPlayTimer);
			this._autoPlayTimer = null;
		}

		var frameIndex = this.getFrameIndex();
		var count = 0;
		var frameCount = 0; // for checking 1 cycle

		this._autoPlayTimer = setInterval(function () {
			frameIndex %= _this2._totalCount;
			var colRow = _this2.toColRow(frameIndex);

			_this2.setColRow(colRow[0], colRow[1]);
			frameIndex++;

			// Done 1 Cycle?
			if (++frameCount === _this2._totalCount) {
				frameCount = 0;
				count++;
			}

			if (playCount > 0 && count === playCount) {
				clearInterval(_this2._autoPlayTimer);
			}
		}, interval);
	};

	SpriteImage.prototype.toColRow = function toColRow(frameIndex) {
		var colCount = this._colCount;
		var rowCount = this._rowCount;

		if (frameIndex < 0) {
			return [0, 0];
		} else if (frameIndex >= this._totalCount) {
			return [colCount - 1, rowCount - 1];
		}

		var col = frameIndex % colCount;
		var row = Math.floor(frameIndex / colCount);

		// console.log(frameIndex, col, row);
		return [col, row];
	};

	return SpriteImage;
}(_component2["default"]);

exports["default"] = SpriteImage;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _browser = __webpack_require__(3);

var _mathUtil = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Singleton
var screenRotationAngleInst = null;
var refCount = 0;

var ScreenRotationAngle = function () {
	function ScreenRotationAngle() {
		_classCallCheck(this, ScreenRotationAngle);

		refCount++;

		if (screenRotationAngleInst) {
			return screenRotationAngleInst;
		}
		/* eslint-disable */
		screenRotationAngleInst = this;
		/* eslint-enable */
		this._onDeviceOrientation = this._onDeviceOrientation.bind(this);
		this._onOrientationChange = this._onOrientationChange.bind(this);

		this._spinR = 0;

		this._screenOrientationAngle = 0;
		_browser.window.addEventListener("deviceorientation", this._onDeviceOrientation);
		_browser.window.addEventListener("orientationchange", this._onOrientationChange);
	}

	ScreenRotationAngle.prototype._onDeviceOrientation = function _onDeviceOrientation(e) {
		if (e.beta === null || e.gamma === null) {
			// (Chrome) deviceorientation is fired with invalid information {alpha=null, beta=null, ...} despite of not dispatching it. We skip it.
			return;
		}

		// Radian
		var betaR = _mathUtil.glMatrix.toRadian(e.beta);
		var gammaR = _mathUtil.glMatrix.toRadian(e.gamma);

		/* spinR range = [-180, 180], left side: 0 ~ -180(deg), right side: 0 ~ 180(deg) */
		this._spinR = Math.atan2(Math.cos(betaR) * Math.sin(gammaR), Math.sin(betaR));
	};

	ScreenRotationAngle.prototype._onOrientationChange = function _onOrientationChange(e) {
		if (_browser.screen && _browser.screen.orientation && _browser.screen.orientation.angle !== undefined) {
			this._screenOrientationAngle = _browser.screen.orientation.angle;
		} else if (_browser.orientation !== undefined) {
			this._screenOrientationAngle = _browser.orientation >= 0 ? _browser.orientation : 360 + _browser.orientation;
		}
	};

	ScreenRotationAngle.prototype.getRadian = function getRadian() {
		// Join with screen orientation
		// this._testVal = this._spinR + ", " + this._screenOrientationAngle + ", " + window.orientation;
		return this._spinR + _mathUtil.glMatrix.toRadian(this._screenOrientationAngle);
	};

	ScreenRotationAngle.prototype.unref = function unref() {
		if (--refCount > 0) {
			return;
		}

		_browser.window.removeEventListener("deviceorientation", this._onDeviceOrientation);
		_browser.window.removeEventListener("orientationchange", this._onOrientationChange);

		this._spinR = 0;
		this._screenOrientationAngle = 0;
		/* eslint-disable */
		screenRotationAngleInst = null;
		/* eslint-enable */
		refCount = 0;
	};

	return ScreenRotationAngle;
}();

exports["default"] = ScreenRotationAngle;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.YawPitchControl = undefined;

var _YawPitchControl = __webpack_require__(35);

var _YawPitchControl2 = _interopRequireDefault(_YawPitchControl);

var _consts = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// Expose DeviceOrientationControls sub module for test purpose
_YawPitchControl2["default"].CONTROL_MODE_VR = _consts.CONTROL_MODE_VR;
_YawPitchControl2["default"].CONTROL_MODE_YAWPITCH = _consts.CONTROL_MODE_YAWPITCH;
_YawPitchControl2["default"].TOUCH_DIRECTION_ALL = _consts.TOUCH_DIRECTION_ALL;
_YawPitchControl2["default"].TOUCH_DIRECTION_YAW = _consts.TOUCH_DIRECTION_YAW;
_YawPitchControl2["default"].TOUCH_DIRECTION_PITCH = _consts.TOUCH_DIRECTION_PITCH;
_YawPitchControl2["default"].TOUCH_DIRECTION_NONE = _consts.TOUCH_DIRECTION_NONE;

// module.exports = YawPitch;
exports.YawPitchControl = _YawPitchControl2["default"];

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

var _posePredictor = __webpack_require__(66);

var _posePredictor2 = _interopRequireDefault(_posePredictor);

var _mathUtil = __webpack_require__(6);

var _mathUtil2 = _interopRequireDefault(_mathUtil);

var _util = __webpack_require__(10);

var _util2 = _interopRequireDefault(_util);

var _browser = __webpack_require__(3);

var _mathUtil3 = __webpack_require__(1);

var _DeviceMotion = __webpack_require__(37);

var _DeviceMotion2 = _interopRequireDefault(_DeviceMotion);

var _ComplementaryFilter = __webpack_require__(36);

var _ComplementaryFilter2 = _interopRequireDefault(_ComplementaryFilter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var K_FILTER = 0.98;
var PREDICTION_TIME_S = 0.040;

var FusionPoseSensor = function (_Component) {
	_inherits(FusionPoseSensor, _Component);

	function FusionPoseSensor() {
		_classCallCheck(this, FusionPoseSensor);

		var _this = _possibleConstructorReturn(this, _Component.call(this));

		_this.deviceMotion = new _DeviceMotion2["default"]();

		_this.accelerometer = new _mathUtil2["default"].Vector3();
		_this.gyroscope = new _mathUtil2["default"].Vector3();

		_this._onDeviceMotionChange = _this._onDeviceMotionChange.bind(_this);
		_this._onScreenOrientationChange = _this._onScreenOrientationChange.bind(_this);

		_this.filter = new _ComplementaryFilter2["default"](K_FILTER);
		_this.posePredictor = new _posePredictor2["default"](PREDICTION_TIME_S);

		_this.filterToWorldQ = new _mathUtil2["default"].Quaternion();

		_this.isFirefoxAndroid = _util2["default"].isFirefoxAndroid();
		_this.isIOS = _util2["default"].isIOS();
		_this._isEnabled = false;

		// Set the filter to world transform, depending on OS.
		if (_this.isIOS) {
			_this.filterToWorldQ.setFromAxisAngle(new _mathUtil2["default"].Vector3(1, 0, 0), Math.PI / 2);
		} else {
			_this.filterToWorldQ.setFromAxisAngle(new _mathUtil2["default"].Vector3(1, 0, 0), -Math.PI / 2);
		}

		_this.inverseWorldToScreenQ = new _mathUtil2["default"].Quaternion();
		_this.worldToScreenQ = new _mathUtil2["default"].Quaternion();
		_this.originalPoseAdjustQ = new _mathUtil2["default"].Quaternion();
		_this.originalPoseAdjustQ.setFromAxisAngle(new _mathUtil2["default"].Vector3(0, 0, 1), -_browser.window.orientation * Math.PI / 180);

		_this._setScreenTransform();
		// Adjust this filter for being in landscape mode.
		if (_util2["default"].isLandscapeMode()) {
			_this.filterToWorldQ.multiply(_this.inverseWorldToScreenQ);
		}

		// Keep track of a reset transform for resetSensor.
		_this.resetQ = new _mathUtil2["default"].Quaternion();

		_this.deviceMotion.on("devicemotion", _this._onDeviceMotionChange);
		_this.enable();
		return _this;
	}

	FusionPoseSensor.prototype.enable = function enable() {
		if (this.isEnabled()) {
			return;
		}
		this.deviceMotion.enable();
		this._isEnabled = true;
		_browser.window.addEventListener("orientationchange", this._onScreenOrientationChange);
	};

	FusionPoseSensor.prototype.disable = function disable() {
		if (!this.isEnabled()) {
			return;
		}
		this.deviceMotion.disable();
		this._isEnabled = false;
		_browser.window.removeEventListener("orientationchange", this._onScreenOrientationChange);
	};

	FusionPoseSensor.prototype.isEnabled = function isEnabled() {
		return this._isEnabled;
	};

	FusionPoseSensor.prototype.destroy = function destroy() {
		this.disable();
		this.deviceMotion = null;
	};

	FusionPoseSensor.prototype._triggerChange = function _triggerChange() {
		var orientation = this.getOrientation();

		// if orientation is not prepared. don't trigger change event
		if (!orientation) {
			return;
		}

		if (!this._prevOrientation) {
			this._prevOrientation = orientation;
			return;
		}

		if (_mathUtil3.quat.equals(this._prevOrientation, orientation)) {
			return;
		}

		this.trigger("change", { quaternion: orientation });
	};

	FusionPoseSensor.prototype.getOrientation = function getOrientation() {
		// Convert from filter space to the the same system used by the
		// deviceorientation event.
		var orientation = this.filter.getOrientation();

		if (!orientation) {
			return null;
		}

		// Predict orientation.
		var out = this._convertFusionToPredicted(orientation);

		// return quaternion as glmatrix quaternion object
		out = _mathUtil3.quat.fromValues(out.x, out.y, out.z, out.w);

		return _mathUtil3.quat.normalize(out, out);
	};

	FusionPoseSensor.prototype._convertFusionToPredicted = function _convertFusionToPredicted(orientation) {
		// Predict orientation.
		this.predictedQ = this.posePredictor.getPrediction(orientation, this.gyroscope, this.previousTimestampS);

		// Convert to THREE coordinate system: -Z forward, Y up, X right.
		var out = new _mathUtil2["default"].Quaternion();

		out.copy(this.filterToWorldQ);
		out.multiply(this.resetQ);
		out.multiply(this.predictedQ);
		out.multiply(this.worldToScreenQ);

		return out;
	};

	FusionPoseSensor.prototype._onDeviceMotionChange = function _onDeviceMotionChange(_ref) {
		var inputEvent = _ref.inputEvent;

		var deviceMotion = inputEvent;
		var accGravity = deviceMotion.accelerationIncludingGravity;
		var rotRate = deviceMotion.adjustedRotationRate || deviceMotion.rotationRate;
		var timestampS = deviceMotion.timeStamp / 1000;

		// Firefox Android timeStamp returns one thousandth of a millisecond.
		if (this.isFirefoxAndroid) {
			timestampS /= 1000;
		}

		this.accelerometer.set(-accGravity.x, -accGravity.y, -accGravity.z);
		this.gyroscope.set(rotRate.alpha, rotRate.beta, rotRate.gamma);

		// With iOS and Firefox Android, rotationRate is reported in degrees,
		// so we first convert to radians.
		if (this.isIOS || this.isFirefoxAndroid) {
			this.gyroscope.multiplyScalar(Math.PI / 180);
		}

		this.filter.addAccelMeasurement(this.accelerometer, timestampS);
		this.filter.addGyroMeasurement(this.gyroscope, timestampS);

		this._triggerChange();

		this.previousTimestampS = timestampS;
	};

	FusionPoseSensor.prototype._onScreenOrientationChange = function _onScreenOrientationChange(screenOrientation) {
		this._setScreenTransform(_browser.window.orientation);
	};

	FusionPoseSensor.prototype._setScreenTransform = function _setScreenTransform() {
		this.worldToScreenQ.set(0, 0, 0, 1);
		switch (_browser.window.orientation) {
			case 0:
				break;
			case 90:
				this.worldToScreenQ.setFromAxisAngle(new _mathUtil2["default"].Vector3(0, 0, 1), 90 / -180 * Math.PI);
				break;
			case -90:
				this.worldToScreenQ.setFromAxisAngle(new _mathUtil2["default"].Vector3(0, 0, 1), -90 / -180 * Math.PI);
				break;
			case 180:
				this.worldToScreenQ.setFromAxisAngle(new _mathUtil2["default"].Vector3(0, 0, 1), 180 / -180 * Math.PI);
				break;
			default:
				break;
		}
		this.inverseWorldToScreenQ.copy(this.worldToScreenQ);
		this.inverseWorldToScreenQ.inverse();
	};

	return FusionPoseSensor;
}(_component2["default"]);

exports["default"] = FusionPoseSensor;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var util = {};

function toAxis(source, offset) {
	return offset.reduce(function (acc, v, i) {
		if (source[i]) {
			acc[source[i]] = v;
		}
		return acc;
	}, {});
}

util.toAxis = toAxis;

exports["default"] = util;
exports.toAxis = toAxis;

/***/ }),
/* 19 */
/***/ (function(module, exports) {

var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];

var alphaIndex = {};
var charIndex = {};

createIndexes(alphaIndex, charIndex);

/**
 * @constructor
 */
function Html5Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1) === 'x' ?
                parseInt(entity.substr(2).toLowerCase(), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.decode = function(str) {
    return new Html5Entities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var charInfo = charIndex[str.charCodeAt(i)];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        result += str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encode = function(str) {
    return new Html5Entities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var charInfo = charIndex[c];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonUTF = function(str) {
    return new Html5Entities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonASCII = function(str) {
    return new Html5Entities().encodeNonASCII(str);
 };

/**
 * @param {Object} alphaIndex Passed by reference.
 * @param {Object} charIndex Passed by reference.
 */
function createIndexes(alphaIndex, charIndex) {
    var i = ENTITIES.length;
    var _results = [];
    while (i--) {
        var e = ENTITIES[i];
        var alpha = e[0];
        var chars = e[1];
        var chr = chars[0];
        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo;
        if (addChar) {
            charInfo = charIndex[chr] = charIndex[chr] || {};
        }
        if (chars[1]) {
            var chr2 = chars[1];
            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
            _results.push(addChar && (charInfo[chr2] = alpha));
        } else {
            alphaIndex[alpha] = String.fromCharCode(chr);
            _results.push(addChar && (charInfo[''] = alpha));
        }
    }
}

module.exports = Html5Entities;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.VERSION = exports.SpriteImage = exports.SpinViewer = exports.PanoViewer = exports.YawPitchControl = undefined;

var _YawPitchControl = __webpack_require__(16);

var _PanoViewer = __webpack_require__(31);

var _SpinViewer = __webpack_require__(33);

var VERSION = "3.0.0-rc";

exports.YawPitchControl = _YawPitchControl.YawPitchControl;
exports.PanoViewer = _PanoViewer.PanoViewer;
exports.SpinViewer = _SpinViewer.SpinViewer;
exports.SpriteImage = _SpinViewer.SpriteImage;
exports.VERSION = VERSION;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__resourceQuery) {

/* global __resourceQuery WorkerGlobalScope self */
/* eslint prefer-destructuring: off */

var url = __webpack_require__(59);
var stripAnsi = __webpack_require__(58);
var log = __webpack_require__(51).getLogger('webpack-dev-server');
var socket = __webpack_require__(62);
var overlay = __webpack_require__(61);

function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute('src');
  }
  // Fall back to getting all scripts in the document.
  var scriptElements = document.scripts || [];
  var currentScript = scriptElements[scriptElements.length - 1];
  if (currentScript) {
    return currentScript.getAttribute('src');
  }
  // Fail as there was no script to use.
  throw new Error('[WDS] Failed to get current script source.');
}

var urlParts = void 0;
var hotReload = true;
if (typeof window !== 'undefined') {
  var qs = window.location.search.toLowerCase();
  hotReload = qs.indexOf('hotreload=false') === -1;
}
if (true) {
  // If this bundle is inlined, use the resource query to get the correct url.
  urlParts = url.parse(__resourceQuery.substr(1));
} else {
  // Else, get the url from the <script> this file was called with.
  var scriptHost = getCurrentScriptSource();
  // eslint-disable-next-line no-useless-escape
  scriptHost = scriptHost.replace(/\/[^\/]+$/, '');
  urlParts = url.parse(scriptHost || '/', false, true);
}

if (!urlParts.port || urlParts.port === '0') {
  urlParts.port = self.location.port;
}

var _hot = false;
var initial = true;
var currentHash = '';
var useWarningOverlay = false;
var useErrorOverlay = false;
var useProgress = false;

var INFO = 'info';
var WARNING = 'warning';
var ERROR = 'error';
var NONE = 'none';

// Set the default log level
log.setDefaultLevel(INFO);

// Send messages to the outside, so plugins can consume it.
function sendMsg(type, data) {
  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: 'webpack' + type,
      data: data
    }, '*');
  }
}

var onSocketMsg = {
  hot: function hot() {
    _hot = true;
    log.info('[WDS] Hot Module Replacement enabled.');
  },
  invalid: function invalid() {
    log.info('[WDS] App updated. Recompiling...');
    // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.
    if (useWarningOverlay || useErrorOverlay) overlay.clear();
    sendMsg('Invalid');
  },
  hash: function hash(_hash) {
    currentHash = _hash;
  },

  'still-ok': function stillOk() {
    log.info('[WDS] Nothing changed.');
    if (useWarningOverlay || useErrorOverlay) overlay.clear();
    sendMsg('StillOk');
  },
  'log-level': function logLevel(level) {
    var hotCtx = __webpack_require__(68);
    if (hotCtx.keys().indexOf('./log') !== -1) {
      hotCtx('./log').setLogLevel(level);
    }
    switch (level) {
      case INFO:
      case ERROR:
        log.setLevel(level);
        break;
      case WARNING:
        // loglevel's warning name is different from webpack's
        log.setLevel('warn');
        break;
      case NONE:
        log.disableAll();
        break;
      default:
        log.error('[WDS] Unknown clientLogLevel \'' + level + '\'');
    }
  },
  overlay: function overlay(value) {
    if (typeof document !== 'undefined') {
      if (typeof value === 'boolean') {
        useWarningOverlay = false;
        useErrorOverlay = value;
      } else if (value) {
        useWarningOverlay = value.warnings;
        useErrorOverlay = value.errors;
      }
    }
  },
  progress: function progress(_progress) {
    if (typeof document !== 'undefined') {
      useProgress = _progress;
    }
  },

  'progress-update': function progressUpdate(data) {
    if (useProgress) log.info('[WDS] ' + data.percent + '% - ' + data.msg + '.');
  },
  ok: function ok() {
    sendMsg('Ok');
    if (useWarningOverlay || useErrorOverlay) overlay.clear();
    if (initial) return initial = false; // eslint-disable-line no-return-assign
    reloadApp();
  },

  'content-changed': function contentChanged() {
    log.info('[WDS] Content base changed. Reloading...');
    self.location.reload();
  },
  warnings: function warnings(_warnings) {
    log.warn('[WDS] Warnings while compiling.');
    var strippedWarnings = _warnings.map(function (warning) {
      return stripAnsi(warning);
    });
    sendMsg('Warnings', strippedWarnings);
    for (var i = 0; i < strippedWarnings.length; i++) {
      log.warn(strippedWarnings[i]);
    }
    if (useWarningOverlay) overlay.showMessage(_warnings);

    if (initial) return initial = false; // eslint-disable-line no-return-assign
    reloadApp();
  },
  errors: function errors(_errors) {
    log.error('[WDS] Errors while compiling. Reload prevented.');
    var strippedErrors = _errors.map(function (error) {
      return stripAnsi(error);
    });
    sendMsg('Errors', strippedErrors);
    for (var i = 0; i < strippedErrors.length; i++) {
      log.error(strippedErrors[i]);
    }
    if (useErrorOverlay) overlay.showMessage(_errors);
  },
  error: function error(_error) {
    log.error(_error);
  },
  close: function close() {
    log.error('[WDS] Disconnected!');
    sendMsg('Close');
  }
};

var hostname = urlParts.hostname;
var protocol = urlParts.protocol;

// check ipv4 and ipv6 `all hostname`
if (hostname === '0.0.0.0' || hostname === '::') {
  // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384
  // eslint-disable-next-line no-bitwise
  if (self.location.hostname && !!~self.location.protocol.indexOf('http')) {
    hostname = self.location.hostname;
  }
}

// `hostname` can be empty when the script path is relative. In that case, specifying
// a protocol would result in an invalid URL.
// When https is used in the app, secure websockets are always necessary
// because the browser doesn't accept non-secure websockets.
if (hostname && (self.location.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {
  protocol = self.location.protocol;
}

var socketUrl = url.format({
  protocol: protocol,
  auth: urlParts.auth,
  hostname: hostname,
  port: urlParts.port,
  pathname: urlParts.path == null || urlParts.path === '/' ? '/sockjs-node' : urlParts.path
});

socket(socketUrl, onSocketMsg);

var isUnloading = false;
self.addEventListener('beforeunload', function () {
  isUnloading = true;
});

function reloadApp() {
  if (isUnloading || !hotReload) {
    return;
  }
  if (_hot) {
    log.info('[WDS] App hot update...');
    // eslint-disable-next-line global-require
    var hotEmitter = __webpack_require__(64);
    hotEmitter.emit('webpackHotUpdate', currentHash);
    if (typeof self !== 'undefined' && self.window) {
      // broadcast update to window
      self.postMessage('webpackHotUpdate' + currentHash, '*');
    }
  } else {
    var rootWindow = self;
    // use parent window for reload (in case we're in an iframe with no valid src)
    var intervalId = self.setInterval(function () {
      if (rootWindow.location.protocol !== 'about:') {
        // reload immediately if protocol is valid
        applyReload(rootWindow, intervalId);
      } else {
        rootWindow = rootWindow.parent;
        if (rootWindow.parent === rootWindow) {
          // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
          applyReload(rootWindow, intervalId);
        }
      }
    });
  }

  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    log.info('[WDS] App updated. Reloading...');
    rootWindow.location.reload();
  }
}
/* WEBPACK VAR INJECTION */}.call(exports, "?http://10.66.100.56:8080"))

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Promise = typeof Promise === 'undefined' ? __webpack_require__(5).Promise : Promise;

var STATUS = {
	"NONE": 0,
	"LOADING": 1,
	"LOADED": 2,
	"ERROR": 3
};

var EVENT = {
	"READYSTATECHANGE": "readystatechange"
};

var ImageLoader = function (_Component) {
	_inherits(ImageLoader, _Component);

	function ImageLoader(image) {
		_classCallCheck(this, ImageLoader);

		var _this = _possibleConstructorReturn(this, _Component.call(this));
		// Super constructor


		_this._image = null;
		_this._onceHandlers = [];
		_this._loadStatus = STATUS.NONE;

		image && _this.set(image);
		return _this;
	}

	ImageLoader.prototype.get = function get() {
		var _this2 = this;

		return new _Promise(function (res, rej) {
			if (!_this2._image) {
				rej("ImageLoader: image is not defiend");
			} else if (_this2._loadStatus === STATUS.LOADED) {
				res(_this2.getElement());
			} else if (_this2._loadStatus === STATUS.LOADING) {
				/* Check isMaybeLoaded() first because there may have
    	posibilities that image already loaded before get is called.
    	for example calling get on external image onload callback.*/
				if (ImageLoader.isMaybeLoaded(_this2._image)) {
					_this2._loadStatus = STATUS.LOADED;
					res(_this2.getElement());
				} else {
					_this2.on(EVENT.READYSTATECHANGE, function (e) {
						if (e.type === STATUS.LOADED) {
							res(_this2.getElement());
						} else {
							rej("ImageLoader: failed to load images.");
						}
					});
				}
			} else {
				rej("ImageLoader: failed to load images");
			}
		});
	};

	/**
  * @param image img element or img url or array of img element or array of img url
  */


	ImageLoader.prototype.set = function set(image) {
		var _this3 = this;

		this._loadStatus = STATUS.LOADING;

		this._image = ImageLoader.createElement(image);

		if (ImageLoader.isMaybeLoaded(this._image)) {
			this._loadStatus = STATUS.LOADED;
			return;
		}

		this.onceLoaded(this._image, function () {
			_this3._loadStatus = STATUS.LOADED;
			_this3.trigger(EVENT.READYSTATECHANGE, {
				type: STATUS.LOADED
			});
		}, function () {
			_this3._loadStatus = STATUS.ERROR;
			_this3.trigger(EVENT.READYSTATECHANGE, {
				type: STATUS.ERROR
			});
		});
	};

	ImageLoader.createElement = function createElement(image) {
		var images = image instanceof Array ? image : [image];

		return images.map(function (img) {
			var _img = img;

			if (typeof img === "string") {
				_img = new Image();
				_img.crossOrigin = "anonymous";
				_img.src = img;
			}
			return _img;
		});
	};

	ImageLoader.prototype.getElement = function getElement() {
		return this._image.length === 1 ? this._image[0] : this._image;
	};

	ImageLoader.isMaybeLoaded = function isMaybeLoaded(image) {
		return image instanceof Image ? image.complete && image.naturalWidth !== 0 : !image.some(function (img) {
			return !img.complete || img.naturalWidth === 0;
		});
	};

	ImageLoader.prototype.onceLoaded = function onceLoaded(target, onload, onerror) {
		var _this4 = this;

		var targets = target instanceof Array ? target : [target];
		var targetsNotLoaded = targets.filter(function (img) {
			return !ImageLoader.isMaybeLoaded(img);
		});
		var loadPromises = targetsNotLoaded.map(function (img) {
			return new _Promise(function (res, rej) {
				_this4._once(img, "load", function () {
					return res(img);
				});
				_this4._once(img, "error", function () {
					return rej(img);
				});
			});
		});

		_Promise.all(loadPromises).then(function (result) {
			return onload(targets.length === 1 ? targets[0] : targets);
		}, function (reason) {
			return onerror(reason);
		});
	};

	ImageLoader.prototype._once = function _once(target, type, listener) {
		var fn = function fn(event) {
			target.removeEventListener(type, fn);
			listener(event);
		};

		target.addEventListener(type, fn);
		this._onceHandlers.push({ target: target, type: type, fn: fn });
	};

	ImageLoader.prototype.getStatus = function getStatus() {
		return this._loadStatus;
	};

	ImageLoader.prototype.destroy = function destroy() {
		this._onceHandlers.forEach(function (handler) {
			handler.target.removeEventListener(handler.type, handler.fn);
		});
		this._onceHandlers = [];
		this._image.src = "";
		this._image = null;
		this._loadStatus = STATUS.NONE;
	};

	return ImageLoader;
}(_component2["default"]);

exports["default"] = ImageLoader;


ImageLoader.STATUS = STATUS;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

var _ImageLoader = __webpack_require__(22);

var _ImageLoader2 = _interopRequireDefault(_ImageLoader);

var _VideoLoader = __webpack_require__(24);

var _VideoLoader2 = _interopRequireDefault(_VideoLoader);

var _WebGLUtils = __webpack_require__(7);

var _WebGLUtils2 = _interopRequireDefault(_WebGLUtils);

var _CubeRenderer = __webpack_require__(27);

var _CubeRenderer2 = _interopRequireDefault(_CubeRenderer);

var _SphereRenderer = __webpack_require__(28);

var _SphereRenderer2 = _interopRequireDefault(_SphereRenderer);

var _mathUtil = __webpack_require__(1);

var _browser = __webpack_require__(25);

var _consts = __webpack_require__(13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Promise = typeof Promise === 'undefined' ? __webpack_require__(5).Promise : Promise;

var ImageType = _consts.PROJECTION_TYPE;

var DEVICE_PIXEL_RATIO = _browser.devicePixelRatio || 1;

// DEVICE_PIXEL_RATIO 가 2를 초과하는 경우는 리소스 낭비이므로 2로 맞춘다.
if (DEVICE_PIXEL_RATIO > 2) {
	DEVICE_PIXEL_RATIO = 2;
}

// define custom events name
/**
 * TODO: how to manage events/errortype with PanoViewer
 *
 * I think renderer events should be seperated from viewer events although it has same name.
 */
var EVENTS = {
	BIND_TEXTURE: "bindTexture",
	IMAGE_LOADED: "imageLoaded",
	ERROR: "error",
	RENDERING_CONTEXT_LOST: "renderingContextLost",
	RENDERING_CONTEXT_RESTORE: "renderingContextRestore"
};

var ERROR_TYPE = {
	INVALID_DEVICE: 10,
	NO_WEBGL: 11,
	FAIL_IMAGE_LOAD: 12
};

var PanoImageRenderer = function (_Component) {
	_inherits(PanoImageRenderer, _Component);

	function PanoImageRenderer(image, width, height, isVideo, sphericalConfig, renderingContextAttributes) {
		_classCallCheck(this, PanoImageRenderer);

		var _this = _possibleConstructorReturn(this, _Component.call(this));
		// Super constructor


		_this.sphericalConfig = sphericalConfig;
		_this.fieldOfView = sphericalConfig.fieldOfView;

		_this.width = width;
		_this.height = height;

		_this._lastQuaternion = null;
		_this._lastYaw = null;
		_this._lastPitch = null;
		_this._lastFieldOfView = null;

		_this.pMatrix = _mathUtil.mat4.create();
		_this.mvMatrix = _mathUtil.mat4.create();

		// initialzie pMatrix
		_mathUtil.mat4.perspective(_this.pMatrix, _mathUtil.glMatrix.toRadian(_this.fieldOfView), width / height, 0.1, 100);

		_this.textureCoordBuffer = null;
		_this.vertexBuffer = null;
		_this.indexBuffer = null;
		_this.canvas = _this._initCanvas(width, height);
		_this._renderingContextAttributes = renderingContextAttributes;
		_this._image = null;
		_this._imageConfig = null;
		_this._imageIsReady = false;
		_this._shouldForceDraw = false;
		_this._keepUpdate = false; // Flag to specify 'continuous update' on video even when still.

		_this._onContentLoad = _this._onContentLoad.bind(_this);
		_this._onContentError = _this._onContentError.bind(_this);

		if (image) {
			_this.setImage({
				image: image,
				imageType: sphericalConfig.imageType,
				isVideo: isVideo,
				cubemapConfig: sphericalConfig.cubemapConfig
			});
		}
		return _this;
	}

	PanoImageRenderer.prototype.getContent = function getContent() {
		return this._image;
	};

	PanoImageRenderer.prototype.setImage = function setImage(_ref) {
		var image = _ref.image,
		    imageType = _ref.imageType,
		    _ref$isVideo = _ref.isVideo,
		    isVideo = _ref$isVideo === undefined ? false : _ref$isVideo,
		    cubemapConfig = _ref.cubemapConfig;

		this._imageIsReady = false;
		this._isVideo = isVideo;
		this._imageConfig = _extends({
			order: "RLUDBF",
			tileConfig: {
				flipHirozontal: false,
				rotation: 0
			}
		}, cubemapConfig);
		this._setImageType(imageType);

		if (this._contentLoader) {
			this._contentLoader.destroy();
		}

		if (isVideo) {
			this._contentLoader = new _VideoLoader2["default"]();
			this._keepUpdate = true;
		} else {
			this._contentLoader = new _ImageLoader2["default"]();
			this._keepUpdate = false;
		}

		// img element or img url
		this._contentLoader.set(image);

		// 이미지의 사이즈를 캐시한다.
		// image is reference for content in contentLoader, so it may be not valid if contentLoader is destroyed.
		this._image = this._contentLoader.getElement();

		return this._contentLoader.get().then(this._onContentLoad, this._onContentError)["catch"](function (e) {
			return setTimeout(function () {
				throw e;
			});
		}); // Prevent exceptions from being isolated in promise chain.
	};

	PanoImageRenderer.prototype._setImageType = function _setImageType(imageType) {
		if (!imageType || this._imageType === imageType) {
			return;
		}

		this._imageType = imageType;
		this._isCubeMap = imageType === ImageType.CUBEMAP;
		this._renderer = this._isCubeMap ? _CubeRenderer2["default"] : _SphereRenderer2["default"];
		this._initWebGL();
	};

	PanoImageRenderer.prototype._initCanvas = function _initCanvas(width, height) {
		var canvas = document.createElement("canvas");

		canvas.width = width;
		canvas.height = height;
		canvas.style.bottom = 0;
		canvas.style.left = 0;
		canvas.style.right = 0;
		canvas.style.top = 0;
		canvas.style.margin = "auto";
		canvas.style.maxHeight = "100%";
		canvas.style.maxWidth = "100%";
		canvas.style.outline = "none";
		canvas.style.position = "absolute";

		this._onWebglcontextlost = this._onWebglcontextlost.bind(this);
		this._onWebglcontextrestored = this._onWebglcontextrestored.bind(this);

		canvas.addEventListener("webglcontextlost", this._onWebglcontextlost);
		canvas.addEventListener("webglcontextrestored", this._onWebglcontextrestored);

		return canvas;
	};

	PanoImageRenderer.prototype._onContentError = function _onContentError(error) {
		this._imageIsReady = false;
		this._image = null;
		this.trigger(EVENTS.ERROR, {
			type: ERROR_TYPE.FAIL_IMAGE_LOAD,
			message: "failed to load image"
		});

		return false;
	};

	PanoImageRenderer.prototype._triggerContentLoad = function _triggerContentLoad() {
		this.trigger(EVENTS.IMAGE_LOADED, {
			content: this._image,
			isVideo: this._isVideo,
			projectionType: this._imageType
		});
	};

	PanoImageRenderer.prototype._onContentLoad = function _onContentLoad(image) {
		this._imageIsReady = true;

		this._triggerContentLoad();
		return true;
	};

	PanoImageRenderer.prototype.isImageLoaded = function isImageLoaded() {
		return !!this._image && this._imageIsReady && (!this._isVideo || this._image.readyState >= 2 /* HAVE_CURRENT_DATA */);
	};

	PanoImageRenderer.prototype.bindTexture = function bindTexture() {
		var _this2 = this;

		return new _Promise(function (res, rej) {
			if (!_this2._contentLoader) {
				rej("ImageLoader is not initialized");
				return;
			}

			_this2._contentLoader.get().then(function () {
				return _this2._bindTexture();
			}, rej).then(res);
		});
	};

	// 부모 엘리먼트에 canvas 를 붙임


	PanoImageRenderer.prototype.attachTo = function attachTo(parentElement) {
		this.detach();
		parentElement.appendChild(this.canvas);
	};

	PanoImageRenderer.prototype.forceContextLoss = function forceContextLoss() {
		if (this.hasRenderingContext()) {
			var loseContextExtension = this.context.getExtension("WEBGL_lose_context");

			if (loseContextExtension) {
				loseContextExtension.loseContext();
			}
		}
	};

	// 부모 엘리먼트에서 canvas 를 제거


	PanoImageRenderer.prototype.detach = function detach() {
		if (this.canvas.parentElement) {
			this.canvas.parentElement.removeChild(this.canvas);
		}
	};

	PanoImageRenderer.prototype.destroy = function destroy() {
		if (this._contentLoader) {
			this._contentLoader.destroy();
		}

		this.detach();
		this.forceContextLoss();

		this.off();

		this.canvas.removeEventListener("webglcontextlost", this._onWebglcontextlost);
		this.canvas.removeEventListener("webglcontextrestored", this._onWebglcontextrestored);
	};

	PanoImageRenderer.prototype.hasRenderingContext = function hasRenderingContext() {
		if (!(this.context && !this.context.isContextLost())) {
			return false;
		} else if (this.context && !this.context.getProgramParameter(this.shaderProgram, this.context.LINK_STATUS)) {
			return false;
		}
		return true;
	};

	PanoImageRenderer.prototype._onWebglcontextlost = function _onWebglcontextlost(e) {
		e.preventDefault();
		this.trigger(EVENTS.RENDERING_CONTEXT_LOST);
	};

	PanoImageRenderer.prototype._onWebglcontextrestored = function _onWebglcontextrestored(e) {
		this._initWebGL();
		this.trigger(EVENTS.RENDERING_CONTEXT_RESTORE);
	};

	PanoImageRenderer.prototype.updateFieldOfView = function updateFieldOfView(fieldOfView) {
		this.fieldOfView = fieldOfView;
		this._updateViewport();
	};

	PanoImageRenderer.prototype.updateViewportDimensions = function updateViewportDimensions(width, height) {
		var viewPortChanged = false;

		this.width = width;
		this.height = height;

		var w = width * DEVICE_PIXEL_RATIO;
		var h = height * DEVICE_PIXEL_RATIO;

		if (w !== this.canvas.width) {
			this.canvas.width = w;
			viewPortChanged = true;
		}

		if (h !== this.canvas.height) {
			this.canvas.height = h;
			viewPortChanged = true;
		}

		if (!viewPortChanged) {
			return;
		}

		this._updateViewport();
		this._shouldForceDraw = true;
	};

	PanoImageRenderer.prototype._updateViewport = function _updateViewport() {
		_mathUtil.mat4.perspective(this.pMatrix, _mathUtil.glMatrix.toRadian(this.fieldOfView), this.canvas.width / this.canvas.height, 0.1, 100);

		this.context.viewport(0, 0, this.context.drawingBufferWidth, this.context.drawingBufferHeight);
	};

	PanoImageRenderer.prototype._initWebGL = function _initWebGL() {
		// TODO: Following code does need to be executed only if width/height, cubicStrip property is changed.
		try {
			this._initRenderingContext();
			this.updateViewportDimensions(this.width, this.height);

			if (this.shaderProgram) {
				this.context.deleteProgram(this.shaderProgram);
			}

			this.shaderProgram = this._initShaderProgram(this.context);
			if (!this.shaderProgram) {
				throw new Error("Failed to intialize shaders: " + _WebGLUtils2["default"].getErrorNameFromWebGLErrorCode(this.context.getError()));
			}

			// Buffers for shader
			this._initBuffers();
		} catch (e) {
			this.trigger(EVENTS.ERROR, {
				type: ERROR_TYPE.NO_WEBGL,
				message: "no webgl support"
			});
			this.destroy();
			return;
		}
		// 캔버스를 투명으로 채운다.
		this.context.clearColor(0, 0, 0, 0);
		var textureTarget = this._isCubeMap ? this.context.TEXTURE_CUBE_MAP : this.context.TEXTURE_2D;

		if (this.texture) {
			this.context.deleteTexture(this.texture);
		}

		this.texture = _WebGLUtils2["default"].createTexture(this.context, textureTarget);
	};

	PanoImageRenderer.prototype._initRenderingContext = function _initRenderingContext() {
		if (this.hasRenderingContext()) {
			return;
		}

		if (!window.WebGLRenderingContext) {
			throw new Error("WebGLRenderingContext not available.");
		}

		this.context = _WebGLUtils2["default"].getWebglContext(this.canvas, this._renderingContextAttributes);

		if (!this.context) {
			throw new Error("Failed to acquire 3D rendering context");
		}
	};

	PanoImageRenderer.prototype._initShaderProgram = function _initShaderProgram(gl) {
		var vertexShaderSource = this._renderer.getVertexShaderSource();
		var vertexShader = _WebGLUtils2["default"].createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);

		if (!vertexShader) {
			return false;
		}

		var fragmentShaderSource = this._renderer.getFragmentShaderSource();
		var fragmentShader = _WebGLUtils2["default"].createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

		if (!fragmentShader) {
			return false;
		}

		var shaderProgram = _WebGLUtils2["default"].createProgram(gl, vertexShader, fragmentShader);

		if (!shaderProgram) {
			return null;
		}

		gl.useProgram(shaderProgram);
		shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
		gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
		shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
		shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
		shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
		shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
		gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

		// clear buffer
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
		// Use TEXTURE0
		gl.uniform1i(shaderProgram.samplerUniform, 0);

		return shaderProgram;
	};

	PanoImageRenderer.prototype._initBuffers = function _initBuffers() {
		var vertexPositionData = this._renderer.getVertexPositionData();
		var indexData = this._renderer.getIndexData();
		var textureCoordData = this._renderer.getTextureCoordData(this._imageConfig);
		var gl = this.context;

		this.vertexBuffer = _WebGLUtils2["default"].initBuffer(gl, gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), 3, this.shaderProgram.vertexPositionAttribute);

		this.indexBuffer = _WebGLUtils2["default"].initBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), 1);

		this.textureCoordBuffer = _WebGLUtils2["default"].initBuffer(gl, gl.ARRAY_BUFFER, new Float32Array(textureCoordData), this._isCubeMap ? 3 : 2, this.shaderProgram.textureCoordAttribute);
	};

	PanoImageRenderer.prototype._bindTexture = function _bindTexture() {
		this._renderer.bindTexture(this.context, this.texture, this._image, this._imageConfig);
		this._shouldForceDraw = true;

		this.trigger(EVENTS.BIND_TEXTURE);
	};

	PanoImageRenderer.prototype._updateTexture = function _updateTexture() {
		this._renderer.updateTexture(this.context, this._image, this._imageConfig);
	};

	PanoImageRenderer.prototype.keepUpdate = function keepUpdate(doUpdate) {
		if (doUpdate && this.isImageLoaded() === false) {
			// Force to draw a frame after image is loaded on render()
			this._shouldForceDraw = true;
		}

		this._keepUpdate = doUpdate;
	};

	PanoImageRenderer.prototype.renderWithQuaternion = function renderWithQuaternion(quaternion, fieldOfView) {
		if (!this.isImageLoaded()) {
			return;
		}

		if (this._keepUpdate === false && this._lastQuaternion && _mathUtil.quat.exactEquals(this._lastQuaternion, quaternion) && this.fieldOfView && this.fieldOfView === fieldOfView && this._shouldForceDraw === false) {
			return;
		}

		// updatefieldOfView only if fieldOfView is changed.
		if (fieldOfView !== undefined && fieldOfView !== this.fieldOfView) {
			this.updateFieldOfView(fieldOfView);
		}

		var outQ = void 0;

		if (!this._isCubeMap) {
			// TODO: Remove this yaw revision by correcting shader
			outQ = _mathUtil.quat.rotateY(_mathUtil.quat.create(), quaternion, _mathUtil.glMatrix.toRadian(90));
		} else {
			outQ = quaternion;
		}

		this.mvMatrix = _mathUtil.mat4.fromQuat(_mathUtil.mat4.create(), outQ);

		this._draw();

		this._lastQuaternion = _mathUtil.quat.clone(quaternion);
		if (this._shouldForceDraw) {
			this._shouldForceDraw = false;
		}
	};

	PanoImageRenderer.prototype.render = function render(yaw, pitch, fieldOfView) {
		if (!this.isImageLoaded()) {
			return;
		}

		if (this._keepUpdate === false && this._lastYaw !== null && this._lastYaw === yaw && this._lastPitch !== null && this._lastPitch === pitch && this.fieldOfView && this.fieldOfView === fieldOfView && this._shouldForceDraw === false) {
			return;
		}

		// fieldOfView 가 존재하면서 기존의 값과 다를 경우에만 업데이트 호출
		if (fieldOfView !== undefined && fieldOfView !== this.fieldOfView) {
			this.updateFieldOfView(fieldOfView);
		}

		_mathUtil.mat4.identity(this.mvMatrix);
		_mathUtil.mat4.rotateX(this.mvMatrix, this.mvMatrix, -_mathUtil.glMatrix.toRadian(pitch));
		_mathUtil.mat4.rotateY(this.mvMatrix, this.mvMatrix, -_mathUtil.glMatrix.toRadian(yaw - (this._isCubeMap ? 0 : 90)));

		this._draw();

		this._lastYaw = yaw;
		this._lastPitch = pitch;
		if (this._shouldForceDraw) {
			this._shouldForceDraw = false;
		}
	};

	PanoImageRenderer.prototype._draw = function _draw() {
		var gl = this.context;

		gl.uniformMatrix4fv(this.shaderProgram.pMatrixUniform, false, this.pMatrix);
		gl.uniformMatrix4fv(this.shaderProgram.mvMatrixUniform, false, this.mvMatrix);

		if (this._isVideo && this._keepUpdate) {
			this._updateTexture();
		}

		if (this.indexBuffer) {
			gl.drawElements(gl.TRIANGLES, this.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		}
	};

	return PanoImageRenderer;
}(_component2["default"]);

exports["default"] = PanoImageRenderer;


PanoImageRenderer.EVENTS = EVENTS;
PanoImageRenderer.ERROR_TYPE = ERROR_TYPE;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _Promise = typeof Promise === 'undefined' ? __webpack_require__(5).Promise : Promise;

// import Agent from "@egjs/agent";

/* Ref https://www.w3schools.com/tags/av_prop_readystate.asp */
var READY_STATUS = {
	HAVE_NOTHING: 0, // no information whether or not the audio/video is ready
	HAVE_METADATA: 1, // HAVE_METADATA - metadata for the audio/video is ready
	HAVE_CURRENT_DATA: 2, // data for the current playback position is available, but not enough data to play next frame/millisecond
	HAVE_FUTURE_DATA: 3, // data for the current and at least the next frame is available
	HAVE_ENOUGH_DATA: 4, // enough data available to start playing
	// below is custom status for failed to load status
	LOADING_FAILED: -1
};

var READYSTATECHANGE_EVENT_NAME = {};

READYSTATECHANGE_EVENT_NAME[READY_STATUS.HAVE_METADATA] = "loadedmetadata";
READYSTATECHANGE_EVENT_NAME[READY_STATUS.HAVE_CURRENT_DATA] = "loadeddata";
READYSTATECHANGE_EVENT_NAME[READY_STATUS.HAVE_FUTURE_DATA] = "canplay";
READYSTATECHANGE_EVENT_NAME[READY_STATUS.HAVE_ENOUGH_DATA] = "canplaythrough";

var VideoLoader = function () {
	function VideoLoader(video) {
		_classCallCheck(this, VideoLoader);

		this._handlers = [];
		this._sourceCount = 0;

		// on iOS safari, 'loadeddata' will not triggered unless the user hits play,
		// so used 'loadedmetadata' instead.
		this._thresholdReadyState = READY_STATUS.HAVE_METADATA;
		this._thresholdEventName = READYSTATECHANGE_EVENT_NAME[this._thresholdReadyState];

		this._loadStatus = video && video.readyState || READY_STATUS.HAVE_NOTHING;

		this._onerror = this._onerror.bind(this);

		video && this.set(video);
	}

	VideoLoader.prototype._onerror = function _onerror() {
		this._errorCount++;
		if (this._errorCount >= this._sourceCount) {
			this._loadStatus = READY_STATUS.LOADING_FAILED;
			this._detachErrorHandler(this._onerror);
		}
	};

	/**
  *
  * @param {Object | String} video Object or String containing Video Source URL<ko>비디오 URL 정보를 담고 있는 문자열이나 객체 {type, src}</ko>
  */


	VideoLoader.prototype._appendSourceElement = function _appendSourceElement(videoUrl) {
		var videoSrc = void 0;
		var videoType = void 0;

		if ((typeof videoUrl === "undefined" ? "undefined" : _typeof(videoUrl)) === "object") {
			videoSrc = videoUrl.src;
			videoType = videoUrl.type;
		} else if (typeof videoUrl === "string") {
			videoSrc = videoUrl;
		}

		if (!videoSrc) {
			return false;
		}

		var sourceElement = document.createElement("source");

		sourceElement.src = videoSrc;
		videoType && (sourceElement.type = videoType);

		this._video.appendChild(sourceElement);
		return true;
	};

	VideoLoader.prototype.set = function set(video) {
		var _this = this;

		this._reset(); // reset resources.

		if (!video) {
			return;
		}

		if (video instanceof HTMLVideoElement) {
			// video tag
			this._video = video;
		} else if (typeof video === "string" || (typeof video === "undefined" ? "undefined" : _typeof(video)) === "object") {
			// url
			this._video = document.createElement("video");
			this._video.setAttribute("crossorigin", "anonymous");
			this._video.setAttribute("webkit-playsinline", "");
			this._video.setAttribute("playsinline", "");

			if (video instanceof Array) {
				video.forEach(function (v) {
					return _this._appendSourceElement(v);
				});
			} else {
				this._appendSourceElement(video);
			}

			this._sourceCount = this._video.querySelectorAll("source").length;

			if (this._sourceCount > 0) {
				if (this._video.readyState < this._thresholdReadyState) {
					this._video.load();
					// attach loading error listener
					this._attachErrorHandler(this._onerror);
				}
			} else {
				this._video = null;
			}
		}
	};

	VideoLoader.prototype._attachErrorHandler = function _attachErrorHandler(handler) {
		this._video.addEventListener("error", handler);
		this._sources = this._video.querySelectorAll("source");
		[].forEach.call(this._sources, function (source) {
			source.addEventListener("error", handler);
		});
	};

	VideoLoader.prototype._detachErrorHandler = function _detachErrorHandler(handler) {
		this._video.removeEventListener("error", handler);
		[].forEach.call(this._sources, function (source) {
			source.removeEventListener("error", handler);
		});
	};

	VideoLoader.prototype.get = function get() {
		var _this2 = this;

		return new _Promise(function (res, rej) {
			if (!_this2._video) {
				rej("VideoLoader: video is undefined");
			} else if (_this2._loadStatus === READY_STATUS.LOADING_FAILED) {
				rej("VideoLoader: video source is invalid");
			} else if (_this2._video.readyState >= _this2._thresholdReadyState) {
				res(_this2._video);
			} else {
				// check errorCnt and reject
				var rejector = function rejector() {
					if (_this2._loadStatus === READY_STATUS.LOADING_FAILED) {
						_this2._detachErrorHandler(rejector);
						rej("VideoLoader: video source is invalid");
					}
				};

				_this2._attachErrorHandler(rejector);
				_this2._once(_this2._thresholdEventName, function () {
					return res(_this2._video);
				});
			}
		});
	};

	VideoLoader.prototype.getElement = function getElement() {
		return this._video;
	};

	VideoLoader.prototype.destroy = function destroy() {
		this._reset();
	};

	VideoLoader.prototype._reset = function _reset() {
		var _this3 = this;

		this._handlers.forEach(function (handler) {
			_this3._video.removeEventListener(handler.type, handler.fn);
		});
		this._handlers = [];
		this._video = null;

		this._sourceCount = 0;
		this._errorCount = 0;
	};

	VideoLoader.prototype._once = function _once(type, listener) {
		var target = this._video;

		var fn = function fn(event) {
			target.removeEventListener(type, fn);
			listener(event);
		};

		/* By useCapture mode enabled, you can capture the error event being fired on source(child)*/
		target.addEventListener(type, fn, true);
		this._handlers.push({ type: type, fn: fn });
	};

	return VideoLoader;
}();

exports["default"] = VideoLoader;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var userAgent = exports.userAgent = window.navigator.userAgent;
var devicePixelRatio = exports.devicePixelRatio = window.devicePixelRatio;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.WebGLUtils = exports.PanoImageRenderer = undefined;

var _PanoImageRenderer = __webpack_require__(23);

var _PanoImageRenderer2 = _interopRequireDefault(_PanoImageRenderer);

var _WebGLUtils = __webpack_require__(7);

var _WebGLUtils2 = _interopRequireDefault(_WebGLUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

exports.PanoImageRenderer = _PanoImageRenderer2["default"];
exports.WebGLUtils = _WebGLUtils2["default"];

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _agent = __webpack_require__(4);

var _agent2 = _interopRequireDefault(_agent);

var _Renderer2 = __webpack_require__(12);

var _Renderer3 = _interopRequireDefault(_Renderer2);

var _mathUtil = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CubeRenderer = function (_Renderer) {
	_inherits(CubeRenderer, _Renderer);

	function CubeRenderer() {
		_classCallCheck(this, CubeRenderer);

		return _possibleConstructorReturn(this, _Renderer.apply(this, arguments));
	}

	CubeRenderer.getVertexPositionData = function getVertexPositionData() {
		CubeRenderer._VERTEX_POSITION_DATA = CubeRenderer._VERTEX_POSITION_DATA !== null ? CubeRenderer._VERTEX_POSITION_DATA : [
		// back
		1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1,

		// front
		-1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1,

		// top
		-1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1,

		// bottom
		1, -1, -1, -1, -1, -1, -1, -1, 1, 1, -1, 1,

		// right
		1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, -1,

		// left
		-1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1];

		return CubeRenderer._VERTEX_POSITION_DATA;
	};

	CubeRenderer.getIndexData = function getIndexData() {
		if (CubeRenderer._INDEX_DATA) {
			return CubeRenderer._INDEX_DATA;
		}

		var indexData = [];
		var vertexPositionData = CubeRenderer.getVertexPositionData();

		for (var i = 0; i < vertexPositionData.length / 3; i += 4) {
			indexData.push(i, i + 2, i + 1, i, i + 3, i + 2);
		}

		CubeRenderer._INDEX_DATA = indexData;
		return indexData;
	};

	CubeRenderer.extractTileConfig = function extractTileConfig(imageConfig) {
		var tileConfig = Array.isArray(imageConfig.tileConfig) ? imageConfig.tileConfig : Array.apply(undefined, Array(6)).map(function () {
			return imageConfig.tileConfig;
		});

		tileConfig = tileConfig.map(function (config) {
			return _extends({
				flipHorizontal: false,
				rotation: 0
			}, config);
		});

		return tileConfig;
	};

	CubeRenderer.extractOrder = function extractOrder(imageConfig) {
		return imageConfig.order || "RLUDBF";
	};

	CubeRenderer.getTextureCoordData = function getTextureCoordData(imageConfig) {
		var vertexOrder = "BFUDRL";
		var order = CubeRenderer.extractOrder(imageConfig);
		var base = CubeRenderer.getVertexPositionData();
		var tileConfig = CubeRenderer.extractTileConfig(imageConfig);
		var elemSize = 3;
		var vertexPerTile = 4;
		var textureCoordData = vertexOrder.split("").map(function (face) {
			return tileConfig[order.indexOf(face)];
		}).map(function (config, i) {
			var rotation = parseInt(config.rotation / 90, 10);
			var ordermap_ = config.flipHorizontal ? [0, 1, 2, 3] : [1, 0, 3, 2];

			for (var r = 0; r < Math.abs(rotation); r++) {
				if (config.flipHorizontal && rotation > 0 || !config.flipHorizontal && rotation < 0) {
					ordermap_.push(ordermap_.shift());
				} else {
					ordermap_.unshift(ordermap_.pop());
				}
			}

			var elemPerTile = elemSize * vertexPerTile;
			var tileVertex = base.slice(i * elemPerTile, i * elemPerTile + elemPerTile);
			var tileTemp = [];

			for (var j = 0; j < vertexPerTile; j++) {
				tileTemp[ordermap_[j]] = tileVertex.splice(0, elemSize);
			}
			return tileTemp;
		}).join().split(",").map(function (v) {
			return parseInt(v, 10);
		});

		return textureCoordData;
	};

	CubeRenderer.getVertexShaderSource = function getVertexShaderSource() {
		return "\n\t\t\tattribute vec3 aVertexPosition;\n\t\t\tattribute vec3 aTextureCoord;\n\t\t\tuniform mat4 uMVMatrix;\n\t\t\tuniform mat4 uPMatrix;\n\t\t\tvarying highp vec3 vVertexDirectionVector;\n\t\t\tvoid main(void) {\n\t\t\t\tgl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n\t\t\t\tvVertexDirectionVector = aTextureCoord;\n\t\t\t}";
	};

	CubeRenderer.getFragmentShaderSource = function getFragmentShaderSource() {
		return "\n\t\t\tvarying highp vec3 vVertexDirectionVector;\n\t\t\tuniform samplerCube uSampler;\n\t\t\tvoid main(void) {\n\t\t\t\tgl_FragColor = textureCube(uSampler, vVertexDirectionVector);\n\t\t\t}";
	};

	CubeRenderer.updateTexture = function updateTexture(gl, image, imageConfig) {
		var baseOrder = "RLUDBF";
		var order = CubeRenderer.extractOrder(imageConfig);
		var orderMap = {};

		order.split("").forEach(function (v, i) {
			orderMap[v] = i;
		});

		try {
			if (image instanceof Array) {
				for (var surfaceIdx = 0; surfaceIdx < 6; surfaceIdx++) {
					var tileIdx = orderMap[baseOrder[surfaceIdx]];

					gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + surfaceIdx, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image[tileIdx]);
				}
			} else {
				var maxCubeMapTextureSize = CubeRenderer.getMaxCubeMapTextureSize(gl, image);

				for (var _surfaceIdx = 0; _surfaceIdx < 6; _surfaceIdx++) {
					var _tileIdx = orderMap[baseOrder[_surfaceIdx]];
					var tile = CubeRenderer.extractTileFromImage(image, _tileIdx, maxCubeMapTextureSize);

					gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _surfaceIdx, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tile);
				}
			}
		} catch (e) {}
	};

	CubeRenderer.bindTexture = function bindTexture(gl, texture, image, imageConfig) {
		gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
		CubeRenderer.updateTexture(gl, image, imageConfig);
	};

	CubeRenderer._getDimension = function _getDimension(pixelSource) {
		var width = pixelSource.naturalWidth || pixelSource.videoWidth;
		var height = pixelSource.naturalHeight || pixelSource.videoHeight;

		return { width: width, height: height };
	};

	CubeRenderer.getSourceTileSize = function getSourceTileSize(image) {
		var _getDimension2 = this._getDimension(image),
		    width = _getDimension2.width,
		    height = _getDimension2.height;

		var aspectRatio = width / height;
		var inputTextureSize = void 0;

		if (aspectRatio === 1 / 6) {
			inputTextureSize = width;
		} else if (aspectRatio === 6) {
			inputTextureSize = height;
		} else if (aspectRatio === 2 / 3) {
			inputTextureSize = width / 2;
		} else {
			inputTextureSize = width / 3;
		}
		return inputTextureSize;
	};

	CubeRenderer.extractTileFromImage = function extractTileFromImage(image, tileIdx, outputTextureSize) {
		var _getDimension3 = this._getDimension(image),
		    width = _getDimension3.width;

		var inputTextureSize = CubeRenderer.getSourceTileSize(image);

		var canvas = document.createElement("canvas");

		canvas.width = outputTextureSize;
		canvas.height = outputTextureSize;
		var context = canvas.getContext("2d");
		var tilePerRow = width / inputTextureSize;

		var x = inputTextureSize * tileIdx % (inputTextureSize * tilePerRow);
		var y = parseInt(tileIdx / tilePerRow, 10) * inputTextureSize;

		context.drawImage(image, x, y, inputTextureSize, inputTextureSize, 0, 0, outputTextureSize, outputTextureSize);
		return canvas;
	};

	CubeRenderer.getMaxCubeMapTextureSize = function getMaxCubeMapTextureSize(gl, image) {
		var agent = (0, _agent2["default"])();
		var maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
		var _imageWidth = CubeRenderer.getSourceTileSize(image);

		if (agent.browser.name === "ie" && parseInt(agent.browser.version, 10) === 11) {
			if (!_mathUtil.util.isPowerOfTwo(_imageWidth)) {
				for (var i = 1; i < maxCubeMapTextureSize; i *= 2) {
					if (i < _imageWidth) {
						continue;
					} else {
						_imageWidth = i;
						break;
					}
				}
			}
		}
		// ios 9 의 경우 텍스쳐 최대사이즈는 1024 이다.
		if (agent.os.name === "ios" && parseInt(agent.os.version, 10) === 9) {
			_imageWidth = 1024;
		}
		// ios 8 의 경우 텍스쳐 최대사이즈는 512 이다.
		if (agent.os.name === "ios" && parseInt(agent.os.version, 10) === 8) {
			_imageWidth = 512;
		}
		// maxCubeMapTextureSize 보다는 작고, imageWidth 보다 큰 2의 승수 중 가장 작은 수
		return Math.min(maxCubeMapTextureSize, _imageWidth);
	};

	return CubeRenderer;
}(_Renderer3["default"]);

exports["default"] = CubeRenderer;


CubeRenderer._VERTEX_POSITION_DATA = null;
CubeRenderer._INDEX_DATA = null;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _agent = __webpack_require__(4);

var _agent2 = _interopRequireDefault(_agent);

var _Renderer2 = __webpack_require__(12);

var _Renderer3 = _interopRequireDefault(_Renderer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var agent = (0, _agent2["default"])();
var isIE11 = agent.browser.name === "ie" && agent.browser.version === "11.0";
var pixelCanvas = void 0;
var pixelContext = void 0;

var SphereRenderer = function (_Renderer) {
	_inherits(SphereRenderer, _Renderer);

	function SphereRenderer() {
		_classCallCheck(this, SphereRenderer);

		return _possibleConstructorReturn(this, _Renderer.apply(this, arguments));
	}

	SphereRenderer.getVertexPositionData = function getVertexPositionData() {
		return SphereRenderer._VERTEX_POSITION_DATA;
	};

	SphereRenderer.getIndexData = function getIndexData() {
		return SphereRenderer._INDEX_DATA;
	};

	SphereRenderer.getTextureCoordData = function getTextureCoordData() {
		return SphereRenderer._TEXTURE_COORD_DATA;
	};

	SphereRenderer.getVertexShaderSource = function getVertexShaderSource() {
		return "\n\t\t\tattribute vec3 aVertexPosition;\n\t\t\tattribute vec2 aTextureCoord;\n\t\t\tuniform mat4 uMVMatrix;\n\t\t\tuniform mat4 uPMatrix;\n\t\t\tvarying highp vec2 vTextureCoord;\n\t\t\tvoid main(void) {\n\t\t\t\tgl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n\t\t\t\tvTextureCoord = aTextureCoord;\n\t\t\t}";
	};

	SphereRenderer.getFragmentShaderSource = function getFragmentShaderSource() {
		return "\n\t\t\tvarying highp vec2 vTextureCoord;\n\t\t\tuniform sampler2D uSampler;\n\t\t\tvoid main(void) {\n\t\t\t\tgl_FragColor = texture2D(\n\t\t\t\t\tuSampler,\n\t\t\t\t\tvec2(vTextureCoord.s, vTextureCoord.t)\n\t\t\t\t);\n\t\t\t}";
	};

	SphereRenderer._getPixelSource = function _getPixelSource(image) {
		if (!pixelCanvas) {
			return image;
		}

		var _getDimension2 = this._getDimension(image),
		    width = _getDimension2.width,
		    height = _getDimension2.height;

		if (pixelCanvas.width !== width) {
			pixelCanvas.width = width;
		}

		if (pixelCanvas.height !== height) {
			pixelCanvas.height = height;
		}

		pixelContext.drawImage(image, 0, 0);

		return pixelCanvas;
	};

	SphereRenderer._getDimension = function _getDimension(pixelSource) {
		var width = pixelSource.naturalWidth || pixelSource.videoWidth;
		var height = pixelSource.naturalHeight || pixelSource.videoHeight;

		return { width: width, height: height };
	};

	SphereRenderer.updateTexture = function updateTexture(gl, image) {
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._getPixelSource(image));
	};

	SphereRenderer.bindTexture = function bindTexture(gl, texture, image) {
		// Make sure image isn't too big
		var _getDimension3 = this._getDimension(image),
		    width = _getDimension3.width,
		    height = _getDimension3.height;

		var size = Math.max(width, height);
		var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);

		if (size > maxSize) {
			/* eslint-disable no-console */
			console.warn("Image width(" + width + ") exceeds device limit(" + maxSize + "))");
			/* eslint-enable no-console */
			return;
		}

		if (isIE11 && image instanceof HTMLVideoElement) {
			pixelCanvas = document.createElement("canvas");
			pixelCanvas.width = width;
			pixelCanvas.height = height;
			pixelContext = pixelCanvas.getContext("2d");
		}

		gl.activeTexture(gl.TEXTURE0);
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		gl.bindTexture(gl.TEXTURE_2D, texture);

		SphereRenderer.updateTexture(gl, image);
	};

	SphereRenderer._initData = function _initData() {
		var latitudeBands = 60;
		var longitudeBands = 60;
		var radius = 2;

		var textureCoordData = [];
		var vertexPositionData = [];
		var indexData = [];
		var latIdx = void 0;
		var lngIdx = void 0;

		for (latIdx = 0; latIdx <= latitudeBands; latIdx++) {
			var theta = (latIdx / latitudeBands - 0.5) * Math.PI;
			var sinTheta = Math.sin(theta);
			var cosTheta = Math.cos(theta);

			for (lngIdx = 0; lngIdx <= longitudeBands; lngIdx++) {
				var phi = (lngIdx / longitudeBands - 0.5) * 2 * Math.PI;
				var sinPhi = Math.sin(phi);
				var cosPhi = Math.cos(phi);
				var x = cosPhi * cosTheta;
				var y = sinTheta;
				var z = sinPhi * cosTheta;
				var u = lngIdx / longitudeBands;
				var v = latIdx / latitudeBands;

				textureCoordData.push(u, v);
				vertexPositionData.push(radius * x, radius * y, radius * z);

				if (lngIdx !== longitudeBands && latIdx !== latitudeBands) {
					var a = latIdx * (longitudeBands + 1) + lngIdx;
					var b = a + longitudeBands + 1;

					indexData.push(a, b, a + 1, b, b + 1, a + 1);
				}
			}
		}

		SphereRenderer._VERTEX_POSITION_DATA = vertexPositionData;
		SphereRenderer._TEXTURE_COORD_DATA = textureCoordData;
		SphereRenderer._INDEX_DATA = indexData;
	};

	return SphereRenderer;
}(_Renderer3["default"]);

exports["default"] = SphereRenderer;


SphereRenderer._VERTEX_POSITION_DATA = null;
SphereRenderer._TEXTURE_COORD_DATA = null;
SphereRenderer._INDEX_DATA = null;

SphereRenderer._initData();

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

var _browser = __webpack_require__(30);

var _YawPitchControl = __webpack_require__(16);

var _PanoImageRenderer = __webpack_require__(26);

var _WebGLUtils = __webpack_require__(7);

var _WebGLUtils2 = _interopRequireDefault(_WebGLUtils);

var _consts = __webpack_require__(13);

var _mathUtil = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Promise = typeof Promise === 'undefined' ? __webpack_require__(5).Promise : Promise;

var PanoViewer = function (_Component) {
	_inherits(PanoViewer, _Component);

	/**
  * @classdesc 360 media viewer
  * @ko 360 미디어 뷰어
  * @class
  * @name eg.view360.PanoViewer
  * @extends eg.Component
  *
  * @param {HTMLElement} container The container element for the renderer. <ko>렌더러의 컨테이너 엘리먼트</ko>
  * @param {Object} config
  *
  * @param {String|Image} config.image Input image url or element<ko>입력 이미지 URL 혹은 엘리먼트(image 와 video 둘 중 하나만 설정한다.)</ko>
  * @param {String|HTMLVideoElement} config.video Input video url or element<ko>입력 비디오 URL 혹은 엘리먼트(image 와 video 둘 중 하나만 설정한다.)</ko>
  * @param {String} [config.projectionType=equirectangular] The type of projection: equirectangular, cubemap <ko>Projection 유형 : equirectangular, cubemap</ko>
  * @param {Object} config.cubemapConfig config cubemap projection layout. <ko>cubemap projection type 의 레이아웃을 설정한다.</ko>
  * @param {Number} [config.width=width of container] the viewer's width. (in px) <ko>뷰어의 너비 (px 단위)</ko>
  * @param {Number} [config.height=height of container] the viewer's height.(in px) <ko>뷰어의 높이 (px 단위)</ko>
  *
  * @param {Number} [config.yaw=0] Initial Yaw of camera (in degree) <ko>카메라의 초기 Yaw (degree 단위)</ko>
  * @param {Number} [config.pitch=0] Initial Pitch of camera (in degree) <ko>카메라의 초기 Pitch (degree 단위)</ko>
  * @param {Number} [config.fov=65] Initial vertical field of view of camera (in degree) <ko>카메라의 초기 수직 field of view (degree 단위)</ko>
  * @param {Boolean} [config.showPolePoint=false] If false, the pole is not displayed inside the viewport <ko>false 인 경우, 극점은 뷰포트 내부에 표시되지 않습니다</ko>
  * @param {Boolean} [config.useZoom=true] When true, enables zoom with the wheel and Pinch gesture <ko>true 일 때 휠 및 집기 제스춰로 확대 / 축소 할 수 있습니다.</ko>
  * @param {Boolean} [config.useKeyboard=true] When true, enables the keyboard move key control: awsd, arrow keys <ko>true 이면 키보드 이동 키 컨트롤을 활성화합니다: awsd, 화살표 키</ko>
  * @param {String} [config.gyroMode=yawPitch] Enables control through device motion. ("none", "yawPitch") <ko>디바이스 움직임을 통한 컨트롤을 활성화 합니다. ("none", "yawPitch") </ko>
  * @param {Array} [config.yawRange=[-180, 180]] Range of controllable Yaw values <ko>제어 가능한 Yaw 값의 범위</ko>
  * @param {Array} [config.pitchRange=[-90, 90]] Range of controllable Pitch values <ko>제어 가능한 Pitch 값의 범위</ko>
  * @param {Array} [config.fovRange=[30, 110]] Range of controllable vertical field of view values <ko>제어 가능한 수직 field of view 값의 범위</ko>
  * @param {Number} [config.touchDirection= PanoViewer.TOUCH_DIRECTION.ALL(6)] Direction of touch that can be controlled by user {@link eg.PanoViewer.TOUCH_DIRECTION}<ko>사용자가 터치로 조작 가능한 방향 {@link eg.PanoViewer.TOUCH_DIRECTION}</ko>
  */
	function PanoViewer(container) {
		var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		_classCallCheck(this, PanoViewer);

		// Raises the error event if webgl is not supported.
		var _this = _possibleConstructorReturn(this, _Component.call(this));

		if (!_WebGLUtils2["default"].isWebGLAvailable()) {
			var _ret;

			setTimeout(function () {
				_this.trigger(_consts.EVENTS.ERROR, {
					type: _consts.ERROR_TYPE.NO_WEBGL,
					message: "no webgl support"
				});
			}, 0);
			return _ret = _this, _possibleConstructorReturn(_this, _ret);
		}

		if (!_WebGLUtils2["default"].isStableWebGL()) {
			var _ret2;

			setTimeout(function () {
				_this.trigger(_consts.EVENTS.ERROR, {
					type: _consts.ERROR_TYPE.INVALID_DEVICE,
					message: "blacklisted browser"
				});
			}, 0);

			return _ret2 = _this, _possibleConstructorReturn(_this, _ret2);
		}

		if (!!options.image && !!options.video) {
			var _ret3;

			setTimeout(function () {
				_this.trigger(_consts.EVENTS.ERROR, {
					type: _consts.ERROR_TYPE.INVALID_RESOURCE,
					message: "Specifying multi resouces(both image and video) is not valid."
				});
			}, 0);
			return _ret3 = _this, _possibleConstructorReturn(_this, _ret3);
		}

		_this._container = container;
		_this._image = options.image || options.video;
		_this._isVideo = !!options.video;
		_this._projectionType = options.projectionType || _consts.PROJECTION_TYPE.EQUIRECTANGULAR;
		_this._cubemapConfig = _extends({
			order: "RLUDBF",
			tileConfig: {
				flipHirozontal: false,
				rotation: 0
			}
		}, options.cubemapConfig);

		// If the width and height are not provided, will use the size of the container.
		_this._width = options.width || parseInt(window.getComputedStyle(container).width, 10);
		_this._height = options.height || parseInt(window.getComputedStyle(container).height, 10);

		_this._yaw = options.yaw || 0;
		_this._pitch = options.pitch || 0;
		_this._fov = options.fov || 65;

		_this._gyroMode = options.gyroMode || _consts.GYRO_MODE.YAWPITCH;
		_this._quaternion = null;

		_this._aspectRatio = _this._width / _this._height;
		var fovRange = options.fovRange || [30, 110];
		var touchDirection = PanoViewer._isValidTouchDirection(options.touchDirection) ? options.touchDirection : _YawPitchControl.YawPitchControl.TOUCH_DIRECTION_ALL;
		var yawPitchConfig = _extends(options, {
			element: container,
			yaw: _this._yaw,
			pitch: _this._pitch,
			fov: _this._fov,
			gyroMode: _this._gyroMode,
			fovRange: fovRange,
			aspectRatio: _this._aspectRatio,
			touchDirection: touchDirection
		});

		_this._isReady = false;

		_this._initYawPitchControl(yawPitchConfig);
		_this._initRenderer(_this._yaw, _this._pitch, _this._fov, _this._projectionType, _this._cubemapConfig);
		return _this;
	}

	/**
 	* Getting the video element that the viewer is currently playing. You can use this for playback.
 	* @ko 뷰어가 현재 사용 중인 비디오 요소를 얻습니다. 이 요소를 이용해 비디오의 컨트롤을 할 수 있습니다.
 	* @method eg.view360.PanoViewer#getVideo
 	* @return {HTMLVideoElement} HTMLVideoElement<ko>HTMLVideoElement</ko>
 	*/


	PanoViewer.prototype.getVideo = function getVideo() {
		if (!this._isVideo) {
			return null;
		}

		return this._photoSphereRenderer.getContent();
	};

	/**
  * Setting the video information to be used by the viewer.
  * @ko 뷰어가 사용할 이미지 정보를 설정 합니다.
  * @method eg.view360.PanoViewer#setVideo
  * @param {String|HTMLVideoElement|Object} video Input video url or element or config object<ko>입력 비디오 URL 혹은 엘리먼트 혹은 설정객체를 활용(image 와 video 둘 중 하나만 설정한다.)</ko>
  * @param {Object} param
  * @param {String} [param.projectionType="equirectangular"] Projection Type<ko>프로젝션 타입</ko>
  * @param {Object} param.cubemapConfig config cubemap projection layout. <ko>cubemap projection type 의 레이아웃을 설정한다.</ko>
  *
  * @return {PanoViewer} PanoViewer instance<ko>PanoViewer 인스턴스</ko>
  */


	PanoViewer.prototype.setVideo = function setVideo(video) {
		var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		if (!video) {
			return this;
		}

		this.setImage(video, {
			projectionType: param.projectionType,
			isVideo: true,
			cubemapConfig: param.cubemapConfig
		});
		return this;
	};

	/**
  * Getting the image information that the viewer is currently using.
  * @ko 뷰어가 현재 사용하고있는 이미지 정보를 얻습니다.
  * @method eg.view360.PanoViewer#getImage
  * @return {Image} Image Object<ko>이미지 객체</ko>
  */


	PanoViewer.prototype.getImage = function getImage() {
		if (this._isVideo) {
			return null;
		}

		return this._photoSphereRenderer.getContent();
	};

	/**
  * Setting the image information to be used by the viewer.
  * @ko 뷰어가 사용할 이미지 정보를 설정 합니다.
  * @method eg.view360.PanoViewer#setImage
  * @param {String|Image|Object} image Input image url or element or config object<ko>입력 이미지 URL 혹은 엘리먼트 혹은 설정객체를 활용(image 와 video 둘 중 하나만 설정한다.)</ko>
  * @param {Object} param Additional information<ko>이미지 추가 정보</ko>
  * @param {String} [param.projectionType="equirectangular"] Projection Type<ko>프로젝션 타입</ko>
  * @param {Object} param.cubemapConfig config cubemap projection layout. <ko>cubemap projection type 의 레이아웃을 설정한다.</ko>
  *
  * @return {PanoViewer} PanoViewer instance<ko>PanoViewer 인스턴스</ko>
  */


	PanoViewer.prototype.setImage = function setImage(image) {
		var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		var cubemapConfig = _extends({
			order: "RLUDBF",
			tileConfig: {
				flipHirozontal: false,
				rotation: 0
			}
		}, param.cubemapConfig);
		var isVideo = !!param.isVideo;

		if (this._image && this._isVideo !== isVideo) {
			/* eslint-disable no-console */
			console.warn("Currently not supporting to change content type(Image <--> Video)");
			/* eslint-enable no-console */
			return this;
		}

		if (!image) {
			return this;
		}

		this._image = image;
		this._isVideo = isVideo;
		this._projectionType = param.projectionType || _consts.PROJECTION_TYPE.EQUIRECTANGULAR;
		this._cubemapConfig = cubemapConfig;

		this._deactivate();
		this._initRenderer(this._yaw, this._pitch, this._fov, this._projectionType, this._cubemapConfig);

		return this;
	};

	/**
  * Can set whether the renderer always updates the texture and renders.
  * @ko 렌더러가 항상 텍스쳐를 갱신하고 화면을 렌더링 할지 여부를 설정할 수 있다.
  *
  * @method eg.view360.PanoViewer#keepUpdate
  * @param {Boolean} doUpdate When true, viewer will always update texture and render, when false viewer will not update texture and render only camera config is changed.<ko>True면, 항상 텍스쳐를 갱신하고 화면을 그린다. False 면 텍스쳐 갱신은 하지 않으며, 카메라 요소에 변화가 있을 때에만 화면을 그린다.</ko>
  */


	PanoViewer.prototype.keepUpdate = function keepUpdate(doUpdate) {
		this._photoSphereRenderer.keepUpdate(doUpdate);
		return this;
	};

	/**
  * Get projection type (equirectangular/cube)
  * @ko 프로젝션 타입(Equirectangular 혹은 Cube)을 반환한다.
  *
  * @method eg.view360.PanoViewer#getProjectionType
  */


	PanoViewer.prototype.getProjectionType = function getProjectionType() {
		return this._projectionType;
	};

	PanoViewer.prototype._initRenderer = function _initRenderer(yaw, pitch, fov, projectionType, cubemapConfig) {
		var _this2 = this;

		this._photoSphereRenderer = new _PanoImageRenderer.PanoImageRenderer(this._image, this._width, this._height, this._isVideo, {
			initialYaw: yaw,
			initialPitch: pitch,
			fieldOfView: fov,
			imageType: projectionType,
			cubemapConfig: cubemapConfig
		});

		this._bindRendererHandler();

		this._photoSphereRenderer.bindTexture().then(function () {
			return _this2._activate();
		}, function () {
			_this2._triggerEvent(_consts.EVENTS.ERROR, {
				type: _consts.ERROR_TYPE.FAIL_BIND_TEXTURE,
				message: "failed to bind texture"
			});
		});
	};

	PanoViewer.prototype._bindRendererHandler = function _bindRendererHandler() {
		var _this3 = this;

		this._photoSphereRenderer.on(_PanoImageRenderer.PanoImageRenderer.EVENTS.ERROR, function (e) {
			_this3.trigger(_consts.EVENTS.ERROR, e);
		});

		this._photoSphereRenderer.on(_PanoImageRenderer.PanoImageRenderer.EVENTS.RENDERING_CONTEXT_LOST, function (e) {
			_this3._deactivate();
			_this3.trigger(_consts.EVENTS.ERROR, {
				type: _consts.ERROR_TYPE.RENDERING_CONTEXT_LOST,
				message: "webgl rendering context lost"
			});
		});
	};

	PanoViewer.prototype._initYawPitchControl = function _initYawPitchControl(yawPitchConfig) {
		var _this4 = this;

		this._yawPitchControl = new _YawPitchControl.YawPitchControl(yawPitchConfig);

		this._yawPitchControl.on(_consts.EVENTS.ANIMATION_END, function (e) {
			_this4._triggerEvent(_consts.EVENTS.ANIMATION_END, e);
		});

		this._yawPitchControl.on("change", function (e) {
			_this4._yaw = e.yaw;
			_this4._pitch = e.pitch;
			_this4._fov = e.fov;
			_this4._quaternion = e.quaternion;

			_this4._triggerEvent(_consts.EVENTS.VIEW_CHANGE, e);
		});
	};

	PanoViewer.prototype._triggerEvent = function _triggerEvent(name, param) {
		var evt = param || {};

		/**
   * Events that is fired when error occurs
   * @ko 에러 발생 시 발생하는 이벤트
   * @name eg.view360.PanoViewer#error
   * @event
   * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
   * @param {Number} param.type Error type
   * 		10: INVALID_DEVICE: Unsupported device
   * 		11: NO_WEBGL: Webgl not support
   * 		12, FAIL_IMAGE_LOAD: Failed to load image
   * 		13: FAIL_BIND_TEXTURE: Failed to bind texture
   * 		14: INVALID_RESOURCE: Only one resource(image or video) should be specified
   * 		15: RENDERING_CONTEXT_LOST: WebGL context lost occurred
   * <ko>에러 종류
   * 		10: INVALID_DEVICE: 미지원 기기
   * 		11: NO_WEBGL: WEBGL 미지원
   * 		12, FAIL_IMAGE_LOAD: 이미지 로드 실패
   * 		13: FAIL_BIND_TEXTURE: 텍스쳐 바인딩 실패
   * 		14: INVALID_RESOURCE: 리소스 지정 오류 (image 혹은 video 중 하나만 지정되어야 함)
   * 		15: RENDERING_CONTEXT_LOST: WebGL context lost 발생
   * </ko>
   * @param {String} param.message Error message <ko>에러 메시지</ko>
   *
   * @example
   *
   * viwer.on({
   *	"error" : function(evt) {
   *		// evt.type === 13
   *		// evt.messaeg === "failed to bind texture"
   * });
   */

		/**
   * Events that is fired when PanoViewer is ready to go.
   * @ko PanoViewer 가 준비된 상태에 발생하는 이벤트
   * @name eg.view360.PanoViewer#ready
   * @event
   *
   * @example
   *
   * viwer.on({
   *	"ready" : function(evt) {
   *		// PanoViewer is ready to show image and handle user interaction.
   * });
   */

		/**
   * Events that is fired when direction or fov is changed.
   * @ko PanoViewer 에서 바라보고 있는 방향이나 FOV(화각)가 변경되었을때 발생하는 이벤트
   * @name eg.view360.PanoViewer#viewChange
   * @event
   * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
   * @param {Number} param.yaw yaw<ko>yaw</ko>
   * @param {Number} param.pitch pitch <ko>pitch</ko>
   * @param {Number} param.fov Field of view (fov) <ko>화각</ko>
   * @example
   *
   * viwer.on({
   *	"viewChange" : function(evt) {
   *		//evt.yaw, evt.pitch, evt.fov is available.
   * });
   */

		/**
   * Events that is fired when animation which is triggered by inertia is ended.
   * @ko 관성에 의한 애니메이션 동작이 완료되었을때 발생하는 이벤트
   * @name eg.view360.PanoViewer#animationEnd
   * @event
   * @example
   *
   * viwer.on({
   *	"animationEnd" : function(evt) {
   *		// animation is ended.
   * });
   */
		return this.trigger(name, evt);
	};

	/**
  * When set true, enables zoom with the wheel and Pinch gesture
  * @ko true 로 설정 시 휠 및 집기 동작으로 확대 / 축소 할 수 있습니다.
  * @method eg.view360.PanoViewer#setUseZoom
  * @param {Boolean} useZoom
  */


	PanoViewer.prototype.setUseZoom = function setUseZoom(useZoom) {
		if (typeof useZoom !== "boolean") {
			return;
		}

		this._yawPitchControl.option("useZoom", useZoom);
	};

	/**
  * When true, enables the keyboard move key control: awsd, arrow keys
  * @ko true이면 키보드 이동 키 컨트롤을 활성화합니다. (awsd, 화살표 키)
  * @method eg.view360.PanoViewer#setUseKeyboard
  * @param {Boolean} useKeyboard
  */


	PanoViewer.prototype.setUseKeyboard = function setUseKeyboard(useKeyboard) {
		this._yawPitchControl.option("useKeyboard", useKeyboard);
	};

	/**
  * Enables control through device motion. ("none", "yawPitch")
  * @ko 디바이스 움직임을 통한 컨트롤을 활성화 합니다. ("none", "yawPitch")
  * @method eg.view360.PanoViewer#setGyroMode
  * @param {String} gyroMode
  */


	PanoViewer.prototype.setGyroMode = function setGyroMode(gyroMode) {
		this._yawPitchControl.option("gyroMode", gyroMode);
	};

	/**
  * Setting the range of controllable FOV values
  * @ko 제어 가능한 FOV 값의 범위 설정
  * @method eg.view360.PanoViewer#setFovRange
  * @param {Array} range
  */


	PanoViewer.prototype.setFovRange = function setFovRange(range) {
		this._yawPitchControl.option("fovRange", range);
	};

	/**
  * Getting the range of controllable FOV values
  * @ko 제어 가능한 FOV 값의 범위 가져 오기
  * @method eg.view360.PanoViewer#getFovRange
  * @return {Array}
  */


	PanoViewer.prototype.getFovRange = function getFovRange() {
		return this._yawPitchControl.option("fovRange");
	};

	/**
  * Update size of canvas element by it's container element's or specified size.
  * @ko 캔버스 엘리먼트의 크기를 컨테이너 엘리먼트의 크기나 지정된 크기로 업데이트합니다.
  * @method eg.view360.PanoViewer#updateViewportDimensions
  * @param {Object} [size]
  * @param {Number} [size.width=width of container]
  * @param {Number} [size.height=height of container]
  */


	PanoViewer.prototype.updateViewportDimensions = function updateViewportDimensions(size) {
		if (!this._isReady) {
			return;
		}
		this._width = size && size.width || parseInt(window.getComputedStyle(this._container).width, 10);
		this._height = size && size.height || parseInt(window.getComputedStyle(this._container).height, 10);
		this._aspectRatio = this._width / this._height;
		this._photoSphereRenderer.updateViewportDimensions(this._width, this._height);
		this._yawPitchControl.option("aspectRatio", this._aspectRatio);

		this.lookAt({}, 0);
	};

	/**
  * Get the vertical field of view
  * @ko 뷰어의 수직 field of view 값을 가져옵니다.
  * @method eg.view360.PanoViewer#getFov
  * @return {Number}
  */


	PanoViewer.prototype.getFov = function getFov() {
		return this._fov;
	};

	/**
  * Get the horizontal field of view in degree
  */


	PanoViewer.prototype._getHFov = function _getHFov() {
		return _mathUtil.glMatrix.toDegree(2 * Math.atan(this._aspectRatio * Math.tan(_mathUtil.glMatrix.toRadian(this._fov) / 2)));
	};

	/**
  * Get current yaw value
  * @ko 뷰어의 yaw 값을 가져옵니다.
  * @method eg.view360.PanoViewer#getYaw
  * @return {Number}
  */


	PanoViewer.prototype.getYaw = function getYaw() {
		return this._yaw;
	};

	/**
  * Get current pitch value
  * @ko 뷰어의 pitch 값을 가져옵니다.
  * @method eg.view360.PanoViewer#getPitch
  * @return {Number}
  */


	PanoViewer.prototype.getPitch = function getPitch() {
		return this._pitch;
	};

	/**
  * Get the range of controllable Yaw values
  * @ko 컨트롤 가능한 Yaw 구간을 가져옵니다.
  * @method eg.view360.PanoViewer#getYawRange
  * @return {Array}
  */


	PanoViewer.prototype.getYawRange = function getYawRange() {
		return this._yawPitchControl.option("yawRange");
	};

	/**
  * Get the range of controllable Pitch values
  * @ko 컨트롤 가능한 Pitch 구간을 가져옵니다.
  * @method eg.view360.PanoViewer#getPitchRange
  * @return {Array}
  */


	PanoViewer.prototype.getPitchRange = function getPitchRange() {
		return this._yawPitchControl.option("pitchRange");
	};

	/**
  * Set the range of controllable Yaw values
  * @ko 컨트롤 가능한 Yaw 구간을 설정합니다.
  * @method eg.view360.PanoViewer#setYawRange
  * @param {Array} range
  */


	PanoViewer.prototype.setYawRange = function setYawRange(yawRange) {
		return this._yawPitchControl.option("yawRange", yawRange);
	};

	/**
  * Set the range of controllable Pitch values
  * @ko 컨트롤 가능한 Pitch 구간을 설정합니다.
  * @method eg.view360.PanoViewer#setPitchRange
  * @param {Array} range
  */


	PanoViewer.prototype.setPitchRange = function setPitchRange(pitchRange) {
		return this._yawPitchControl.option("pitchRange", pitchRange);
	};

	/**
  * If false, the pole is not displayed inside the viewport
  * @ko false 인 경우, 폴은 뷰포트 내부에 표시되지 않습니다.
  * @method eg.view360.PanoViewer#setPitchRange
  * @param {Boolean} showPolePoint
  */


	PanoViewer.prototype.setShowPolePoint = function setShowPolePoint(showPolePoint) {
		return this._yawPitchControl.option("showPolePoint", showPolePoint);
	};

	/**
  * Set a new view by setting camera configuration. Any parameters not specified remain the same.
  * @ko 카메라 설정을 지정하여 화면을 갱신합니다. 지정되지 않은 매개 변수는 동일하게 유지됩니다.
  * @method eg.view360.PanoViewer#lookAt
  * @param {Object} orientation
  * @param {Number} orientation.yaw Target yaw in degree <ko>목표 yaw (degree 단위)</ko>
  * @param {Number} orientation.pitch Target pitch in degree <ko>목표 pitch (degree 단위)</ko>
  * @param {Number} orientation.fov Target vertical fov in degree <ko>목표 수직 fov (degree 단위)</ko>
  * @param {Number} duration Animation duration in milliseconds <ko>애니메이션 시간 (밀리 초)</ko>
  */


	PanoViewer.prototype.lookAt = function lookAt(orientation, duration) {
		if (!this._isReady) {
			return;
		}

		var yaw = orientation.yaw !== undefined ? orientation.yaw : this._yaw;
		var pitch = orientation.pitch !== undefined ? orientation.pitch : this._pitch;
		var pitchRange = this._yawPitchControl.option("pitchRange");
		var verticalAngleOfImage = pitchRange[1] - pitchRange[0];
		var fov = orientation.fov !== undefined ? orientation.fov : this._fov;

		if (verticalAngleOfImage < fov) {
			fov = verticalAngleOfImage;
		}

		this._yawPitchControl.lookAt({ yaw: yaw, pitch: pitch, fov: fov }, duration);

		if (duration === 0) {
			this._photoSphereRenderer.render(yaw, pitch, fov);
		}
	};

	PanoViewer.prototype._activate = function _activate() {
		this._photoSphereRenderer.attachTo(this._container);
		this._yawPitchControl.enable();

		this.updateViewportDimensions();

		this._isReady = true;
		this._triggerEvent(_consts.EVENTS.READY);
		this._startRender();
	};

	/**
  * Register the callback on the raf to call _renderLoop every frame.
  */


	PanoViewer.prototype._startRender = function _startRender() {
		this._renderLoop = this._renderLoop.bind(this);
		this._rafId = window.requestAnimationFrame(this._renderLoop);
	};

	PanoViewer.prototype._renderLoop = function _renderLoop() {
		if (this._photoSphereRenderer) {
			if (this._quaternion) {
				this._photoSphereRenderer.renderWithQuaternion(this._quaternion, this._fov);
			} else {
				this._photoSphereRenderer.render(this._yaw, this._pitch, this._fov);
			}
		}
		this._rafId = window.requestAnimationFrame(this._renderLoop);
	};

	PanoViewer.prototype._stopRender = function _stopRender() {
		if (this._rafId) {
			window.cancelAnimationFrame(this._rafId);
			delete this._rafId;
		}
	};

	/**
  * Destroy webgl context and block user interaction and stop rendering
  */


	PanoViewer.prototype._deactivate = function _deactivate() {
		if (this._photoSphereRenderer) {
			this._photoSphereRenderer.destroy();
			this._photoSphereRenderer = null;
		}

		if (this._isReady) {
			this._yawPitchControl.disable();
			this._stopRender();
			this._isReady = false;
		}
	};

	PanoViewer._isValidTouchDirection = function _isValidTouchDirection(direction) {
		return direction === PanoViewer.TOUCH_DIRECTION.NONE || direction === PanoViewer.TOUCH_DIRECTION.YAW || direction === PanoViewer.TOUCH_DIRECTION.PITCH || direction === PanoViewer.TOUCH_DIRECTION.ALL;
	};

	/**
  * Set touch direction by which user can control.
  * @ko 사용자가 조작가능한 터치 방향을 지정한다.
  * @method eg.view360.PanoViewer#setTouchDirection
  * @param {Number} direction of the touch. {@link eg.PanoViewer.TOUCH_DIRECTION}<ko>컨트롤 가능한 방향 {@link eg.PanoViewer.TOUCH_DIRECTION}</ko>
  * @return {eg.PanoViewer} PanoViewer instance
  * @example
  *
  * panoViewer = new PanoViewer(el);
  * // Limit the touch direction to the yaw direction only.
  * panoViewer.setTouchDirection(PanoViewer.TOUCH_DIRECTION.YAW);
  */


	PanoViewer.prototype.setTouchDirection = function setTouchDirection(direction) {
		if (PanoViewer._isValidTouchDirection(direction)) {
			this._yawPitchControl.option("touchDirection", direction);
		}

		return this;
	};

	/**
  * Returns touch direction by which user can control
  * @ko 사용자가 조작가능한 터치 방향을 반환한다.
  * @method eg.view360.PanoViewer#getTouchDirection
  * @return {Number} direction of the touch. {@link eg.PanoViewer.TOUCH_DIRECTION}<ko>컨트롤 가능한 방향 {@link eg.PanoViewer.TOUCH_DIRECTION}</ko>
  * @example
  *
  * panoViewer = new PanoViewer(el);
  * // Returns the current touch direction.
  * var dir = panoViewer.getTouchDirection();
  */


	PanoViewer.prototype.getTouchDirection = function getTouchDirection() {
		return this._yawPitchControl.option("touchDirection");
	};

	/**
  * Destroy viewer. Remove all registered event listeners and remove viewer canvas.
  * @ko 뷰어 인스턴스를 해제합니다. 모든 등록된 이벤트리스너를 제거하고 뷰어 캔버스를 삭제한다.
  * @method eg.view360.PanoViewer#destroy
  */


	PanoViewer.prototype.destroy = function destroy() {
		this._deactivate();

		if (this._yawPitchControl) {
			this._yawPitchControl.destroy();
			this._yawPitchControl = null;
		}
	};

	PanoViewer.isWebGLAvailable = function isWebGLAvailable() {
		return _WebGLUtils2["default"].isWebGLAvailable();
	};

	/**
  * Check whether the current environment supports the gyro sensor.
  * @ko 현재 브라우저 환경이 자이로 센서를 지원하는지 여부를 확인합니다.
  * @function isGyroSensorAvailable
  * @memberof eg.view360.PanoViewer
  * @param {Function} callback Function to take the gyro sensor availability as argument <ko>자이로 센서를 지원하는지 여부를 인자로 받는 함수</ko>
  * @static
  */


	PanoViewer.isGyroSensorAvailable = function isGyroSensorAvailable(callback) {
		if (!_browser.DeviceMotionEvent) {
			callback && callback(false);
			return;
		}

		var onDeviceMotionChange = void 0;

		function checkGyro() {
			return new _Promise(function (res, rej) {
				onDeviceMotionChange = function onDeviceMotionChange(deviceMotion) {
					var isGyroSensorAvailable = deviceMotion.rotationRate.alpha !== null;

					res(isGyroSensorAvailable);
				};

				window.addEventListener("devicemotion", onDeviceMotionChange);
			});
		}

		function timeout() {
			return new _Promise(function (res, rej) {
				setTimeout(function () {
					return res(false);
				}, 1000);
			});
		}

		_Promise.race([checkGyro(), timeout()]).then(function (isGyroSensorAvailable) {
			window.removeEventListener("devicemotion", onDeviceMotionChange);

			callback && callback(isGyroSensorAvailable);

			PanoViewer.isGyroSensorAvailable = function (fb) {
				fb && fb(isGyroSensorAvailable);
				return isGyroSensorAvailable;
			};
		});
	};

	return PanoViewer;
}(_component2["default"]);

exports["default"] = PanoViewer;


PanoViewer.ERROR_TYPE = _consts.ERROR_TYPE;
PanoViewer.EVENTS = _consts.EVENTS;
PanoViewer.ProjectionType = _consts.PROJECTION_TYPE;
/**
 * Constant value for touch directions
 * @ko 터치 방향에 대한 상수 값.
 * @namespace
 * @name TOUCH_DIRECTION
 * @memberof eg.PanoViewer
 */
PanoViewer.TOUCH_DIRECTION = {
	/**
  * Constant value for none direction.
  * @ko none 방향에 대한 상수 값.
  * @name NONE
  * @memberof eg.PanoViewer.TOUCH_DIRECTION
  * @constant
  * @type {Number}
  * @default 1
  */
	NONE: _YawPitchControl.YawPitchControl.TOUCH_DIRECTION_NONE,
	/**
  * Constant value for horizontal(yaw) direction.
  * @ko horizontal(yaw) 방향에 대한 상수 값.
  * @name YAW
  * @memberof eg.PanoViewer.TOUCH_DIRECTION
  * @constant
  * @type {Number}
  * @default 6
  */
	YAW: _YawPitchControl.YawPitchControl.TOUCH_DIRECTION_YAW,
	/**
  * Constant value for vertical direction.
  * @ko vertical(pitch) 방향에 대한 상수 값.
  * @name PITCH
  * @memberof eg.PanoViewer.TOUCH_DIRECTION
  * @constant
  * @type {Number}
  * @default 24
  */
	PITCH: _YawPitchControl.YawPitchControl.TOUCH_DIRECTION_PITCH,
	/**
  * Constant value for all direction.
  * @ko all 방향에 대한 상수 값.
  * @name ALL
  * @memberof eg.PanoViewer.TOUCH_DIRECTION
  * @constant
  * @type {Number}
  * @default 30
  */
	ALL: _YawPitchControl.YawPitchControl.TOUCH_DIRECTION_ALL
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var win = window;

exports.window = win;
var DeviceMotionEvent = exports.DeviceMotionEvent = win.DeviceMotionEvent;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.PanoViewer = undefined;

var _PanoViewer = __webpack_require__(29);

var _PanoViewer2 = _interopRequireDefault(_PanoViewer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

exports.PanoViewer = _PanoViewer2["default"];

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

var _axes = __webpack_require__(11);

var _axes2 = _interopRequireDefault(_axes);

var _SpriteImage = __webpack_require__(14);

var _SpriteImage2 = _interopRequireDefault(_SpriteImage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DEFAULT_PAN_SCALE = 0.21;

/**
 * @class eg.view360.SpinViewer
 * @classdesc A module used to displays each image sequentially according to the direction of the user's touch movement (left / right) of the sprite image that is collected by rotating the object.
 * @ko 물체 주위를 회전하여 촬영한 이미지들을 모은 스프라이트 이미지를 사용자의 터치 이동 방향(좌 / 우) 에 따라 각 이미지들을 순차적으로 보여주는 컴포넌트입니다.
 * @extends eg.Component
 *
 * @param {HTMLElement} element The element to show the image <ko>이미지를 보여줄 대상 요소</ko>
 * @param {Object} options The option object<ko>파라미터 객체</ko>
 * @param {String} options.imageUrl The url of the sprite image <ko>스프라이트 이미지의 url</ko>
 * @param {Number} [options.rowCount=1] Number of horizontal frames in the sprite image <ko>스프라이트 이미지의 가로 프레임 갯수</ko>
 * @param {Number} [options.colCount=1] Number of vertical frames in the sprite image <ko>스프라이트 이미지의 세로 프레임 갯수</ko>
 * @param {Number|String} [options.width="auto"] The width of the target element to show the image <ko>이미지를 보여줄 대상 요소의 너비</ko>
 * @param {Number|String} [options.height="auto"] The height of the target element to show the image <ko>이미지를 보여줄 대상 요소의 높이</ko>
 * @param {Boolean} [options.autoHeight=true] Whether to automatically set the height of the image area to match the original image's proportion <ko>원본 이미지 비율에 맞게 이미지 영역의 높이를 자동으로 설정할지 여부</ko>
 * @param {Number[]} [options.colRow=[0, 0]] The column, row coordinates of the first frame of the sprite image (based on 0 index) <ko> 스프라이트 이미지 중 처음 보여줄 프레임의 (column, row) 좌표 (0 index 기반)</ko>
 * @param {Number} [options.scale=1] Spin scale (The larger the spin, the more).<ko>Spin 배율 (클 수록 더 많이 움직임)</ko>
 * @support {"ie": "9+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.3+ (except 3.x)"}
 * @example
 *
 * // Initialize SpinViewer
 * var el = document.getElementById("product-360");
 * var viewer = new eg.view360.SpinViewer(el, {
 * 	imageUrl: "/img/bag360.jpg", // required
 * 	rowCount: 24 //required
 * });
 */

var SpinViewer = function (_Component) {
	_inherits(SpinViewer, _Component);

	function SpinViewer(element, options) {
		_classCallCheck(this, SpinViewer);

		var _this = _possibleConstructorReturn(this, _Component.call(this));

		_this._el = element;

		var opt = options || {};
		var colCount = opt.colCount || 1;
		var rowCount = opt.rowCount || 1;

		_this._scale = (opt.scale || 1) * DEFAULT_PAN_SCALE;

		_this._frameCount = colCount * rowCount;

		// Init SpriteImage
		_this._sprites = new _SpriteImage2["default"](element, opt).on({
			"load": function load(evt) {
				/**
     * Events that occur when component loading is complete
     * @ko 컴포넌트 로딩이 완료되면 발생하는 이벤트
     * @name eg.view360.SpinViewer#load
     * @event
     * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @param {HTMLElement} param.target The target element for which to display the image <ko>이미지를 보여줄 대상 엘리먼트</ko>
     * @param {HTMLElement} param.bgElement Generated background image element <ko>생성된 background 이미지 엘리먼트</ko>
     *
     * @example
     *
     * viwer.on({
     *	"load" : function(evt) {
     *		this.spinBy({angle: 360, duration: 300});
     *	}
     * });
     */
				_this.trigger("load", evt);
			},
			"imageError": function imageError(evt) {
				/**
     * An event that occurs when the image index is changed by the user's left / right panning
     * @ko 사용자의 좌우 Panning 에 의해 이미지 인덱스가 변경되었을때 발생하는 이벤트
     * @name eg.view360.SpinViewer#imageError
     * @event
     * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @param {String} param.imageUrl User-specified image URL <ko>사용자가 지정한 이미지 URL</ko>
     *
     * @example
     *
     * viewer.on({
     *	"imageError" : function(evt) {
     *		// Error handling
     *		console.log(e.imageUrl);
     *	}
     * });
     */
				_this.trigger("imageError", {
					imageUrl: evt.imageUrl
				});
			}
		});

		// Init Axes
		_this._panInput = new _axes.PanInput(_this._el, {
			scale: [_this._scale, _this._scale]
		});
		_this._axes = new _axes2["default"]({
			angle: {
				range: [0, 359],
				circular: true
			}
		}).on({
			"change": function change(evt) {
				var curr = Math.floor(evt.pos.angle / (360 / _this._frameCount));
				var frameIndex = _this._frameCount - curr - 1;

				_this._sprites.setFrameIndex(frameIndex);

				/**
     * An event that occurs when the image index is changed by the user's left / right panning
     * @ko 사용자의 좌우 Panning 에 의해 이미지 인덱스가 변경되었을때 발생하는 이벤트
     * @name eg.view360.SpinViewer#change
     * @event
     * @param {Object} param The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @param {Number[]} param.colRow Column, row of the frame in the sprite image <ko>스프라이트 이미지 내 프레임의 column, row</ko>
     * @param {Number} param.frameIndex Index value that is sequentially appended in Z direction based on col and row.<ko>col, row 를 기반으로 Z 방향으로 순차적으로 붙여지는 index 값</ko>
     * @param {Number} param.angle The angle that is currently internally held at an angle between 0 and 359. (not a real product angle) <ko>0 ~ 359 범위의 각도로 현재 내부적으로 유지하고 있는 각도 (실제 이미지의 각도가 아님)</ko>
     *
     * @example
     *
     * viwer.on({
     *	"change" : function(evt) {
     *		console.log(event.frameIndex, event.colRow, event.angle);   // event.colRow = [0, 4] event.frameIndex = 4, event = 30
     *	}
     * });
     */
				_this.trigger("change", {
					frameIndex: frameIndex,
					colRow: _this._sprites.getColRow(),
					angle: evt.pos.angle
				});
			}
		});

		_this._axes.connect("angle", _this._panInput);
		return _this;
	}

	/**
  * Set spin scale
  * @ko scale 을 조정할 수 있는 함수
  * @method eg.view360.SpinViewer#setScale
  * @param {Number} scale Rotation multiples at spin, the larger the rotation<ko>Spin 시 회전 배수값, 커질 수록 더 많이 회전</ko>
  *
  * @return {Object} Instance of SpinViewer <ko>SpinViewer 인스턴스</ko>
  *
  * @example
  *
  * viewer.setScale(2);// It moves twice as much.
  */


	SpinViewer.prototype.setScale = function setScale(scale) {
		if (isNaN(scale) || scale < 0) {
			return this;
		}

		this._scale = scale * DEFAULT_PAN_SCALE;
		this._panInput.options.scale = [this._scale, this._scale];

		return this;
	};

	/**
  * It gives the effect of rotating at a specified angle for a certain period of time(duration).
  * @ko 지정된 각도(angle)로 일정 시간동안(duration) 회전하는 효과를 준다.
  * @method eg.view360.SpinViewer#spinBy
  * @param {Object} param The parameter object<ko>파라미터 객체</ko>
  * @param {Number} [param.angle=0] angle<ko>회전 각도</ko>
  * @param {Number} [param.duration=400] duration<ko>회전할 시간 - 밀리세컨드 단위</ko>
  *
  * @return {Object} Instance of SpinViewer <ko>SpinViewer 인스턴스</ko>
  *
  * @example
  *
  * viewer.spinBy({angle: 720, duration: 500});
  */


	SpinViewer.prototype.spinBy = function spinBy(_ref) {
		var _ref$angle = _ref.angle,
		    angle = _ref$angle === undefined ? 0 : _ref$angle,
		    _ref$duration = _ref.duration,
		    duration = _ref$duration === undefined ? 400 : _ref$duration;

		this._axes.setBy({ angle: angle }, duration);

		return this;
	};

	return SpinViewer;
}(_component2["default"]);

exports["default"] = SpinViewer;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.SpriteImage = exports.SpinViewer = undefined;

var _SpinViewer = __webpack_require__(32);

var _SpinViewer2 = _interopRequireDefault(_SpinViewer);

var _SpriteImage = __webpack_require__(14);

var _SpriteImage2 = _interopRequireDefault(_SpriteImage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

exports.SpinViewer = _SpinViewer2["default"];
exports.SpriteImage = _SpriteImage2["default"];


_SpinViewer2["default"].VERSION = "3.0.0-rc";

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

var _FusionPoseSensor = __webpack_require__(17);

var _FusionPoseSensor2 = _interopRequireDefault(_FusionPoseSensor);

var _ScreenRotationAngle = __webpack_require__(15);

var _ScreenRotationAngle2 = _interopRequireDefault(_ScreenRotationAngle);

var _mathUtil = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ORIGIN_VECTOR = _mathUtil.vec3.fromValues(0, 0, 0);
var X_AXIS_VECTOR = _mathUtil.vec3.fromValues(1, 0, 0);
var Y_AXIS_VECTOR = _mathUtil.vec3.fromValues(0, 1, 0);

var DeviceQuaternion = function (_Component) {
	_inherits(DeviceQuaternion, _Component);

	function DeviceQuaternion() {
		_classCallCheck(this, DeviceQuaternion);

		var _this = _possibleConstructorReturn(this, _Component.call(this));

		_this._screenRotationAngle = new _ScreenRotationAngle2["default"]();
		_this._fusionPoseSensor = new _FusionPoseSensor2["default"]();
		_this._quaternion = _mathUtil.quat.create();

		_this._fusionPoseSensor.enable();
		_this._fusionPoseSensor.on("change", function (e) {
			_this._quaternion = e.quaternion;

			_this.trigger("change", { isTrusted: true });
		});
		return _this;
	}

	DeviceQuaternion.prototype.getCombinedQuaternion = function getCombinedQuaternion(yaw, pitch) {
		var deviceR = this._screenRotationAngle.getRadian();

		// rotate x-axis around z-axis about screen rotation angle.
		var pitchAxis = _mathUtil.vec3.rotateZ(_mathUtil.vec3.create(), X_AXIS_VECTOR, ORIGIN_VECTOR, deviceR);
		var yawQ = _mathUtil.quat.setAxisAngle(_mathUtil.quat.create(), Y_AXIS_VECTOR, _mathUtil.glMatrix.toRadian(-yaw));
		// rotate quaternion around new x-axis about pitch angle.
		var pitchQ = _mathUtil.quat.setAxisAngle(_mathUtil.quat.create(), pitchAxis, _mathUtil.glMatrix.toRadian(-pitch));
		var conj = _mathUtil.quat.conjugate(_mathUtil.quat.create(), this._quaternion);
		// Multiply pitch quaternion -> device quaternion -> yaw quaternion
		var outQ = _mathUtil.quat.multiply(_mathUtil.quat.create(), pitchQ, conj);

		_mathUtil.quat.multiply(outQ, outQ, yawQ);
		return outQ;
	};

	DeviceQuaternion.prototype.destroy = function destroy() {
		// detach all event handler
		this.off();

		if (this._fusionPoseSensor) {
			this._fusionPoseSensor.off();
			this._fusionPoseSensor.destroy();
			this._fusionPoseSensor = null;
		}

		if (this._screenRotationAngle) {
			this._screenRotationAngle.unref();
			this._screenRotationAngle = null;
		}
	};

	return DeviceQuaternion;
}(_component2["default"]);

exports["default"] = DeviceQuaternion;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

var _axes = __webpack_require__(11);

var _axes2 = _interopRequireDefault(_axes);

var _browser = __webpack_require__(3);

var _WheelInput = __webpack_require__(40);

var _WheelInput2 = _interopRequireDefault(_WheelInput);

var _TiltMotionInput = __webpack_require__(39);

var _TiltMotionInput2 = _interopRequireDefault(_TiltMotionInput);

var _RotationPanInput = __webpack_require__(38);

var _RotationPanInput2 = _interopRequireDefault(_RotationPanInput);

var _DeviceQuaternion = __webpack_require__(34);

var _DeviceQuaternion2 = _interopRequireDefault(_DeviceQuaternion);

var _mathUtil = __webpack_require__(1);

var _consts = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DEFAULT_YAW_RANGE = [-_consts.YAW_RANGE_HALF, _consts.YAW_RANGE_HALF];
var DEFAULT_PITCH_RANGE = [-_consts.PITCH_RANGE_HALF, _consts.PITCH_RANGE_HALF];
var CIRCULAR_PITCH_RANGE = [-_consts.CIRCULAR_PITCH_RANGE_HALF, _consts.CIRCULAR_PITCH_RANGE_HALF];
/**
 * A module used to provide coordinate based on yaw/pitch orientation. This module receives user touch action, keyboard, mouse and device orientation(if it exists) as input, then combines them and converts it to yaw/pitch coordinates.
 *
 * @alias eg.YawPitchControl
 * @extends eg.Component
 *
 * @support {"ie": "10+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.3+ (except 3.x)"}
 */
var YawPitchControl = function (_Component) {
	_inherits(YawPitchControl, _Component);

	/**
  * @param {Object} options The option object of the eg.YawPitch module
  * @param {Element}[options.element=null] element A base element for the eg.YawPitch module
  * @param {Number} [options.yaw=0] initial yaw (degree)
  * @param {Number} [options.pitch=0] initial pitch (degree)
  * @param {Number} [options.fov=65] initial field of view (degree)
  * @param {Boolean} [optiosn.showPolePoint=true] Indicates whether pole is shown
  * @param {Boolean} [options.useZoom=true] Indicates whether zoom is available
  * @param {Boolean} [options.useKeyboard=true] Indicates whether keyboard is enabled
  * @param {String} [config.gyroMode=yawPitch] Enables control through device motion.
  * @param {Number} [options.touchDirection=TOUCH_DIRECTION_ALL] Direction of the touch movement (TOUCH_DIRECTION_ALL: all,  TOUCH_DIRECTION_YAW: horizontal, TOUCH_DIRECTION_PITCH: vertical, TOUCH_DIRECTION_NONE: no move)
  * @param {Array} [options.yawRange=[-180, 180] Range of visible yaw
  * @param {Array} [options.pitchRange=[-90, 90] Range of visible pitch
  * @param {Array} [options.fovRange=[30, 110] Range of FOV
  * @param {Number} [options.aspectRatio=1] Aspect Ratio
  */
	function YawPitchControl(options) {
		_classCallCheck(this, YawPitchControl);

		var _this = _possibleConstructorReturn(this, _Component.call(this));

		var opt = _extends({
			element: null,
			yaw: 0,
			pitch: 0,
			fov: 65,
			showPolePoint: false,
			useZoom: true,
			useKeyboard: true,
			gyroMode: _consts.GYRO_MODE.YAWPITCH,
			touchDirection: _consts.TOUCH_DIRECTION_ALL,
			yawRange: DEFAULT_YAW_RANGE,
			pitchRange: DEFAULT_PITCH_RANGE,
			fovRange: [30, 110],
			aspectRatio: 1 /* TODO: Need Mandatory? */
		}, options);

		_this._element = opt.element;
		_this._initialFov = opt.fov;
		_this._enabled = false;
		_this._isAnimating = false;
		_this._deviceQuaternion = null;

		_this._initAxes(opt);
		_this.option(opt);
		return _this;
	}

	YawPitchControl.prototype._initAxes = function _initAxes(opt) {
		var _this2 = this;

		var yRange = this._updateYawRange(opt.yawRange, opt.fov, opt.aspectRatio);
		var pRange = this._updatePitchRange(opt.pitchRange, opt.fov, opt.showPolePoint);
		var useRotation = opt.gyroMode === _consts.GYRO_MODE.VR;

		this.axesPanInput = new _RotationPanInput2["default"](this._element, { useRotation: useRotation });
		this.axesWheelInput = new _WheelInput2["default"](this._element, { scale: 4 });
		// this.axesTiltMotionInput = SUPPORT_DEVICEMOTION ? new TiltMotionInput(this._element) : null;
		this.axesTiltMotionInput = null;
		this.axesPinchInput = _browser.SUPPORT_TOUCH ? new _axes.PinchInput(this._element, { scale: -1 }) : null;
		this.axesMoveKeyInput = new _axes.MoveKeyInput(this._element, { scale: [-6, 6] });

		this.axes = new _axes2["default"]({
			yaw: {
				range: yRange,
				circular: YawPitchControl.isCircular(yRange),
				bounce: [0, 0]
			},
			pitch: {
				range: pRange,
				circular: YawPitchControl.isCircular(pRange),
				bounce: [0, 0]
			},
			fov: {
				range: opt.fovRange,
				circular: [false, false],
				bounce: [0, 0]
			}
		}, {
			deceleration: _consts.MC_DECELERATION,
			maximumDuration: _consts.MC_MAXIMUM_DURATION
		}, {
			yaw: opt.yaw,
			pitch: opt.pitch,
			fov: opt.fov
		}).on({
			hold: function hold(evt) {
				_this2.trigger("hold", { isTrusted: evt.isTrusted });
			},
			change: function change(evt) {
				if (evt.delta.fov !== 0) {
					_this2._setPanScale(evt.pos.fov);
					_this2._updateControlScale(evt);
				}
				_this2._triggerChange(evt);
			},
			release: function release(evt) {
				_this2._triggerChange(evt);
			},
			animationStart: function animationStart(evt) {},
			animationEnd: function animationEnd(evt) {
				_this2.trigger("animationEnd", { isTrusted: evt.isTrusted });
			}
		});
	};

	YawPitchControl.prototype._setPanScale = function _setPanScale(fov) {
		var areaHeight = parseInt((0, _browser.getComputedStyle)(this._element).height, 10);
		var scale = _consts.MC_BIND_SCALE[0] * fov / this._initialFov * _consts.PAN_SCALE / areaHeight;

		this.axesPanInput.options.scale = [scale, scale];
		this.axes.options.deceleration = _consts.MC_DECELERATION * fov / _consts.MAX_FIELD_OF_VIEW;
	};

	/*
  * Override component's option method
  * to call method for updating values which is affected by option change.
  *
  * @param {*} args
  */


	YawPitchControl.prototype.option = function option() {
		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		var argLen = args.length;

		// Getter
		if (argLen === 0) {
			return this._getOptions();
		} else if (argLen === 1 && typeof args[0] === "string") {
			return this._getOptions(args[0]);
		}

		// Setter
		var beforeOptions = _extends({}, this.options);
		var newOptions = {};
		var changedKeyList = []; // TODO: if value is not changed, then do not push on changedKeyList.

		if (argLen === 1) {
			changedKeyList = Object.keys(args[0]);
			newOptions = _extends({}, args[0]);
		} else if (argLen >= 2) {
			changedKeyList.push(args[0]);
			newOptions[args[0]] = args[1];
		}

		this._setOptions(this._getValidatedOptions(newOptions));
		this._applyOptions(changedKeyList, beforeOptions);
		return this;
	};

	YawPitchControl.prototype._getValidatedOptions = function _getValidatedOptions(newOptions) {
		if (newOptions.yawRange) {
			newOptions.yawRange = this._getValidYawRange(newOptions.yawRange, newOptions.fov, newOptions.aspectRatio);
		}
		if (newOptions.pitchRange) {
			newOptions.pitchRange = this._getValidPitchRange(newOptions.pitchRange, newOptions.fov);
		}
		return newOptions;
	};

	YawPitchControl.prototype._getOptions = function _getOptions(key) {
		var value = void 0;

		if (typeof key === "string") {
			value = this.options[key];
		} else if (arguments.length === 0) {
			value = this.options;
		}
		return value;
	};

	YawPitchControl.prototype._setOptions = function _setOptions(options) {
		for (var key in options) {
			this.options[key] = options[key];
		}
	};

	YawPitchControl.prototype._applyOptions = function _applyOptions(keys, prevOptions) {
		// If one of below is changed, call updateControlScale()
		if (keys.some(function (key) {
			return key === "showPolePoint" || key === "fov" || key === "aspectRatio" || key === "yawRange" || key === "pitchRange";
		})) {
			this._updateControlScale();
		}

		if (keys.some(function (key) {
			return key === "fovRange";
		})) {
			var fovRange = this.options.fovRange;
			var prevFov = this.axes.get().fov;
			var nextFov = this.axes.get().fov;

			_mathUtil.vec2.copy(this.axes.axis.fov.range, fovRange);

			if (nextFov < fovRange[0]) {
				nextFov = fovRange[0];
			} else if (prevFov > fovRange[1]) {
				nextFov = fovRange[1];
			}

			if (prevFov !== nextFov) {
				this.axes.setTo({
					fov: nextFov
				}, 0);
				this._updateControlScale();
			}
		}

		if (keys.some(function (key) {
			return key === "gyroMode";
		}) && _browser.SUPPORT_DEVICEMOTION) {
			var gyroMode = this.options.gyroMode;

			// Disconnect first
			if (this.axesTiltMotionInput) {
				this.axes.disconnect(this.axesTiltMotionInput);
				this.axesTiltMotionInput.destroy();
				this.axesTiltMotionInput = null;
			}

			if (this._deviceQuaternion) {
				this._deviceQuaternion.destroy();
				this._deviceQuaternion = null;
			}

			if (gyroMode === _consts.GYRO_MODE.YAWPITCH) {
				this.axesTiltMotionInput = new _TiltMotionInput2["default"](this._element);
				this.axes.connect(["yaw", "pitch"], this.axesTiltMotionInput);
			} else if (gyroMode === _consts.GYRO_MODE.VR) {
				this._initDeviceQuaternion();
			}
		}

		if (keys.some(function (key) {
			return key === "useKeyboard";
		})) {
			var useKeyboard = this.options.useKeyboard;

			if (useKeyboard) {
				this.axes.connect(["yaw", "pitch"], this.axesMoveKeyInput);
			} else {
				this.axes.disconnect(this.axesMoveKeyInput);
			}
		}

		if (keys.some(function (key) {
			return key === "useZoom";
		})) {
			var useZoom = this.options.useZoom;

			if (useZoom) {
				this.axes.connect(["fov"], this.axesWheelInput);
				this.axesPinchInput && this.axes.connect(["fov"], this.axesPinchInput);
			} else {
				this.axes.disconnect(this.axesWheelInput);
				this.axesPinchInput && this.axes.disconnect(this.axesPinchInput);
			}
		}

		if (keys.some(function (key) {
			return key === "touchDirection";
		})) {
			this._enabled && this._enableTouch(this.options.touchDirection);
		}
	};

	YawPitchControl.prototype._enableTouch = function _enableTouch(direction) {
		var yawEnabled = direction & _consts.TOUCH_DIRECTION_YAW ? "yaw" : null;
		var pitchEnabled = direction & _consts.TOUCH_DIRECTION_PITCH ? "pitch" : null;

		this.axes.connect([yawEnabled, pitchEnabled], this.axesPanInput);
	};

	YawPitchControl.prototype._initDeviceQuaternion = function _initDeviceQuaternion() {
		var _this3 = this;

		this._deviceQuaternion = new _DeviceQuaternion2["default"]();

		this._deviceQuaternion.on("change", function (e) {
			_this3._triggerChange(e);
		});
	};

	YawPitchControl.prototype._getValidYawRange = function _getValidYawRange(newYawRange, newFov, newAspectRatio) {
		var ratio = YawPitchControl.adjustAspectRatio(newAspectRatio || this.options.aspectRatio || 1);
		var fov = newFov || this.axes.get().fov;
		var horizontalFov = fov * ratio;
		var isValid = newYawRange[1] - newYawRange[0] >= horizontalFov;

		if (isValid) {
			return newYawRange;
		} else {
			return this.options.yawRange || DEFAULT_YAW_RANGE;
		}
	};

	YawPitchControl.prototype._getValidPitchRange = function _getValidPitchRange(newPitchRange, newFov) {
		var fov = newFov || this.axes.get().fov;
		var isValid = newPitchRange[1] - newPitchRange[0] >= fov;

		if (isValid) {
			return newPitchRange;
		} else {
			return this.options.pitchRange || DEFAULT_PITCH_RANGE;
		}
	};

	YawPitchControl.isCircular = function isCircular(range) {
		return range[1] - range[0] < 360 ? [false, false] : [true, true];
	};

	/**
  * Update yaw/pitch min/max by 5 factor
  *
  * 1. showPolePoint
  * 2. fov
  * 3. yawRange
  * 4. pitchRange
  * 5. aspectRatio
  *
  * If one of above is changed, call this function
  */


	YawPitchControl.prototype._updateControlScale = function _updateControlScale(changeEvt) {
		var opt = this.options;
		var fov = this.axes.get().fov;

		var pRange = this._updatePitchRange(opt.pitchRange, fov, opt.showPolePoint);
		var yRange = this._updateYawRange(opt.yawRange, fov, opt.aspectRatio);

		// TODO: If not changed!?
		var pos = this.axes.get();
		var y = pos.yaw;
		var p = pos.pitch;

		_mathUtil.vec2.copy(this.axes.axis.yaw.range, yRange);
		_mathUtil.vec2.copy(this.axes.axis.pitch.range, pRange);
		this.axes.axis.yaw.circular = YawPitchControl.isCircular(yRange);
		this.axes.axis.pitch.circular = YawPitchControl.isCircular(pRange);

		/**
   * update yaw/pitch by it's range.
   */
		if (y < yRange[0]) {
			y = yRange[0];
		} else if (y > yRange[1]) {
			y = yRange[1];
		}

		if (p < pRange[0]) {
			p = pRange[0];
		} else if (p > pRange[1]) {
			p = pRange[1];
		}

		if (changeEvt) {
			changeEvt.set({
				yaw: y,
				pitch: p
			});
		}

		this.axes.setTo({
			yaw: y,
			pitch: p
		}, 0);

		return this;
	};

	YawPitchControl.prototype._updatePitchRange = function _updatePitchRange(pitchRange, fov, showPolePoint) {
		if (this.options.gyroMode === _consts.GYRO_MODE.VR) {
			// Circular pitch on VR
			return CIRCULAR_PITCH_RANGE;
		}

		var verticalAngle = pitchRange[1] - pitchRange[0];
		var halfFov = fov / 2;
		var isPanorama = verticalAngle < 180;

		if (showPolePoint && !isPanorama) {
			// Use full pinch range
			return pitchRange.map(function (v) {
				return +v.toFixed(5);
			});
		}

		// Round value as movableCood do.
		return [pitchRange[0] + halfFov, pitchRange[1] - halfFov].map(function (v) {
			return +v.toFixed(5);
		});
	};

	YawPitchControl.prototype._updateYawRange = function _updateYawRange(yawRange, fov, aspectRatio) {
		if (this.options.gyroMode === _consts.GYRO_MODE.VR) {
			return DEFAULT_YAW_RANGE;
		}

		var horizontalAngle = yawRange[1] - yawRange[0];

		/**
   * Full 360 Mode
   */
		if (horizontalAngle >= 360) {
			// Don't limit yaw range on Full 360 mode.
			return yawRange.map(function (v) {
				return +v.toFixed(5);
			});
		}

		/**
   * Panorama mode
   */
		var MAGIC_NUMBER = 1;
		var ratio = YawPitchControl.adjustAspectRatio(aspectRatio);
		var halfHorizontalFov = fov / 2 * ratio;

		// TODO: Magic Number Fix!
		if (horizontalAngle > 290) {
			MAGIC_NUMBER = 0.794; // horizontalAngle = 286;
		} else if (horizontalAngle > 125) {
			MAGIC_NUMBER = 0.98; // horizontalAngle *= 0.98;
		}

		// Round value as movableCood do.
		return [yawRange[0] * MAGIC_NUMBER + halfHorizontalFov, yawRange[1] * MAGIC_NUMBER - halfHorizontalFov].map(function (v) {
			return +v.toFixed(5);
		});
	};

	YawPitchControl.prototype._triggerChange = function _triggerChange(evt) {
		var pos = this.axes.get();
		var opt = this.options;
		var event = {
			targetElement: opt.element,
			isTrusted: evt.isTrusted
		};

		event.yaw = pos.yaw;
		event.pitch = pos.pitch;
		event.fov = pos.fov;

		if (opt.gyroMode === _consts.GYRO_MODE.VR) {
			event.quaternion = this._deviceQuaternion.getCombinedQuaternion(pos.yaw, pos.pitch);
		}
		this.trigger("change", event);
	};

	// TODO: makes constant to be logic


	YawPitchControl.adjustAspectRatio = function adjustAspectRatio(input) {
		var inputRange = [0.520, 0.540, 0.563, 0.570, 0.584, 0.590, 0.609, 0.670, 0.702, 0.720, 0.760, 0.780, 0.820, 0.920, 0.970, 1.00, 1.07, 1.14, 1.19, 1.25, 1.32, 1.38, 1.40, 1.43, 1.53, 1.62, 1.76, 1.77, 1.86, 1.96, 2.26, 2.30, 2.60, 3.00, 5.00, 6.00];
		var outputRange = [0.510, 0.540, 0.606, 0.560, 0.628, 0.630, 0.647, 0.710, 0.736, 0.757, 0.780, 0.770, 0.800, 0.890, 0.975, 1.00, 1.07, 1.10, 1.15, 1.18, 1.22, 1.27, 1.30, 1.33, 1.39, 1.45, 1.54, 1.55, 1.58, 1.62, 1.72, 1.82, 1.92, 2.00, 2.24, 2.30];

		var rangeIdx = -1;

		for (var i = 0; i < inputRange.length - 1; i++) {
			if (inputRange[i] <= input && inputRange[i + 1] >= input) {
				rangeIdx = i;
				break;
			}
		}

		if (rangeIdx === -1) {
			if (inputRange[0] > input) {
				return outputRange[0];
			} else {
				return outputRange[outputRange[0].length - 1];
			}
		}

		var inputA = inputRange[rangeIdx];
		var inputB = inputRange[rangeIdx + 1];
		var outputA = outputRange[rangeIdx];
		var outputB = outputRange[rangeIdx + 1];

		return YawPitchControl.lerp(outputA, outputB, (input - inputA) / (inputB - inputA));
	};

	YawPitchControl.lerp = function lerp(a, b, fraction) {
		return a + fraction * (b - a);
	};

	/**
  * Enable YawPitch functionality
  *
  * @method eg.YawPitch#enable
  */


	YawPitchControl.prototype.enable = function enable() {
		if (this._enabled) {
			return this;
		}

		// touchDirection is decided by parameter is valid string (Ref. Axes.connect)
		this._enableTouch(this.options.touchDirection);

		this._applyOptions(Object.keys(this.options), this.options);
		this._setPanScale(this.getFov());

		this._enabled = true;
		return this;
	};

	/**
  * Disable YawPitch functionality
  *
  * @method eg.YawPitch#disable
  */


	YawPitchControl.prototype.disable = function disable(persistOrientation) {
		if (!this._enabled) {
			return this;
		}

		// TODO: Check peristOrientation is needed!
		if (!persistOrientation) {
			this._resetOrientation();
		}
		this.axes.disconnect();
		this._enabled = false;
		return this;
	};

	YawPitchControl.prototype._resetOrientation = function _resetOrientation() {
		var opt = this.options;

		this.axes.setTo({
			yaw: opt.yaw,
			pitch: opt.pitch,
			fov: opt.fov
		}, 0);

		return this;
	};

	/**
  * Set one or more of yaw, pitch, fov
  *
  * @param {Object} coordinate yaw, pitch, fov
  * @param {Number} duration Animation duration. if it is above 0 then it's animated.
  */


	YawPitchControl.prototype.lookAt = function lookAt(_ref, duration) {
		var yaw = _ref.yaw,
		    pitch = _ref.pitch,
		    fov = _ref.fov;

		var pos = this.axes.get();

		var y = yaw === undefined ? 0 : yaw - pos.yaw;
		var p = pitch === undefined ? 0 : pitch - pos.pitch;
		var f = fov === undefined ? 0 : fov - pos.fov;

		this.axes.setBy({
			yaw: y,
			pitch: p,
			fov: f
		}, duration);
	};

	YawPitchControl.prototype.get = function get() {
		return this.axes.get();
	};

	YawPitchControl.prototype.getYaw = function getYaw() {
		return this.axes.get().yaw;
	};

	YawPitchControl.prototype.getPitch = function getPitch() {
		return this.axes.get().pitch;
	};

	YawPitchControl.prototype.getFov = function getFov() {
		return this.axes.get().fov;
	};

	/**
  * Destroys objects
  */


	YawPitchControl.prototype.destroy = function destroy() {
		this.axes && this.axes.destroy();
		this.axisPanInput && this.axisPanInput.destroy();
		this.axesWheelInput && this.axesWheelInput.destroy();
		this.axesTiltMotionInput && this.axesTiltMotionInput.destroy();
		this.axesDeviceOrientationInput && this.axesDeviceOrientationInput.destroy();
		this.axesPinchInput && this.axesPinchInput.destroy();
		this.axesMoveKeyInput && this.axesMoveKeyInput.destroy();
		this._deviceQuaternion && this._deviceQuaternion.destroy();
	};

	return YawPitchControl;
}(_component2["default"]);

YawPitchControl.VERSION = "3.0.0-rc";
exports["default"] = YawPitchControl;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _mathUtil = __webpack_require__(6);

var _mathUtil2 = _interopRequireDefault(_mathUtil);

var _complementaryFilter = __webpack_require__(65);

var _complementaryFilter2 = _interopRequireDefault(_complementaryFilter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

_complementaryFilter2["default"].prototype.run_ = function () {
	if (!this.isOrientationInitialized) {
		this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
		this.previousFilterQ.copy(this.accelQ);
		this.isOrientationInitialized = true;
		return;
	}

	var deltaT = this.currentGyroMeasurement.timestampS - this.previousGyroMeasurement.timestampS;

	// Convert gyro rotation vector to a quaternion delta.
	var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);

	this.gyroIntegralQ.multiply(gyroDeltaQ);

	// filter_1 = K * (filter_0 + gyro * dT) + (1 - K) * accel.
	this.filterQ.copy(this.previousFilterQ);
	this.filterQ.multiply(gyroDeltaQ);

	// Calculate the delta between the current estimated gravity and the real
	// gravity vector from accelerometer.
	var invFilterQ = new _mathUtil2["default"].Quaternion();

	invFilterQ.copy(this.filterQ);
	invFilterQ.inverse();

	this.estimatedGravity.set(0, 0, -1);
	this.estimatedGravity.applyQuaternion(invFilterQ);
	this.estimatedGravity.normalize();

	this.measuredGravity.copy(this.currentAccelMeasurement.sample);
	this.measuredGravity.normalize();

	// Compare estimated gravity with measured gravity, get the delta quaternion
	// between the two.
	var deltaQ = new _mathUtil2["default"].Quaternion();

	deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
	deltaQ.inverse();

	// Calculate the SLERP target: current orientation plus the measured-estimated
	// quaternion delta.
	var targetQ = new _mathUtil2["default"].Quaternion();

	targetQ.copy(this.filterQ);
	targetQ.multiply(deltaQ);

	// SLERP factor: 0 is pure gyro, 1 is pure accel.
	this.filterQ.slerp(targetQ, 1 - this.kFilter);

	this.previousFilterQ.copy(this.filterQ);

	if (!this.isFilterQuaternionInitialized) {
		this.isFilterQuaternionInitialized = true;
	}
};

_complementaryFilter2["default"].prototype.getOrientation = function () {
	if (this.isFilterQuaternionInitialized) {
		return this.filterQ;
	} else {
		return null;
	}
};

exports["default"] = _complementaryFilter2["default"];

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

var _agent = __webpack_require__(4);

var _agent2 = _interopRequireDefault(_agent);

var _mathUtil = __webpack_require__(1);

var _browser = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var STILLNESS_THRESHOLD = 200; // millisecond

var DeviceMotion = function (_Component) {
	_inherits(DeviceMotion, _Component);

	function DeviceMotion() {
		_classCallCheck(this, DeviceMotion);

		var _this = _possibleConstructorReturn(this, _Component.call(this));

		_this._onDeviceMotion = _this._onDeviceMotion.bind(_this);
		_this._onDeviceOrientation = _this._onDeviceOrientation.bind(_this);

		_this.isAndroid = (0, _agent2["default"])().os.name === "android";

		_this.stillGyroVec = _mathUtil.vec3.create();
		_this.rawGyroVec = _mathUtil.vec3.create();
		_this.adjustedGyroVec = _mathUtil.vec3.create();

		_this._timer = null;

		_this.lastDevicemotionTimestamp = 0;
		_this._isEnabled = false;
		_this.enable();
		return _this;
	}

	DeviceMotion.prototype._onDeviceOrientation = function _onDeviceOrientation() {
		var _this2 = this;

		this._timer && clearTimeout(this._timer);
		this._timer = setTimeout(function () {
			if (new Date().getTime() - _this2.lastDevicemotionTimestamp < STILLNESS_THRESHOLD) {
				_mathUtil.vec3.copy(_this2.stillGyroVec, _this2.rawGyroVec);
			}
		}, STILLNESS_THRESHOLD);
	};

	DeviceMotion.prototype._onDeviceMotion = function _onDeviceMotion(e) {
		// desktop chrome triggers devicemotion event with empthy sensor values.
		// Those events should ignored.
		if (e.interval === 0 || e.acceleration.x === null) {
			return;
		}

		if (this.isAndroid) {
			_mathUtil.vec3.set(this.rawGyroVec, e.rotationRate.alpha || 0, e.rotationRate.beta || 0, e.rotationRate.gamma || 0);
			_mathUtil.vec3.subtract(this.adjustedGyroVec, this.rawGyroVec, this.stillGyroVec);
			this.lastDevicemotionTimestamp = new Date().getTime();

			e.adjustedRotationRate = {
				alpha: this.adjustedGyroVec[0],
				beta: this.adjustedGyroVec[1],
				gamma: this.adjustedGyroVec[2] };
		}

		this.trigger("devicemotion", {
			inputEvent: e
		});
	};

	DeviceMotion.prototype.enable = function enable() {
		if (this.isAndroid) {
			_browser.window.addEventListener("deviceorientation", this._onDeviceOrientation);
		}
		_browser.window.addEventListener("devicemotion", this._onDeviceMotion);
		this._isEnabled = true;
	};

	DeviceMotion.prototype.disable = function disable() {
		if (this.isAndroid) {
			_browser.window.removeEventListener("deviceorientation", this._onDeviceOrientation);
		}
		_browser.window.removeEventListener("devicemotion", this._onDeviceMotion);
		this._isEnabled = false;
	};

	return DeviceMotion;
}(_component2["default"]);

exports["default"] = DeviceMotion;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _axes = __webpack_require__(11);

var _axes2 = _interopRequireDefault(_axes);

var _ScreenRotationAngle = __webpack_require__(15);

var _ScreenRotationAngle2 = _interopRequireDefault(_ScreenRotationAngle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * RotationPanInput is extension of PanInput to compensate coordinates by screen rotation angle.
 *
 * The reason for using this function is that in VR mode,
 * the roll angle is adjusted in the direction opposite to the screen rotation angle.
 *
 * Therefore, the angle that the user touches and moves does not match the angle at which the actual object should move.
 * @extends PanInput
 */
var RotationPanInput = function (_PanInput) {
	_inherits(RotationPanInput, _PanInput);

	/**
  * Constructor
  *
  * @private
  * @param {HTMLElement} el target element
  * @param {Object} [options] The option object
  * @param {Boolean} [options.useRotation]  Whether to use rotation(or VR)
  */
	function RotationPanInput(el, options) {
		_classCallCheck(this, RotationPanInput);

		var _this = _possibleConstructorReturn(this, _PanInput.call(this, el, options));

		_this._useRotation = !!(options && options.useRotation);

		_this._screenRotationAngle = null;
		_this._useRotation && (_this._screenRotationAngle = new _ScreenRotationAngle2["default"]());
		_this._userDirection = _axes2["default"].DIRECTION_ALL;
		return _this;
	}

	RotationPanInput.prototype.connect = function connect(observer) {
		// User intetened direction
		this._userDirection = this._direction;

		// In VR Mode, Use ALL direction if direction is not none
		// Because horizontal and vertical is changed dynamically by screen rotation.
		// this._direction is used to initialize hammerjs
		if (this._useRotation && this._direction & _axes2["default"].DIRECTION_ALL) {
			this._direction = _axes2["default"].DIRECTION_ALL;
		}

		_PanInput.prototype.connect.call(this, observer);
	};

	RotationPanInput.prototype.getOffset = function getOffset(properties, useDirection) {
		if (this._useRotation === false) {
			return _PanInput.prototype.getOffset.call(this, properties, useDirection);
		}

		var offset = _PanInput.prototype.getOffset.call(this, properties, [true, true]);
		var newOffset = [0, 0];
		var theta = this._screenRotationAngle.getRadian();
		var cosTheta = Math.cos(theta);
		var sinTheta = Math.sin(theta);

		newOffset[0] = offset[0] * cosTheta - offset[1] * sinTheta;
		newOffset[1] = offset[1] * cosTheta + offset[0] * sinTheta;

		// Use only user allowed direction.
		if (!(this._userDirection & _axes2["default"].DIRECTION_HORIZONTAL)) {
			newOffset[0] = 0;
		} else if (!(this._userDirection & _axes2["default"].DIRECTION_VERTICAL)) {
			newOffset[1] = 0;
		}

		return newOffset;
	};

	RotationPanInput.prototype.destroy = function destroy() {
		if (this._useRotation) {
			this._screenRotationAngle && this._screenRotationAngle.unref();
		}

		_PanInput.prototype.destroy.call(this);
	};

	return RotationPanInput;
}(_axes.PanInput);

/**
 * Override getDirectionByAngle to return DIRECTION_ALL
 * Ref: https://github.com/naver/egjs-axes/issues/99
 *
 * But we obey axes's rule. If axes's rule is problem, let's apply following code.
 */
// PanInput.getDirectionByAngle = function (angle, thresholdAngle) {
// 	return DIRECTION_ALL;
// };


exports["default"] = RotationPanInput;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

var _utils = __webpack_require__(18);

var _FusionPoseSensor = __webpack_require__(17);

var _FusionPoseSensor2 = _interopRequireDefault(_FusionPoseSensor);

var _mathUtil = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function getDeltaYaw(prvQ, curQ) {
	var yawDeltaByYaw = _mathUtil.util.getRotationDelta(prvQ, curQ, _mathUtil.ROTATE_CONSTANT.YAW_DELTA_BY_YAW);
	var yawDeltaByRoll = _mathUtil.util.getRotationDelta(prvQ, curQ, _mathUtil.ROTATE_CONSTANT.YAW_DELTA_BY_ROLL) * Math.sin(_mathUtil.util.extractPitchFromQuat(curQ));

	return yawDeltaByRoll + yawDeltaByYaw;
}

function getDeltaPitch(prvQ, curQ) {
	var pitchDelta = _mathUtil.util.getRotationDelta(prvQ, curQ, _mathUtil.ROTATE_CONSTANT.PITCH_DELTA);

	return pitchDelta;
}

var TiltMotionInput = function (_Component) {
	_inherits(TiltMotionInput, _Component);

	function TiltMotionInput(el, options) {
		_classCallCheck(this, TiltMotionInput);

		var _this = _possibleConstructorReturn(this, _Component.call(this));

		_this.element = el;

		_this._prevQuaternion = null;
		_this._quaternion = null;

		_this.fusionPoseSensor = null;

		_this.options = _extends({
			scale: 1,
			threshold: 0
		}, options);

		_this._onPoseChange = _this._onPoseChange.bind(_this);
		return _this;
	}

	TiltMotionInput.prototype.mapAxes = function mapAxes(axes) {
		this.axes = axes;
	};

	TiltMotionInput.prototype.connect = function connect(observer) {
		if (this.observer) {
			return this;
		}
		this.observer = observer;
		this.fusionPoseSensor = new _FusionPoseSensor2["default"]();
		this.fusionPoseSensor.enable();
		this._attachEvent();
		return this;
	};

	TiltMotionInput.prototype.disconnect = function disconnect() {
		if (!this.observer) {
			return this;
		}

		this._dettachEvent();
		this.fusionPoseSensor.disable();
		this.fusionPoseSensor.destroy();
		this.fusionPoseSensor = null;
		this.observer = null;
		return this;
	};

	TiltMotionInput.prototype.destroy = function destroy() {
		this.disconnect();
		this.element = null;
		this.options = null;
		this.axes = null;
		this._prevQuaternion = null;
		this._quaternion = null;
	};

	TiltMotionInput.prototype._onPoseChange = function _onPoseChange(event) {
		if (!this._prevQuaternion) {
			this._prevQuaternion = _mathUtil.quat.clone(event.quaternion);
			this._quaternion = _mathUtil.quat.clone(event.quaternion);
			return;
		}

		_mathUtil.quat.copy(this._prevQuaternion, this._quaternion);
		_mathUtil.quat.copy(this._quaternion, event.quaternion);

		this.observer.change(this, event, (0, _utils.toAxis)(this.axes, [getDeltaYaw(this._prevQuaternion, this._quaternion), getDeltaPitch(this._prevQuaternion, this._quaternion)]));
	};

	TiltMotionInput.prototype._attachEvent = function _attachEvent() {
		this.fusionPoseSensor.on("change", this._onPoseChange);
	};

	TiltMotionInput.prototype._dettachEvent = function _dettachEvent() {
		this.fusionPoseSensor.off("change", this._onPoseChange);
	};

	return TiltMotionInput;
}(_component2["default"]);

exports["default"] = TiltMotionInput;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _component = __webpack_require__(0);

var _component2 = _interopRequireDefault(_component);

var _utils = __webpack_require__(18);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WheelInput = function (_Component) {
	_inherits(WheelInput, _Component);

	function WheelInput(el, options) {
		_classCallCheck(this, WheelInput);

		var _this = _possibleConstructorReturn(this, _Component.call(this));

		_this.element = el;

		_this.options = _extends({
			scale: 1,
			threshold: 0
		}, options);

		_this._onWheel = _this._onWheel.bind(_this);
		return _this;
	}

	WheelInput.prototype.mapAxes = function mapAxes(axes) {
		this.axes = axes;
	};

	WheelInput.prototype.connect = function connect(observer) {
		if (this.observer) {
			return this;
		}
		this.observer = observer;
		this._attachEvent();
		return this;
	};

	WheelInput.prototype.disconnect = function disconnect() {
		if (!this.observer) {
			return this;
		}
		this.observer = null;
		this._dettachEvent();
		return this;
	};

	WheelInput.prototype.destroy = function destroy() {
		this.disconnect();
		this.element = null;
		this.options = null;
		this.axes = null;
	};

	WheelInput.prototype._onWheel = function _onWheel(event) {
		event.preventDefault();

		if (event.deltaY === 0) {
			return;
		}

		this.observer.change(this, event, (0, _utils.toAxis)(this.axes, [(event.deltaY < 0 ? -1 : 1) * this.options.scale]));
	};

	WheelInput.prototype._attachEvent = function _attachEvent() {
		this.element.addEventListener("wheel", this._onWheel, false);
	};

	WheelInput.prototype._dettachEvent = function _dettachEvent() {
		this.element.removeEventListener("wheel", this._onWheel, false);
	};

	return WheelInput;
}(_component2["default"]);

exports["default"] = WheelInput;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _common = __webpack_require__(2);

var _common2 = _interopRequireDefault(_common);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
/**
 * Original Code
 * https://github.com/toji/gl-matrix/blob/v2.3.2/src/gl-matrix/mat4.js
 * 4x4 Matrix util
 * modified by egjs
 */
mat4.create = function () {
    var out = new _common2["default"].ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function (out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) {
        // If the source and destination differ, copy the unchanged rows
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
mat4.fromQuat = function (out, q) {
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,
        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = 2 * far * near * nf;
    out[15] = 0;
    return out;
};

module.exports = mat4;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _common = __webpack_require__(2);

var _common2 = _interopRequireDefault(_common);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
/**
 * Original Code
 * https://github.com/toji/gl-matrix/blob/v2.3.2/src/gl-matrix/quat.js
 * Quaternion util
 * modified by egjs
 */
quat.create = function () {
    var out = new _common2["default"].ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = function (a) {
    var out = new _common2["default"].ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = function (x, y, z, w) {
    var out = new _common2["default"].ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = function (out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function (out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function (out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3],
        bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5;

    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3],
        bx = Math.sin(rad),
        bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5;

    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3],
        by = Math.sin(rad),
        bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = function (out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x * x + y * y + z * z + w * w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.equals = function (a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    return Math.abs(a0 - b0) <= _common2["default"].EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common2["default"].EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common2["default"].EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common2["default"].EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
};

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

module.exports = quat;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _common = __webpack_require__(2);

var _common2 = _interopRequireDefault(_common);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */
var vec2 = {}; /**
                * Original Code
                * https://github.com/toji/gl-matrix/blob/v2.3.2/src/gl-matrix/vec2.js
                * 2 Dimensional Vector Util
                * modified by egjs
                */


vec2.copy = function (out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
};

module.exports = vec2;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _common = __webpack_require__(2);

var _common2 = _interopRequireDefault(_common);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
/**
 * Original Code
 * https://github.com/toji/gl-matrix/blob/v2.3.2/src/gl-matrix/vec3.js
 * 3 Dimensional Vector Util
 * modified by egjs
 */
vec3.create = function () {
    var out = new _common2["default"].ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function (x, y, z) {
    var out = new _common2["default"].ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

vec3.set = function (out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

vec3.copy = function (out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function (out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function (out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x * x + y * y + z * z);
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function (out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x * x + y * y + z * z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function (out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        bx = b[0],
        by = b[1],
        bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function (out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0],
        y = a[1],
        z = a[2],
        qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3],


    // calculate quat * vec
    ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function (out, a, b, c) {
    var p = [],
        r = [];
    //Translate point to the origin
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];

    //perform rotation
    r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
    r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
    r[2] = p[2];

    //translate to correct position
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];

    return out;
};

module.exports = vec3;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
}
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
}
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
}
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
}

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text
  }

  // Cache opened sequence.
  var ansiCodes = []
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
    var ot = _openTags[seq]
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop()
        return '</span>'
      }
      // Open tag.
      ansiCodes.push(seq)
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
    }

    var ct = _closeTags[seq]
    if (ct) {
      // Pop sequence
      ansiCodes.pop()
      return ct
    }
    return ''
  })

  // Make sure tags are closed.
  var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

  return ret
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.')
  }

  var _finalColors = {}
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null
    if (!hex) {
      _finalColors[key] = _defColors[key]
      continue
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex]
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string'
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
      }
      var defHexColor = _defColors[key]
      if (!hex[0]) {
        hex[0] = defHexColor[0]
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]]
        hex.push(defHexColor[1])
      }

      hex = hex.slice(0, 2)
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
    }
    _finalColors[key] = hex
  }
  _setTags(_finalColors)
}

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors)
}

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {}

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () { return _openTags }
  })
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () { return _closeTags }
  })
} else {
  ansiHTML.tags.open = _openTags
  ansiHTML.tags.close = _closeTags
}

function _setTags (colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey

  for (var code in _styles) {
    var color = _styles[code]
    var oriColor = colors[color] || '000'
    _openTags[code] = 'color:#' + oriColor
    code = parseInt(code)
    _openTags[(code + 10).toString()] = 'background:#' + oriColor
  }
}

ansiHTML.reset()


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),
/* 47 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  XmlEntities: __webpack_require__(50),
  Html4Entities: __webpack_require__(49),
  Html5Entities: __webpack_require__(19),
  AllHtmlEntities: __webpack_require__(19)
};


/***/ }),
/* 49 */
/***/ (function(module, exports) {

var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];

var alphaIndex = {};
var numIndex = {};

var i = 0;
var length = HTML_ALPHA.length;
while (i < length) {
    var a = HTML_ALPHA[i];
    var c = HTML_CODES[i];
    alphaIndex[a] = String.fromCharCode(c);
    numIndex[c] = a;
    i++;
}

/**
 * @constructor
 */
function Html4Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1).toLowerCase() === 'x' ?
                parseInt(entity.substr(2), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.decode = function(str) {
    return new Html4Entities().decode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var alpha = numIndex[str.charCodeAt(i)];
        result += alpha ? "&" + alpha + ";" : str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encode = function(str) {
    return new Html4Entities().encode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var cc = str.charCodeAt(i);
        var alpha = numIndex[cc];
        if (alpha) {
            result += "&" + alpha + ";";
        } else if (cc < 32 || cc > 126) {
            result += "&#" + cc + ";";
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonUTF = function(str) {
    return new Html4Entities().encodeNonUTF(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonASCII = function(str) {
    return new Html4Entities().encodeNonASCII(str);
};

module.exports = Html4Entities;


/***/ }),
/* 50 */
/***/ (function(module, exports) {

var ALPHA_INDEX = {
    '&lt': '<',
    '&gt': '>',
    '&quot': '"',
    '&apos': '\'',
    '&amp': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': '\'',
    '&amp;': '&'
};

var CHAR_INDEX = {
    60: 'lt',
    62: 'gt',
    34: 'quot',
    39: 'apos',
    38: 'amp'
};

var CHAR_S_INDEX = {
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;',
    '&': '&amp;'
};

/**
 * @constructor
 */
function XmlEntities() {}

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/<|>|"|'|&/g, function(s) {
        return CHAR_S_INDEX[s];
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encode = function(str) {
    return new XmlEntities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {
        if (s.charAt(1) === '#') {
            var code = s.charAt(2).toLowerCase() === 'x' ?
                parseInt(s.substr(3), 16) :
                parseInt(s.substr(2));

            if (isNaN(code) || code < -32768 || code > 65535) {
                return '';
            }
            return String.fromCharCode(code);
        }
        return ALPHA_INDEX[s] || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.decode = function(str) {
    return new XmlEntities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var alpha = CHAR_INDEX[c];
        if (alpha) {
            result += "&" + alpha + ";";
            i++;
            continue;
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonUTF = function(str) {
    return new XmlEntities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLenght = str.length;
    var result = '';
    var i = 0;
    while (i < strLenght) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonASCII = function(str) {
    return new XmlEntities().encodeNonASCII(str);
 };

module.exports = XmlEntities;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof module === 'object' && module.exports) {
        module.exports = definition();
    } else {
        root.log = definition();
    }
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));


/***/ }),
/* 52 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(63)(module), __webpack_require__(9)))

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(54);
exports.encode = exports.stringify = __webpack_require__(55);


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/* sockjs-client v1.1.4 | http://sockjs.org | MIT license */
(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.SockJS = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
'use strict';

var transportList = require('./transport-list');

module.exports = require('./main')(transportList);

// TODO can't get rid of this until all servers do
if ('_sockjs_onload' in global) {
  setTimeout(global._sockjs_onload, 1);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./main":14,"./transport-list":16}],2:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function CloseEvent() {
  Event.call(this);
  this.initEvent('close', false, false);
  this.wasClean = false;
  this.code = 0;
  this.reason = '';
}

inherits(CloseEvent, Event);

module.exports = CloseEvent;

},{"./event":4,"inherits":57}],3:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventTarget = require('./eventtarget')
  ;

function EventEmitter() {
  EventTarget.call(this);
}

inherits(EventEmitter, EventTarget);

EventEmitter.prototype.removeAllListeners = function(type) {
  if (type) {
    delete this._listeners[type];
  } else {
    this._listeners = {};
  }
};

EventEmitter.prototype.once = function(type, listener) {
  var self = this
    , fired = false;

  function g() {
    self.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  this.on(type, g);
};

EventEmitter.prototype.emit = function() {
  var type = arguments[0];
  var listeners = this._listeners[type];
  if (!listeners) {
    return;
  }
  // equivalent of Array.prototype.slice.call(arguments, 1);
  var l = arguments.length;
  var args = new Array(l - 1);
  for (var ai = 1; ai < l; ai++) {
    args[ai - 1] = arguments[ai];
  }
  for (var i = 0; i < listeners.length; i++) {
    listeners[i].apply(this, args);
  }
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

module.exports.EventEmitter = EventEmitter;

},{"./eventtarget":5,"inherits":57}],4:[function(require,module,exports){
'use strict';

function Event(eventType) {
  this.type = eventType;
}

Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
  this.type = eventType;
  this.bubbles = canBubble;
  this.cancelable = cancelable;
  this.timeStamp = +new Date();
  return this;
};

Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault = function() {};

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

module.exports = Event;

},{}],5:[function(require,module,exports){
'use strict';

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

function EventTarget() {
  this._listeners = {};
}

EventTarget.prototype.addEventListener = function(eventType, listener) {
  if (!(eventType in this._listeners)) {
    this._listeners[eventType] = [];
  }
  var arr = this._listeners[eventType];
  // #4
  if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
    arr = arr.concat([listener]);
  }
  this._listeners[eventType] = arr;
};

EventTarget.prototype.removeEventListener = function(eventType, listener) {
  var arr = this._listeners[eventType];
  if (!arr) {
    return;
  }
  var idx = arr.indexOf(listener);
  if (idx !== -1) {
    if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
    } else {
      delete this._listeners[eventType];
    }
    return;
  }
};

EventTarget.prototype.dispatchEvent = function() {
  var event = arguments[0];
  var t = event.type;
  // equivalent of Array.prototype.slice.call(arguments, 0);
  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
  if (this['on' + t]) {
    this['on' + t].apply(this, args);
  }
  if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
    var listeners = this._listeners[t];
    for (var i = 0; i < listeners.length; i++) {
      listeners[i].apply(this, args);
    }
  }
};

module.exports = EventTarget;

},{}],6:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function TransportMessageEvent(data) {
  Event.call(this);
  this.initEvent('message', false, false);
  this.data = data;
}

inherits(TransportMessageEvent, Event);

module.exports = TransportMessageEvent;

},{"./event":4,"inherits":57}],7:[function(require,module,exports){
'use strict';

var JSON3 = require('json3')
  , iframeUtils = require('./utils/iframe')
  ;

function FacadeJS(transport) {
  this._transport = transport;
  transport.on('message', this._transportMessage.bind(this));
  transport.on('close', this._transportClose.bind(this));
}

FacadeJS.prototype._transportClose = function(code, reason) {
  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
};
FacadeJS.prototype._transportMessage = function(frame) {
  iframeUtils.postMessage('t', frame);
};
FacadeJS.prototype._send = function(data) {
  this._transport.send(data);
};
FacadeJS.prototype._close = function() {
  this._transport.close();
  this._transport.removeAllListeners();
};

module.exports = FacadeJS;

},{"./utils/iframe":47,"json3":58}],8:[function(require,module,exports){
(function (process){
'use strict';

var urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , JSON3 = require('json3')
  , FacadeJS = require('./facade')
  , InfoIframeReceiver = require('./info-iframe-receiver')
  , iframeUtils = require('./utils/iframe')
  , loc = require('./location')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:iframe-bootstrap');
}

module.exports = function(SockJS, availableTransports) {
  var transportMap = {};
  availableTransports.forEach(function(at) {
    if (at.facadeTransport) {
      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
    }
  });

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
  var parentOrigin;

  /* eslint-disable camelcase */
  SockJS.bootstrap_iframe = function() {
    /* eslint-enable camelcase */
    var facade;
    iframeUtils.currentWindowId = loc.hash.slice(1);
    var onMessage = function(e) {
      if (e.source !== parent) {
        return;
      }
      if (typeof parentOrigin === 'undefined') {
        parentOrigin = e.origin;
      }
      if (e.origin !== parentOrigin) {
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = JSON3.parse(e.data);
      } catch (ignored) {
        debug('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
        return;
      }
      switch (iframeMessage.type) {
      case 's':
        var p;
        try {
          p = JSON3.parse(iframeMessage.data);
        } catch (ignored) {
          debug('bad json', iframeMessage.data);
          break;
        }
        var version = p[0];
        var transport = p[1];
        var transUrl = p[2];
        var baseUrl = p[3];
        debug(version, transport, transUrl, baseUrl);
        // change this to semver logic
        if (version !== SockJS.version) {
          throw new Error('Incompatible SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".');
        }

        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
          throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
        }
        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
        break;
      case 'm':
        facade._send(iframeMessage.data);
        break;
      case 'c':
        if (facade) {
          facade._close();
        }
        facade = null;
        break;
      }
    };

    eventUtils.attachEvent('message', onMessage);

    // Start
    iframeUtils.postMessage('s');
  };
};

}).call(this,{ env: {} })

},{"./facade":7,"./info-iframe-receiver":10,"./location":13,"./utils/event":46,"./utils/iframe":47,"./utils/url":52,"debug":55,"json3":58}],9:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , objectUtils = require('./utils/object')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-ajax');
}

function InfoAjax(url, AjaxObject) {
  EventEmitter.call(this);

  var self = this;
  var t0 = +new Date();
  this.xo = new AjaxObject('GET', url);

  this.xo.once('finish', function(status, text) {
    var info, rtt;
    if (status === 200) {
      rtt = (+new Date()) - t0;
      if (text) {
        try {
          info = JSON3.parse(text);
        } catch (e) {
          debug('bad json', text);
        }
      }

      if (!objectUtils.isObject(info)) {
        info = {};
      }
    }
    self.emit('finish', info, rtt);
    self.removeAllListeners();
  });
}

inherits(InfoAjax, EventEmitter);

InfoAjax.prototype.close = function() {
  this.removeAllListeners();
  this.xo.close();
};

module.exports = InfoAjax;

}).call(this,{ env: {} })

},{"./utils/object":49,"debug":55,"events":3,"inherits":57,"json3":58}],10:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , JSON3 = require('json3')
  , XHRLocalObject = require('./transport/sender/xhr-local')
  , InfoAjax = require('./info-ajax')
  ;

function InfoReceiverIframe(transUrl) {
  var self = this;
  EventEmitter.call(this);

  this.ir = new InfoAjax(transUrl, XHRLocalObject);
  this.ir.once('finish', function(info, rtt) {
    self.ir = null;
    self.emit('message', JSON3.stringify([info, rtt]));
  });
}

inherits(InfoReceiverIframe, EventEmitter);

InfoReceiverIframe.transportName = 'iframe-info-receiver';

InfoReceiverIframe.prototype.close = function() {
  if (this.ir) {
    this.ir.close();
    this.ir = null;
  }
  this.removeAllListeners();
};

module.exports = InfoReceiverIframe;

},{"./info-ajax":9,"./transport/sender/xhr-local":37,"events":3,"inherits":57,"json3":58}],11:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , utils = require('./utils/event')
  , IframeTransport = require('./transport/iframe')
  , InfoReceiverIframe = require('./info-iframe-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-iframe');
}

function InfoIframe(baseUrl, url) {
  var self = this;
  EventEmitter.call(this);

  var go = function() {
    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

    ifr.once('message', function(msg) {
      if (msg) {
        var d;
        try {
          d = JSON3.parse(msg);
        } catch (e) {
          debug('bad json', msg);
          self.emit('finish');
          self.close();
          return;
        }

        var info = d[0], rtt = d[1];
        self.emit('finish', info, rtt);
      }
      self.close();
    });

    ifr.once('close', function() {
      self.emit('finish');
      self.close();
    });
  };

  // TODO this seems the same as the 'needBody' from transports
  if (!global.document.body) {
    utils.attachEvent('load', go);
  } else {
    go();
  }
}

inherits(InfoIframe, EventEmitter);

InfoIframe.enabled = function() {
  return IframeTransport.enabled();
};

InfoIframe.prototype.close = function() {
  if (this.ifr) {
    this.ifr.close();
  }
  this.removeAllListeners();
  this.ifr = null;
};

module.exports = InfoIframe;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./info-iframe-receiver":10,"./transport/iframe":22,"./utils/event":46,"debug":55,"events":3,"inherits":57,"json3":58}],12:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , urlUtils = require('./utils/url')
  , XDR = require('./transport/sender/xdr')
  , XHRCors = require('./transport/sender/xhr-cors')
  , XHRLocal = require('./transport/sender/xhr-local')
  , XHRFake = require('./transport/sender/xhr-fake')
  , InfoIframe = require('./info-iframe')
  , InfoAjax = require('./info-ajax')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-receiver');
}

function InfoReceiver(baseUrl, urlInfo) {
  debug(baseUrl);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self.doXhr(baseUrl, urlInfo);
  }, 0);
}

inherits(InfoReceiver, EventEmitter);

// TODO this is currently ignoring the list of available transports and the whitelist

InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
  if (urlInfo.sameOrigin) {
    return new InfoAjax(url, XHRLocal);
  }
  if (XHRCors.enabled) {
    return new InfoAjax(url, XHRCors);
  }
  if (XDR.enabled && urlInfo.sameScheme) {
    return new InfoAjax(url, XDR);
  }
  if (InfoIframe.enabled()) {
    return new InfoIframe(baseUrl, url);
  }
  return new InfoAjax(url, XHRFake);
};

InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
  var self = this
    , url = urlUtils.addPath(baseUrl, '/info')
    ;
  debug('doXhr', url);

  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

  this.timeoutRef = setTimeout(function() {
    debug('timeout');
    self._cleanup(false);
    self.emit('finish');
  }, InfoReceiver.timeout);

  this.xo.once('finish', function(info, rtt) {
    debug('finish', info, rtt);
    self._cleanup(true);
    self.emit('finish', info, rtt);
  });
};

InfoReceiver.prototype._cleanup = function(wasClean) {
  debug('_cleanup');
  clearTimeout(this.timeoutRef);
  this.timeoutRef = null;
  if (!wasClean && this.xo) {
    this.xo.close();
  }
  this.xo = null;
};

InfoReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  this._cleanup(false);
};

InfoReceiver.timeout = 8000;

module.exports = InfoReceiver;

}).call(this,{ env: {} })

},{"./info-ajax":9,"./info-iframe":11,"./transport/sender/xdr":34,"./transport/sender/xhr-cors":35,"./transport/sender/xhr-fake":36,"./transport/sender/xhr-local":37,"./utils/url":52,"debug":55,"events":3,"inherits":57}],13:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.location || {
  origin: 'http://localhost:80'
, protocol: 'http'
, host: 'localhost'
, port: 80
, href: 'http://localhost/'
, hash: ''
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (process,global){
'use strict';

require('./shims');

var URL = require('url-parse')
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , random = require('./utils/random')
  , escape = require('./utils/escape')
  , urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , transport = require('./utils/transport')
  , objectUtils = require('./utils/object')
  , browser = require('./utils/browser')
  , log = require('./utils/log')
  , Event = require('./event/event')
  , EventTarget = require('./event/eventtarget')
  , loc = require('./location')
  , CloseEvent = require('./event/close')
  , TransportMessageEvent = require('./event/trans-message')
  , InfoReceiver = require('./info-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:main');
}

var transports;

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
function SockJS(url, protocols, options) {
  if (!(this instanceof SockJS)) {
    return new SockJS(url, protocols, options);
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
  }
  EventTarget.call(this);

  this.readyState = SockJS.CONNECTING;
  this.extensions = '';
  this.protocol = '';

  // non-standard extension
  options = options || {};
  if (options.protocols_whitelist) {
    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
  }
  this._transportsWhitelist = options.transports;
  this._transportOptions = options.transportOptions || {};

  var sessionId = options.sessionId || 8;
  if (typeof sessionId === 'function') {
    this._generateSessionId = sessionId;
  } else if (typeof sessionId === 'number') {
    this._generateSessionId = function() {
      return random.string(sessionId);
    };
  } else {
    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
  }

  this._server = options.server || random.numberString(1000);

  // Step 1 of WS spec - parse and validate the url. Issue #8
  var parsedUrl = new URL(url);
  if (!parsedUrl.host || !parsedUrl.protocol) {
    throw new SyntaxError("The URL '" + url + "' is invalid");
  } else if (parsedUrl.hash) {
    throw new SyntaxError('The URL must not contain a fragment');
  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
  }

  var secure = parsedUrl.protocol === 'https:';
  // Step 2 - don't allow secure origin with an insecure protocol
  if (loc.protocol === 'https' && !secure) {
    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
  }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
  if (!protocols) {
    protocols = [];
  } else if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  // Step 5 - check protocols argument
  var sortedProtocols = protocols.sort();
  sortedProtocols.forEach(function(proto, i) {
    if (!proto) {
      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
    }
    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
    }
  });

  // Step 6 - convert origin
  var o = urlUtils.getOrigin(loc.href);
  this._origin = o ? o.toLowerCase() : null;

  // remove the trailing slash
  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

  // store the sanitized url
  this.url = parsedUrl.href;
  debug('using url', this.url);

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
  this._urlInfo = {
    nullOrigin: !browser.hasDomain()
  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
  };

  this._ir = new InfoReceiver(this.url, this._urlInfo);
  this._ir.once('finish', this._receiveInfo.bind(this));
}

inherits(SockJS, EventTarget);

function userSetCode(code) {
  return code === 1000 || (code >= 3000 && code <= 4999);
}

SockJS.prototype.close = function(code, reason) {
  // Step 1
  if (code && !userSetCode(code)) {
    throw new Error('InvalidAccessError: Invalid code');
  }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
  if (reason && reason.length > 123) {
    throw new SyntaxError('reason argument has an invalid length');
  }

  // Step 3.1
  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
    return;
  }

  // TODO look at docs to determine how to set this
  var wasClean = true;
  this._close(code || 1000, reason || 'Normal closure', wasClean);
};

SockJS.prototype.send = function(data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
  if (typeof data !== 'string') {
    data = '' + data;
  }
  if (this.readyState === SockJS.CONNECTING) {
    throw new Error('InvalidStateError: The connection has not been established yet');
  }
  if (this.readyState !== SockJS.OPEN) {
    return;
  }
  this._transport.send(escape.quote(data));
};

SockJS.version = require('./version');

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._receiveInfo = function(info, rtt) {
  debug('_receiveInfo', rtt);
  this._ir = null;
  if (!info) {
    this._close(1002, 'Cannot connect to server');
    return;
  }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
  this._rto = this.countRTO(rtt);
  // allow server to override url used for the actual transport
  this._transUrl = info.base_url ? info.base_url : this.url;
  info = objectUtils.extend(info, this._urlInfo);
  debug('info', info);
  // determine list of desired and supported transports
  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
  this._transports = enabledTransports.main;
  debug(this._transports.length + ' enabled transports');

  this._connect();
};

SockJS.prototype._connect = function() {
  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
    debug('attempt', Transport.transportName);
    if (Transport.needBody) {
      if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
        debug('waiting for body');
        this._transports.unshift(Transport);
        eventUtils.attachEvent('load', this._connect.bind(this));
        return;
      }
    }

    // calculate timeout based on RTO and round trips. Default to 5s
    var timeoutMs = (this._rto * Transport.roundTrips) || 5000;
    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
    debug('using timeout', timeoutMs);

    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
    var options = this._transportOptions[Transport.transportName];
    debug('transport url', transportUrl);
    var transportObj = new Transport(transportUrl, this._transUrl, options);
    transportObj.on('message', this._transportMessage.bind(this));
    transportObj.once('close', this._transportClose.bind(this));
    transportObj.transportName = Transport.transportName;
    this._transport = transportObj;

    return;
  }
  this._close(2000, 'All transports failed', false);
};

SockJS.prototype._transportTimeout = function() {
  debug('_transportTimeout');
  if (this.readyState === SockJS.CONNECTING) {
    this._transportClose(2007, 'Transport timed out');
  }
};

SockJS.prototype._transportMessage = function(msg) {
  debug('_transportMessage', msg);
  var self = this
    , type = msg.slice(0, 1)
    , content = msg.slice(1)
    , payload
    ;

  // first check for messages that don't need a payload
  switch (type) {
    case 'o':
      this._open();
      return;
    case 'h':
      this.dispatchEvent(new Event('heartbeat'));
      debug('heartbeat', this.transport);
      return;
  }

  if (content) {
    try {
      payload = JSON3.parse(content);
    } catch (e) {
      debug('bad json', content);
    }
  }

  if (typeof payload === 'undefined') {
    debug('empty payload', content);
    return;
  }

  switch (type) {
    case 'a':
      if (Array.isArray(payload)) {
        payload.forEach(function(p) {
          debug('message', self.transport, p);
          self.dispatchEvent(new TransportMessageEvent(p));
        });
      }
      break;
    case 'm':
      debug('message', this.transport, payload);
      this.dispatchEvent(new TransportMessageEvent(payload));
      break;
    case 'c':
      if (Array.isArray(payload) && payload.length === 2) {
        this._close(payload[0], payload[1], true);
      }
      break;
  }
};

SockJS.prototype._transportClose = function(code, reason) {
  debug('_transportClose', this.transport, code, reason);
  if (this._transport) {
    this._transport.removeAllListeners();
    this._transport = null;
    this.transport = null;
  }

  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
    this._connect();
    return;
  }

  this._close(code, reason);
};

SockJS.prototype._open = function() {
  debug('_open', this._transport.transportName, this.readyState);
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transportTimeoutId) {
      clearTimeout(this._transportTimeoutId);
      this._transportTimeoutId = null;
    }
    this.readyState = SockJS.OPEN;
    this.transport = this._transport.transportName;
    this.dispatchEvent(new Event('open'));
    debug('connected', this.transport);
  } else {
    // The server might have been restarted, and lost track of our
    // connection.
    this._close(1006, 'Server lost session');
  }
};

SockJS.prototype._close = function(code, reason, wasClean) {
  debug('_close', this.transport, code, reason, wasClean, this.readyState);
  var forceFail = false;

  if (this._ir) {
    forceFail = true;
    this._ir.close();
    this._ir = null;
  }
  if (this._transport) {
    this._transport.close();
    this._transport = null;
    this.transport = null;
  }

  if (this.readyState === SockJS.CLOSED) {
    throw new Error('InvalidStateError: SockJS has already been closed');
  }

  this.readyState = SockJS.CLOSING;
  setTimeout(function() {
    this.readyState = SockJS.CLOSED;

    if (forceFail) {
      this.dispatchEvent(new Event('error'));
    }

    var e = new CloseEvent('close');
    e.wasClean = wasClean || false;
    e.code = code || 1000;
    e.reason = reason;

    this.dispatchEvent(e);
    this.onmessage = this.onclose = this.onerror = null;
    debug('disconnected');
  }.bind(this), 0);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
SockJS.prototype.countRTO = function(rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
  if (rtt > 100) {
    return 4 * rtt; // rto > 400msec
  }
  return 300 + rtt; // 300msec < rto <= 400msec
};

module.exports = function(availableTransports) {
  transports = transport(availableTransports);
  require('./iframe-bootstrap')(SockJS, availableTransports);
  return SockJS;
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./event/close":2,"./event/event":4,"./event/eventtarget":5,"./event/trans-message":6,"./iframe-bootstrap":8,"./info-receiver":12,"./location":13,"./shims":15,"./utils/browser":44,"./utils/escape":45,"./utils/event":46,"./utils/log":48,"./utils/object":49,"./utils/random":50,"./utils/transport":51,"./utils/url":52,"./version":53,"debug":55,"inherits":57,"json3":58,"url-parse":61}],15:[function(require,module,exports){
/* eslint-disable */
/* jscs: disable */
'use strict';

// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);

},{}],16:[function(require,module,exports){
'use strict';

module.exports = [
  // streaming transports
  require('./transport/websocket')
, require('./transport/xhr-streaming')
, require('./transport/xdr-streaming')
, require('./transport/eventsource')
, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))

  // polling transports
, require('./transport/htmlfile')
, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))
, require('./transport/xhr-polling')
, require('./transport/xdr-polling')
, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))
, require('./transport/jsonp-polling')
];

},{"./transport/eventsource":20,"./transport/htmlfile":21,"./transport/jsonp-polling":23,"./transport/lib/iframe-wrap":26,"./transport/websocket":38,"./transport/xdr-polling":39,"./transport/xdr-streaming":40,"./transport/xhr-polling":41,"./transport/xhr-streaming":42}],17:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('../../utils/event')
  , urlUtils = require('../../utils/url')
  , XHR = global.XMLHttpRequest
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:browser:xhr');
}

function AbstractXHRObject(method, url, payload, opts) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function () {
    self._start(method, url, payload, opts);
  }, 0);
}

inherits(AbstractXHRObject, EventEmitter);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
  var self = this;

  try {
    this.xhr = new XHR();
  } catch (x) {
    // intentionally empty
  }

  if (!this.xhr) {
    debug('no xhr');
    this.emit('finish', 0, 'no xhr support');
    this._cleanup();
    return;
  }

  // several browsers cache POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload cleanup');
    self._cleanup(true);
  });
  try {
    this.xhr.open(method, url, true);
    if (this.timeout && 'timeout' in this.xhr) {
      this.xhr.timeout = this.timeout;
      this.xhr.ontimeout = function() {
        debug('xhr timeout');
        self.emit('finish', 0, '');
        self._cleanup(false);
      };
    }
  } catch (e) {
    debug('exception', e);
    // IE raises an exception on wrong port.
    this.emit('finish', 0, '');
    this._cleanup(false);
    return;
  }

  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
    debug('withCredentials');
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

    this.xhr.withCredentials = 'true';
  }
  if (opts && opts.headers) {
    for (var key in opts.headers) {
      this.xhr.setRequestHeader(key, opts.headers[key]);
    }
  }

  this.xhr.onreadystatechange = function() {
    if (self.xhr) {
      var x = self.xhr;
      var text, status;
      debug('readyState', x.readyState);
      switch (x.readyState) {
      case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
        try {
          status = x.status;
          text = x.responseText;
        } catch (e) {
          // intentionally empty
        }
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }

        // IE does return readystate == 3 for 404 answers.
        if (status === 200 && text && text.length > 0) {
          debug('chunk');
          self.emit('chunk', status, text);
        }
        break;
      case 4:
        status = x.status;
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
        if (status === 12005 || status === 12029) {
          status = 0;
        }

        debug('finish', status, x.responseText);
        self.emit('finish', status, x.responseText);
        self._cleanup(false);
        break;
      }
    }
  };

  try {
    self.xhr.send(payload);
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
};

AbstractXHRObject.prototype._cleanup = function(abort) {
  debug('cleanup');
  if (!this.xhr) {
    return;
  }
  this.removeAllListeners();
  utils.unloadDel(this.unloadRef);

  // IE needs this field to be a function
  this.xhr.onreadystatechange = function() {};
  if (this.xhr.ontimeout) {
    this.xhr.ontimeout = null;
  }

  if (abort) {
    try {
      this.xhr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

AbstractXHRObject.enabled = !!XHR;
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (!AbstractXHRObject.enabled && (axo in global)) {
  debug('overriding xmlhttprequest');
  XHR = function() {
    try {
      return new global[axo]('Microsoft.XMLHTTP');
    } catch (e) {
      return null;
    }
  };
  AbstractXHRObject.enabled = !!new XHR();
}

var cors = false;
try {
  cors = 'withCredentials' in new XHR();
} catch (ignored) {
  // intentionally empty
}

AbstractXHRObject.supportsCORS = cors;

module.exports = AbstractXHRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],18:[function(require,module,exports){
(function (global){
module.exports = global.EventSource;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
(function (global){
'use strict';

var Driver = global.WebSocket || global.MozWebSocket;
if (Driver) {
	module.exports = function WebSocketBrowserDriver(url) {
		return new Driver(url);
	};
} else {
	module.exports = undefined;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , EventSourceReceiver = require('./receiver/eventsource')
  , XHRCorsObject = require('./sender/xhr-cors')
  , EventSourceDriver = require('eventsource')
  ;

function EventSourceTransport(transUrl) {
  if (!EventSourceTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
}

inherits(EventSourceTransport, AjaxBasedTransport);

EventSourceTransport.enabled = function() {
  return !!EventSourceDriver;
};

EventSourceTransport.transportName = 'eventsource';
EventSourceTransport.roundTrips = 2;

module.exports = EventSourceTransport;

},{"./lib/ajax-based":24,"./receiver/eventsource":29,"./sender/xhr-cors":35,"eventsource":18,"inherits":57}],21:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , HtmlfileReceiver = require('./receiver/htmlfile')
  , XHRLocalObject = require('./sender/xhr-local')
  , AjaxBasedTransport = require('./lib/ajax-based')
  ;

function HtmlFileTransport(transUrl) {
  if (!HtmlfileReceiver.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
}

inherits(HtmlFileTransport, AjaxBasedTransport);

HtmlFileTransport.enabled = function(info) {
  return HtmlfileReceiver.enabled && info.sameOrigin;
};

HtmlFileTransport.transportName = 'htmlfile';
HtmlFileTransport.roundTrips = 2;

module.exports = HtmlFileTransport;

},{"./lib/ajax-based":24,"./receiver/htmlfile":30,"./sender/xhr-local":37,"inherits":57}],22:[function(require,module,exports){
(function (process){
'use strict';

// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var inherits = require('inherits')
  , JSON3 = require('json3')
  , EventEmitter = require('events').EventEmitter
  , version = require('../version')
  , urlUtils = require('../utils/url')
  , iframeUtils = require('../utils/iframe')
  , eventUtils = require('../utils/event')
  , random = require('../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:transport:iframe');
}

function IframeTransport(transport, transUrl, baseUrl) {
  if (!IframeTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  EventEmitter.call(this);

  var self = this;
  this.origin = urlUtils.getOrigin(baseUrl);
  this.baseUrl = baseUrl;
  this.transUrl = transUrl;
  this.transport = transport;
  this.windowId = random.string(8);

  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
  debug(transport, transUrl, iframeUrl);

  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
    debug('err callback');
    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
    self.close();
  });

  this.onmessageCallback = this._message.bind(this);
  eventUtils.attachEvent('message', this.onmessageCallback);
}

inherits(IframeTransport, EventEmitter);

IframeTransport.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.iframeObj) {
    eventUtils.detachEvent('message', this.onmessageCallback);
    try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
      this.postMessage('c');
    } catch (x) {
      // intentionally empty
    }
    this.iframeObj.cleanup();
    this.iframeObj = null;
    this.onmessageCallback = this.iframeObj = null;
  }
};

IframeTransport.prototype._message = function(e) {
  debug('message', e.data);
  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
    debug('not same origin', e.origin, this.origin);
    return;
  }

  var iframeMessage;
  try {
    iframeMessage = JSON3.parse(e.data);
  } catch (ignored) {
    debug('bad json', e.data);
    return;
  }

  if (iframeMessage.windowId !== this.windowId) {
    debug('mismatched window id', iframeMessage.windowId, this.windowId);
    return;
  }

  switch (iframeMessage.type) {
  case 's':
    this.iframeObj.loaded();
    // window global dependency
    this.postMessage('s', JSON3.stringify([
      version
    , this.transport
    , this.transUrl
    , this.baseUrl
    ]));
    break;
  case 't':
    this.emit('message', iframeMessage.data);
    break;
  case 'c':
    var cdata;
    try {
      cdata = JSON3.parse(iframeMessage.data);
    } catch (ignored) {
      debug('bad json', iframeMessage.data);
      return;
    }
    this.emit('close', cdata[0], cdata[1]);
    this.close();
    break;
  }
};

IframeTransport.prototype.postMessage = function(type, data) {
  debug('postMessage', type, data);
  this.iframeObj.post(JSON3.stringify({
    windowId: this.windowId
  , type: type
  , data: data || ''
  }), this.origin);
};

IframeTransport.prototype.send = function(message) {
  debug('send', message);
  this.postMessage('m', message);
};

IframeTransport.enabled = function() {
  return iframeUtils.iframeEnabled;
};

IframeTransport.transportName = 'iframe';
IframeTransport.roundTrips = 2;

module.exports = IframeTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/iframe":47,"../utils/random":50,"../utils/url":52,"../version":53,"debug":55,"events":3,"inherits":57,"json3":58}],23:[function(require,module,exports){
(function (global){
'use strict';

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = require('inherits')
  , SenderReceiver = require('./lib/sender-receiver')
  , JsonpReceiver = require('./receiver/jsonp')
  , jsonpSender = require('./sender/jsonp')
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/sender-receiver":28,"./receiver/jsonp":31,"./sender/jsonp":33,"inherits":57}],24:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , SenderReceiver = require('./sender-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:ajax-based');
}

function createAjaxSender(AjaxObject) {
  return function(url, payload, callback) {
    debug('create ajax sender', url, payload);
    var opt = {};
    if (typeof payload === 'string') {
      opt.headers = {'Content-type': 'text/plain'};
    }
    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
    xo.once('finish', function(status) {
      debug('finish', status);
      xo = null;

      if (status !== 200 && status !== 204) {
        return callback(new Error('http status ' + status));
      }
      callback();
    });
    return function() {
      debug('abort');
      xo.close();
      xo = null;

      var err = new Error('Aborted');
      err.code = 1000;
      callback(err);
    };
  };
}

function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
}

inherits(AjaxBasedTransport, SenderReceiver);

module.exports = AjaxBasedTransport;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./sender-receiver":28,"debug":55,"inherits":57}],25:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self.close();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.close = function() {
  debug('close');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],26:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , IframeTransport = require('../iframe')
  , objectUtils = require('../../utils/object')
  ;

module.exports = function(transport) {

  function IframeWrapTransport(transUrl, baseUrl) {
    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
  }

  inherits(IframeWrapTransport, IframeTransport);

  IframeWrapTransport.enabled = function(url, info) {
    if (!global.document) {
      return false;
    }

    var iframeInfo = objectUtils.extend({}, info);
    iframeInfo.sameOrigin = true;
    return transport.enabled(iframeInfo) && IframeTransport.enabled();
  };

  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
  IframeWrapTransport.needBody = true;
  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

  IframeWrapTransport.facadeTransport = transport;

  return IframeWrapTransport;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/object":49,"../iframe":22,"inherits":57}],27:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],28:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , BufferedSender = require('./buffered-sender')
  , Polling = require('./polling')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender-receiver');
}

function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
  debug(pollUrl);
  var self = this;
  BufferedSender.call(this, transUrl, senderFunc);

  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
  this.poll.on('message', function(msg) {
    debug('poll message', msg);
    self.emit('message', msg);
  });
  this.poll.once('close', function(code, reason) {
    debug('poll close', code, reason);
    self.poll = null;
    self.emit('close', code, reason);
    self.close();
  });
}

inherits(SenderReceiver, BufferedSender);

SenderReceiver.prototype.close = function() {
  BufferedSender.prototype.close.call(this);
  debug('close');
  this.removeAllListeners();
  if (this.poll) {
    this.poll.abort();
    this.poll = null;
  }
};

module.exports = SenderReceiver;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./buffered-sender":25,"./polling":27,"debug":55,"inherits":57}],29:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , EventSourceDriver = require('eventsource')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"eventsource":18,"inherits":57}],30:[function(require,module,exports){
(function (process,global){
'use strict';

var inherits = require('inherits')
  , iframeUtils = require('../../utils/iframe')
  , urlUtils = require('../../utils/url')
  , EventEmitter = require('events').EventEmitter
  , random = require('../../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {
    // intentionally empty
  }
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],31:[function(require,module,exports){
(function (process,global){
'use strict';

var utils = require('../../utils/iframe')
  , random = require('../../utils/random')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {
          // intentionally empty
        }
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {
        // intentionally empty
      }
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],32:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:xhr');
}

function XhrReceiver(url, AjaxObject) {
  debug(url);
  EventEmitter.call(this);
  var self = this;

  this.bufferPosition = 0;

  this.xo = new AjaxObject('POST', url, null);
  this.xo.on('chunk', this._chunkHandler.bind(this));
  this.xo.once('finish', function(status, text) {
    debug('finish', status, text);
    self._chunkHandler(status, text);
    self.xo = null;
    var reason = status === 200 ? 'network' : 'permanent';
    debug('close', reason);
    self.emit('close', null, reason);
    self._cleanup();
  });
}

inherits(XhrReceiver, EventEmitter);

XhrReceiver.prototype._chunkHandler = function(status, text) {
  debug('_chunkHandler', status);
  if (status !== 200 || !text) {
    return;
  }

  for (var idx = -1; ; this.bufferPosition += idx + 1) {
    var buf = text.slice(this.bufferPosition);
    idx = buf.indexOf('\n');
    if (idx === -1) {
      break;
    }
    var msg = buf.slice(0, idx);
    if (msg) {
      debug('message', msg);
      this.emit('message', msg);
    }
  }
};

XhrReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

XhrReceiver.prototype.abort = function() {
  debug('abort');
  if (this.xo) {
    this.xo.close();
    debug('close');
    this.emit('close', null, 'user');
    this.xo = null;
  }
  this._cleanup();
};

module.exports = XhrReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],33:[function(require,module,exports){
(function (process,global){
'use strict';

var random = require('../../utils/random')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/random":50,"../../utils/url":52,"debug":55}],34:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , eventUtils = require('../../utils/event')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:xdr');
}

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

function XDRObject(method, url, payload) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self._start(method, url, payload);
  }, 0);
}

inherits(XDRObject, EventEmitter);

XDRObject.prototype._start = function(method, url, payload) {
  debug('_start');
  var self = this;
  var xdr = new global.XDomainRequest();
  // IE caches even POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  xdr.onerror = function() {
    debug('onerror');
    self._error();
  };
  xdr.ontimeout = function() {
    debug('ontimeout');
    self._error();
  };
  xdr.onprogress = function() {
    debug('progress', xdr.responseText);
    self.emit('chunk', 200, xdr.responseText);
  };
  xdr.onload = function() {
    debug('load');
    self.emit('finish', 200, xdr.responseText);
    self._cleanup(false);
  };
  this.xdr = xdr;
  this.unloadRef = eventUtils.unloadAdd(function() {
    self._cleanup(true);
  });
  try {
    // Fails with AccessDenied if port number is bogus
    this.xdr.open(method, url);
    if (this.timeout) {
      this.xdr.timeout = this.timeout;
    }
    this.xdr.send(payload);
  } catch (x) {
    this._error();
  }
};

XDRObject.prototype._error = function() {
  this.emit('finish', 0, '');
  this._cleanup(false);
};

XDRObject.prototype._cleanup = function(abort) {
  debug('cleanup', abort);
  if (!this.xdr) {
    return;
  }
  this.removeAllListeners();
  eventUtils.unloadDel(this.unloadRef);

  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
  if (abort) {
    try {
      this.xdr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xdr = null;
};

XDRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

// IE 8/9 if the request target uses the same scheme - #79
XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

module.exports = XDRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],35:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRCorsObject(method, url, payload, opts) {
  XhrDriver.call(this, method, url, payload, opts);
}

inherits(XHRCorsObject, XhrDriver);

XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

module.exports = XHRCorsObject;

},{"../driver/xhr":17,"inherits":57}],36:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;

},{"events":3,"inherits":57}],37:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRLocalObject(method, url, payload /*, opts */) {
  XhrDriver.call(this, method, url, payload, {
    noCredentials: true
  });
}

inherits(XHRLocalObject, XhrDriver);

XHRLocalObject.enabled = XhrDriver.enabled;

module.exports = XHRLocalObject;

},{"../driver/xhr":17,"inherits":57}],38:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('../utils/event')
  , urlUtils = require('../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , WebsocketDriver = require('./driver/websocket')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:websocket');
}

function WebSocketTransport(transUrl, ignore, options) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url, [], options);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  var ws = this.ws;
  this._cleanup();
  if (ws) {
    ws.close();
  }
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/url":52,"./driver/websocket":19,"debug":55,"events":3,"inherits":57}],39:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XdrStreamingTransport = require('./xdr-streaming')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"./xdr-streaming":40,"inherits":57}],40:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

function XdrStreamingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
}

inherits(XdrStreamingTransport, AjaxBasedTransport);

XdrStreamingTransport.enabled = function(info) {
  if (info.cookie_needed || info.nullOrigin) {
    return false;
  }
  return XDRObject.enabled && info.sameScheme;
};

XdrStreamingTransport.transportName = 'xdr-streaming';
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrStreamingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"inherits":57}],41:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  ;

function XhrPollingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
}

inherits(XhrPollingTransport, AjaxBasedTransport);

XhrPollingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }

  if (XHRLocalObject.enabled && info.sameOrigin) {
    return true;
  }
  return XHRCorsObject.enabled;
};

XhrPollingTransport.transportName = 'xhr-polling';
XhrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XhrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],42:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  , browser = require('../utils/browser')
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../utils/browser":44,"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],43:[function(require,module,exports){
(function (global){
'use strict';

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],44:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  isOpera: function() {
    return global.navigator &&
      /opera/i.test(global.navigator.userAgent);
  }

, isKonqueror: function() {
    return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent);
  }

  // #187 wrap document.domain in try/catch because of WP8 from file:///
, hasDomain: function () {
    // non-browser client always has a domain
    if (!global.document) {
      return true;
    }

    try {
      return !!global.document.domain;
    } catch (e) {
      return false;
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],45:[function(require,module,exports){
'use strict';

var JSON3 = require('json3');

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
// eslint-disable-next-line no-control-regex
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON3.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};

},{"json3":58}],46:[function(require,module,exports){
(function (global){
'use strict';

var random = require('./random');

var onUnload = {}
  , afterUnload = false
    // detect google chrome packaged apps because they don't allow the 'unload' event
  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
  ;

module.exports = {
  attachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.addEventListener(event, listener, false);
    } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
      global.document.attachEvent('on' + event, listener);
      // I get 'window' for ie8.
      global.attachEvent('on' + event, listener);
    }
  }

, detachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.removeEventListener(event, listener, false);
    } else if (global.document && global.detachEvent) {
      global.document.detachEvent('on' + event, listener);
      global.detachEvent('on' + event, listener);
    }
  }

, unloadAdd: function(listener) {
    if (isChromePackagedApp) {
      return null;
    }

    var ref = random.string(8);
    onUnload[ref] = listener;
    if (afterUnload) {
      setTimeout(this.triggerUnloadCallbacks, 0);
    }
    return ref;
  }

, unloadDel: function(ref) {
    if (ref in onUnload) {
      delete onUnload[ref];
    }
  }

, triggerUnloadCallbacks: function() {
    for (var ref in onUnload) {
      onUnload[ref]();
      delete onUnload[ref];
    }
  }
};

var unloadTriggered = function() {
  if (afterUnload) {
    return;
  }
  afterUnload = true;
  module.exports.triggerUnloadCallbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
if (!isChromePackagedApp) {
  module.exports.attachEvent('unload', unloadTriggered);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./random":50}],47:[function(require,module,exports){
(function (process,global){
'use strict';

var eventUtils = require('./event')
  , JSON3 = require('json3')
  , browser = require('./browser')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:iframe');
}

module.exports = {
  WPrefix: '_jp'
, currentWindowId: null

, polluteGlobalNamespace: function() {
    if (!(module.exports.WPrefix in global)) {
      global[module.exports.WPrefix] = {};
    }
  }

, postMessage: function(type, data) {
    if (global.parent !== global) {
      global.parent.postMessage(JSON3.stringify({
        windowId: module.exports.currentWindowId
      , type: type
      , data: data || ''
      }), '*');
    } else {
      debug('Cannot postMessage, no parent window.', type, data);
    }
  }

, createIframe: function(iframeUrl, errorCallback) {
    var iframe = global.document.createElement('iframe');
    var tref, unloadRef;
    var unattach = function() {
      debug('unattach');
      clearTimeout(tref);
      // Explorer had problems with that.
      try {
        iframe.onload = null;
      } catch (x) {
        // intentionally empty
      }
      iframe.onerror = null;
    };
    var cleanup = function() {
      debug('cleanup');
      if (iframe) {
        unattach();
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
        setTimeout(function() {
          if (iframe) {
            iframe.parentNode.removeChild(iframe);
          }
          iframe = null;
        }, 0);
        eventUtils.unloadDel(unloadRef);
      }
    };
    var onerror = function(err) {
      debug('onerror', err);
      if (iframe) {
        cleanup();
        errorCallback(err);
      }
    };
    var post = function(msg, origin) {
      debug('post', msg, origin);
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {
        // intentionally empty
      }
    };

    iframe.src = iframeUrl;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function() {
      onerror('onerror');
    };
    iframe.onload = function() {
      debug('onload');
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
      clearTimeout(tref);
      tref = setTimeout(function() {
        onerror('onload timeout');
      }, 2000);
    };
    global.document.body.appendChild(iframe);
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }

/* eslint no-undef: "off", new-cap: "off" */
, createHtmlfile: function(iframeUrl, errorCallback) {
    var axo = ['Active'].concat('Object').join('X');
    var doc = new global[axo]('htmlfile');
    var tref, unloadRef;
    var iframe;
    var unattach = function() {
      clearTimeout(tref);
      iframe.onerror = null;
    };
    var cleanup = function() {
      if (doc) {
        unattach();
        eventUtils.unloadDel(unloadRef);
        iframe.parentNode.removeChild(iframe);
        iframe = doc = null;
        CollectGarbage();
      }
    };
    var onerror = function(r) {
      debug('onerror', r);
      if (doc) {
        cleanup();
        errorCallback(r);
      }
    };
    var post = function(msg, origin) {
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {
        // intentionally empty
      }
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframeUrl;
    iframe.onerror = function() {
      onerror('onerror');
    };
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }
};

module.exports.iframeEnabled = false;
if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror());
}

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./browser":44,"./event":46,"debug":55,"json3":58}],48:[function(require,module,exports){
(function (global){
'use strict';

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists;

  try {
    levelExists = global.console && global.console[level] && global.console[level].apply;
  } catch(e) {
    // do nothing
  }

  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
'use strict';

module.exports = {
  isObject: function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

, extend: function(obj) {
    if (!this.isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  }
};

},{}],50:[function(require,module,exports){
'use strict';

/* global crypto:true */
var crypto = require('crypto');

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
module.exports = {
  string: function(length) {
    var max = _randomStringChars.length;
    var bytes = crypto.randomBytes(length);
    var ret = [];
    for (var i = 0; i < length; i++) {
      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
    }
    return ret.join('');
  }

, number: function(max) {
    return Math.floor(Math.random() * max);
  }

, numberString: function(max) {
    var t = ('' + (max - 1)).length;
    var p = new Array(t + 1).join('0');
    return (p + this.number(max)).slice(-t);
  }
};

},{"crypto":43}],51:[function(require,module,exports){
(function (process){
'use strict';

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

}).call(this,{ env: {} })

},{"debug":55}],52:[function(require,module,exports){
(function (process){
'use strict';

var URL = require('url-parse');

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:url');
}

module.exports = {
  getOrigin: function(url) {
    if (!url) {
      return null;
    }

    var p = new URL(url);
    if (p.protocol === 'file:') {
      return null;
    }

    var port = p.port;
    if (!port) {
      port = (p.protocol === 'https:') ? '443' : '80';
    }

    return p.protocol + '//' + p.hostname + ':' + port;
  }

, isOriginEqual: function(a, b) {
    var res = this.getOrigin(a) === this.getOrigin(b);
    debug('same', a, b, res);
    return res;
  }

, isSchemeEqual: function(a, b) {
    return (a.split(':')[0] === b.split(':')[0]);
  }

, addPath: function (url, path) {
    var qs = url.split('?');
    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
  }

, addQuery: function (url, q) {
    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
  }
};

}).call(this,{ env: {} })

},{"debug":55,"url-parse":61}],53:[function(require,module,exports){
module.exports = '1.1.4';

},{}],54:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000
var m = s * 60
var h = m * 60
var d = h * 24
var y = d * 365.25

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {}
  var type = typeof val
  if (type === 'string' && val.length > 0) {
    return parse(val)
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ?
			fmtLong(val) :
			fmtShort(val)
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
}

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str)
  if (str.length > 10000) {
    return
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
  if (!match) {
    return
  }
  var n = parseFloat(match[1])
  var type = (match[2] || 'ms').toLowerCase()
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y
    case 'days':
    case 'day':
    case 'd':
      return n * d
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n
    default:
      return undefined
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd'
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h'
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm'
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's'
  }
  return ms + 'ms'
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms'
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name
  }
  return Math.ceil(ms / n) + ' ' + name + 's'
}

},{}],55:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,{ env: {} })

},{"./debug":56}],56:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":54}],57:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],58:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  //
  // Little nifty parsing hack, leverage the fact that RegExp.exec increments
  // the lastIndex property so we can continue executing this loop until we've
  // parsed all results.
  //
  for (;
    part = parser.exec(query);
    result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])
  );

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],60:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],61:[function(require,module,exports){
'use strict';

var required = require('requires-port')
  , lolcation = require('./lolcation')
  , qs = require('querystringify')
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @api private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @api private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} location Location defaults for relative paths.
 * @param {Boolean|Function} parser Parser for the query string.
 * @api public
 */
function URL(address, location, parser) {
  if (!(this instanceof URL)) {
    return new URL(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[2] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];
    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL}
 * @api public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
      url.pathname = value.length && value.charAt(0) !== '/' ? '/' + value : value;

      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
};

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String}
 * @api public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

URL.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
URL.extractProtocol = extractProtocol;
URL.location = lolcation;
URL.qs = qs;

module.exports = URL;

},{"./lolcation":62,"querystringify":59,"requires-port":60}],62:[function(require,module,exports){
(function (global){
'use strict';

var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 }
  , URL;

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @api public
 */
module.exports = function lolcation(loc) {
  loc = loc || global.location || {};
  URL = URL || require('./');

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new URL(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new URL(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./":61}]},{},[1])(1)
});


//# sourceMappingURL=sockjs.js.map

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ansiRegex = __webpack_require__(46)();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(53);
var util = __webpack_require__(60);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(56);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).

var ansiHTML = __webpack_require__(45);
var Entities = __webpack_require__(48).AllHtmlEntities;

var entities = new Entities();

var colors = {
  reset: ['transparent', 'transparent'],
  black: '181818',
  red: 'E36049',
  green: 'B3CB74',
  yellow: 'FFD080',
  blue: '7CAFC2',
  magenta: '7FACCA',
  cyan: 'C3C2EF',
  lightgrey: 'EBE7E3',
  darkgrey: '6D7891'
};
ansiHTML.setColors(colors);

function createOverlayIframe(onIframeLoad) {
  var iframe = document.createElement('iframe');
  iframe.id = 'webpack-dev-server-client-overlay';
  iframe.src = 'about:blank';
  iframe.style.position = 'fixed';
  iframe.style.left = 0;
  iframe.style.top = 0;
  iframe.style.right = 0;
  iframe.style.bottom = 0;
  iframe.style.width = '100vw';
  iframe.style.height = '100vh';
  iframe.style.border = 'none';
  iframe.style.zIndex = 9999999999;
  iframe.onload = onIframeLoad;
  return iframe;
}

function addOverlayDivTo(iframe) {
  var div = iframe.contentDocument.createElement('div');
  div.id = 'webpack-dev-server-client-overlay-div';
  div.style.position = 'fixed';
  div.style.boxSizing = 'border-box';
  div.style.left = 0;
  div.style.top = 0;
  div.style.right = 0;
  div.style.bottom = 0;
  div.style.width = '100vw';
  div.style.height = '100vh';
  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
  div.style.color = '#E8E8E8';
  div.style.fontFamily = 'Menlo, Consolas, monospace';
  div.style.fontSize = 'large';
  div.style.padding = '2rem';
  div.style.lineHeight = '1.2';
  div.style.whiteSpace = 'pre-wrap';
  div.style.overflow = 'auto';
  iframe.contentDocument.body.appendChild(div);
  return div;
}

var overlayIframe = null;
var overlayDiv = null;
var lastOnOverlayDivReady = null;

function ensureOverlayDivExists(onOverlayDivReady) {
  if (overlayDiv) {
    // Everything is ready, call the callback right away.
    onOverlayDivReady(overlayDiv);
    return;
  }

  // Creating an iframe may be asynchronous so we'll schedule the callback.
  // In case of multiple calls, last callback wins.
  lastOnOverlayDivReady = onOverlayDivReady;

  if (overlayIframe) {
    // We're already creating it.
    return;
  }

  // Create iframe and, when it is ready, a div inside it.
  overlayIframe = createOverlayIframe(function () {
    overlayDiv = addOverlayDivTo(overlayIframe);
    // Now we can talk!
    lastOnOverlayDivReady(overlayDiv);
  });

  // Zalgo alert: onIframeLoad() will be called either synchronously
  // or asynchronously depending on the browser.
  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.
  document.body.appendChild(overlayIframe);
}

function showMessageOverlay(message) {
  ensureOverlayDivExists(function (div) {
    // Make it look similar to our terminal.
    div.innerHTML = '<span style="color: #' + colors.red + '">Failed to compile.</span><br><br>' + ansiHTML(entities.encode(message));
  });
}

function destroyErrorOverlay() {
  if (!overlayDiv) {
    // It is not there in the first place.
    return;
  }

  // Clean up and reset internal state.
  document.body.removeChild(overlayIframe);
  overlayDiv = null;
  overlayIframe = null;
  lastOnOverlayDivReady = null;
}

// Successful compilation.
exports.clear = function handleSuccess() {
  destroyErrorOverlay();
};

// Compilation with errors (e.g. syntax error or missing modules).
exports.showMessage = function handleMessage(messages) {
  showMessageOverlay(messages[0]);
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SockJS = __webpack_require__(57);

var retries = 0;
var sock = null;

var socket = function initSocket(url, handlers) {
  sock = new SockJS(url);

  sock.onopen = function onopen() {
    retries = 0;
  };

  sock.onclose = function onclose() {
    if (retries === 0) {
      handlers.close();
    }

    // Try to reconnect.
    sock = null;

    // After 10 retries stop trying, to prevent logspam.
    if (retries <= 10) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-mixed-operators, no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;

      setTimeout(function () {
        socket(url, handlers);
      }, retryInMs);
    }
  };

  sock.onmessage = function onmessage(e) {
    // This assumes that all data sent via the websocket is JSON.
    var msg = JSON.parse(e.data);
    if (handlers[msg.type]) {
      handlers[msg.type](msg.data);
    }
  };
};

module.exports = socket;

/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var EventEmitter = __webpack_require__(47);
module.exports = new EventEmitter();


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var SensorSample = __webpack_require__(67);
var MathUtil = __webpack_require__(6);
var Util = __webpack_require__(10);

/**
 * An implementation of a simple complementary filter, which fuses gyroscope and
 * accelerometer data from the 'devicemotion' event.
 *
 * Accelerometer data is very noisy, but stable over the long term.
 * Gyroscope data is smooth, but tends to drift over the long term.
 *
 * This fusion is relatively simple:
 * 1. Get orientation estimates from accelerometer by applying a low-pass filter
 *    on that data.
 * 2. Get orientation estimates from gyroscope by integrating over time.
 * 3. Combine the two estimates, weighing (1) in the long term, but (2) for the
 *    short term.
 */
function ComplementaryFilter(kFilter) {
  this.kFilter = kFilter;

  // Raw sensor measurements.
  this.currentAccelMeasurement = new SensorSample();
  this.currentGyroMeasurement = new SensorSample();
  this.previousGyroMeasurement = new SensorSample();

  // Set default look direction to be in the correct direction.
  if (Util.isIOS()) {
    this.filterQ = new MathUtil.Quaternion(-1, 0, 0, 1);
  } else {
    this.filterQ = new MathUtil.Quaternion(1, 0, 0, 1);
  }
  this.previousFilterQ = new MathUtil.Quaternion();
  this.previousFilterQ.copy(this.filterQ);

  // Orientation based on the accelerometer.
  this.accelQ = new MathUtil.Quaternion();
  // Whether or not the orientation has been initialized.
  this.isOrientationInitialized = false;
  // Running estimate of gravity based on the current orientation.
  this.estimatedGravity = new MathUtil.Vector3();
  // Measured gravity based on accelerometer.
  this.measuredGravity = new MathUtil.Vector3();

  // Debug only quaternion of gyro-based orientation.
  this.gyroIntegralQ = new MathUtil.Quaternion();
}

ComplementaryFilter.prototype.addAccelMeasurement = function(vector, timestampS) {
  this.currentAccelMeasurement.set(vector, timestampS);
};

ComplementaryFilter.prototype.addGyroMeasurement = function(vector, timestampS) {
  this.currentGyroMeasurement.set(vector, timestampS);

  var deltaT = timestampS - this.previousGyroMeasurement.timestampS;
  if (Util.isTimestampDeltaValid(deltaT)) {
    this.run_();
  }

  this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
};

ComplementaryFilter.prototype.run_ = function() {

  if (!this.isOrientationInitialized) {
    this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
    this.previousFilterQ.copy(this.accelQ);
    this.isOrientationInitialized = true;
    return;
  }

  var deltaT = this.currentGyroMeasurement.timestampS -
      this.previousGyroMeasurement.timestampS;

  // Convert gyro rotation vector to a quaternion delta.
  var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
  this.gyroIntegralQ.multiply(gyroDeltaQ);

  // filter_1 = K * (filter_0 + gyro * dT) + (1 - K) * accel.
  this.filterQ.copy(this.previousFilterQ);
  this.filterQ.multiply(gyroDeltaQ);

  // Calculate the delta between the current estimated gravity and the real
  // gravity vector from accelerometer.
  var invFilterQ = new MathUtil.Quaternion();
  invFilterQ.copy(this.filterQ);
  invFilterQ.inverse();

  this.estimatedGravity.set(0, 0, -1);
  this.estimatedGravity.applyQuaternion(invFilterQ);
  this.estimatedGravity.normalize();

  this.measuredGravity.copy(this.currentAccelMeasurement.sample);
  this.measuredGravity.normalize();

  // Compare estimated gravity with measured gravity, get the delta quaternion
  // between the two.
  var deltaQ = new MathUtil.Quaternion();
  deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
  deltaQ.inverse();

  if (Util.isDebug()) {
    console.log('Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)',
                MathUtil.radToDeg * Util.getQuaternionAngle(deltaQ),
                (this.estimatedGravity.x).toFixed(1),
                (this.estimatedGravity.y).toFixed(1),
                (this.estimatedGravity.z).toFixed(1),
                (this.measuredGravity.x).toFixed(1),
                (this.measuredGravity.y).toFixed(1),
                (this.measuredGravity.z).toFixed(1));
  }

  // Calculate the SLERP target: current orientation plus the measured-estimated
  // quaternion delta.
  var targetQ = new MathUtil.Quaternion();
  targetQ.copy(this.filterQ);
  targetQ.multiply(deltaQ);

  // SLERP factor: 0 is pure gyro, 1 is pure accel.
  this.filterQ.slerp(targetQ, 1 - this.kFilter);

  this.previousFilterQ.copy(this.filterQ);
};

ComplementaryFilter.prototype.getOrientation = function() {
  return this.filterQ;
};

ComplementaryFilter.prototype.accelToQuaternion_ = function(accel) {
  var normAccel = new MathUtil.Vector3();
  normAccel.copy(accel);
  normAccel.normalize();
  var quat = new MathUtil.Quaternion();
  quat.setFromUnitVectors(new MathUtil.Vector3(0, 0, -1), normAccel);
  quat.inverse();
  return quat;
};

ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function(gyro, dt) {
  // Extract axis and angle from the gyroscope data.
  var quat = new MathUtil.Quaternion();
  var axis = new MathUtil.Vector3();
  axis.copy(gyro);
  axis.normalize();
  quat.setFromAxisAngle(axis, gyro.length() * dt);
  return quat;
};


module.exports = ComplementaryFilter;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MathUtil = __webpack_require__(6);
var Util = __webpack_require__(10);

/**
 * Given an orientation and the gyroscope data, predicts the future orientation
 * of the head. This makes rendering appear faster.
 *
 * Also see: http://msl.cs.uiuc.edu/~lavalle/papers/LavYerKatAnt14.pdf
 *
 * @param {Number} predictionTimeS time from head movement to the appearance of
 * the corresponding image.
 */
function PosePredictor(predictionTimeS) {
  this.predictionTimeS = predictionTimeS;

  // The quaternion corresponding to the previous state.
  this.previousQ = new MathUtil.Quaternion();
  // Previous time a prediction occurred.
  this.previousTimestampS = null;

  // The delta quaternion that adjusts the current pose.
  this.deltaQ = new MathUtil.Quaternion();
  // The output quaternion.
  this.outQ = new MathUtil.Quaternion();
}

PosePredictor.prototype.getPrediction = function(currentQ, gyro, timestampS) {
  if (!this.previousTimestampS) {
    this.previousQ.copy(currentQ);
    this.previousTimestampS = timestampS;
    return currentQ;
  }

  // Calculate axis and angle based on gyroscope rotation rate data.
  var axis = new MathUtil.Vector3();
  axis.copy(gyro);
  axis.normalize();

  var angularSpeed = gyro.length();

  // If we're rotating slowly, don't do prediction.
  if (angularSpeed < MathUtil.degToRad * 20) {
    if (Util.isDebug()) {
      console.log('Moving slowly, at %s deg/s: no prediction',
                  (MathUtil.radToDeg * angularSpeed).toFixed(1));
    }
    this.outQ.copy(currentQ);
    this.previousQ.copy(currentQ);
    return this.outQ;
  }

  // Get the predicted angle based on the time delta and latency.
  var deltaT = timestampS - this.previousTimestampS;
  var predictAngle = angularSpeed * this.predictionTimeS;

  this.deltaQ.setFromAxisAngle(axis, predictAngle);
  this.outQ.copy(this.previousQ);
  this.outQ.multiply(this.deltaQ);

  this.previousQ.copy(currentQ);
  this.previousTimestampS = timestampS;

  return this.outQ;
};


module.exports = PosePredictor;


/***/ }),
/* 67 */
/***/ (function(module, exports) {

function SensorSample(sample, timestampS) {
  this.set(sample, timestampS);
};

SensorSample.prototype.set = function(sample, timestampS) {
  this.sample = sample;
  this.timestampS = timestampS;
};

SensorSample.prototype.copy = function(sensorSample) {
  this.set(sensorSample.sample, sensorSample.timestampS);
};

module.exports = SensorSample;


/***/ }),
/* 68 */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	throw new Error("Cannot find module '" + req + "'.");
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = 68;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(21);
module.exports = __webpack_require__(20);


/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBhOWYzMThlN2E3MmM0ZWNiNzQ2YyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcIkBlZ2pzL2NvbXBvbmVudFwiLFwiY29tbW9uanMyXCI6XCJAZWdqcy9jb21wb25lbnRcIixcImFtZFwiOlwiQGVnanMvY29tcG9uZW50XCIsXCJyb290XCI6W1wiZWdcIixcIkNvbXBvbmVudFwiXX0iLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL21hdGgtdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvbWF0aFV0aWwvY29tbW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9ZYXdQaXRjaENvbnRyb2wvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L0BlZ2pzL2FnZW50L2Rpc3QvYWdlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vd2VidnItcG9seWZpbGwvc3JjL21hdGgtdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvUGFub0ltYWdlUmVuZGVyZXIvV2ViR0xVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvWWF3UGl0Y2hDb250cm9sL2NvbnN0cy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vd2VidnItcG9seWZpbGwvc3JjL3V0aWwuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJAZWdqcy9heGVzXCIsXCJjb21tb25qczJcIjpcIkBlZ2pzL2F4ZXNcIixcImFtZFwiOlwiQGVnanMvYXhlc1wiLFwicm9vdFwiOltcImVnXCIsXCJBeGVzXCJdfSIsIndlYnBhY2s6Ly8vLi9zcmMvUGFub0ltYWdlUmVuZGVyZXIvcmVuZGVyZXIvUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1Bhbm9WaWV3ZXIvY29uc3RzLmpzIiwid2VicGFjazovLy8uL3NyYy9TcGluVmlld2VyL1Nwcml0ZUltYWdlLmpzIiwid2VicGFjazovLy8uL3NyYy9ZYXdQaXRjaENvbnRyb2wvU2NyZWVuUm90YXRpb25BbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvWWF3UGl0Y2hDb250cm9sL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ZYXdQaXRjaENvbnRyb2wvaW5wdXQvRnVzaW9uUG9zZVNlbnNvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvWWF3UGl0Y2hDb250cm9sL3V0aWxzLmpzIiwid2VicGFjazovLy8uL34vaHRtbC1lbnRpdGllcy9saWIvaHRtbDUtZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQ/YzliOCIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50Iiwid2VicGFjazovLy8uL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9JbWFnZUxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvUGFub0ltYWdlUmVuZGVyZXIvUGFub0ltYWdlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1Bhbm9JbWFnZVJlbmRlcmVyL1ZpZGVvTG9hZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9icm93c2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvUGFub0ltYWdlUmVuZGVyZXIvcmVuZGVyZXIvQ3ViZVJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9yZW5kZXJlci9TcGhlcmVSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvUGFub1ZpZXdlci9QYW5vVmlld2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9QYW5vVmlld2VyL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1Bhbm9WaWV3ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NwaW5WaWV3ZXIvU3BpblZpZXdlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvU3BpblZpZXdlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvWWF3UGl0Y2hDb250cm9sL0RldmljZVF1YXRlcm5pb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1lhd1BpdGNoQ29udHJvbC9ZYXdQaXRjaENvbnRyb2wuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1lhd1BpdGNoQ29udHJvbC9pbnB1dC9Db21wbGVtZW50YXJ5RmlsdGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9ZYXdQaXRjaENvbnRyb2wvaW5wdXQvRGV2aWNlTW90aW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9ZYXdQaXRjaENvbnRyb2wvaW5wdXQvUm90YXRpb25QYW5JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvWWF3UGl0Y2hDb250cm9sL2lucHV0L1RpbHRNb3Rpb25JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvWWF3UGl0Y2hDb250cm9sL2lucHV0L1doZWVsSW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL21hdGhVdGlsL21hdDQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL21hdGhVdGlsL3F1YXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL21hdGhVdGlsL3ZlYzIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL21hdGhVdGlsL3ZlYzMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbnNpLWh0bWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbnNpLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2h0bWwtZW50aXRpZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9odG1sLWVudGl0aWVzL2xpYi9odG1sNC1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2h0bWwtZW50aXRpZXMvbGliL3htbC1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8uL34vcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9zb2NranMtY2xpZW50L2Rpc3Qvc29ja2pzLmpzIiwid2VicGFjazovLy8uL34vc3RyaXAtYW5zaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vLy4vfi91cmwvdXRpbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L292ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9zb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9lbWl0dGVyLmpzIiwid2VicGFjazovLy8uL34vd2VidnItcG9seWZpbGwvc3JjL3NlbnNvci1mdXNpb24vY29tcGxlbWVudGFyeS1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi93ZWJ2ci1wb2x5ZmlsbC9zcmMvc2Vuc29yLWZ1c2lvbi9wb3NlLXByZWRpY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3dlYnZyLXBvbHlmaWxsL3NyYy9zZW5zb3ItZnVzaW9uL3NlbnNvci1zYW1wbGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9ob3Qgbm9ucmVjdXJzaXZlIF5cXC5cXC9sb2ckIl0sIm5hbWVzIjpbInF1YXRUb1ZlYzMiLCJxdWF0ZXJuaW9uIiwiYmFzZVYiLCJmcm9tVmFsdWVzIiwidHJhbnNmb3JtUXVhdCIsInV0aWwiLCJpc1Bvd2VyT2ZUd28iLCJuIiwiZXh0cmFjdFBpdGNoRnJvbVF1YXQiLCJNYXRoIiwiYXRhbjIiLCJzcXJ0IiwicG93IiwiUk9UQVRFX0NPTlNUQU5UIiwiUElUQ0hfREVMVEEiLCJZQVdfREVMVEFfQllfUk9MTCIsIllBV19ERUxUQV9CWV9ZQVciLCJ0YXJnZXRBeGlzIiwibWVzaFBvaW50IiwiZ2V0Um90YXRpb25EZWx0YSIsInByZXZRIiwiY3VyUSIsInJvdGF0ZUtpbmQiLCJwcmV2UXVhdGVybmlvbiIsImNsb25lIiwiY3VyUXVhdGVybmlvbiIsIm5vcm1hbGl6ZSIsInByZXZQb2ludCIsImN1clBvaW50Iiwicm90YXRlRGlzdGFuY2UiLCJkb3QiLCJjcm9zcyIsImNyZWF0ZSIsInJvdGF0ZURpcmVjdGlvbiIsIm1lc2hQb2ludDIiLCJtZXNoUG9pbnQzIiwidmVjVSIsInZlY1YiLCJ2ZWNOIiwiY29lZmZpY2llbnRBIiwiY29lZmZpY2llbnRCIiwiY29lZmZpY2llbnRDIiwiZGlzdGFuY2UiLCJhYnMiLCJwcm9qZWN0ZWRQcmV2UG9pbnQiLCJzdWJ0cmFjdCIsInNjYWxlIiwidHJpZ29ub21ldHJpY1JhdGlvIiwibGVuZ3RoIiwidGhldGEiLCJhY29zIiwiY3Jvc3NWZWMiLCJ0aGV0YURpcmVjdGlvbiIsImRlbHRhUmFkaWFuIiwidG9EZWdyZWUiLCJnbE1hdHJpeCIsIm1hdDQiLCJxdWF0IiwidmVjMiIsInZlYzMiLCJBUlJBWV9UWVBFIiwiRmxvYXQzMkFycmF5IiwiQXJyYXkiLCJkZWdyZWUiLCJQSSIsInRvUmFkaWFuIiwiYSIsIkVQU0lMT04iLCJtb2R1bGUiLCJleHBvcnRzIiwid2luIiwid2luZG93Iiwic2VsZiIsIkZ1bmN0aW9uIiwic2NyZWVuIiwib3JpZW50YXRpb24iLCJkb2N1bWVudCIsImdldENvbXB1dGVkU3R5bGUiLCJ1c2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJTVVBQT1JUX1RPVUNIIiwiU1VQUE9SVF9ERVZJQ0VNT1RJT04iLCJXRUJHTF9FUlJPUl9DT0RFIiwid2ViZ2xBdmFpbGFiaWxpdHkiLCJXZWJHTFV0aWxzIiwiY3JlYXRlU2hhZGVyIiwiZ2wiLCJ0eXBlIiwic291cmNlIiwic2hhZGVyIiwic2hhZGVyU291cmNlIiwiY29tcGlsZVNoYWRlciIsInN1Y2Nlc3MiLCJnZXRTaGFkZXJQYXJhbWV0ZXIiLCJDT01QSUxFX1NUQVRVUyIsImRlbGV0ZVNoYWRlciIsImNyZWF0ZVByb2dyYW0iLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciIsInByb2dyYW0iLCJhdHRhY2hTaGFkZXIiLCJsaW5rUHJvZ3JhbSIsImdldFByb2dyYW1QYXJhbWV0ZXIiLCJMSU5LX1NUQVRVUyIsImRlbGV0ZVByb2dyYW0iLCJpbml0QnVmZmVyIiwidGFyZ2V0IiwiZGF0YSIsIml0ZW1TaXplIiwiYXR0ciIsImJ1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsImJpbmRCdWZmZXIiLCJidWZmZXJEYXRhIiwiU1RBVElDX0RSQVciLCJudW1JdGVtcyIsInVuZGVmaW5lZCIsImVuYWJsZVZlcnRleEF0dHJpYkFycmF5IiwidmVydGV4QXR0cmliUG9pbnRlciIsIkZMT0FUIiwiYmluZEJ1ZmZlclRvQXR0cmlidXRlIiwiQVJSQVlfQlVGRkVSIiwiZ2V0V2ViZ2xDb250ZXh0IiwiY2FudmFzIiwidXNlckNvbnRleHRBdHRyaWJ1dGVzIiwid2ViZ2xJZGVudGlmaWVycyIsImNvbnRleHQiLCJjb250ZXh0QXR0cmlidXRlcyIsInByZXNlcnZlRHJhd2luZ0J1ZmZlciIsImFudGlhbGlhcyIsIm9uV2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvciIsImUiLCJzdGF0dXNNZXNzYWdlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImkiLCJnZXRDb250ZXh0IiwidCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjcmVhdGVUZXh0dXJlIiwidGV4dHVyZVRhcmdldCIsInRleHR1cmUiLCJiaW5kVGV4dHVyZSIsInRleFBhcmFtZXRlcmkiLCJURVhUVVJFX01BR19GSUxURVIiLCJMSU5FQVIiLCJURVhUVVJFX01JTl9GSUxURVIiLCJURVhUVVJFX1dSQVBfUyIsIkNMQU1QX1RPX0VER0UiLCJURVhUVVJFX1dSQVBfVCIsImlzV2ViR0xBdmFpbGFibGUiLCJjcmVhdGVFbGVtZW50Iiwid2ViZ2xDb250ZXh0IiwibG9zZUNvbnRleHRFeHRlbnNpb24iLCJnZXRFeHRlbnNpb24iLCJsb3NlQ29udGV4dCIsImlzU3RhYmxlV2ViR0wiLCJhZ2VudEluZm8iLCJpc1N0YWJsZVdlYmdsIiwib3MiLCJuYW1lIiwicGFyc2VGbG9hdCIsInZlcnNpb24iLCJicm93c2VyIiwiZ2V0RXJyb3JOYW1lRnJvbVdlYkdMRXJyb3JDb2RlIiwiY29kZSIsIkNPTlRST0xfTU9ERV9WUiIsIkNPTlRST0xfTU9ERV9ZQVdQSVRDSCIsIlRPVUNIX0RJUkVDVElPTl9OT05FIiwiVE9VQ0hfRElSRUNUSU9OX1lBVyIsIlRPVUNIX0RJUkVDVElPTl9QSVRDSCIsIlRPVUNIX0RJUkVDVElPTl9BTEwiLCJNQ19ERUNFTEVSQVRJT04iLCJNQ19NQVhJTVVNX0RVUkFUSU9OIiwiTUNfQklORF9TQ0FMRSIsIk1JTl9GSUVMRF9PRl9WSUVXIiwiTUFYX0ZJRUxEX09GX1ZJRVciLCJQQU5fU0NBTEUiLCJERUxUQV9USFJFU0hPTEQiLCJZQVdfUkFOR0VfSEFMRiIsIlBJVENIX1JBTkdFX0hBTEYiLCJDSVJDVUxBUl9QSVRDSF9SQU5HRV9IQUxGIiwiUElOQ0hfRVZFTlRTIiwiS0VZTUFQIiwiTEVGVF9BUlJPVyIsIkEiLCJVUF9BUlJPVyIsIlciLCJSSUdIVF9BUlJPVyIsIkQiLCJET1dOX0FSUk9XIiwiUyIsIkdZUk9fTU9ERSIsIk5PTkUiLCJZQVdQSVRDSCIsIlZSIiwiUmVuZGVyZXIiLCJFUlJPUl9UWVBFIiwiSU5WQUxJRF9ERVZJQ0UiLCJOT19XRUJHTCIsIkZBSUxfSU1BR0VfTE9BRCIsIkZBSUxfQklORF9URVhUVVJFIiwiSU5WQUxJRF9SRVNPVVJDRSIsIlJFTkRFUklOR19DT05URVhUX0xPU1QiLCJFVkVOVFMiLCJSRUFEWSIsIlZJRVdfQ0hBTkdFIiwiQU5JTUFUSU9OX0VORCIsIkVSUk9SIiwiUFJPSkVDVElPTl9UWVBFIiwiRVFVSVJFQ1RBTkdVTEFSIiwiQ1VCRU1BUCIsIlNwcml0ZUltYWdlIiwiZWxlbWVudCIsIm9wdGlvbnMiLCJvcHQiLCJfZWwiLCJfcm93Q291bnQiLCJyb3dDb3VudCIsIl9jb2xDb3VudCIsImNvbENvdW50IiwiX3RvdGFsQ291bnQiLCJfd2lkdGgiLCJ3aWR0aCIsIl9oZWlnaHQiLCJoZWlnaHQiLCJfYXV0b0hlaWdodCIsImF1dG9IZWlnaHQiLCJfY29sUm93IiwiY29sUm93IiwiZnJhbWVJbmRleCIsInNldEZyYW1lSW5kZXgiLCJzdHlsZSIsIl9nZXRTaXplU3RyaW5nIiwiaW1hZ2VVcmwiLCJzZXRUaW1lb3V0IiwidHJpZ2dlciIsIl9pbWFnZSIsIkltYWdlIiwib25sb2FkIiwiX2JnIiwiX2NyZWF0ZUJnRGl2IiwiYXBwZW5kQ2hpbGQiLCJzZXRDb2xSb3ciLCJiZ0VsZW1lbnQiLCJfYXV0b1BsYXlSZXNlcnZlZEluZm8iLCJwbGF5Iiwib25lcnJvciIsInNyYyIsImltZyIsImVsIiwiYmFja2dyb3VuZEltYWdlIiwiYmFja2dyb3VuZFNpemUiLCJ1bml0V2lkdGgiLCJ1bml0SGVpZ2h0IiwiciIsInBhZGRpbmdCb3R0b20iLCJpbmRleCIsInRvQ29sUm93IiwiZ2V0RnJhbWVJbmRleCIsImNvbCIsInJvdyIsImJhY2tncm91bmRQb3NpdGlvbiIsImdldENvbFJvdyIsInNpemUiLCJzdG9wIiwiX2F1dG9QbGF5VGltZXIiLCJjbGVhckludGVydmFsIiwiaW50ZXJ2YWwiLCJwbGF5Q291bnQiLCJjb3VudCIsImZyYW1lQ291bnQiLCJzZXRJbnRlcnZhbCIsImZsb29yIiwic2NyZWVuUm90YXRpb25BbmdsZUluc3QiLCJyZWZDb3VudCIsIlNjcmVlblJvdGF0aW9uQW5nbGUiLCJfb25EZXZpY2VPcmllbnRhdGlvbiIsImJpbmQiLCJfb25PcmllbnRhdGlvbkNoYW5nZSIsIl9zcGluUiIsIl9zY3JlZW5PcmllbnRhdGlvbkFuZ2xlIiwiYmV0YSIsImdhbW1hIiwiYmV0YVIiLCJnYW1tYVIiLCJjb3MiLCJzaW4iLCJhbmdsZSIsImdldFJhZGlhbiIsInVucmVmIiwiWWF3UGl0Y2hDb250cm9sIiwiS19GSUxURVIiLCJQUkVESUNUSU9OX1RJTUVfUyIsIkZ1c2lvblBvc2VTZW5zb3IiLCJkZXZpY2VNb3Rpb24iLCJhY2NlbGVyb21ldGVyIiwiVmVjdG9yMyIsImd5cm9zY29wZSIsIl9vbkRldmljZU1vdGlvbkNoYW5nZSIsIl9vblNjcmVlbk9yaWVudGF0aW9uQ2hhbmdlIiwiZmlsdGVyIiwicG9zZVByZWRpY3RvciIsImZpbHRlclRvV29ybGRRIiwiUXVhdGVybmlvbiIsImlzRmlyZWZveEFuZHJvaWQiLCJpc0lPUyIsIl9pc0VuYWJsZWQiLCJzZXRGcm9tQXhpc0FuZ2xlIiwiaW52ZXJzZVdvcmxkVG9TY3JlZW5RIiwid29ybGRUb1NjcmVlblEiLCJvcmlnaW5hbFBvc2VBZGp1c3RRIiwiX3NldFNjcmVlblRyYW5zZm9ybSIsImlzTGFuZHNjYXBlTW9kZSIsIm11bHRpcGx5IiwicmVzZXRRIiwib24iLCJlbmFibGUiLCJpc0VuYWJsZWQiLCJkaXNhYmxlIiwiZGVzdHJveSIsIl90cmlnZ2VyQ2hhbmdlIiwiZ2V0T3JpZW50YXRpb24iLCJfcHJldk9yaWVudGF0aW9uIiwiZXF1YWxzIiwib3V0IiwiX2NvbnZlcnRGdXNpb25Ub1ByZWRpY3RlZCIsIngiLCJ5IiwieiIsInciLCJwcmVkaWN0ZWRRIiwiZ2V0UHJlZGljdGlvbiIsInByZXZpb3VzVGltZXN0YW1wUyIsImNvcHkiLCJpbnB1dEV2ZW50IiwiYWNjR3Jhdml0eSIsImFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkiLCJyb3RSYXRlIiwiYWRqdXN0ZWRSb3RhdGlvblJhdGUiLCJyb3RhdGlvblJhdGUiLCJ0aW1lc3RhbXBTIiwidGltZVN0YW1wIiwic2V0IiwiYWxwaGEiLCJtdWx0aXBseVNjYWxhciIsImFkZEFjY2VsTWVhc3VyZW1lbnQiLCJhZGRHeXJvTWVhc3VyZW1lbnQiLCJzY3JlZW5PcmllbnRhdGlvbiIsImludmVyc2UiLCJ0b0F4aXMiLCJvZmZzZXQiLCJyZWR1Y2UiLCJhY2MiLCJ2IiwiVkVSU0lPTiIsIlBhbm9WaWV3ZXIiLCJTcGluVmlld2VyIiwiU1RBVFVTIiwiRVZFTlQiLCJJbWFnZUxvYWRlciIsImltYWdlIiwiX29uY2VIYW5kbGVycyIsIl9sb2FkU3RhdHVzIiwiZ2V0IiwicmVzIiwicmVqIiwiTE9BREVEIiwiZ2V0RWxlbWVudCIsIkxPQURJTkciLCJpc01heWJlTG9hZGVkIiwiUkVBRFlTVEFURUNIQU5HRSIsIm9uY2VMb2FkZWQiLCJpbWFnZXMiLCJtYXAiLCJfaW1nIiwiY3Jvc3NPcmlnaW4iLCJjb21wbGV0ZSIsIm5hdHVyYWxXaWR0aCIsInNvbWUiLCJ0YXJnZXRzIiwidGFyZ2V0c05vdExvYWRlZCIsImxvYWRQcm9taXNlcyIsIl9vbmNlIiwiYWxsIiwidGhlbiIsInJlYXNvbiIsImxpc3RlbmVyIiwiZm4iLCJldmVudCIsInB1c2giLCJnZXRTdGF0dXMiLCJmb3JFYWNoIiwiaGFuZGxlciIsIkltYWdlVHlwZSIsIkRFVklDRV9QSVhFTF9SQVRJTyIsIkJJTkRfVEVYVFVSRSIsIklNQUdFX0xPQURFRCIsIlJFTkRFUklOR19DT05URVhUX1JFU1RPUkUiLCJQYW5vSW1hZ2VSZW5kZXJlciIsImlzVmlkZW8iLCJzcGhlcmljYWxDb25maWciLCJyZW5kZXJpbmdDb250ZXh0QXR0cmlidXRlcyIsImZpZWxkT2ZWaWV3IiwiX2xhc3RRdWF0ZXJuaW9uIiwiX2xhc3RZYXciLCJfbGFzdFBpdGNoIiwiX2xhc3RGaWVsZE9mVmlldyIsInBNYXRyaXgiLCJtdk1hdHJpeCIsInBlcnNwZWN0aXZlIiwidGV4dHVyZUNvb3JkQnVmZmVyIiwidmVydGV4QnVmZmVyIiwiaW5kZXhCdWZmZXIiLCJfaW5pdENhbnZhcyIsIl9yZW5kZXJpbmdDb250ZXh0QXR0cmlidXRlcyIsIl9pbWFnZUNvbmZpZyIsIl9pbWFnZUlzUmVhZHkiLCJfc2hvdWxkRm9yY2VEcmF3IiwiX2tlZXBVcGRhdGUiLCJfb25Db250ZW50TG9hZCIsIl9vbkNvbnRlbnRFcnJvciIsInNldEltYWdlIiwiaW1hZ2VUeXBlIiwiY3ViZW1hcENvbmZpZyIsImdldENvbnRlbnQiLCJfaXNWaWRlbyIsIm9yZGVyIiwidGlsZUNvbmZpZyIsImZsaXBIaXJvem9udGFsIiwicm90YXRpb24iLCJfc2V0SW1hZ2VUeXBlIiwiX2NvbnRlbnRMb2FkZXIiLCJfaW1hZ2VUeXBlIiwiX2lzQ3ViZU1hcCIsIl9yZW5kZXJlciIsIl9pbml0V2ViR0wiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJtYXJnaW4iLCJtYXhIZWlnaHQiLCJtYXhXaWR0aCIsIm91dGxpbmUiLCJwb3NpdGlvbiIsIl9vbldlYmdsY29udGV4dGxvc3QiLCJfb25XZWJnbGNvbnRleHRyZXN0b3JlZCIsImVycm9yIiwibWVzc2FnZSIsIl90cmlnZ2VyQ29udGVudExvYWQiLCJjb250ZW50IiwicHJvamVjdGlvblR5cGUiLCJpc0ltYWdlTG9hZGVkIiwicmVhZHlTdGF0ZSIsIl9iaW5kVGV4dHVyZSIsImF0dGFjaFRvIiwicGFyZW50RWxlbWVudCIsImRldGFjaCIsImZvcmNlQ29udGV4dExvc3MiLCJoYXNSZW5kZXJpbmdDb250ZXh0IiwicmVtb3ZlQ2hpbGQiLCJvZmYiLCJpc0NvbnRleHRMb3N0Iiwic2hhZGVyUHJvZ3JhbSIsInByZXZlbnREZWZhdWx0IiwidXBkYXRlRmllbGRPZlZpZXciLCJfdXBkYXRlVmlld3BvcnQiLCJ1cGRhdGVWaWV3cG9ydERpbWVuc2lvbnMiLCJ2aWV3UG9ydENoYW5nZWQiLCJoIiwidmlld3BvcnQiLCJkcmF3aW5nQnVmZmVyV2lkdGgiLCJkcmF3aW5nQnVmZmVySGVpZ2h0IiwiX2luaXRSZW5kZXJpbmdDb250ZXh0IiwiX2luaXRTaGFkZXJQcm9ncmFtIiwiRXJyb3IiLCJnZXRFcnJvciIsIl9pbml0QnVmZmVycyIsImNsZWFyQ29sb3IiLCJURVhUVVJFX0NVQkVfTUFQIiwiVEVYVFVSRV8yRCIsImRlbGV0ZVRleHR1cmUiLCJXZWJHTFJlbmRlcmluZ0NvbnRleHQiLCJ2ZXJ0ZXhTaGFkZXJTb3VyY2UiLCJnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UiLCJWRVJURVhfU0hBREVSIiwiZnJhZ21lbnRTaGFkZXJTb3VyY2UiLCJnZXRGcmFnbWVudFNoYWRlclNvdXJjZSIsIkZSQUdNRU5UX1NIQURFUiIsInVzZVByb2dyYW0iLCJ2ZXJ0ZXhQb3NpdGlvbkF0dHJpYnV0ZSIsImdldEF0dHJpYkxvY2F0aW9uIiwicE1hdHJpeFVuaWZvcm0iLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJtdk1hdHJpeFVuaWZvcm0iLCJzYW1wbGVyVW5pZm9ybSIsInRleHR1cmVDb29yZEF0dHJpYnV0ZSIsImNsZWFyIiwiQ09MT1JfQlVGRkVSX0JJVCIsIkRFUFRIX0JVRkZFUl9CSVQiLCJTVEVOQ0lMX0JVRkZFUl9CSVQiLCJ1bmlmb3JtMWkiLCJ2ZXJ0ZXhQb3NpdGlvbkRhdGEiLCJnZXRWZXJ0ZXhQb3NpdGlvbkRhdGEiLCJpbmRleERhdGEiLCJnZXRJbmRleERhdGEiLCJ0ZXh0dXJlQ29vcmREYXRhIiwiZ2V0VGV4dHVyZUNvb3JkRGF0YSIsIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwiVWludDE2QXJyYXkiLCJfdXBkYXRlVGV4dHVyZSIsInVwZGF0ZVRleHR1cmUiLCJrZWVwVXBkYXRlIiwiZG9VcGRhdGUiLCJyZW5kZXJXaXRoUXVhdGVybmlvbiIsImV4YWN0RXF1YWxzIiwib3V0USIsInJvdGF0ZVkiLCJmcm9tUXVhdCIsIl9kcmF3IiwicmVuZGVyIiwieWF3IiwicGl0Y2giLCJpZGVudGl0eSIsInJvdGF0ZVgiLCJ1bmlmb3JtTWF0cml4NGZ2IiwiZHJhd0VsZW1lbnRzIiwiVFJJQU5HTEVTIiwiVU5TSUdORURfU0hPUlQiLCJSRUFEWV9TVEFUVVMiLCJIQVZFX05PVEhJTkciLCJIQVZFX01FVEFEQVRBIiwiSEFWRV9DVVJSRU5UX0RBVEEiLCJIQVZFX0ZVVFVSRV9EQVRBIiwiSEFWRV9FTk9VR0hfREFUQSIsIkxPQURJTkdfRkFJTEVEIiwiUkVBRFlTVEFURUNIQU5HRV9FVkVOVF9OQU1FIiwiVmlkZW9Mb2FkZXIiLCJ2aWRlbyIsIl9oYW5kbGVycyIsIl9zb3VyY2VDb3VudCIsIl90aHJlc2hvbGRSZWFkeVN0YXRlIiwiX3RocmVzaG9sZEV2ZW50TmFtZSIsIl9vbmVycm9yIiwiX2Vycm9yQ291bnQiLCJfZGV0YWNoRXJyb3JIYW5kbGVyIiwiX2FwcGVuZFNvdXJjZUVsZW1lbnQiLCJ2aWRlb1VybCIsInZpZGVvU3JjIiwidmlkZW9UeXBlIiwic291cmNlRWxlbWVudCIsIl92aWRlbyIsIl9yZXNldCIsIkhUTUxWaWRlb0VsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJxdWVyeVNlbGVjdG9yQWxsIiwibG9hZCIsIl9hdHRhY2hFcnJvckhhbmRsZXIiLCJfc291cmNlcyIsImNhbGwiLCJyZWplY3RvciIsImRldmljZVBpeGVsUmF0aW8iLCJDdWJlUmVuZGVyZXIiLCJfVkVSVEVYX1BPU0lUSU9OX0RBVEEiLCJfSU5ERVhfREFUQSIsImV4dHJhY3RUaWxlQ29uZmlnIiwiaW1hZ2VDb25maWciLCJpc0FycmF5IiwiZmxpcEhvcml6b250YWwiLCJjb25maWciLCJleHRyYWN0T3JkZXIiLCJ2ZXJ0ZXhPcmRlciIsImJhc2UiLCJlbGVtU2l6ZSIsInZlcnRleFBlclRpbGUiLCJzcGxpdCIsImluZGV4T2YiLCJmYWNlIiwicGFyc2VJbnQiLCJvcmRlcm1hcF8iLCJzaGlmdCIsInVuc2hpZnQiLCJwb3AiLCJlbGVtUGVyVGlsZSIsInRpbGVWZXJ0ZXgiLCJzbGljZSIsInRpbGVUZW1wIiwiaiIsInNwbGljZSIsImpvaW4iLCJiYXNlT3JkZXIiLCJvcmRlck1hcCIsInN1cmZhY2VJZHgiLCJ0aWxlSWR4IiwidGV4SW1hZ2UyRCIsIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCIsIlJHQkEiLCJVTlNJR05FRF9CWVRFIiwibWF4Q3ViZU1hcFRleHR1cmVTaXplIiwiZ2V0TWF4Q3ViZU1hcFRleHR1cmVTaXplIiwidGlsZSIsImV4dHJhY3RUaWxlRnJvbUltYWdlIiwiX2dldERpbWVuc2lvbiIsInBpeGVsU291cmNlIiwidmlkZW9XaWR0aCIsIm5hdHVyYWxIZWlnaHQiLCJ2aWRlb0hlaWdodCIsImdldFNvdXJjZVRpbGVTaXplIiwiYXNwZWN0UmF0aW8iLCJpbnB1dFRleHR1cmVTaXplIiwib3V0cHV0VGV4dHVyZVNpemUiLCJ0aWxlUGVyUm93IiwiZHJhd0ltYWdlIiwiYWdlbnQiLCJnZXRQYXJhbWV0ZXIiLCJNQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFIiwiX2ltYWdlV2lkdGgiLCJtaW4iLCJpc0lFMTEiLCJwaXhlbENhbnZhcyIsInBpeGVsQ29udGV4dCIsIlNwaGVyZVJlbmRlcmVyIiwiX1RFWFRVUkVfQ09PUkRfREFUQSIsIl9nZXRQaXhlbFNvdXJjZSIsIm1heCIsIm1heFNpemUiLCJNQVhfVEVYVFVSRV9TSVpFIiwiY29uc29sZSIsIndhcm4iLCJhY3RpdmVUZXh0dXJlIiwiVEVYVFVSRTAiLCJwaXhlbFN0b3JlaSIsIlVOUEFDS19GTElQX1lfV0VCR0wiLCJfaW5pdERhdGEiLCJsYXRpdHVkZUJhbmRzIiwibG9uZ2l0dWRlQmFuZHMiLCJyYWRpdXMiLCJsYXRJZHgiLCJsbmdJZHgiLCJzaW5UaGV0YSIsImNvc1RoZXRhIiwicGhpIiwic2luUGhpIiwiY29zUGhpIiwidSIsImIiLCJjb250YWluZXIiLCJfY29udGFpbmVyIiwiX3Byb2plY3Rpb25UeXBlIiwiX2N1YmVtYXBDb25maWciLCJfeWF3IiwiX3BpdGNoIiwiX2ZvdiIsImZvdiIsIl9neXJvTW9kZSIsImd5cm9Nb2RlIiwiX3F1YXRlcm5pb24iLCJfYXNwZWN0UmF0aW8iLCJmb3ZSYW5nZSIsInRvdWNoRGlyZWN0aW9uIiwiX2lzVmFsaWRUb3VjaERpcmVjdGlvbiIsInlhd1BpdGNoQ29uZmlnIiwiX2lzUmVhZHkiLCJfaW5pdFlhd1BpdGNoQ29udHJvbCIsIl9pbml0UmVuZGVyZXIiLCJnZXRWaWRlbyIsIl9waG90b1NwaGVyZVJlbmRlcmVyIiwic2V0VmlkZW8iLCJwYXJhbSIsImdldEltYWdlIiwiX2RlYWN0aXZhdGUiLCJnZXRQcm9qZWN0aW9uVHlwZSIsImluaXRpYWxZYXciLCJpbml0aWFsUGl0Y2giLCJfYmluZFJlbmRlcmVySGFuZGxlciIsIl9hY3RpdmF0ZSIsIl90cmlnZ2VyRXZlbnQiLCJfeWF3UGl0Y2hDb250cm9sIiwiZXZ0Iiwic2V0VXNlWm9vbSIsInVzZVpvb20iLCJvcHRpb24iLCJzZXRVc2VLZXlib2FyZCIsInVzZUtleWJvYXJkIiwic2V0R3lyb01vZGUiLCJzZXRGb3ZSYW5nZSIsInJhbmdlIiwiZ2V0Rm92UmFuZ2UiLCJsb29rQXQiLCJnZXRGb3YiLCJfZ2V0SEZvdiIsImF0YW4iLCJ0YW4iLCJnZXRZYXciLCJnZXRQaXRjaCIsImdldFlhd1JhbmdlIiwiZ2V0UGl0Y2hSYW5nZSIsInNldFlhd1JhbmdlIiwieWF3UmFuZ2UiLCJzZXRQaXRjaFJhbmdlIiwicGl0Y2hSYW5nZSIsInNldFNob3dQb2xlUG9pbnQiLCJzaG93UG9sZVBvaW50IiwiZHVyYXRpb24iLCJ2ZXJ0aWNhbEFuZ2xlT2ZJbWFnZSIsIl9zdGFydFJlbmRlciIsIl9yZW5kZXJMb29wIiwiX3JhZklkIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiX3N0b3BSZW5kZXIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImRpcmVjdGlvbiIsIlRPVUNIX0RJUkVDVElPTiIsIllBVyIsIlBJVENIIiwiQUxMIiwic2V0VG91Y2hEaXJlY3Rpb24iLCJnZXRUb3VjaERpcmVjdGlvbiIsImlzR3lyb1NlbnNvckF2YWlsYWJsZSIsImNhbGxiYWNrIiwib25EZXZpY2VNb3Rpb25DaGFuZ2UiLCJjaGVja0d5cm8iLCJ0aW1lb3V0IiwicmFjZSIsImZiIiwiUHJvamVjdGlvblR5cGUiLCJEZXZpY2VNb3Rpb25FdmVudCIsIkRFRkFVTFRfUEFOX1NDQUxFIiwiX3NjYWxlIiwiX2ZyYW1lQ291bnQiLCJfc3ByaXRlcyIsIl9wYW5JbnB1dCIsIl9heGVzIiwiY2lyY3VsYXIiLCJjdXJyIiwicG9zIiwiY29ubmVjdCIsInNldFNjYWxlIiwiaXNOYU4iLCJzcGluQnkiLCJzZXRCeSIsIk9SSUdJTl9WRUNUT1IiLCJYX0FYSVNfVkVDVE9SIiwiWV9BWElTX1ZFQ1RPUiIsIkRldmljZVF1YXRlcm5pb24iLCJfc2NyZWVuUm90YXRpb25BbmdsZSIsIl9mdXNpb25Qb3NlU2Vuc29yIiwiaXNUcnVzdGVkIiwiZ2V0Q29tYmluZWRRdWF0ZXJuaW9uIiwiZGV2aWNlUiIsInBpdGNoQXhpcyIsInJvdGF0ZVoiLCJ5YXdRIiwic2V0QXhpc0FuZ2xlIiwicGl0Y2hRIiwiY29uaiIsImNvbmp1Z2F0ZSIsIkRFRkFVTFRfWUFXX1JBTkdFIiwiREVGQVVMVF9QSVRDSF9SQU5HRSIsIkNJUkNVTEFSX1BJVENIX1JBTkdFIiwiX2VsZW1lbnQiLCJfaW5pdGlhbEZvdiIsIl9lbmFibGVkIiwiX2lzQW5pbWF0aW5nIiwiX2RldmljZVF1YXRlcm5pb24iLCJfaW5pdEF4ZXMiLCJ5UmFuZ2UiLCJfdXBkYXRlWWF3UmFuZ2UiLCJwUmFuZ2UiLCJfdXBkYXRlUGl0Y2hSYW5nZSIsInVzZVJvdGF0aW9uIiwiYXhlc1BhbklucHV0IiwiYXhlc1doZWVsSW5wdXQiLCJheGVzVGlsdE1vdGlvbklucHV0IiwiYXhlc1BpbmNoSW5wdXQiLCJheGVzTW92ZUtleUlucHV0IiwiYXhlcyIsImlzQ2lyY3VsYXIiLCJib3VuY2UiLCJkZWNlbGVyYXRpb24iLCJtYXhpbXVtRHVyYXRpb24iLCJob2xkIiwiY2hhbmdlIiwiZGVsdGEiLCJfc2V0UGFuU2NhbGUiLCJfdXBkYXRlQ29udHJvbFNjYWxlIiwicmVsZWFzZSIsImFuaW1hdGlvblN0YXJ0IiwiYW5pbWF0aW9uRW5kIiwiYXJlYUhlaWdodCIsImFyZ3MiLCJhcmdMZW4iLCJfZ2V0T3B0aW9ucyIsImJlZm9yZU9wdGlvbnMiLCJuZXdPcHRpb25zIiwiY2hhbmdlZEtleUxpc3QiLCJPYmplY3QiLCJrZXlzIiwiX3NldE9wdGlvbnMiLCJfZ2V0VmFsaWRhdGVkT3B0aW9ucyIsIl9hcHBseU9wdGlvbnMiLCJfZ2V0VmFsaWRZYXdSYW5nZSIsIl9nZXRWYWxpZFBpdGNoUmFuZ2UiLCJrZXkiLCJ2YWx1ZSIsImFyZ3VtZW50cyIsInByZXZPcHRpb25zIiwicHJldkZvdiIsIm5leHRGb3YiLCJheGlzIiwic2V0VG8iLCJkaXNjb25uZWN0IiwiX2luaXREZXZpY2VRdWF0ZXJuaW9uIiwiX2VuYWJsZVRvdWNoIiwieWF3RW5hYmxlZCIsInBpdGNoRW5hYmxlZCIsIm5ld1lhd1JhbmdlIiwibmV3Rm92IiwibmV3QXNwZWN0UmF0aW8iLCJyYXRpbyIsImFkanVzdEFzcGVjdFJhdGlvIiwiaG9yaXpvbnRhbEZvdiIsImlzVmFsaWQiLCJuZXdQaXRjaFJhbmdlIiwiY2hhbmdlRXZ0IiwicCIsInZlcnRpY2FsQW5nbGUiLCJoYWxmRm92IiwiaXNQYW5vcmFtYSIsInRvRml4ZWQiLCJob3Jpem9udGFsQW5nbGUiLCJNQUdJQ19OVU1CRVIiLCJoYWxmSG9yaXpvbnRhbEZvdiIsInRhcmdldEVsZW1lbnQiLCJpbnB1dCIsImlucHV0UmFuZ2UiLCJvdXRwdXRSYW5nZSIsInJhbmdlSWR4IiwiaW5wdXRBIiwiaW5wdXRCIiwib3V0cHV0QSIsIm91dHB1dEIiLCJsZXJwIiwiZnJhY3Rpb24iLCJwZXJzaXN0T3JpZW50YXRpb24iLCJfcmVzZXRPcmllbnRhdGlvbiIsImYiLCJheGlzUGFuSW5wdXQiLCJheGVzRGV2aWNlT3JpZW50YXRpb25JbnB1dCIsInByb3RvdHlwZSIsInJ1bl8iLCJpc09yaWVudGF0aW9uSW5pdGlhbGl6ZWQiLCJhY2NlbFEiLCJhY2NlbFRvUXVhdGVybmlvbl8iLCJjdXJyZW50QWNjZWxNZWFzdXJlbWVudCIsInNhbXBsZSIsInByZXZpb3VzRmlsdGVyUSIsImRlbHRhVCIsImN1cnJlbnRHeXJvTWVhc3VyZW1lbnQiLCJwcmV2aW91c0d5cm9NZWFzdXJlbWVudCIsImd5cm9EZWx0YVEiLCJneXJvVG9RdWF0ZXJuaW9uRGVsdGFfIiwiZ3lyb0ludGVncmFsUSIsImZpbHRlclEiLCJpbnZGaWx0ZXJRIiwiZXN0aW1hdGVkR3Jhdml0eSIsImFwcGx5UXVhdGVybmlvbiIsIm1lYXN1cmVkR3Jhdml0eSIsImRlbHRhUSIsInNldEZyb21Vbml0VmVjdG9ycyIsInRhcmdldFEiLCJzbGVycCIsImtGaWx0ZXIiLCJpc0ZpbHRlclF1YXRlcm5pb25Jbml0aWFsaXplZCIsIlNUSUxMTkVTU19USFJFU0hPTEQiLCJEZXZpY2VNb3Rpb24iLCJfb25EZXZpY2VNb3Rpb24iLCJpc0FuZHJvaWQiLCJzdGlsbEd5cm9WZWMiLCJyYXdHeXJvVmVjIiwiYWRqdXN0ZWRHeXJvVmVjIiwiX3RpbWVyIiwibGFzdERldmljZW1vdGlvblRpbWVzdGFtcCIsImNsZWFyVGltZW91dCIsIkRhdGUiLCJnZXRUaW1lIiwiYWNjZWxlcmF0aW9uIiwiUm90YXRpb25QYW5JbnB1dCIsIl91c2VSb3RhdGlvbiIsIl91c2VyRGlyZWN0aW9uIiwiRElSRUNUSU9OX0FMTCIsIm9ic2VydmVyIiwiX2RpcmVjdGlvbiIsImdldE9mZnNldCIsInByb3BlcnRpZXMiLCJ1c2VEaXJlY3Rpb24iLCJuZXdPZmZzZXQiLCJESVJFQ1RJT05fSE9SSVpPTlRBTCIsIkRJUkVDVElPTl9WRVJUSUNBTCIsImdldERlbHRhWWF3IiwicHJ2USIsInlhd0RlbHRhQnlZYXciLCJ5YXdEZWx0YUJ5Um9sbCIsImdldERlbHRhUGl0Y2giLCJwaXRjaERlbHRhIiwiVGlsdE1vdGlvbklucHV0IiwiX3ByZXZRdWF0ZXJuaW9uIiwiZnVzaW9uUG9zZVNlbnNvciIsInRocmVzaG9sZCIsIl9vblBvc2VDaGFuZ2UiLCJtYXBBeGVzIiwiX2F0dGFjaEV2ZW50IiwiX2RldHRhY2hFdmVudCIsIldoZWVsSW5wdXQiLCJfb25XaGVlbCIsImRlbHRhWSIsInJhZCIsInMiLCJjIiwiYTEwIiwiYTExIiwiYTEyIiwiYTEzIiwiYTIwIiwiYTIxIiwiYTIyIiwiYTIzIiwiYTAwIiwiYTAxIiwiYTAyIiwiYTAzIiwicSIsIngyIiwieTIiLCJ6MiIsInh4IiwieXgiLCJ5eSIsInp4IiwienkiLCJ6eiIsInd4Iiwid3kiLCJ3eiIsImZvdnkiLCJhc3BlY3QiLCJuZWFyIiwiZmFyIiwibmYiLCJheCIsImF5IiwiYXoiLCJhdyIsImJ4IiwiYnkiLCJieiIsImJ3IiwibGVuIiwiYTAiLCJhMSIsImEyIiwiYTMiLCJiMCIsImIxIiwiYjIiLCJiMyIsInF4IiwicXkiLCJxeiIsInF3IiwiaXgiLCJpeSIsIml6IiwiaXciXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2hFQSwrQzs7Ozs7Ozs7Ozs7O0FDaUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLFNBQVNBLFVBQVQsQ0FBb0JDLFVBQXBCLEVBQWdDO0FBQy9CLEtBQU1DLFFBQVEsaUJBQUtDLFVBQUwsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsQ0FBZDs7QUFFQSxrQkFBS0MsYUFBTCxD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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSw2QkFBNkI7O0FBRTdCLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxDQUFDLEU7Ozs7OztBQ2hkRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGOztBQUVoRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZDtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDZDQUE2QztBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQixVQUFVLE9BQU87QUFDakI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZDtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQixVQUFVLFNBQVM7QUFDbkI7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0EsV0FBVztBQUNYOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckIsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7Ozs7QUFJRDs7Ozs7Ozs7QUMxcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtB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QUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0gsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7O0FDelBEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7Ozs7Ozs7c0RDdkx0QztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsS0FBSztBQUNMLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUNBQW1DO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qjs7QUFFeEIseUNBQXlDLHFCQUFxQjs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0I7O0FBRXREO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxpQkFBaUI7QUFDL0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUFBO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7Ozs7QUNwaEJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BGQTs7QUFFQTtBQUNBOzs7Ozs7OzBEQ0hBO0FBQ0EsYUFBYSxTQUEyRCxtQkFBbUIsZ0RBQWdELGFBQWEsS0FBSyxNQUFNLGdDQUFnQyxTQUFTLHFDQUFxQyxTQUFTLG1DQUFtQyxPQUFPLEtBQUssT0FBTyxnQkFBZ0IsYUFBYSwwQkFBMEIsMEJBQTBCLGdCQUFnQixVQUFVLFVBQVUsMENBQTBDLDhCQUF3QixvQkFBb0IsOENBQThDLGtDQUFrQyxZQUFZLFlBQVksbUNBQW1DLGlCQUFpQixnQkFBZ0Isc0JBQXNCLG9CQUFvQiwwQ0FBMEMsWUFBWSxXQUFXLFlBQVksU0FBUyxHQUFHO0FBQzF5QjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEVBQUUsa0NBQWtDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsMEJBQTBCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLGdDQUFnQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLDBCQUEwQjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsK0JBQStCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLHVJQUF1STtBQUMxSTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsbUVBQW1FO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLHNGQUFzRjtBQUN6RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsc0hBQXNIO0FBQ3pIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsd05BQXdOO0FBQzNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxHQUFHO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSwwUUFBMFE7QUFDN1E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSx5R0FBeUc7QUFDNUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBCQUEwQixxREFBcUQsbUJBQW1CLFdBQVc7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLGtJQUFrSTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsb0NBQW9DO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLHdEQUF3RDtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUseUdBQXlHO0FBQzVHOztBQUVB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QUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxDQUFDLEVBQUUsV0FBVztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsRUFBRSxjQUFjO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLEtBQUs7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzdEJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7OztBQzdIQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0I7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNyQkE7QUFDQTs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7Ozs7OztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7Ozs7O0FDaEZBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0EsNEIiLCJmaWxlIjoidmlldzM2MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIkBlZ2pzL2NvbXBvbmVudFwiKSwgcmVxdWlyZShcIkBlZ2pzL2F4ZXNcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJ2aWV3MzYwXCIsIFtcIkBlZ2pzL2NvbXBvbmVudFwiLCBcIkBlZ2pzL2F4ZXNcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1widmlldzM2MFwiXSA9IGZhY3RvcnkocmVxdWlyZShcIkBlZ2pzL2NvbXBvbmVudFwiKSwgcmVxdWlyZShcIkBlZ2pzL2F4ZXNcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImVnXCJdID0gcm9vdFtcImVnXCJdIHx8IHt9LCByb290W1wiZWdcIl1bXCJ2aWV3MzYwXCJdID0gZmFjdG9yeShyb290W1wiZWdcIl1bXCJDb21wb25lbnRcIl0sIHJvb3RbXCJlZ1wiXVtcIkF4ZXNcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTFfXykge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDY5KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBhOWYzMThlN2E3MmM0ZWNiNzQ2YyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcIkBlZ2pzL2NvbXBvbmVudFwiLFwiY29tbW9uanMyXCI6XCJAZWdqcy9jb21wb25lbnRcIixcImFtZFwiOlwiQGVnanMvY29tcG9uZW50XCIsXCJyb290XCI6W1wiZWdcIixcIkNvbXBvbmVudFwiXX1cbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBPcmlnaW5hbCBDb2RlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdG9qaS9nbC1tYXRyaXgvYmxvYi92Mi4zLjIvc3JjL2dsLW1hdHJpeC5qc1xuICogTWF0aCBVdGlsXG4gKiBtb2RpZmllZCBieSBlZ2pzXG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBnbC1tYXRyaXggLSBIaWdoIHBlcmZvcm1hbmNlIG1hdHJpeCBhbmQgdmVjdG9yIG9wZXJhdGlvbnNcbiAqIEBhdXRob3IgQnJhbmRvbiBKb25lc1xuICogQGF1dGhvciBDb2xpbiBNYWNLZW56aWUgSVZcbiAqIEB2ZXJzaW9uIDIuMy4yXG4gKi9cblxuLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuLy8gU29tZSBtaW5pbWFsIG1hdGggZnVuY3Rpb25hbGl0eSBib3Jyb3dlZCBmcm9tIGdsLU1hdHJpeCBhbmQgc3RyaXBwZWQgZG93blxuLy8gZm9yIHRoZSBwdXJwb3NlcyBvZiB0aGlzIGxpYnJhcnkuXG5cbmltcG9ydCBnbE1hdHJpeCBmcm9tIFwiLi9tYXRoVXRpbC9jb21tb24uanNcIjtcbmltcG9ydCB2ZWMzIGZyb20gXCIuL21hdGhVdGlsL3ZlYzMuanNcIjtcbmltcG9ydCB2ZWMyIGZyb20gXCIuL21hdGhVdGlsL3ZlYzIuanNcIjtcbmltcG9ydCBxdWF0IGZyb20gXCIuL21hdGhVdGlsL3F1YXQuanNcIjtcbmltcG9ydCBtYXQ0IGZyb20gXCIuL21hdGhVdGlsL21hdDQuanNcIjtcblxuZnVuY3Rpb24gcXVhdFRvVmVjMyhxdWF0ZXJuaW9uKSB7XG5cdGNvbnN0IGJhc2VWID0gdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDEpO1xuXG5cdHZlYzMudHJhbnNmb3JtUXVhdChiYXNlViwgYmFzZVYsIHF1YXRlcm5pb24pO1xuXHRyZXR1cm4gYmFzZVY7XG59XG5cbmNvbnN0IHV0aWwgPSB7fTtcblxudXRpbC5pc1Bvd2VyT2ZUd28gPSBmdW5jdGlvbihuKSB7XG5cdHJldHVybiBuICYmIChuICYgKG4gLSAxKSkgPT09IDA7XG59O1xuXG51dGlsLmV4dHJhY3RQaXRjaEZyb21RdWF0ID0gZnVuY3Rpb24ocXVhdGVybmlvbikge1xuXHRjb25zdCBiYXNlViA9IHF1YXRUb1ZlYzMocXVhdGVybmlvbik7XG5cblx0cmV0dXJuIC0xICogTWF0aC5hdGFuMihcblx0XHRiYXNlVlsxXSxcblx0XHRNYXRoLnNxcnQoTWF0aC5wb3coYmFzZVZbMF0sIDIpICsgTWF0aC5wb3coYmFzZVZbMl0sIDIpKSk7XG59O1xuXG4vLyBpbXBsZW1lbnQgcmVmZXJlbmNlXG4vLyB0aGUgZ2VuZXJhbCBlcXVhdGlvbiBvZiBhIHBsYW5lIDogaHR0cDovL3d3dy5naXNkZXZlbG9wZXIuY28ua3IvZW50cnkv7Y+J66m07J2YLeqzteyLnVxuLy8gY2FsY3VsYXRpbmcgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9ycyA6IGh0dHA6Ly9kYXJrcGdtci50aXN0b3J5LmNvbS8xMjFcbmNvbnN0IFJPVEFURV9DT05TVEFOVCA9IHtcblx0UElUQ0hfREVMVEE6IDEsXG5cdFlBV19ERUxUQV9CWV9ST0xMOiAyLFxuXHRZQVdfREVMVEFfQllfWUFXOiAzLFxufTtcblxuUk9UQVRFX0NPTlNUQU5UW1JPVEFURV9DT05TVEFOVC5QSVRDSF9ERUxUQV0gPSB7XG5cdHRhcmdldEF4aXM6IFswLCAxLCAwXSxcblx0bWVzaFBvaW50OiBbMCwgMCwgMV0sXG59O1xuUk9UQVRFX0NPTlNUQU5UW1JPVEFURV9DT05TVEFOVC5ZQVdfREVMVEFfQllfUk9MTF0gPSB7XG5cdHRhcmdldEF4aXM6IFswLCAxLCAwXSxcblx0bWVzaFBvaW50OiBbMSwgMCwgMF0sXG59O1xuUk9UQVRFX0NPTlNUQU5UW1JPVEFURV9DT05TVEFOVC5ZQVdfREVMVEFfQllfWUFXXSA9IHtcblx0dGFyZ2V0QXhpczogWzEsIDAsIDBdLFxuXHRtZXNoUG9pbnQ6IFswLCAwLCAxXSxcbn07XG5cbmZ1bmN0aW9uIGdldFJvdGF0aW9uRGVsdGEocHJldlEsIGN1clEsIHJvdGF0ZUtpbmQpIHtcblx0Y29uc3QgdGFyZ2V0QXhpcyA9IHZlYzMuZnJvbVZhbHVlcyhcblx0XHRST1RBVEVfQ09OU1RBTlRbcm90YXRlS2luZF0udGFyZ2V0QXhpc1swXSxcblx0XHRST1RBVEVfQ09OU1RBTlRbcm90YXRlS2luZF0udGFyZ2V0QXhpc1sxXSxcblx0XHRST1RBVEVfQ09OU1RBTlRbcm90YXRlS2luZF0udGFyZ2V0QXhpc1syXVxuXHQpO1xuXHRjb25zdCBtZXNoUG9pbnQgPSBST1RBVEVfQ09OU1RBTlRbcm90YXRlS2luZF0ubWVzaFBvaW50O1xuXG5cdGNvbnN0IHByZXZRdWF0ZXJuaW9uID0gcXVhdC5jbG9uZShwcmV2USk7XG5cdGNvbnN0IGN1clF1YXRlcm5pb24gPSBxdWF0LmNsb25lKGN1clEpO1xuXG5cdHF1YXQubm9ybWFsaXplKHByZXZRdWF0ZXJuaW9uLCBwcmV2UXVhdGVybmlvbik7XG5cdHF1YXQubm9ybWFsaXplKGN1clF1YXRlcm5pb24sIGN1clF1YXRlcm5pb24pO1xuXG5cdGxldCBwcmV2UG9pbnQgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMSk7XG5cdGxldCBjdXJQb2ludCA9IHZlYzMuZnJvbVZhbHVlcygwLCAwLCAxKTtcblxuXHR2ZWMzLnRyYW5zZm9ybVF1YXQocHJldlBvaW50LCBwcmV2UG9pbnQsIHByZXZRdWF0ZXJuaW9uKTtcblx0dmVjMy50cmFuc2Zvcm1RdWF0KGN1clBvaW50LCBjdXJQb2ludCwgY3VyUXVhdGVybmlvbik7XG5cdHZlYzMudHJhbnNmb3JtUXVhdCh0YXJnZXRBeGlzLCB0YXJnZXRBeGlzLCBjdXJRdWF0ZXJuaW9uKTtcblxuXHRjb25zdCByb3RhdGVEaXN0YW5jZSA9IHZlYzMuZG90KHRhcmdldEF4aXMsIHZlYzMuY3Jvc3ModmVjMy5jcmVhdGUoKSwgcHJldlBvaW50LCBjdXJQb2ludCkpO1xuXHRjb25zdCByb3RhdGVEaXJlY3Rpb24gPSByb3RhdGVEaXN0YW5jZSA+IDAgPyAxIDogLTE7XG5cblx0Ly8gd2hlbiBjb3VudGVyIGNsb2NrIHdpc2UsIHVzZSB2ZWMzLmZyb21WYWx1ZXMoMCwxLDApXG5cdC8vIHdoZW4gY2xvY2sgd2lzZSwgdXNlIHZlYzMuZnJvbVZhbHVlcygwLC0xLDApXG5cdC8vIGNvbnN0IG1lc2hQb2ludDEgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMCk7XG5cdGNvbnN0IG1lc2hQb2ludDIgPSB2ZWMzLmZyb21WYWx1ZXMobWVzaFBvaW50WzBdLCBtZXNoUG9pbnRbMV0sIG1lc2hQb2ludFsyXSk7XG5cblx0bGV0IG1lc2hQb2ludDM7XG5cblx0aWYgKHJvdGF0ZUtpbmQgIT09IFJPVEFURV9DT05TVEFOVC5ZQVdfREVMVEFfQllfWUFXKSB7XG5cdFx0bWVzaFBvaW50MyA9IHZlYzMuZnJvbVZhbHVlcygwLCByb3RhdGVEaXJlY3Rpb24sIDApO1xuXHR9IGVsc2Uge1xuXHRcdG1lc2hQb2ludDMgPSB2ZWMzLmZyb21WYWx1ZXMocm90YXRlRGlyZWN0aW9uLCAwLCAwKTtcblx0fVxuXG5cdHZlYzMudHJhbnNmb3JtUXVhdChtZXNoUG9pbnQyLCBtZXNoUG9pbnQyLCBjdXJRdWF0ZXJuaW9uKTtcblx0dmVjMy50cmFuc2Zvcm1RdWF0KG1lc2hQb2ludDMsIG1lc2hQb2ludDMsIGN1clF1YXRlcm5pb24pO1xuXG5cdGNvbnN0IHZlY1UgPSBtZXNoUG9pbnQyO1xuXHRjb25zdCB2ZWNWID0gbWVzaFBvaW50Mztcblx0Y29uc3QgdmVjTiA9IHZlYzMuY3JlYXRlKCk7XG5cblx0dmVjMy5jcm9zcyh2ZWNOLCB2ZWNVLCB2ZWNWKTtcblx0dmVjMy5ub3JtYWxpemUodmVjTiwgdmVjTik7XG5cblx0Y29uc3QgY29lZmZpY2llbnRBID0gdmVjTlswXTtcblx0Y29uc3QgY29lZmZpY2llbnRCID0gdmVjTlsxXTtcblx0Y29uc3QgY29lZmZpY2llbnRDID0gdmVjTlsyXTtcbi8vXHRjb25zdCBjb2VmZmljaWVudEQgPSAtMSAqIHZlYzMuZG90KHZlY04sIG1lc2hQb2ludDEpO1xuXG5cdC8vIGEgcG9pbnQgb24gdGhlIHBsYW5lXG5cdGN1clBvaW50ID0gdmVjMy5mcm9tVmFsdWVzKG1lc2hQb2ludFswXSwgbWVzaFBvaW50WzFdLCBtZXNoUG9pbnRbMl0pO1xuXHR2ZWMzLnRyYW5zZm9ybVF1YXQoY3VyUG9pbnQsIGN1clBvaW50LCBjdXJRdWF0ZXJuaW9uKTtcblxuXHQvLyBhIHBvaW50IHNob3VsZCBwcm9qZWN0IG9uIHRoZSBwbGFuZVxuXHRwcmV2UG9pbnQgPSB2ZWMzLmZyb21WYWx1ZXMobWVzaFBvaW50WzBdLCBtZXNoUG9pbnRbMV0sIG1lc2hQb2ludFsyXSk7XG5cdHZlYzMudHJhbnNmb3JtUXVhdChwcmV2UG9pbnQsIHByZXZQb2ludCwgcHJldlF1YXRlcm5pb24pO1xuXG5cdC8vIGRpc3RhbmNlIGJldHdlZW4gcHJldlBvaW50IGFuZCB0aGUgcGxhbmVcblx0bGV0IGRpc3RhbmNlID0gTWF0aC5hYnMoXG5cdFx0cHJldlBvaW50WzBdICogY29lZmZpY2llbnRBICtcblx0XHRwcmV2UG9pbnRbMV0gKiBjb2VmZmljaWVudEIgK1xuXHRcdHByZXZQb2ludFsyXSAqIGNvZWZmaWNpZW50Q1xuXHQpO1xuXG5cdGNvbnN0IHByb2plY3RlZFByZXZQb2ludCA9IHZlYzMuY3JlYXRlKCk7XG5cblx0dmVjMy5zdWJ0cmFjdChwcm9qZWN0ZWRQcmV2UG9pbnQsIHByZXZQb2ludCwgdmVjMy5zY2FsZSh2ZWMzLmNyZWF0ZSgpLCB2ZWNOLCBkaXN0YW5jZSkpO1xuXG5cdGxldCB0cmlnb25vbWV0cmljUmF0aW8gPVxuXHRcdChwcm9qZWN0ZWRQcmV2UG9pbnRbMF0gKiBjdXJQb2ludFswXSArXG5cdFx0cHJvamVjdGVkUHJldlBvaW50WzFdICogY3VyUG9pbnRbMV0gK1xuXHRcdHByb2plY3RlZFByZXZQb2ludFsyXSAqIGN1clBvaW50WzJdKSAvXG5cdFx0KHZlYzMubGVuZ3RoKHByb2plY3RlZFByZXZQb2ludCkgKiB2ZWMzLmxlbmd0aChjdXJQb2ludCkpO1xuXG5cdC8vIGRlZmVuc2l2ZSBibG9ja1xuXHRpZiAodHJpZ29ub21ldHJpY1JhdGlvID4gMSkge1xuXHRcdHRyaWdvbm9tZXRyaWNSYXRpbyA9IDE7XG5cdH1cblxuXHRjb25zdCB0aGV0YSA9IE1hdGguYWNvcyh0cmlnb25vbWV0cmljUmF0aW8pO1xuXG5cdGNvbnN0IGNyb3NzVmVjID0gdmVjMy5jcm9zcyh2ZWMzLmNyZWF0ZSgpLCBjdXJQb2ludCwgcHJvamVjdGVkUHJldlBvaW50KTtcblxuXHRkaXN0YW5jZSA9XG5cdFx0Y29lZmZpY2llbnRBICogY3Jvc3NWZWNbMF0gK1xuXHRcdGNvZWZmaWNpZW50QiAqIGNyb3NzVmVjWzFdICtcblx0XHRjb2VmZmljaWVudEMgKiBjcm9zc1ZlY1syXTtcblxuXHRsZXQgdGhldGFEaXJlY3Rpb247XG5cblx0aWYgKHJvdGF0ZUtpbmQgIT09IFJPVEFURV9DT05TVEFOVC5ZQVdfREVMVEFfQllfWUFXKSB7XG5cdFx0dGhldGFEaXJlY3Rpb24gPSBkaXN0YW5jZSA+IDAgPyAxIDogLTE7XG5cdH0gZWxzZSB7XG5cdFx0dGhldGFEaXJlY3Rpb24gPSBkaXN0YW5jZSA8IDAgPyAxIDogLTE7XG5cdH1cblxuXHRjb25zdCBkZWx0YVJhZGlhbiA9IHRoZXRhICogdGhldGFEaXJlY3Rpb24gKiByb3RhdGVEaXJlY3Rpb247XG5cblx0cmV0dXJuIGdsTWF0cml4LnRvRGVncmVlKGRlbHRhUmFkaWFuKTtcbn1cblxudXRpbC5nZXRSb3RhdGlvbkRlbHRhID0gZ2V0Um90YXRpb25EZWx0YTtcblxuZXhwb3J0IHtcblx0dXRpbCxcblx0Z2xNYXRyaXgsXG5cdG1hdDQsXG5cdHF1YXQsXG5cdHZlYzIsXG5cdHZlYzMsXG5cdFJPVEFURV9DT05TVEFOVCxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvbWF0aC11dGlsLmpzIiwiLyoqXG4gKiBPcmlnaW5hbCBDb2RlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdG9qaS9nbC1tYXRyaXgvYmxvYi92Mi4zLjIvc3JjL2dsLW1hdHJpeC9jb21tb24uanNcbiAqIENvbW1vbiB1dGlsaXRpZXNcbiAqIG1vZGlmaWVkIGJ5IGVnanNcbiAqL1xudmFyIGdsTWF0cml4ID0ge307XG5cbmdsTWF0cml4LkFSUkFZX1RZUEUgPSAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5cbnZhciBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xuXG5nbE1hdHJpeC50b1JhZGlhbiA9IGZ1bmN0aW9uKGEpe1xuICAgICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cblxuZ2xNYXRyaXgudG9EZWdyZWUgPSBmdW5jdGlvbihhKXtcbiAgICAgcmV0dXJuIGEgLyBkZWdyZWU7XG59XG5cbi8vIGdsTWF0cml4LkVQU0lMT04gPSAwLjAwMDAwMTtcbmdsTWF0cml4LkVQU0lMT04gPSAwLjAwMDE7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xNYXRyaXg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvbWF0aFV0aWwvY29tbW9uLmpzIiwiLyogZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLW5lc3RlZC10ZXJuYXJ5ICovXG5jb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5NYXRoID09PSBNYXRoID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5NYXRoID09PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbi8qIGVzbGludC1lbmFibGUgbm8tbmVzdGVkLXRlcm5hcnkgKi9cbi8qIGVzbGludC1lbmFibGUgbm8tbmV3LWZ1bmMgKi9cblxud2luLkZsb2F0MzJBcnJheSA9ICh0eXBlb2Ygd2luLkZsb2F0MzJBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgPyB3aW4uRmxvYXQzMkFycmF5IDogd2luLkFycmF5O1xuXG5leHBvcnQge3dpbiBhcyB3aW5kb3d9O1xuZXhwb3J0IGNvbnN0IHNjcmVlbiA9IHdpbi5zY3JlZW47XG5leHBvcnQgY29uc3Qgb3JpZW50YXRpb24gPSB3aW4ub3JpZW50YXRpb247XG5leHBvcnQgY29uc3QgZG9jdW1lbnQgPSB3aW4uZG9jdW1lbnQ7XG5leHBvcnQgY29uc3QgRmxvYXQzMkFycmF5ID0gd2luLkZsb2F0MzJBcnJheTtcbmV4cG9ydCBjb25zdCBnZXRDb21wdXRlZFN0eWxlID0gd2luLmdldENvbXB1dGVkU3R5bGU7XG5leHBvcnQgY29uc3QgdXNlckFnZW50ID0gd2luLm5hdmlnYXRvci51c2VyQWdlbnQ7XG5leHBvcnQgY29uc3QgU1VQUE9SVF9UT1VDSCA9IFwib250b3VjaHN0YXJ0XCIgaW4gd2luO1xuZXhwb3J0IGNvbnN0IFNVUFBPUlRfREVWSUNFTU9USU9OID0gXCJvbmRldmljZW1vdGlvblwiIGluIHdpbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9ZYXdQaXRjaENvbnRyb2wvYnJvd3Nlci5qcyIsIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE3IE5BVkVSIENvcnAuXHJcbiAqIEBlZ2pzL2FnZW50IHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqIFxyXG4gKiBAZWdqcy9hZ2VudCBKYXZhU2NyaXB0IGxpYnJhcnlcclxuICogXHJcbiAqIFxyXG4gKiBAdmVyc2lvbiAyLjEuMlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJhZ2VudFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJlZ1wiXSA9IHJvb3RbXCJlZ1wiXSB8fCB7fSwgcm9vdFtcImVnXCJdW1wiYWdlbnRcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfYWdlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2FnZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FnZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbm1vZHVsZS5leHBvcnRzID0gX2FnZW50MltcImRlZmF1bHRcIl07IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvcHlyaWdodCAoYykgTkFWRVIgQ29ycC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBlZ2pzLWFnZW50IHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfYnJvd3NlciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfUGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9QYXJzZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUGFyc2VyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogQG5hbWVzcGFjZSBlZ1xuICovXG5cbi8qKlxuICogRXh0cmFjdHMgYnJvd3NlciBhbmQgb3BlcmF0aW5nIHN5c3RlbSBpbmZvcm1hdGlvbiBmcm9tIHRoZSB1c2VyIGFnZW50IHN0cmluZy5cbiAqIEBrbyDsnKDsoIAg7JeQ7J207KCE7Yq4IOusuOyekOyXtOyXkOyEnCDruIzrnbzsmrDsoIDsmYAg7Jq07JiB7LK07KCcIOygleuztOulvCDstpTstpztlZzri6QuXG4gKiBAZnVuY3Rpb24gZWcjYWdlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdXNlckFnZW50PW5hdmlnYXRvci51c2VyQWdlbnRdIHVzZXIgYWdlbnQgc3RyaW5nIHRvIHBhcnNlIDxrbz7tjIzsi7HtlaAg7Jyg7KCA7JeQ7J207KCE7Yq4IOusuOyekOyXtDwva28+XG4gKiBAcmV0dXJuIHtPYmplY3R9IGFnZW50SW5mb1xuICogQHJldHVybiB7T2JqZWN0fSBhZ2VudEluZm8ub3Mgb3MgT3BlcmF0aW5nIHN5c3RlbSBpbmZvcm1hdGlvbiA8a28+7Jq07JiB7LK07KCcIOygleuztDwva28+XG4gKiBAcmV0dXJuIHtTdHJpbmd9IGFnZW50SW5mby5vcy5uYW1lIE9wZXJhdGluZyBzeXN0ZW0gbmFtZSAoYW5kcm9pZCwgaW9zLCB3aW5kb3csIG1hYywgdW5rbm93bikgPGtvPuyatOyYgeyytOygnCDsnbTrpoQgKGFuZHJvaWQsIGlvcywgd2luZG93LCBtYWMsIHVua25vd24pPC9rbz5cbiAqIEByZXR1cm4ge1N0cmluZ30gYWdlbnRJbmZvLm9zLnZlcnNpb24gT3BlcmF0aW5nIHN5c3RlbSB2ZXJzaW9uIDxrbz7smrTsmIHssrTsoJwg67KE7KCEPC9rbz5cbiAqIEByZXR1cm4ge1N0cmluZ30gYWdlbnRJbmZvLmJyb3dzZXIgQnJvd3NlciBpbmZvcm1hdGlvbiA8a28+67iM65287Jqw7KCAIOygleuztDwva28+XG4gKiBAcmV0dXJuIHtTdHJpbmd9IGFnZW50SW5mby5icm93c2VyLm5hbWUgQnJvd3NlciBuYW1lIChzYWZhcmksIGNocm9tZSwgc2Jyb3dzZXIsIGllLCBmaXJlZm94LCB1bmtub3duKSA8a28+67iM65287Jqw7KCAIOydtOumhCAoc2FmYXJpLCBjaHJvbWUsIHNicm93c2VyLCBpZSwgZmlyZWZveCwgdW5rbm93bik8L2tvPlxuICogQHJldHVybiB7U3RyaW5nfSBhZ2VudEluZm8uYnJvd3Nlci52ZXJzaW9uIEJyb3dzZXIgdmVyc2lvbiA8a28+67iM65287Jqw7KCAIOuyhOyghCA8L2tvPlxuICogQHJldHVybiB7Qm9vbGVhbn0gYWdlbnRJbmZvLmJyb3dzZXIud2VidmlldyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBpbmFwcDxrbz7sm7nrt7Ag67iM65287Jqw7KCAIOyXrOu2gDwva28+XG4gKiBAcmV0dXJuIHtCb29sZWFufSBhZ2VudEluZm8uaXNNb2JpbGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgZm9yIG1vYmlsZTxrbz7rqqjrsJTsnbwg67iM65287Jqw7KCAIOyXrOu2gDwva28+XG4gKi9cbi8qKlxuICogQ29weXJpZ2h0IChjKSBOQVZFUiBDb3JwLlxuICogZWdqcy1hZ2VudCBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGFnZW50KCkge1xuICB2YXIgdWEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF9icm93c2VyLm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgX1BhcnNlcjJbXCJkZWZhdWx0XCJdLnNldFVhKHVhKTtcblxuICB2YXIgYWdlbnRJbmZvID0ge1xuICAgIG9zOiBfUGFyc2VyMltcImRlZmF1bHRcIl0uZ2V0T3MoKSxcbiAgICBicm93c2VyOiBfUGFyc2VyMltcImRlZmF1bHRcIl0uZ2V0QnJvd3NlcigpLFxuICAgIGlzTW9iaWxlOiBfUGFyc2VyMltcImRlZmF1bHRcIl0uZ2V0SXNNb2JpbGUoKVxuICB9O1xuXG4gIGFnZW50SW5mby5icm93c2VyLm5hbWUgPSBhZ2VudEluZm8uYnJvd3Nlci5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGFnZW50SW5mby5vcy5uYW1lID0gYWdlbnRJbmZvLm9zLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgYWdlbnRJbmZvLm9zLnZlcnNpb24gPSBhZ2VudEluZm8ub3MudmVyc2lvbi50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChhZ2VudEluZm8ub3MubmFtZSA9PT0gXCJpb3NcIiAmJiBhZ2VudEluZm8uYnJvd3Nlci53ZWJ2aWV3KSB7XG4gICAgYWdlbnRJbmZvLmJyb3dzZXIudmVyc2lvbiA9IFwiLTFcIjtcbiAgfVxuXG4gIHJldHVybiBhZ2VudEluZm87XG59XG5hZ2VudC5WRVJTSU9OID0gXCIyLjEuMlwiO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBhZ2VudDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93IHx8IHt9O1xuXG52YXIgUmVnRXhwID0gZXhwb3J0cy5SZWdFeHAgPSB3aW4uUmVnRXhwO1xudmFyIG5hdmlnYXRvciA9IGV4cG9ydHMubmF2aWdhdG9yID0gd2luLm5hdmlnYXRvcjtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcGFyc2VSdWxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcGFyc2VSdWxlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJzZVJ1bGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBVQSA9IHZvaWQgMDtcblxuZnVuY3Rpb24gc2V0VWEodWEpIHtcblx0VUEgPSB1YTtcbn1cblxuZnVuY3Rpb24gaXNNYXRjaGVkKGJhc2UsIHRhcmdldCkge1xuXHRyZXR1cm4gdGFyZ2V0ICYmIHRhcmdldC50ZXN0ID8gISF0YXJnZXQudGVzdChiYXNlKSA6IGJhc2UuaW5kZXhPZih0YXJnZXQpID4gLTE7XG59XG5cbmZ1bmN0aW9uIGdldElkZW50aXR5U3RyaW5nRnJvbUFycmF5KHJ1bGVzLCBkZWZhdWx0U3RyaW5ncykge1xuXHR2YXIgbWF0Y2hlZFJ1bGUgPSBydWxlcy5maWx0ZXIoZnVuY3Rpb24gKHJ1bGUpIHtcblx0XHRyZXR1cm4gaXNNYXRjaGVkKFVBLCBydWxlLmNyaXRlcmlhKTtcblx0fSlbMF07XG5cblx0cmV0dXJuIG1hdGNoZWRSdWxlICYmIG1hdGNoZWRSdWxlLmlkZW50aXR5IHx8IGRlZmF1bHRTdHJpbmdzLm5hbWU7XG59XG5cbmZ1bmN0aW9uIGdldFJ1bGUocnVsZXMsIHRhcmdldElkZW50aXR5KSB7XG5cdHJldHVybiBydWxlcy5maWx0ZXIoZnVuY3Rpb24gKHJ1bGUpIHtcblx0XHR2YXIgY3JpdGVyaWEgPSBydWxlLmNyaXRlcmlhO1xuXHRcdHZhciBpZGVudGl0eU1hdGNoZWQgPSBuZXcgUmVnRXhwKHJ1bGUuaWRlbnRpdHksIFwiaVwiKS50ZXN0KHRhcmdldElkZW50aXR5KTtcblxuXHRcdGlmIChjcml0ZXJpYSA/IGlkZW50aXR5TWF0Y2hlZCAmJiBpc01hdGNoZWQoVUEsIGNyaXRlcmlhKSA6IGlkZW50aXR5TWF0Y2hlZCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0pWzBdO1xufVxuXG5mdW5jdGlvbiBnZXRCcm93c2VyTmFtZSgpIHtcblx0cmV0dXJuIGdldElkZW50aXR5U3RyaW5nRnJvbUFycmF5KF9wYXJzZVJ1bGVzMltcImRlZmF1bHRcIl0uYnJvd3NlciwgX3BhcnNlUnVsZXMyW1wiZGVmYXVsdFwiXS5kZWZhdWx0U3RyaW5nLmJyb3dzZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRCcm93c2VyUnVsZShicm93c2VyTmFtZSkge1xuXHR2YXIgcnVsZSA9IGdldFJ1bGUoX3BhcnNlUnVsZXMyW1wiZGVmYXVsdFwiXS5icm93c2VyLCBicm93c2VyTmFtZSk7XG5cblx0aWYgKCFydWxlKSB7XG5cdFx0cnVsZSA9IHtcblx0XHRcdGNyaXRlcmlhOiBicm93c2VyTmFtZSxcblx0XHRcdHZlcnNpb25TZWFyY2g6IGJyb3dzZXJOYW1lLFxuXHRcdFx0aWRlbnRpdHk6IGJyb3dzZXJOYW1lXG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiBydWxlO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0QnJvd3NlclZlcnNpb24odmVyc2lvblRva2VuLCB1YSkge1xuXHR2YXIgYnJvd3NlclZlcnNpb24gPSBfcGFyc2VSdWxlczJbXCJkZWZhdWx0XCJdLmRlZmF1bHRTdHJpbmcuYnJvd3Nlci52ZXJzaW9uO1xuXHR2YXIgdmVyc2lvblJlZ2V4UmVzdWx0ID0gbmV3IFJlZ0V4cChcIihcIiArIHZlcnNpb25Ub2tlbiArIFwiKVwiLCBcImlcIikuZXhlYyh1YSk7XG5cblx0aWYgKCF2ZXJzaW9uUmVnZXhSZXN1bHQpIHtcblx0XHRyZXR1cm4gYnJvd3NlclZlcnNpb247XG5cdH1cblxuXHR2YXIgdmVyc2lvblRva2VuSW5kZXggPSB2ZXJzaW9uUmVnZXhSZXN1bHQuaW5kZXg7XG5cdHZhciB2ZXJUa24gPSB2ZXJzaW9uUmVnZXhSZXN1bHRbMF07XG5cblx0aWYgKHZlcnNpb25Ub2tlbkluZGV4ID4gLTEpIHtcblx0XHR2YXIgdmVyc2lvbkluZGV4ID0gdmVyc2lvblRva2VuSW5kZXggKyB2ZXJUa24ubGVuZ3RoICsgMTtcblxuXHRcdGJyb3dzZXJWZXJzaW9uID0gdWEuc3Vic3RyaW5nKHZlcnNpb25JbmRleCkuc3BsaXQoXCIgXCIpWzBdLnJlcGxhY2UoL18vZywgXCIuXCIpLnJlcGxhY2UoLzt8XFwpL2csIFwiXCIpO1xuXHR9XG5cdHJldHVybiBicm93c2VyVmVyc2lvbjtcbn1cblxuZnVuY3Rpb24gZ2V0QnJvd3NlclZlcnNpb24oYnJvd3Nlck5hbWUpIHtcblx0aWYgKCFicm93c2VyTmFtZSkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBjb25zb2xlLmxvZyhicm93c2VyUnVsZSk7XG5cdC8vIGNvbnN0IHZlcnNpb25Ub2tlbiA9IGJyb3dzZXJSdWxlID8gYnJvd3NlclJ1bGUudmVyc2lvblNlYXJjaCA6IGJyb3dzZXJOYW1lO1xuXHR2YXIgYnJvd3NlclJ1bGUgPSBnZXRCcm93c2VyUnVsZShicm93c2VyTmFtZSk7XG5cdHZhciB2ZXJzaW9uVG9rZW4gPSBicm93c2VyUnVsZS52ZXJzaW9uU2VhcmNoIHx8IGJyb3dzZXJOYW1lO1xuXHR2YXIgYnJvd3NlclZlcnNpb24gPSBleHRyYWN0QnJvd3NlclZlcnNpb24odmVyc2lvblRva2VuLCBVQSk7XG5cblx0cmV0dXJuIGJyb3dzZXJWZXJzaW9uO1xufVxuXG5mdW5jdGlvbiBpc1dlYnZpZXcoKSB7XG5cdHZhciB3ZWJ2aWV3UnVsZXMgPSBfcGFyc2VSdWxlczJbXCJkZWZhdWx0XCJdLndlYnZpZXc7XG5cdHZhciBicm93c2VyVmVyc2lvbiA9IHZvaWQgMDtcblxuXHRyZXR1cm4gd2Vidmlld1J1bGVzLmZpbHRlcihmdW5jdGlvbiAocnVsZSkge1xuXHRcdHJldHVybiBpc01hdGNoZWQoVUEsIHJ1bGUuY3JpdGVyaWEpO1xuXHR9KS5zb21lKGZ1bmN0aW9uIChydWxlKSB7XG5cdFx0YnJvd3NlclZlcnNpb24gPSBleHRyYWN0QnJvd3NlclZlcnNpb24ocnVsZS5icm93c2VyVmVyc2lvblNlYXJjaCwgVUEpO1xuXHRcdGlmIChpc01hdGNoZWQoVUEsIHJ1bGUud2Vidmlld1Rva2VuKSB8fCBpc01hdGNoZWQoYnJvd3NlclZlcnNpb24sIHJ1bGUud2Vidmlld0Jyb3dzZXJWZXJzaW9uKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBnZXRPU1J1bGUob3NOYW1lKSB7XG5cdHJldHVybiBnZXRSdWxlKF9wYXJzZVJ1bGVzMltcImRlZmF1bHRcIl0ub3MsIG9zTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldE9zTmFtZSgpIHtcblx0cmV0dXJuIGdldElkZW50aXR5U3RyaW5nRnJvbUFycmF5KF9wYXJzZVJ1bGVzMltcImRlZmF1bHRcIl0ub3MsIF9wYXJzZVJ1bGVzMltcImRlZmF1bHRcIl0uZGVmYXVsdFN0cmluZy5vcyk7XG59XG5cbmZ1bmN0aW9uIGdldE9zVmVyc2lvbihvc05hbWUpIHtcblx0dmFyIG9zUnVsZSA9IGdldE9TUnVsZShvc05hbWUpIHx8IHt9O1xuXHR2YXIgZGVmYXVsdE9TVmVyc2lvbiA9IF9wYXJzZVJ1bGVzMltcImRlZmF1bHRcIl0uZGVmYXVsdFN0cmluZy5vcy52ZXJzaW9uO1xuXHR2YXIgb3NWZXJzaW9uID0gdm9pZCAwO1xuXG5cdGlmICghb3NOYW1lKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXHRpZiAob3NSdWxlLnZlcnNpb25BbGlhcykge1xuXHRcdHJldHVybiBvc1J1bGUudmVyc2lvbkFsaWFzO1xuXHR9XG5cdHZhciBvc1ZlcnNpb25Ub2tlbiA9IG9zUnVsZS52ZXJzaW9uU2VhcmNoIHx8IG9zTmFtZTtcblx0dmFyIG9zVmVyc2lvblJlZ2V4ID0gbmV3IFJlZ0V4cChcIihcIiArIG9zVmVyc2lvblRva2VuICsgXCIpXFxcXHMoW1xcXFxkX1xcXFwuXSt8XFxcXGRfMClcIiwgXCJpXCIpO1xuXHR2YXIgb3NWZXJzaW9uUmVnZXhSZXN1bHQgPSBvc1ZlcnNpb25SZWdleC5leGVjKFVBKTtcblxuXHRpZiAob3NWZXJzaW9uUmVnZXhSZXN1bHQpIHtcblx0XHRvc1ZlcnNpb24gPSBvc1ZlcnNpb25SZWdleC5leGVjKFVBKVsyXS5yZXBsYWNlKC9fL2csIFwiLlwiKS5yZXBsYWNlKC87fFxcKS9nLCBcIlwiKTtcblx0fVxuXHRyZXR1cm4gb3NWZXJzaW9uIHx8IGRlZmF1bHRPU1ZlcnNpb247XG59XG5cbmZ1bmN0aW9uIGdldE9zKCkge1xuXHR2YXIgbmFtZSA9IGdldE9zTmFtZSgpO1xuXHR2YXIgdmVyc2lvbiA9IGdldE9zVmVyc2lvbihuYW1lKTtcblxuXHRyZXR1cm4geyBuYW1lOiBuYW1lLCB2ZXJzaW9uOiB2ZXJzaW9uIH07XG59XG5cbmZ1bmN0aW9uIGdldEJyb3dzZXIoKSB7XG5cdHZhciBuYW1lID0gZ2V0QnJvd3Nlck5hbWUoKTtcblx0dmFyIHZlcnNpb24gPSBnZXRCcm93c2VyVmVyc2lvbihuYW1lKTtcblxuXHRyZXR1cm4geyBuYW1lOiBuYW1lLCB2ZXJzaW9uOiB2ZXJzaW9uLCB3ZWJ2aWV3OiBpc1dlYnZpZXcoKSB9O1xufVxuXG5mdW5jdGlvbiBnZXRJc01vYmlsZSgpIHtcblx0cmV0dXJuIFVBLmluZGV4T2YoXCJNb2JpXCIpICE9PSAtMTtcbn1cblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB7XG5cdGdldE9zOiBnZXRPcyxcblx0Z2V0QnJvd3NlcjogZ2V0QnJvd3Nlcixcblx0Z2V0SXNNb2JpbGU6IGdldElzTW9iaWxlLFxuXHRzZXRVYTogc2V0VWFcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBwYXJzZVJ1bGVzID0ge1xuXHRicm93c2VyOiBbe1xuXHRcdGNyaXRlcmlhOiBcIlBoYW50b21KU1wiLFxuXHRcdGlkZW50aXR5OiBcIlBoYW50b21KU1wiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogL1doYWxlLyxcblx0XHRpZGVudGl0eTogXCJXaGFsZVwiLFxuXHRcdHZlcnNpb25TZWFyY2g6IFwiV2hhbGVcIlxuXHR9LCB7XG5cdFx0Y3JpdGVyaWE6IC9FZGdlLyxcblx0XHRpZGVudGl0eTogXCJFZGdlXCIsXG5cdFx0dmVyc2lvblNlYXJjaDogXCJFZGdlXCJcblx0fSwge1xuXHRcdGNyaXRlcmlhOiAvTVNJRXxUcmlkZW50fFdpbmRvd3MgUGhvbmUvLFxuXHRcdGlkZW50aXR5OiBcIklFXCIsXG5cdFx0dmVyc2lvblNlYXJjaDogXCJJRU1vYmlsZXxNU0lFfHJ2XCJcblx0fSwge1xuXHRcdGNyaXRlcmlhOiAvTWl1aUJyb3dzZXIvLFxuXHRcdGlkZW50aXR5OiBcIk1JVUkgQnJvd3NlclwiLFxuXHRcdHZlcnNpb25TZWFyY2g6IFwiTWl1aUJyb3dzZXJcIlxuXHR9LCB7XG5cdFx0Y3JpdGVyaWE6IC9TYW1zdW5nQnJvd3Nlci8sXG5cdFx0aWRlbnRpdHk6IFwiU2Ftc3VuZyBJbnRlcm5ldFwiLFxuXHRcdHZlcnNpb25TZWFyY2g6IFwiU2Ftc3VuZ0Jyb3dzZXJcIlxuXHR9LCB7XG5cdFx0Y3JpdGVyaWE6IC9TQU1TVU5HIC8sXG5cdFx0aWRlbnRpdHk6IFwiU2Ftc3VuZyBJbnRlcm5ldFwiLFxuXHRcdHZlcnNpb25TZWFyY2g6IFwiVmVyc2lvblwiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogL0Nocm9tZXxDcmlPUy8sXG5cdFx0aWRlbnRpdHk6IFwiQ2hyb21lXCJcblx0fSwge1xuXHRcdGNyaXRlcmlhOiAvQW5kcm9pZC8sXG5cdFx0aWRlbnRpdHk6IFwiQW5kcm9pZCBCcm93c2VyXCIsXG5cdFx0dmVyc2lvblNlYXJjaDogXCJWZXJzaW9uXCJcblx0fSwge1xuXHRcdGNyaXRlcmlhOiAvaVBob25lfGlQYWQvLFxuXHRcdGlkZW50aXR5OiBcIlNhZmFyaVwiLFxuXHRcdHZlcnNpb25TZWFyY2g6IFwiVmVyc2lvblwiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogXCJBcHBsZVwiLFxuXHRcdGlkZW50aXR5OiBcIlNhZmFyaVwiLFxuXHRcdHZlcnNpb25TZWFyY2g6IFwiVmVyc2lvblwiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogXCJGaXJlZm94XCIsXG5cdFx0aWRlbnRpdHk6IFwiRmlyZWZveFwiXG5cdH1dLFxuXHRvczogW3tcblx0XHRjcml0ZXJpYTogL1dpbmRvd3MgUGhvbmUvLFxuXHRcdGlkZW50aXR5OiBcIldpbmRvd3MgUGhvbmVcIixcblx0XHR2ZXJzaW9uU2VhcmNoOiBcIldpbmRvd3MgUGhvbmVcIlxuXHR9LCB7XG5cdFx0Y3JpdGVyaWE6IFwiV2luZG93cyAyMDAwXCIsXG5cdFx0aWRlbnRpdHk6IFwiV2luZG93XCIsXG5cdFx0dmVyc2lvbkFsaWFzOiBcIjUuMFwiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogL1dpbmRvd3MgTlQvLFxuXHRcdGlkZW50aXR5OiBcIldpbmRvd1wiLFxuXHRcdHZlcnNpb25TZWFyY2g6IFwiV2luZG93cyBOVFwiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogL2lQaG9uZXxpUGFkLyxcblx0XHRpZGVudGl0eTogXCJpT1NcIixcblx0XHR2ZXJzaW9uU2VhcmNoOiBcImlQaG9uZSBPU3xDUFUgT1NcIlxuXHR9LCB7XG5cdFx0Y3JpdGVyaWE6IFwiTWFjXCIsXG5cdFx0dmVyc2lvblNlYXJjaDogXCJPUyBYXCIsXG5cdFx0aWRlbnRpdHk6IFwiTUFDXCJcblx0fSwge1xuXHRcdGNyaXRlcmlhOiAvQW5kcm9pZC8sXG5cdFx0aWRlbnRpdHk6IFwiQW5kcm9pZFwiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogL1RpemVuLyxcblx0XHRpZGVudGl0eTogXCJUaXplblwiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogL1dlYjBTLyxcblx0XHRpZGVudGl0eTogXCJXZWJPU1wiXG5cdH1dLFxuXG5cdC8vIFdlYnZpZXcgY2hlY2sgY29uZGl0aW9uXG5cdC8vIGlvczogSWYgaGFzIG5vIHZlcnNpb24gaW5mb3JtYXRpb25cblx0Ly8gQW5kcm9pZCA1LjAgJiYgY2hyb21lIDQwKzogUHJlc2VuY2Ugb2YgXCI7IHd2XCIgaW4gdXNlckFnZW50XG5cdC8vIFVuZGVyIGFuZHJvaWQgNS4wOiBQcmVzZW5jZSBvZiBcIk5BVkVSXCIgb3IgXCJEYXVtXCIgaW4gdXNlckFnZW50XG5cdHdlYnZpZXc6IFt7XG5cdFx0Y3JpdGVyaWE6IC9pUGhvbmV8aVBhZC8sXG5cdFx0YnJvd3NlclZlcnNpb25TZWFyY2g6IFwiVmVyc2lvblwiLFxuXHRcdHdlYnZpZXdCcm93c2VyVmVyc2lvbjogLy0xL1xuXHR9LCB7XG5cdFx0Y3JpdGVyaWE6IC9pUGhvbmV8aVBhZHxBbmRyb2lkLyxcblx0XHR3ZWJ2aWV3VG9rZW46IC9OQVZFUnxEQVVNfDsgd3YvXG5cblx0fV0sXG5cdGRlZmF1bHRTdHJpbmc6IHtcblx0XHRicm93c2VyOiB7XG5cdFx0XHR2ZXJzaW9uOiBcIi0xXCIsXG5cdFx0XHRuYW1lOiBcInVua25vd25cIlxuXHRcdH0sXG5cdFx0b3M6IHtcblx0XHRcdHZlcnNpb246IFwiLTFcIixcblx0XHRcdG5hbWU6IFwidW5rbm93blwiXG5cdFx0fVxuXHR9XG59O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHBhcnNlUnVsZXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGVnanMvYWdlbnQvZGlzdC9hZ2VudC5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RlZmFucGVubmVyL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIHY0LjIuNCszMTRlNDgzMVxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5FUzZQcm9taXNlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgeDtcbiAgcmV0dXJuIHggIT09IG51bGwgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5cblxudmFyIF9pc0FycmF5ID0gdm9pZCAwO1xuaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xufSBlbHNlIHtcbiAgX2lzQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG59XG5cbnZhciBpc0FycmF5ID0gX2lzQXJyYXk7XG5cbnZhciBsZW4gPSAwO1xudmFyIHZlcnR4TmV4dCA9IHZvaWQgMDtcbnZhciBjdXN0b21TY2hlZHVsZXJGbiA9IHZvaWQgMDtcblxudmFyIGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgcXVldWVbbGVuXSA9IGNhbGxiYWNrO1xuICBxdWV1ZVtsZW4gKyAxXSA9IGFyZztcbiAgbGVuICs9IDI7XG4gIGlmIChsZW4gPT09IDIpIHtcbiAgICAvLyBJZiBsZW4gaXMgMiwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgaWYgKGN1c3RvbVNjaGVkdWxlckZuKSB7XG4gICAgICBjdXN0b21TY2hlZHVsZXJGbihmbHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG4gIGN1c3RvbVNjaGVkdWxlckZuID0gc2NoZWR1bGVGbjtcbn1cblxuZnVuY3Rpb24gc2V0QXNhcChhc2FwRm4pIHtcbiAgYXNhcCA9IGFzYXBGbjtcbn1cblxudmFyIGJyb3dzZXJXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbnZhciBicm93c2VyR2xvYmFsID0gYnJvd3NlcldpbmRvdyB8fCB7fTtcbnZhciBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgaXNOb2RlID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbi8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBub2RlXG5mdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcbiAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbn1cblxuLy8gdmVydHhcbmZ1bmN0aW9uIHVzZVZlcnR4VGltZXIoKSB7XG4gIGlmICh0eXBlb2YgdmVydHhOZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2ZXJ0eE5leHQoZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIG5vZGUuZGF0YSA9IGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyO1xuICB9O1xufVxuXG4vLyB3ZWIgd29ya2VyXG5mdW5jdGlvbiB1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU2V0VGltZW91dCgpIHtcbiAgLy8gU3RvcmUgc2V0VGltZW91dCByZWZlcmVuY2Ugc28gZXM2LXByb21pc2Ugd2lsbCBiZSB1bmFmZmVjdGVkIGJ5XG4gIC8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxuICB2YXIgZ2xvYmFsU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbFNldFRpbWVvdXQoZmx1c2gsIDEpO1xuICB9O1xufVxuXG52YXIgcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgIHZhciBhcmcgPSBxdWV1ZVtpICsgMV07XG5cbiAgICBjYWxsYmFjayhhcmcpO1xuXG4gICAgcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgcXVldWVbaSArIDFdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFZlcnR4KCkge1xuICB0cnkge1xuICAgIHZhciB2ZXJ0eCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCkucmVxdWlyZSgndmVydHgnKTtcbiAgICB2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgIHJldHVybiB1c2VWZXJ0eFRpbWVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xuICB9XG59XG5cbnZhciBzY2hlZHVsZUZsdXNoID0gdm9pZCAwO1xuLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbmlmIChpc05vZGUpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG59IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG59IGVsc2UgaWYgKGlzV29ya2VyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNZXNzYWdlQ2hhbm5lbCgpO1xufSBlbHNlIGlmIChicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgcGFyZW50ID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgfVxuXG4gIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG5cbiAgaWYgKF9zdGF0ZSkge1xuICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1tfc3RhdGUgLSAxXTtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjayhfc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcGFyZW50Ll9yZXN1bHQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gIH1cblxuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZXNvbHZlYCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIHJlc29sdmVkIHdpdGggdGhlXG4gIHBhc3NlZCBgdmFsdWVgLiBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVzb2x2ZSgxKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoMSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZXNvbHZlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgZnVsZmlsbGVkIHdpdGggdGhlIGdpdmVuXG4gIGB2YWx1ZWBcbiovXG5mdW5jdGlvbiByZXNvbHZlJDEob2JqZWN0KSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBQRU5ESU5HID0gdm9pZCAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xuXG52YXIgVFJZX0NBVENIX0VSUk9SID0geyBlcnJvcjogbnVsbCB9O1xuXG5mdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKHByb21pc2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGVycm9yO1xuICAgIHJldHVybiBUUllfQ0FUQ0hfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VGhlbih0aGVuJCQxLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gIHRyeSB7XG4gICAgdGhlbiQkMS5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGFzYXAoZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gdHJ5VGhlbih0aGVuJCQxLCB0aGVuYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH1cbiAgfSwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQxID09PSB0aGVuICYmIG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoZW4kJDEgPT09IFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIFRSWV9DQVRDSF9FUlJPUi5lcnJvcik7XG4gICAgICBUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodGhlbiQkMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGVuJCQxKSkge1xuICAgICAgaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBzZWxmRnVsZmlsbG1lbnQoKSk7XG4gIH0gZWxzZSBpZiAob2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlLCBnZXRUaGVuKHZhbHVlKSk7XG4gIH0gZWxzZSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICB9XG5cbiAgcHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cbiAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzYXAocHVibGlzaCwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cblxuICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gIF9zdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSA9IG9uUmVqZWN0aW9uO1xuXG4gIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMCxcbiAgICAgIGNhbGxiYWNrID0gdm9pZCAwLFxuICAgICAgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgVFJZX0NBVENIX0VSUk9SLmVycm9yID0gZTtcbiAgICByZXR1cm4gVFJZX0NBVENIX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdmFyIGhhc0NhbGxiYWNrID0gaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICB2YWx1ZSA9IHZvaWQgMCxcbiAgICAgIGVycm9yID0gdm9pZCAwLFxuICAgICAgc3VjY2VlZGVkID0gdm9pZCAwLFxuICAgICAgZmFpbGVkID0gdm9pZCAwO1xuXG4gIGlmIChoYXNDYWxsYmFjaykge1xuICAgIHZhbHVlID0gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCk7XG5cbiAgICBpZiAodmFsdWUgPT09IFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgIGVycm9yID0gdmFsdWUuZXJyb3I7XG4gICAgICB2YWx1ZS5lcnJvciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gbm9vcFxuICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gIHRyeSB7XG4gICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcbiAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBlKTtcbiAgfVxufVxuXG52YXIgaWQgPSAwO1xuZnVuY3Rpb24gbmV4dElkKCkge1xuICByZXR1cm4gaWQrKztcbn1cblxuZnVuY3Rpb24gbWFrZVByb21pc2UocHJvbWlzZSkge1xuICBwcm9taXNlW1BST01JU0VfSURdID0gaWQrKztcbiAgcHJvbWlzZS5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbn1cblxudmFyIEVudW1lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gICAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcblxuICAgIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG4gICAgICBtYWtlUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgICAgdGhpcy5fZW51bWVyYXRlKGlucHV0KTtcbiAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcbiAgICB9XG4gIH1cblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24gX2VudW1lcmF0ZShpbnB1dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gUEVORElORyAmJiBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2VhY2hFbnRyeShpbnB1dFtpXSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbiBfZWFjaEVudHJ5KGVudHJ5LCBpKSB7XG4gICAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuICAgIHZhciByZXNvbHZlJCQxID0gYy5yZXNvbHZlO1xuXG5cbiAgICBpZiAocmVzb2x2ZSQkMSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgICB2YXIgX3RoZW4gPSBnZXRUaGVuKGVudHJ5KTtcblxuICAgICAgaWYgKF90aGVuID09PSB0aGVuICYmIGVudHJ5Ll9zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSQxKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIF90aGVuKTtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHByb21pc2UsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KG5ldyBjKGZ1bmN0aW9uIChyZXNvbHZlJCQxKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUkJDEoZW50cnkpO1xuICAgICAgICB9KSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChyZXNvbHZlJCQxKGVudHJ5KSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbiBfc2V0dGxlZEF0KHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG5cbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgICBpZiAoc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiBfd2lsbFNldHRsZUF0KHByb21pc2UsIGkpIHtcbiAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICBzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRW51bWVyYXRvcjtcbn0oKTtcblxuLyoqXG4gIGBQcm9taXNlLmFsbGAgYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9taXNlcywgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaFxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXMgZm9yIHRoZSBwYXNzZWQgcHJvbWlzZXMsIG9yXG4gIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuICBlbGVtZW50cyBvZiB0aGUgcGFzc2VkIGl0ZXJhYmxlIHRvIHByb21pc2VzIGFzIGl0IHJ1bnMgdGhpcyBhbGdvcml0aG0uXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlc29sdmUoMik7XG4gIGxldCBwcm9taXNlMyA9IHJlc29sdmUoMyk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgfSk7XG4gIGBgYFxuXG4gIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgbGV0IHByb21pc2UzID0gcmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gZW50cmllcyBhcnJheSBvZiBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICBAc3RhdGljXG4qL1xuZnVuY3Rpb24gYWxsKGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yYWNlYCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2ggaXMgc2V0dGxlZCBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlXG4gIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMicpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFByb21pc2UucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdFxuICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG4gIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IHNldHRsZWQgcHJvbWlzZSBoYXNcbiAgYmVjb21lIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvbWlzZSAyJykpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICB9KTtcbiAgYGBgXG5cbiAgQW4gZXhhbXBsZSByZWFsLXdvcmxkIHVzZSBjYXNlIGlzIGltcGxlbWVudGluZyB0aW1lb3V0czpcblxuICBgYGBqYXZhc2NyaXB0XG4gIFByb21pc2UucmFjZShbYWpheCgnZm9vLmpzb24nKSwgdGltZW91dCg1MDAwKV0pXG4gIGBgYFxuXG4gIEBtZXRob2QgcmFjZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuICBwcm9taXNlIHRvIHNldHRsZS5cbiovXG5mdW5jdGlvbiByYWNlKGVudHJpZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkoZW50cmllcykpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5mdW5jdGlvbiByZWplY3QkMShyZWFzb24pIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbmVlZHNSZXNvbHZlcigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xufVxuXG5mdW5jdGlvbiBuZWVkc05ldygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbn1cblxuLyoqXG4gIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gIFRlcm1pbm9sb2d5XG4gIC0tLS0tLS0tLS0tXG5cbiAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgQmFzaWMgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLVxuXG4gIGBgYGpzXG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gb24gc3VjY2Vzc1xuICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgLy8gb24gZmFpbHVyZVxuICAgIHJlamVjdChyZWFzb24pO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIEFkdmFuY2VkIFVzYWdlOlxuICAtLS0tLS0tLS0tLS0tLS1cblxuICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICBgYGBqc1xuICBQcm9taXNlLmFsbChbXG4gICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KTtcbiAgYGBgXG5cbiAgQGNsYXNzIFByb21pc2VcbiAgQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZXJcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAY29uc3RydWN0b3JcbiovXG5cbnZhciBQcm9taXNlJDEgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICB0aGlzW1BST01JU0VfSURdID0gbmV4dElkKCk7XG4gICAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgIGlmIChub29wICE9PSByZXNvbHZlcikge1xuICAgICAgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nICYmIG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gIH0pO1xuICBgYGBcbiAgIENoYWluaW5nXG4gIC0tLS0tLS0tXG4gICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gIH0pO1xuICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgfSk7XG4gIGBgYFxuICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgQXNzaW1pbGF0aW9uXG4gIC0tLS0tLS0tLS0tLVxuICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gIH0pO1xuICBgYGBcbiAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgU2ltcGxlIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IHJlc3VsdDtcbiAgIHRyeSB7XG4gICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyBmYWlsdXJlXG4gIH0pO1xuICBgYGBcbiAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IGF1dGhvciwgYm9va3M7XG4gICB0cnkge1xuICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG4gICB9XG4gICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuICAgfVxuICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgaWYgKGVycikge1xuICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICB9XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfVxuICB9KTtcbiAgYGBgXG4gICBQcm9taXNlIEV4YW1wbGU7XG4gICBgYGBqYXZhc2NyaXB0XG4gIGZpbmRBdXRob3IoKS5cbiAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgIC8vIGZvdW5kIGJvb2tzXG4gIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfSk7XG4gIGBgYFxuICAgQG1ldGhvZCB0aGVuXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG4gIC8qKlxuICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gIH1cbiAgLy8gc3luY2hyb25vdXNcbiAgdHJ5IHtcbiAgZmluZEF1dGhvcigpO1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9XG4gIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgQG1ldGhvZCBjYXRjaFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgIGBmaW5hbGx5YCB3aWxsIGJlIGludm9rZWQgcmVnYXJkbGVzcyBvZiB0aGUgcHJvbWlzZSdzIGZhdGUganVzdCBhcyBuYXRpdmVcbiAgICB0cnkvY2F0Y2gvZmluYWxseSBiZWhhdmVzXG4gIFxuICAgIFN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpIHtcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBdXRob3IoKTtcbiAgICB9XG4gIFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZmluZEF1dGhvcigpOyAvLyBzdWNjZWVkIG9yIGZhaWxcbiAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIGFsd2F5cyBydW5zXG4gICAgICAvLyBkb2Vzbid0IGFmZmVjdCB0aGUgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBBc3luY2hyb25vdXMgZXhhbXBsZTpcbiAgXG4gICAgYGBganNcbiAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIHJldHVybiBmaW5kT3RoZXJBdXRoZXIoKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCl7XG4gICAgICAvLyBhdXRob3Igd2FzIGVpdGhlciBmb3VuZCwgb3Igbm90XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgZmluYWxseVxuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuXG4gIFByb21pc2UucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbiBfZmluYWxseShjYWxsYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwcm9taXNlLmNvbnN0cnVjdG9yO1xuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFByb21pc2U7XG59KCk7XG5cblByb21pc2UkMS5wcm90b3R5cGUudGhlbiA9IHRoZW47XG5Qcm9taXNlJDEuYWxsID0gYWxsO1xuUHJvbWlzZSQxLnJhY2UgPSByYWNlO1xuUHJvbWlzZSQxLnJlc29sdmUgPSByZXNvbHZlJDE7XG5Qcm9taXNlJDEucmVqZWN0ID0gcmVqZWN0JDE7XG5Qcm9taXNlJDEuX3NldFNjaGVkdWxlciA9IHNldFNjaGVkdWxlcjtcblByb21pc2UkMS5fc2V0QXNhcCA9IHNldEFzYXA7XG5Qcm9taXNlJDEuX2FzYXAgPSBhc2FwO1xuXG4vKmdsb2JhbCBzZWxmKi9cbmZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICB2YXIgbG9jYWwgPSB2b2lkIDA7XG5cbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWwgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYWwgPSBzZWxmO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBsb2NhbCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgUCA9IGxvY2FsLlByb21pc2U7XG5cbiAgaWYgKFApIHtcbiAgICB2YXIgcHJvbWlzZVRvU3RyaW5nID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgcHJvbWlzZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFAucmVzb2x2ZSgpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBzaWxlbnRseSBpZ25vcmVkXG4gICAgfVxuXG4gICAgaWYgKHByb21pc2VUb1N0cmluZyA9PT0gJ1tvYmplY3QgUHJvbWlzZV0nICYmICFQLmNhc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBsb2NhbC5Qcm9taXNlID0gUHJvbWlzZSQxO1xufVxuXG4vLyBTdHJhbmdlIGNvbXBhdC4uXG5Qcm9taXNlJDEucG9seWZpbGwgPSBwb2x5ZmlsbDtcblByb21pc2UkMS5Qcm9taXNlID0gUHJvbWlzZSQxO1xuXG5yZXR1cm4gUHJvbWlzZSQxO1xuXG59KSkpO1xuXG5cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXM2LXByb21pc2UubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgTWF0aFV0aWwgPSB3aW5kb3cuTWF0aFV0aWwgfHwge307XG5cbk1hdGhVdGlsLmRlZ1RvUmFkID0gTWF0aC5QSSAvIDE4MDtcbk1hdGhVdGlsLnJhZFRvRGVnID0gMTgwIC8gTWF0aC5QSTtcblxuLy8gU29tZSBtaW5pbWFsIG1hdGggZnVuY3Rpb25hbGl0eSBib3Jyb3dlZCBmcm9tIFRIUkVFLk1hdGggYW5kIHN0cmlwcGVkIGRvd25cbi8vIGZvciB0aGUgcHVycG9zZXMgb2YgdGhpcyBsaWJyYXJ5LlxuXG5cbk1hdGhVdGlsLlZlY3RvcjIgPSBmdW5jdGlvbiAoIHgsIHkgKSB7XG4gIHRoaXMueCA9IHggfHwgMDtcbiAgdGhpcy55ID0geSB8fCAwO1xufTtcblxuTWF0aFV0aWwuVmVjdG9yMi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBNYXRoVXRpbC5WZWN0b3IyLFxuXG4gIHNldDogZnVuY3Rpb24gKCB4LCB5ICkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggdiApIHtcbiAgICB0aGlzLnggPSB2Lng7XG4gICAgdGhpcy55ID0gdi55O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuICAgIHRoaXMueCA9IGEueCAtIGIueDtcbiAgICB0aGlzLnkgPSBhLnkgLSBiLnk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbn07XG5cbk1hdGhVdGlsLlZlY3RvcjMgPSBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG4gIHRoaXMueCA9IHggfHwgMDtcbiAgdGhpcy55ID0geSB8fCAwO1xuICB0aGlzLnogPSB6IHx8IDA7XG59O1xuXG5NYXRoVXRpbC5WZWN0b3IzLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IE1hdGhVdGlsLlZlY3RvcjMsXG5cbiAgc2V0OiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueiA9IHo7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG4gICAgdGhpcy54ID0gdi54O1xuICAgIHRoaXMueSA9IHYueTtcbiAgICB0aGlzLnogPSB2Lno7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKTtcbiAgfSxcblxuICBub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NhbGFyID0gdGhpcy5sZW5ndGgoKTtcblxuICAgIGlmICggc2NhbGFyICE9PSAwICkge1xuICAgICAgdmFyIGludlNjYWxhciA9IDEgLyBzY2FsYXI7XG5cbiAgICAgIHRoaXMubXVsdGlwbHlTY2FsYXIoaW52U2NhbGFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54ID0gMDtcbiAgICAgIHRoaXMueSA9IDA7XG4gICAgICB0aGlzLnogPSAwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcbiAgICB0aGlzLnggKj0gc2NhbGFyO1xuICAgIHRoaXMueSAqPSBzY2FsYXI7XG4gICAgdGhpcy56ICo9IHNjYWxhcjtcbiAgfSxcblxuICBhcHBseVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcbiAgICB2YXIgeiA9IHRoaXMuejtcblxuICAgIHZhciBxeCA9IHEueDtcbiAgICB2YXIgcXkgPSBxLnk7XG4gICAgdmFyIHF6ID0gcS56O1xuICAgIHZhciBxdyA9IHEudztcblxuICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjdG9yXG4gICAgdmFyIGl4ID0gIHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcbiAgICB2YXIgaXkgPSAgcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xuICAgIHZhciBpeiA9ICBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG4gICAgdmFyIGl3ID0gLSBxeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgdGhpcy54ID0gaXggKiBxdyArIGl3ICogLSBxeCArIGl5ICogLSBxeiAtIGl6ICogLSBxeTtcbiAgICB0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtIHF5ICsgaXogKiAtIHF4IC0gaXggKiAtIHF6O1xuICAgIHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC0gcXogKyBpeCAqIC0gcXkgLSBpeSAqIC0gcXg7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBkb3Q6IGZ1bmN0aW9uICggdiApIHtcbiAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xuICB9LFxuXG4gIGNyb3NzVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuICAgIHZhciBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xuICAgIHZhciBieCA9IGIueCwgYnkgPSBiLnksIGJ6ID0gYi56O1xuXG4gICAgdGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XG4gICAgdGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG4gICAgdGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbn07XG5cbk1hdGhVdGlsLlF1YXRlcm5pb24gPSBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XG4gIHRoaXMueCA9IHggfHwgMDtcbiAgdGhpcy55ID0geSB8fCAwO1xuICB0aGlzLnogPSB6IHx8IDA7XG4gIHRoaXMudyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcbn07XG5cbk1hdGhVdGlsLlF1YXRlcm5pb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTWF0aFV0aWwuUXVhdGVybmlvbixcblxuICBzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy56ID0gejtcbiAgICB0aGlzLncgPSB3O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCBxdWF0ZXJuaW9uICkge1xuICAgIHRoaXMueCA9IHF1YXRlcm5pb24ueDtcbiAgICB0aGlzLnkgPSBxdWF0ZXJuaW9uLnk7XG4gICAgdGhpcy56ID0gcXVhdGVybmlvbi56O1xuICAgIHRoaXMudyA9IHF1YXRlcm5pb24udztcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHNldEZyb21FdWxlclhZWjogZnVuY3Rpb24oIHgsIHksIHogKSB7XG4gICAgdmFyIGMxID0gTWF0aC5jb3MoIHggLyAyICk7XG4gICAgdmFyIGMyID0gTWF0aC5jb3MoIHkgLyAyICk7XG4gICAgdmFyIGMzID0gTWF0aC5jb3MoIHogLyAyICk7XG4gICAgdmFyIHMxID0gTWF0aC5zaW4oIHggLyAyICk7XG4gICAgdmFyIHMyID0gTWF0aC5zaW4oIHkgLyAyICk7XG4gICAgdmFyIHMzID0gTWF0aC5zaW4oIHogLyAyICk7XG5cbiAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG4gICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcbiAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzZXRGcm9tRXVsZXJZWFo6IGZ1bmN0aW9uKCB4LCB5LCB6ICkge1xuICAgIHZhciBjMSA9IE1hdGguY29zKCB4IC8gMiApO1xuICAgIHZhciBjMiA9IE1hdGguY29zKCB5IC8gMiApO1xuICAgIHZhciBjMyA9IE1hdGguY29zKCB6IC8gMiApO1xuICAgIHZhciBzMSA9IE1hdGguc2luKCB4IC8gMiApO1xuICAgIHZhciBzMiA9IE1hdGguc2luKCB5IC8gMiApO1xuICAgIHZhciBzMyA9IE1hdGguc2luKCB6IC8gMiApO1xuXG4gICAgdGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgIHRoaXMueSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICB0aGlzLnogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc2V0RnJvbUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcbiAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXG4gICAgLy8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuICAgIHZhciBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsIHMgPSBNYXRoLnNpbiggaGFsZkFuZ2xlICk7XG5cbiAgICB0aGlzLnggPSBheGlzLnggKiBzO1xuICAgIHRoaXMueSA9IGF4aXMueSAqIHM7XG4gICAgdGhpcy56ID0gYXhpcy56ICogcztcbiAgICB0aGlzLncgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBtdWx0aXBseTogZnVuY3Rpb24gKCBxICkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHRoaXMsIHEgKTtcbiAgfSxcblxuICBtdWx0aXBseVF1YXRlcm5pb25zOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG4gICAgLy8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXG5cbiAgICB2YXIgcWF4ID0gYS54LCBxYXkgPSBhLnksIHFheiA9IGEueiwgcWF3ID0gYS53O1xuICAgIHZhciBxYnggPSBiLngsIHFieSA9IGIueSwgcWJ6ID0gYi56LCBxYncgPSBiLnc7XG5cbiAgICB0aGlzLnggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XG4gICAgdGhpcy55ID0gcWF5ICogcWJ3ICsgcWF3ICogcWJ5ICsgcWF6ICogcWJ4IC0gcWF4ICogcWJ6O1xuICAgIHRoaXMueiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcbiAgICB0aGlzLncgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBpbnZlcnNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy54ICo9IC0xO1xuICAgIHRoaXMueSAqPSAtMTtcbiAgICB0aGlzLnogKj0gLTE7XG5cbiAgICB0aGlzLm5vcm1hbGl6ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgbm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGwgPSBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xuXG4gICAgaWYgKCBsID09PSAwICkge1xuICAgICAgdGhpcy54ID0gMDtcbiAgICAgIHRoaXMueSA9IDA7XG4gICAgICB0aGlzLnogPSAwO1xuICAgICAgdGhpcy53ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IDEgLyBsO1xuXG4gICAgICB0aGlzLnggPSB0aGlzLnggKiBsO1xuICAgICAgdGhpcy55ID0gdGhpcy55ICogbDtcbiAgICAgIHRoaXMueiA9IHRoaXMueiAqIGw7XG4gICAgICB0aGlzLncgPSB0aGlzLncgKiBsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHNsZXJwOiBmdW5jdGlvbiAoIHFiLCB0ICkge1xuICAgIGlmICggdCA9PT0gMCApIHJldHVybiB0aGlzO1xuICAgIGlmICggdCA9PT0gMSApIHJldHVybiB0aGlzLmNvcHkoIHFiICk7XG5cbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMueiwgdyA9IHRoaXMudztcblxuICAgIC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXG5cbiAgICB2YXIgY29zSGFsZlRoZXRhID0gdyAqIHFiLncgKyB4ICogcWIueCArIHkgKiBxYi55ICsgeiAqIHFiLno7XG5cbiAgICBpZiAoIGNvc0hhbGZUaGV0YSA8IDAgKSB7XG4gICAgICB0aGlzLncgPSAtIHFiLnc7XG4gICAgICB0aGlzLnggPSAtIHFiLng7XG4gICAgICB0aGlzLnkgPSAtIHFiLnk7XG4gICAgICB0aGlzLnogPSAtIHFiLno7XG5cbiAgICAgIGNvc0hhbGZUaGV0YSA9IC0gY29zSGFsZlRoZXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvcHkoIHFiICk7XG4gICAgfVxuXG4gICAgaWYgKCBjb3NIYWxmVGhldGEgPj0gMS4wICkge1xuICAgICAgdGhpcy53ID0gdztcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgdGhpcy56ID0gejtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGhhbGZUaGV0YSA9IE1hdGguYWNvcyggY29zSGFsZlRoZXRhICk7XG4gICAgdmFyIHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhICk7XG5cbiAgICBpZiAoIE1hdGguYWJzKCBzaW5IYWxmVGhldGEgKSA8IDAuMDAxICkge1xuICAgICAgdGhpcy53ID0gMC41ICogKCB3ICsgdGhpcy53ICk7XG4gICAgICB0aGlzLnggPSAwLjUgKiAoIHggKyB0aGlzLnggKTtcbiAgICAgIHRoaXMueSA9IDAuNSAqICggeSArIHRoaXMueSApO1xuICAgICAgdGhpcy56ID0gMC41ICogKCB6ICsgdGhpcy56ICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciByYXRpb0EgPSBNYXRoLnNpbiggKCAxIC0gdCApICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGEsXG4gICAgcmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcblxuICAgIHRoaXMudyA9ICggdyAqIHJhdGlvQSArIHRoaXMudyAqIHJhdGlvQiApO1xuICAgIHRoaXMueCA9ICggeCAqIHJhdGlvQSArIHRoaXMueCAqIHJhdGlvQiApO1xuICAgIHRoaXMueSA9ICggeSAqIHJhdGlvQSArIHRoaXMueSAqIHJhdGlvQiApO1xuICAgIHRoaXMueiA9ICggeiAqIHJhdGlvQSArIHRoaXMueiAqIHJhdGlvQiApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc2V0RnJvbVVuaXRWZWN0b3JzOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gaHR0cDovL2xvbGVuZ2luZS5uZXQvYmxvZy8yMDE0LzAyLzI0L3F1YXRlcm5pb24tZnJvbS10d28tdmVjdG9ycy1maW5hbFxuICAgIC8vIGFzc3VtZXMgZGlyZWN0aW9uIHZlY3RvcnMgdkZyb20gYW5kIHZUbyBhcmUgbm9ybWFsaXplZFxuXG4gICAgdmFyIHYxLCByO1xuICAgIHZhciBFUFMgPSAwLjAwMDAwMTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIHZGcm9tLCB2VG8gKSB7XG4gICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBNYXRoVXRpbC5WZWN0b3IzKCk7XG5cbiAgICAgIHIgPSB2RnJvbS5kb3QoIHZUbyApICsgMTtcblxuICAgICAgaWYgKCByIDwgRVBTICkge1xuICAgICAgICByID0gMDtcblxuICAgICAgICBpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xuICAgICAgICAgIHYxLnNldCggLSB2RnJvbS55LCB2RnJvbS54LCAwICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdjEuc2V0KCAwLCAtIHZGcm9tLnosIHZGcm9tLnkgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdjEuY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMueCA9IHYxLng7XG4gICAgICB0aGlzLnkgPSB2MS55O1xuICAgICAgdGhpcy56ID0gdjEuejtcbiAgICAgIHRoaXMudyA9IHI7XG5cbiAgICAgIHRoaXMubm9ybWFsaXplKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSgpLFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXRoVXRpbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi93ZWJ2ci1wb2x5ZmlsbC9zcmMvbWF0aC11dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBhZ2VudCBmcm9tIFwiQGVnanMvYWdlbnRcIjtcblxuY29uc3QgV0VCR0xfRVJST1JfQ09ERSA9IHtcblx0XCIwXCI6IFwiTk9fRVJST1JcIixcblx0XCIxMjgwXCI6IFwiSU5WQUxJRF9FTlVNXCIsXG5cdFwiMTI4MVwiOiBcIklOVkFMSURfVkFMVUVcIixcblx0XCIxMjgyXCI6IFwiSU5WQUxJRF9PUEVSQVRJT05cIixcblx0XCIxMjg1XCI6IFwiT1VUX09GX01FTU9SWVwiLFxuXHRcIjEyODZcIjogXCJJTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTlwiLFxuXHRcIjM3NDQyXCI6IFwiQ09OVEVYVF9MT1NUX1dFQkdMXCJcbn07XG5cbmxldCB3ZWJnbEF2YWlsYWJpbGl0eSA9IG51bGw7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMVXRpbHMge1xuXHRzdGF0aWMgY3JlYXRlU2hhZGVyKGdsLCB0eXBlLCBzb3VyY2UpIHtcblx0XHRjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG5cblx0XHRnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuXHRcdGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblx0XHRjb25zdCBzdWNjZXNzID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xuXG5cdFx0aWYgKHN1Y2Nlc3MpIHtcblx0XHRcdHJldHVybiBzaGFkZXI7XG5cdFx0fVxuXG5cdFx0Z2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRzdGF0aWMgY3JlYXRlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcikge1xuXHRcdGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cblx0XHRnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcblx0XHRnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuXHRcdGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXHRcdGNvbnN0IHN1Y2Nlc3MgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKTtcblxuXHRcdGlmIChzdWNjZXNzKSB7XG5cdFx0XHRyZXR1cm4gcHJvZ3JhbTtcblx0XHR9XG5cblx0XHRnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0c3RhdGljIGluaXRCdWZmZXIoZ2wsIHRhcmdldCAvKiBiaW5kIHBvaW50ICovLCBkYXRhLCBpdGVtU2l6ZSwgYXR0cikge1xuXHRcdGNvbnN0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG5cdFx0Z2wuYmluZEJ1ZmZlcih0YXJnZXQsIGJ1ZmZlcik7XG5cdFx0Z2wuYnVmZmVyRGF0YSh0YXJnZXQsIGRhdGEsIGdsLlNUQVRJQ19EUkFXKTtcblxuXHRcdGlmIChidWZmZXIpIHtcblx0XHRcdGJ1ZmZlci5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuXHRcdFx0YnVmZmVyLm51bUl0ZW1zID0gZGF0YS5sZW5ndGggLyBpdGVtU2l6ZTtcblx0XHR9XG5cblx0XHRpZiAoYXR0ciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyKTtcblx0XHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0ciwgYnVmZmVyLml0ZW1TaXplLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXHRcdH1cblxuXHRcdHJldHVybiBidWZmZXI7XG5cdH1cblxuXHRzdGF0aWMgYmluZEJ1ZmZlclRvQXR0cmlidXRlKGdsLCBidWZmZXIsIGF0dHIpIHtcblx0XHRpZiAoYnVmZmVyID09PSBudWxsIHx8IGF0dHIgPT09IG51bGwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHIsIGJ1ZmZlci5pdGVtU2l6ZSwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblx0fVxuXG5cdHN0YXRpYyBnZXRXZWJnbENvbnRleHQoY2FudmFzLCB1c2VyQ29udGV4dEF0dHJpYnV0ZXMpIHtcblx0XHRjb25zdCB3ZWJnbElkZW50aWZpZXJzID0gW1wid2ViZ2xcIiwgXCJleHBlcmltZW50YWwtd2ViZ2xcIiwgXCJ3ZWJraXQtM2RcIiwgXCJtb3otd2ViZ2xcIl07XG5cdFx0bGV0IGNvbnRleHQgPSBudWxsO1xuXHRcdGNvbnN0IGNvbnRleHRBdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0XHRwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxuXHRcdFx0YW50aWFsaWFzOiBmYWxzZVxuXHRcdH0sIHVzZXJDb250ZXh0QXR0cmlidXRlcyk7XG5cblx0XHRmdW5jdGlvbiBvbldlYmdsY29udGV4dGNyZWF0aW9uZXJyb3IoZSkge1xuXHRcdFx0cmV0dXJuIGUuc3RhdHVzTWVzc2FnZTtcblx0XHR9XG5cblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dGNyZWF0aW9uZXJyb3JcIiwgb25XZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgd2ViZ2xJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KHdlYmdsSWRlbnRpZmllcnNbaV0sIGNvbnRleHRBdHRyaWJ1dGVzKTtcblx0XHRcdH0gY2F0Y2ggKHQpIHt9XG5cdFx0XHRpZiAoY29udGV4dCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dGNyZWF0aW9uZXJyb3JcIiwgb25XZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yKTtcblxuXHRcdHJldHVybiBjb250ZXh0O1xuXHR9XG5cblx0c3RhdGljIGNyZWF0ZVRleHR1cmUoZ2wsIHRleHR1cmVUYXJnZXQpIHtcblx0XHRjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG5cdFx0Z2wuYmluZFRleHR1cmUodGV4dHVyZVRhcmdldCwgdGV4dHVyZSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlVGFyZ2V0LCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlVGFyZ2V0LCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlVGFyZ2V0LCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlVGFyZ2V0LCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0Z2wuYmluZFRleHR1cmUodGV4dHVyZVRhcmdldCwgbnVsbCk7XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB3ZWJnbCBhdmFpbGFiaWxpdHkgb2YgdGhlIGN1cnJlbnQgYnJvd3Nlci5cblx0ICogQG1ldGhvZCBXZWJHTFV0aWxzI2lzV2ViR0xBdmFpbGFibGVcblx0ICogQHJldHVlbiB7Qm9vbGVhbn0gaXNXZWJHTEF2YWlsYWJsZVxuXHQgKi9cblx0c3RhdGljIGlzV2ViR0xBdmFpbGFibGUoKSB7XG5cdFx0aWYgKHdlYmdsQXZhaWxhYmlsaXR5ID09PSBudWxsKSB7XG5cdFx0XHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXHRcdFx0Y29uc3Qgd2ViZ2xDb250ZXh0ID0gV2ViR0xVdGlscy5nZXRXZWJnbENvbnRleHQoY2FudmFzKTtcblxuXHRcdFx0d2ViZ2xBdmFpbGFiaWxpdHkgPSAhIXdlYmdsQ29udGV4dDtcblxuXHRcdFx0Ly8gd2ViZ2xDb250ZXh0IFJlc291cmNlIGZvcmNlZCBjb2xsZWN0aW9uXG5cdFx0XHRpZiAod2ViZ2xDb250ZXh0KSB7XG5cdFx0XHRcdGNvbnN0IGxvc2VDb250ZXh0RXh0ZW5zaW9uID0gd2ViZ2xDb250ZXh0LmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKTtcblxuXHRcdFx0XHRsb3NlQ29udGV4dEV4dGVuc2lvbiAmJiBsb3NlQ29udGV4dEV4dGVuc2lvbi5sb3NlQ29udGV4dCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gd2ViZ2xBdmFpbGFiaWxpdHk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIHdlYmdsIGlzIHN0YWJsZSBpbiB0aGUgY3VycmVudCBicm93c2VyLlxuXHQgKiBAbWV0aG9kIFdlYkdMVXRpbHMjaXNTdGFibGVXZWJHTFxuXHQgKiBAcmV0dWVuIHtCb29sZWFufSBpc1N0YWJsZVdlYkdMXG5cdCAqL1xuXHRzdGF0aWMgaXNTdGFibGVXZWJHTCgpIHtcblx0XHRjb25zdCBhZ2VudEluZm8gPSBhZ2VudCgpO1xuXHRcdGxldCBpc1N0YWJsZVdlYmdsID0gdHJ1ZTtcblxuXHRcdGlmIChhZ2VudEluZm8ub3MubmFtZSA9PT0gXCJhbmRyb2lkXCIgJiYgcGFyc2VGbG9hdChhZ2VudEluZm8ub3MudmVyc2lvbikgPD0gNC4zKSB7XG5cdFx0XHRpc1N0YWJsZVdlYmdsID0gZmFsc2U7XG5cdFx0fSBlbHNlIGlmIChhZ2VudEluZm8ub3MubmFtZSA9PT0gXCJhbmRyb2lkXCIgJiYgcGFyc2VGbG9hdChhZ2VudEluZm8ub3MudmVyc2lvbikgPT09IDQuNCkge1xuXHRcdFx0aWYgKGFnZW50SW5mby5icm93c2VyLm5hbWUgIT09IFwiY2hyb21lXCIpIHtcblx0XHRcdFx0aXNTdGFibGVXZWJnbCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gaXNTdGFibGVXZWJnbDtcblx0fVxuXG5cdHN0YXRpYyBnZXRFcnJvck5hbWVGcm9tV2ViR0xFcnJvckNvZGUoY29kZSkge1xuXHRcdGlmICghKGNvZGUgaW4gV0VCR0xfRVJST1JfQ09ERSkpIHtcblx0XHRcdHJldHVybiBcIlVOS05PV05fRVJST1JcIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gV0VCR0xfRVJST1JfQ09ERVtjb2RlXTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1Bhbm9JbWFnZVJlbmRlcmVyL1dlYkdMVXRpbHMuanMiLCJjb25zdCBDT05UUk9MX01PREVfVlIgPSAxO1xuY29uc3QgQ09OVFJPTF9NT0RFX1lBV1BJVENIID0gMjtcblxuY29uc3QgVE9VQ0hfRElSRUNUSU9OX05PTkUgPSAxO1xuY29uc3QgVE9VQ0hfRElSRUNUSU9OX1lBVyA9IDI7XG5jb25zdCBUT1VDSF9ESVJFQ1RJT05fUElUQ0ggPSA0O1xuY29uc3QgVE9VQ0hfRElSRUNUSU9OX0FMTCA9IFRPVUNIX0RJUkVDVElPTl9ZQVcgfCBUT1VDSF9ESVJFQ1RJT05fUElUQ0g7XG5cbi8qIENvbnN0IGZvciBNb3ZhYmxlQ29vcmQgKi9cbmNvbnN0IE1DX0RFQ0VMRVJBVElPTiA9IDAuMDAxNDtcbmNvbnN0IE1DX01BWElNVU1fRFVSQVRJT04gPSAxMDAwO1xuY29uc3QgTUNfQklORF9TQ0FMRSA9IFswLjIwLCAwLjIwXTtcblxuY29uc3QgTUlOX0ZJRUxEX09GX1ZJRVcgPSAyMDtcbmNvbnN0IE1BWF9GSUVMRF9PRl9WSUVXID0gMTEwO1xuY29uc3QgUEFOX1NDQUxFID0gMzIwO1xuXG4vLyBjb25zdCBERUxUQV9USFJFU0hPTEQgPSAwLjAxNTtcbi8vIGNvbnN0IERFTFRBX1RIUkVTSE9MRCA9IDAuMDk7IC8vIE5vdGU0XG4vLyBjb25zdCBERUxUQV9USFJFU0hPTEQgPSAwLjA4MjU7XG4vLyBjb25zdCBERUxUQV9USFJFU0hPTEQgPSAwLjA3NTtcbi8vIGNvbnN0IERFTFRBX1RIUkVTSE9MRCA9IDAuMDY7XG4vLyBjb25zdCBERUxUQV9USFJFU0hPTEQgPSAwLjA0NTtcbmNvbnN0IERFTFRBX1RIUkVTSE9MRCA9IDAuMDM3NTsgLy8gTm90ZTJcblxuY29uc3QgWUFXX1JBTkdFX0hBTEYgPSAxODA7XG5jb25zdCBQSVRDSF9SQU5HRV9IQUxGID0gOTA7XG5jb25zdCBDSVJDVUxBUl9QSVRDSF9SQU5HRV9IQUxGID0gMTgwO1xuY29uc3QgUElOQ0hfRVZFTlRTID0gXCJwaW5jaHN0YXJ0IHBpbmNobW92ZSBwaW5jaGVuZFwiO1xuXG5jb25zdCBLRVlNQVAgPSB7XG5cdExFRlRfQVJST1c6IDM3LFxuXHRBOiA2NSxcblx0VVBfQVJST1c6IDM4LFxuXHRXOiA4Nyxcblx0UklHSFRfQVJST1c6IDM5LFxuXHREOiA2OCxcblx0RE9XTl9BUlJPVzogNDAsXG5cdFM6IDgzLFxufTtcblxuY29uc3QgR1lST19NT0RFID0ge1xuXHROT05FOiBcIm5vbmVcIixcblx0WUFXUElUQ0g6IFwieWF3UGl0Y2hcIixcblx0VlI6IFwiVlJcIlxufTtcblxuZXhwb3J0IHtcblx0R1lST19NT0RFLFxuXG5cdENPTlRST0xfTU9ERV9WUixcblx0Q09OVFJPTF9NT0RFX1lBV1BJVENILFxuXG5cdFRPVUNIX0RJUkVDVElPTl9OT05FLFxuXHRUT1VDSF9ESVJFQ1RJT05fWUFXLFxuXHRUT1VDSF9ESVJFQ1RJT05fUElUQ0gsXG5cdFRPVUNIX0RJUkVDVElPTl9BTEwsXG5cblx0TUNfREVDRUxFUkFUSU9OLFxuXHRNQ19NQVhJTVVNX0RVUkFUSU9OLFxuXHRNQ19CSU5EX1NDQUxFLFxuXHRNSU5fRklFTERfT0ZfVklFVyxcblx0TUFYX0ZJRUxEX09GX1ZJRVcsXG5cdFBBTl9TQ0FMRSxcblx0REVMVEFfVEhSRVNIT0xELFxuXHRZQVdfUkFOR0VfSEFMRixcblx0UElUQ0hfUkFOR0VfSEFMRixcblx0Q0lSQ1VMQVJfUElUQ0hfUkFOR0VfSEFMRixcblx0UElOQ0hfRVZFTlRTLFxuXHRLRVlNQVBcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvWWF3UGl0Y2hDb250cm9sL2NvbnN0cy5qcyIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgVXRpbCA9IHdpbmRvdy5VdGlsIHx8IHt9O1xuXG5VdGlsLk1JTl9USU1FU1RFUCA9IDAuMDAxO1xuVXRpbC5NQVhfVElNRVNURVAgPSAxO1xuXG5VdGlsLmJhc2U2NCA9IGZ1bmN0aW9uKG1pbWVUeXBlLCBiYXNlNjQpIHtcbiAgcmV0dXJuICdkYXRhOicgKyBtaW1lVHlwZSArICc7YmFzZTY0LCcgKyBiYXNlNjQ7XG59O1xuXG5VdGlsLmNsYW1wID0gZnVuY3Rpb24odmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIHZhbHVlKSwgbWF4KTtcbn07XG5cblV0aWwubGVycCA9IGZ1bmN0aW9uKGEsIGIsIHQpIHtcbiAgcmV0dXJuIGEgKyAoKGIgLSBhKSAqIHQpO1xufTtcblxuLyoqXG4gKiBMaWdodCBwb2x5ZmlsbCBmb3IgYFByb21pc2UucmFjZWAuIFJldHVybnNcbiAqIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGZpcnN0IHByb21pc2VcbiAqIHByb3ZpZGVkIHJlc29sdmVzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8UHJvbWlzZT59IHByb21pc2VzXG4gKi9cblV0aWwucmFjZSA9IGZ1bmN0aW9uKHByb21pc2VzKSB7XG4gIGlmIChQcm9taXNlLnJhY2UpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKHByb21pc2VzKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvbWlzZXNbaV0udGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5VdGlsLmlzSU9TID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgaXNJT1MgPSAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzSU9TO1xuICB9O1xufSkoKTtcblxuVXRpbC5pc1dlYlZpZXdBbmRyb2lkID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgaXNXZWJWaWV3QW5kcm9pZCA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVmVyc2lvbicpICE9PSAtMSAmJlxuICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdBbmRyb2lkJykgIT09IC0xICYmXG4gICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpICE9PSAtMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc1dlYlZpZXdBbmRyb2lkO1xuICB9O1xufSkoKTtcblxuVXRpbC5pc1NhZmFyaSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGlzU2FmYXJpID0gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc1NhZmFyaTtcbiAgfTtcbn0pKCk7XG5cblV0aWwuaXNGaXJlZm94QW5kcm9pZCA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGlzRmlyZWZveEFuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSAhPT0gLTEgJiZcbiAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQW5kcm9pZCcpICE9PSAtMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc0ZpcmVmb3hBbmRyb2lkO1xuICB9O1xufSkoKTtcblxuVXRpbC5pc1I3ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgaXNSNyA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignUjcgQnVpbGQnKSAhPT0gLTE7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNSNztcbiAgfTtcbn0pKCk7XG5cblV0aWwuaXNMYW5kc2NhcGVNb2RlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydG4gPSAod2luZG93Lm9yaWVudGF0aW9uID09IDkwIHx8IHdpbmRvdy5vcmllbnRhdGlvbiA9PSAtOTApO1xuICByZXR1cm4gVXRpbC5pc1I3KCkgPyAhcnRuIDogcnRuO1xufTtcblxuLy8gSGVscGVyIG1ldGhvZCB0byB2YWxpZGF0ZSB0aGUgdGltZSBzdGVwcyBvZiBzZW5zb3IgdGltZXN0YW1wcy5cblV0aWwuaXNUaW1lc3RhbXBEZWx0YVZhbGlkID0gZnVuY3Rpb24odGltZXN0YW1wRGVsdGFTKSB7XG4gIGlmIChpc05hTih0aW1lc3RhbXBEZWx0YVMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aW1lc3RhbXBEZWx0YVMgPD0gVXRpbC5NSU5fVElNRVNURVApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRpbWVzdGFtcERlbHRhUyA+IFV0aWwuTUFYX1RJTUVTVEVQKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuVXRpbC5nZXRTY3JlZW5XaWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTWF0aC5tYXgod2luZG93LnNjcmVlbi53aWR0aCwgd2luZG93LnNjcmVlbi5oZWlnaHQpICpcbiAgICAgIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xufTtcblxuVXRpbC5nZXRTY3JlZW5IZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGgubWluKHdpbmRvdy5zY3JlZW4ud2lkdGgsIHdpbmRvdy5zY3JlZW4uaGVpZ2h0KSAqXG4gICAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbn07XG5cblV0aWwucmVxdWVzdEZ1bGxzY3JlZW4gPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIGlmIChVdGlsLmlzV2ViVmlld0FuZHJvaWQoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChlbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgZWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbigpO1xuICB9IGVsc2UgaWYgKGVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICBlbGVtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gIH0gZWxzZSBpZiAoZWxlbWVudC5tb3pSZXF1ZXN0RnVsbFNjcmVlbikge1xuICAgIGVsZW1lbnQubW96UmVxdWVzdEZ1bGxTY3JlZW4oKTtcbiAgfSBlbHNlIGlmIChlbGVtZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICBlbGVtZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblV0aWwuZXhpdEZ1bGxzY3JlZW4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKSB7XG4gICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbikge1xuICAgIGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKCk7XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbikge1xuICAgIGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4oKTtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuKSB7XG4gICAgZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbigpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuVXRpbC5nZXRGdWxsc2NyZWVuRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgfHxcbiAgICAgIGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fFxuICAgICAgZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudDtcbn07XG5cblV0aWwubGlua1Byb2dyYW0gPSBmdW5jdGlvbihnbCwgdmVydGV4U291cmNlLCBmcmFnbWVudFNvdXJjZSwgYXR0cmliTG9jYXRpb25NYXApIHtcbiAgLy8gTm8gZXJyb3IgY2hlY2tpbmcgZm9yIGJyZXZpdHkuXG4gIHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XG4gIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNvdXJjZSk7XG4gIGdsLmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyKTtcblxuICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNvdXJjZSk7XG4gIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuXG4gIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcblxuICBmb3IgKHZhciBhdHRyaWJOYW1lIGluIGF0dHJpYkxvY2F0aW9uTWFwKVxuICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJMb2NhdGlvbk1hcFthdHRyaWJOYW1lXSwgYXR0cmliTmFtZSk7XG5cbiAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG5cbiAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG5cbiAgcmV0dXJuIHByb2dyYW07XG59O1xuXG5VdGlsLmdldFByb2dyYW1Vbmlmb3JtcyA9IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gIHZhciB1bmlmb3JtcyA9IHt9O1xuICB2YXIgdW5pZm9ybUNvdW50ID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xuICB2YXIgdW5pZm9ybU5hbWUgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmlmb3JtQ291bnQ7IGkrKykge1xuICAgIHZhciB1bmlmb3JtSW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgaSk7XG4gICAgdW5pZm9ybU5hbWUgPSB1bmlmb3JtSW5mby5uYW1lLnJlcGxhY2UoJ1swXScsICcnKTtcbiAgICB1bmlmb3Jtc1t1bmlmb3JtTmFtZV0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgdW5pZm9ybU5hbWUpO1xuICB9XG4gIHJldHVybiB1bmlmb3Jtcztcbn07XG5cblV0aWwub3J0aG9NYXRyaXggPSBmdW5jdGlvbiAob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICB2YXIgbHIgPSAxIC8gKGxlZnQgLSByaWdodCksXG4gICAgICBidCA9IDEgLyAoYm90dG9tIC0gdG9wKSxcbiAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gLTIgKiBscjtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gLTIgKiBidDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDIgKiBuZjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn07XG5cblV0aWwuY29weUFycmF5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZGVzdCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICBkZXN0W2ldID0gc291cmNlW2ldO1xuICB9XG59O1xuXG5VdGlsLmlzTW9iaWxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjaGVjayA9IGZhbHNlO1xuICAoZnVuY3Rpb24oYSl7aWYoLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWluby9pLnRlc3QoYSl8fC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzXFwtKXxhaShrb3xybil8YWwoYXZ8Y2F8Y28pfGFtb2l8YW4oZXh8bnl8eXcpfGFwdHV8YXIoY2h8Z28pfGFzKHRlfHVzKXxhdHR3fGF1KGRpfFxcLW18ciB8cyApfGF2YW58YmUoY2t8bGx8bnEpfGJpKGxifHJkKXxibChhY3xheil8YnIoZXx2KXd8YnVtYnxid1xcLShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtXFwtfGNlbGx8Y2h0bXxjbGRjfGNtZFxcLXxjbyhtcHxuZCl8Y3Jhd3xkYShpdHxsbHxuZyl8ZGJ0ZXxkY1xcLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8XFwtZCl8ZWwoNDl8YWkpfGVtKGwyfHVsKXxlcihpY3xrMCl8ZXNsOHxleihbNC03XTB8b3N8d2F8emUpfGZldGN8Zmx5KFxcLXxfKXxnMSB1fGc1NjB8Z2VuZXxnZlxcLTV8Z1xcLW1vfGdvKFxcLnd8b2QpfGdyKGFkfHVuKXxoYWllfGhjaXR8aGRcXC0obXxwfHQpfGhlaVxcLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzXFwtY3xodChjKFxcLXwgfF98YXxnfHB8c3x0KXx0cCl8aHUoYXd8dGMpfGlcXC0oMjB8Z298bWEpfGkyMzB8aWFjKCB8XFwtfFxcLyl8aWJyb3xpZGVhfGlnMDF8aWtvbXxpbTFrfGlubm98aXBhcXxpcmlzfGphKHR8dilhfGpicm98amVtdXxqaWdzfGtkZGl8a2VqaXxrZ3QoIHxcXC8pfGtsb258a3B0IHxrd2NcXC18a3lvKGN8ayl8bGUobm98eGkpfGxnKCBnfFxcLyhrfGx8dSl8NTB8NTR8XFwtW2Etd10pfGxpYnd8bHlueHxtMVxcLXd8bTNnYXxtNTBcXC98bWEodGV8dWl8eG8pfG1jKDAxfDIxfGNhKXxtXFwtY3J8bWUocmN8cmkpfG1pKG84fG9hfHRzKXxtbWVmfG1vKDAxfDAyfGJpfGRlfGRvfHQoXFwtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSlcXC18b258dGZ8d2Z8d2d8d3QpfG5vayg2fGkpfG56cGh8bzJpbXxvcCh0aXx3dil8b3Jhbnxvd2cxfHA4MDB8cGFuKGF8ZHx0KXxwZHhnfHBnKDEzfFxcLShbMS04XXxjKSl8cGhpbHxwaXJlfHBsKGF5fHVjKXxwblxcLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdFxcLWd8cWFcXC1hfHFjKDA3fDEyfDIxfDMyfDYwfFxcLVsyLTddfGlcXC0pfHF0ZWt8cjM4MHxyNjAwfHJha3N8cmltOXxybyh2ZXx6byl8czU1XFwvfHNhKGdlfG1hfG1tfG1zfG55fHZhKXxzYygwMXxoXFwtfG9vfHBcXC0pfHNka1xcL3xzZShjKFxcLXwwfDEpfDQ3fG1jfG5kfHJpKXxzZ2hcXC18c2hhcnxzaWUoXFwtfG0pfHNrXFwtMHxzbCg0NXxpZCl8c20oYWx8YXJ8YjN8aXR8dDUpfHNvKGZ0fG55KXxzcCgwMXxoXFwtfHZcXC18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2xcXC18dGRnXFwtfHRlbChpfG0pfHRpbVxcLXx0XFwtbW98dG8ocGx8c2gpfHRzKDcwfG1cXC18bTN8bTUpfHR4XFwtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118XFwtdil8dm00MHx2b2RhfHZ1bGN8dngoNTJ8NTN8NjB8NjF8NzB8ODB8ODF8ODN8ODV8OTgpfHczYyhcXC18ICl8d2ViY3x3aGl0fHdpKGcgfG5jfG53KXx3bWxifHdvbnV8eDcwMHx5YXNcXC18eW91cnx6ZXRvfHp0ZVxcLS9pLnRlc3QoYS5zdWJzdHIoMCw0KSkpY2hlY2sgPSB0cnVlfSkobmF2aWdhdG9yLnVzZXJBZ2VudHx8bmF2aWdhdG9yLnZlbmRvcnx8d2luZG93Lm9wZXJhKTtcbiAgcmV0dXJuIGNoZWNrO1xufTtcblxuVXRpbC5leHRlbmQgPSBmdW5jdGlvbihkZXN0LCBzcmMpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgZGVzdFtrZXldID0gc3JjW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59XG5cblV0aWwuc2FmYXJpQ3NzU2l6ZVdvcmthcm91bmQgPSBmdW5jdGlvbihjYW52YXMpIHtcbiAgLy8gVE9ETyhzbXVzKTogUmVtb3ZlIHRoaXMgd29ya2Fyb3VuZCB3aGVuIFNhZmFyaSBmb3IgaU9TIGlzIGZpeGVkLlxuICAvLyBpT1Mgb25seSB3b3JrYXJvdW5kIChmb3IgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1MjU1NikuXG4gIC8vXG4gIC8vIFwiVG8gdGhlIGxhc3QgSSBncmFwcGxlIHdpdGggdGhlZTtcbiAgLy8gIGZyb20gaGVsbCdzIGhlYXJ0IEkgc3RhYiBhdCB0aGVlO1xuICAvLyAgZm9yIGhhdGUncyBzYWtlIEkgc3BpdCBteSBsYXN0IGJyZWF0aCBhdCB0aGVlLlwiXG4gIC8vIC0tIE1vYnkgRGljaywgYnkgSGVybWFuIE1lbHZpbGxlXG4gIGlmIChVdGlsLmlzSU9TKCkpIHtcbiAgICB2YXIgd2lkdGggPSBjYW52YXMuc3R5bGUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGNhbnZhcy5zdHlsZS5oZWlnaHQ7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gKHBhcnNlSW50KHdpZHRoKSArIDEpICsgJ3B4JztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gKHBhcnNlSW50KGhlaWdodCkpICsgJ3B4JztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH0sIDEwMCk7XG4gIH1cblxuICAvLyBEZWJ1ZyBvbmx5LlxuICB3aW5kb3cuVXRpbCA9IFV0aWw7XG4gIHdpbmRvdy5jYW52YXMgPSBjYW52YXM7XG59O1xuXG5VdGlsLmlzRGVidWcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFV0aWwuZ2V0UXVlcnlQYXJhbWV0ZXIoJ2RlYnVnJyk7XG59O1xuXG5VdGlsLmdldFF1ZXJ5UGFyYW1ldGVyID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgbmFtZSA9IG5hbWUucmVwbGFjZSgvW1xcW10vLCBcIlxcXFxbXCIpLnJlcGxhY2UoL1tcXF1dLywgXCJcXFxcXVwiKTtcbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChcIltcXFxcPyZdXCIgKyBuYW1lICsgXCI9KFteJiNdKilcIiksXG4gICAgICByZXN1bHRzID0gcmVnZXguZXhlYyhsb2NhdGlvbi5zZWFyY2gpO1xuICByZXR1cm4gcmVzdWx0cyA9PT0gbnVsbCA/IFwiXCIgOiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1sxXS5yZXBsYWNlKC9cXCsvZywgXCIgXCIpKTtcbn07XG5cblV0aWwuZnJhbWVEYXRhRnJvbVBvc2UgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBwaU92ZXIxODAgPSBNYXRoLlBJIC8gMTgwLjA7XG4gIHZhciByYWQ0NSA9IE1hdGguUEkgKiAwLjI1O1xuXG4gIC8vIEJvcnJvd2VkIGZyb20gZ2xNYXRyaXguXG4gIGZ1bmN0aW9uIG1hdDRfcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcob3V0LCBmb3YsIG5lYXIsIGZhcikge1xuICAgIHZhciB1cFRhbiA9IE1hdGgudGFuKGZvdiA/IChmb3YudXBEZWdyZWVzICogcGlPdmVyMTgwKSA6IHJhZDQ1KSxcbiAgICBkb3duVGFuID0gTWF0aC50YW4oZm92ID8gKGZvdi5kb3duRGVncmVlcyAqIHBpT3ZlcjE4MCkgOiByYWQ0NSksXG4gICAgbGVmdFRhbiA9IE1hdGgudGFuKGZvdiA/IChmb3YubGVmdERlZ3JlZXMgKiBwaU92ZXIxODApIDogcmFkNDUpLFxuICAgIHJpZ2h0VGFuID0gTWF0aC50YW4oZm92ID8gKGZvdi5yaWdodERlZ3JlZXMgKiBwaU92ZXIxODApIDogcmFkNDUpLFxuICAgIHhTY2FsZSA9IDIuMCAvIChsZWZ0VGFuICsgcmlnaHRUYW4pLFxuICAgIHlTY2FsZSA9IDIuMCAvICh1cFRhbiArIGRvd25UYW4pO1xuXG4gICAgb3V0WzBdID0geFNjYWxlO1xuICAgIG91dFsxXSA9IDAuMDtcbiAgICBvdXRbMl0gPSAwLjA7XG4gICAgb3V0WzNdID0gMC4wO1xuICAgIG91dFs0XSA9IDAuMDtcbiAgICBvdXRbNV0gPSB5U2NhbGU7XG4gICAgb3V0WzZdID0gMC4wO1xuICAgIG91dFs3XSA9IDAuMDtcbiAgICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgICBvdXRbOV0gPSAoKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjUpO1xuICAgIG91dFsxMF0gPSBmYXIgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzExXSA9IC0xLjA7XG4gICAgb3V0WzEyXSA9IDAuMDtcbiAgICBvdXRbMTNdID0gMC4wO1xuICAgIG91dFsxNF0gPSAoZmFyICogbmVhcikgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzE1XSA9IDAuMDtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0NF9mcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIHEsIHYpIHtcbiAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgICB4eiA9IHggKiB6MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gICAgb3V0WzFdID0geHkgKyB3ejtcbiAgICBvdXRbMl0gPSB4eiAtIHd5O1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geHkgLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICAgIG91dFs2XSA9IHl6ICsgd3g7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4eiArIHd5O1xuICAgIG91dFs5XSA9IHl6IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1hdDRfdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdLFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gICAgaWYgKGEgPT09IG91dCkge1xuICAgICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xuICAgICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgICBvdXRbMF0gPSBhMDA7IG91dFsxXSA9IGEwMTsgb3V0WzJdID0gYTAyOyBvdXRbM10gPSBhMDM7XG4gICAgICBvdXRbNF0gPSBhMTA7IG91dFs1XSA9IGExMTsgb3V0WzZdID0gYTEyOyBvdXRbN10gPSBhMTM7XG4gICAgICBvdXRbOF0gPSBhMjA7IG91dFs5XSA9IGEyMTsgb3V0WzEwXSA9IGEyMjsgb3V0WzExXSA9IGEyMztcblxuICAgICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWF0NF9pbnZlcnQob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIHZhciBkZWZhdWx0T3JpZW50YXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAxXSk7XG4gIHZhciBkZWZhdWx0UG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwXSk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlRXllTWF0cmljZXMocHJvamVjdGlvbiwgdmlldywgcG9zZSwgcGFyYW1ldGVycywgdnJEaXNwbGF5KSB7XG4gICAgbWF0NF9wZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyhwcm9qZWN0aW9uLCBwYXJhbWV0ZXJzID8gcGFyYW1ldGVycy5maWVsZE9mVmlldyA6IG51bGwsIHZyRGlzcGxheS5kZXB0aE5lYXIsIHZyRGlzcGxheS5kZXB0aEZhcik7XG5cbiAgICB2YXIgb3JpZW50YXRpb24gPSBwb3NlLm9yaWVudGF0aW9uIHx8IGRlZmF1bHRPcmllbnRhdGlvbjtcbiAgICB2YXIgcG9zaXRpb24gPSBwb3NlLnBvc2l0aW9uIHx8IGRlZmF1bHRQb3NpdGlvbjtcblxuICAgIG1hdDRfZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24odmlldywgb3JpZW50YXRpb24sIHBvc2l0aW9uKTtcbiAgICBpZiAocGFyYW1ldGVycylcbiAgICAgIG1hdDRfdHJhbnNsYXRlKHZpZXcsIHZpZXcsIHBhcmFtZXRlcnMub2Zmc2V0KTtcbiAgICBtYXQ0X2ludmVydCh2aWV3LCB2aWV3KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihmcmFtZURhdGEsIHBvc2UsIHZyRGlzcGxheSkge1xuICAgIGlmICghZnJhbWVEYXRhIHx8ICFwb3NlKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgZnJhbWVEYXRhLnBvc2UgPSBwb3NlO1xuICAgIGZyYW1lRGF0YS50aW1lc3RhbXAgPSBwb3NlLnRpbWVzdGFtcDtcblxuICAgIHVwZGF0ZUV5ZU1hdHJpY2VzKFxuICAgICAgICBmcmFtZURhdGEubGVmdFByb2plY3Rpb25NYXRyaXgsIGZyYW1lRGF0YS5sZWZ0Vmlld01hdHJpeCxcbiAgICAgICAgcG9zZSwgdnJEaXNwbGF5LmdldEV5ZVBhcmFtZXRlcnMoXCJsZWZ0XCIpLCB2ckRpc3BsYXkpO1xuICAgIHVwZGF0ZUV5ZU1hdHJpY2VzKFxuICAgICAgICBmcmFtZURhdGEucmlnaHRQcm9qZWN0aW9uTWF0cml4LCBmcmFtZURhdGEucmlnaHRWaWV3TWF0cml4LFxuICAgICAgICBwb3NlLCB2ckRpc3BsYXkuZ2V0RXllUGFyYW1ldGVycyhcInJpZ2h0XCIpLCB2ckRpc3BsYXkpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59KSgpO1xuXG5VdGlsLmlzSW5zaWRlQ3Jvc3NEb21haW5JRnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlzRnJhbWVkID0gKHdpbmRvdy5zZWxmICE9PSB3aW5kb3cudG9wKTtcbiAgdmFyIHJlZkRvbWFpbiA9IFV0aWwuZ2V0RG9tYWluRnJvbVVybChkb2N1bWVudC5yZWZlcnJlcik7XG4gIHZhciB0aGlzRG9tYWluID0gVXRpbC5nZXREb21haW5Gcm9tVXJsKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICByZXR1cm4gaXNGcmFtZWQgJiYgKHJlZkRvbWFpbiAhPT0gdGhpc0RvbWFpbik7XG59O1xuXG4vLyBGcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIzOTQ1MDI3LlxuVXRpbC5nZXREb21haW5Gcm9tVXJsID0gZnVuY3Rpb24odXJsKSB7XG4gIHZhciBkb21haW47XG4gIC8vIEZpbmQgJiByZW1vdmUgcHJvdG9jb2wgKGh0dHAsIGZ0cCwgZXRjLikgYW5kIGdldCBkb21haW4uXG4gIGlmICh1cmwuaW5kZXhPZihcIjovL1wiKSA+IC0xKSB7XG4gICAgZG9tYWluID0gdXJsLnNwbGl0KCcvJylbMl07XG4gIH1cbiAgZWxzZSB7XG4gICAgZG9tYWluID0gdXJsLnNwbGl0KCcvJylbMF07XG4gIH1cblxuICAvL2ZpbmQgJiByZW1vdmUgcG9ydCBudW1iZXJcbiAgZG9tYWluID0gZG9tYWluLnNwbGl0KCc6JylbMF07XG5cbiAgcmV0dXJuIGRvbWFpbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBVdGlsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3dlYnZyLXBvbHlmaWxsL3NyYy91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwiQGVnanMvYXhlc1wiLFwiY29tbW9uanMyXCI6XCJAZWdqcy9heGVzXCIsXCJhbWRcIjpcIkBlZ2pzL2F4ZXNcIixcInJvb3RcIjpbXCJlZ1wiLFwiQXhlc1wiXX1cbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmVyIHtcblx0Ly8gRGVmaW5lIGludGVyZmFjZSBmb3IgUmVuZGVyZXJzXG5cdC8qKlxuXHQgKiBGb2xsb3dpbmcgTVVTVCBCRSBERUZJTkVEIG9uIENoaWxkIG9mIFJlbmRlcmVyXG5cdCAqXG5cdCAqIERBVEFcblx0ICpcblx0ICogIC0gZ2V0VmVydGV4UG9zaXRpb25EYXRhXG5cdCAqICAtIGdldEluZGV4RGF0YVxuXHQgKiAgLSBnZXRUZXh0dXJlQ29vcmREYXRhXG5cdCAqXG5cdCAqIFNPVVJDRVxuXHQgKlxuXHQgKiAgLSBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2Vcblx0ICogIC0gZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2Vcblx0ICpcblx0ICogVEVYVFVSRVxuXHQgKlxuXHQgKiAgLSBiaW5kVGV4dHVyZVxuXHQgKi9cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9yZW5kZXJlci9SZW5kZXJlci5qcyIsImltcG9ydCB7R1lST19NT0RFfSBmcm9tIFwiLi4vWWF3UGl0Y2hDb250cm9sL2NvbnN0c1wiO1xuXG5jb25zdCBFUlJPUl9UWVBFID0ge1xuXHRJTlZBTElEX0RFVklDRTogMTAsXG5cdE5PX1dFQkdMOiAxMSxcblx0RkFJTF9JTUFHRV9MT0FEOiAxMixcblx0RkFJTF9CSU5EX1RFWFRVUkU6IDEzLFxuXHRJTlZBTElEX1JFU09VUkNFOiAxNCxcblx0UkVOREVSSU5HX0NPTlRFWFRfTE9TVDogMTVcbn07XG5cbmNvbnN0IEVWRU5UUyA9IHtcblx0UkVBRFk6IFwicmVhZHlcIixcblx0VklFV19DSEFOR0U6IFwidmlld0NoYW5nZVwiLFxuXHRBTklNQVRJT05fRU5EOiBcImFuaW1hdGlvbkVuZFwiLFxuXHRFUlJPUjogXCJlcnJvclwiXG59O1xuXG5jb25zdCBQUk9KRUNUSU9OX1RZUEUgPSB7XG5cdEVRVUlSRUNUQU5HVUxBUjogXCJlcXVpcmVjdGFuZ3VsYXJcIixcblx0Q1VCRU1BUDogXCJjdWJlbWFwXCJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRHWVJPX01PREUsXG5cdEVWRU5UUyxcblx0RVJST1JfVFlQRSxcblx0UFJPSkVDVElPTl9UWVBFXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1Bhbm9WaWV3ZXIvY29uc3RzLmpzIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG5cbi8qKlxuICogQGNsYXNzIGVnLnZpZXczNjAuU3ByaXRlSW1hZ2VcbiAqIEBjbGFzc2Rlc2MgQSBtb2R1bGUgdGhhdCBkaXNwbGF5cyBhIHNpbmdsZSBvciBjb250aW51b3VzIGltYWdlIG9mIGFueSBvbmUgb2YgdGhlIFwic3ByaXRlIGltYWdlc1wiLiBTcGluVmlld2VyIGludGVybmFsbHkgdXNlcyBTcHJpdGVJbWFnZSB0byBzaG93IGVhY2ggZnJhbWUgb2YgdGhlIHNwcml0ZSBpbWFnZS5cbiAqIEBrbyDsiqTtlITrnbzsnbTtirgg7J2066+47KeAIOykkSDsnoTsnZjsnZgg7ZWcIO2UhOugiOyehOydhCDri6jrsJzshLEg7Zi57J2AIOyXsOyGjeyggeycvOuhnCDrs7Tsl6zso7zripQg7Lu07Y+s64SM7Yq47J6F64uI64ukLiBTcGluVmlld2VyIOuKlCDrgrTrtoDsoIHsnLzroZwgU3ByaXRlSW1hZ2Ug66W8IOyCrOyaqe2VmOyXrCDsiqTtlITrnbzsnbTtirgg7J2066+47KeA7J2YIOqwgSDtlITroIjsnoTsnYQg67O07Jes7KSN64uI64ukLlxuICogQGV4dGVuZHMgZWcuQ29tcG9uZW50XG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBzaG93IHRoZSBpbWFnZSA8a28+7J2066+47KeA66W8IOuztOyXrOykhCDrjIDsg4Eg7JqU7IaMPC9rbz5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb24gb2JqZWN0PGtvPu2MjOudvOuvuO2EsCDqsJ3ssrQ8L2tvPlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuaW1hZ2VVcmwgVGhlIHVybCBvZiB0aGUgc3ByaXRlIGltYWdlIDxrbz7siqTtlITrnbzsnbTtirgg7J2066+47KeA7J2YIHVybDwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucm93Q291bnQ9MV0gTnVtYmVyIG9mIGhvcml6b250YWwgZnJhbWVzIGluIHRoZSBzcHJpdGUgaW1hZ2UgPGtvPuyKpO2UhOudvOydtO2KuCDsnbTrr7jsp4DsnZgg6rCA66GcIO2UhOugiOyehCDqsK/siJg8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbENvdW50PTFdIE51bWJlciBvZiB2ZXJ0aWNhbCBmcmFtZXMgaW4gdGhlIHNwcml0ZSBpbWFnZSA8a28+7Iqk7ZSE65287J207Yq4IOydtOuvuOyngOydmCDshLjroZwg7ZSE66CI7J6EIOqwr+yImDwva28+XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtvcHRpb25zLndpZHRoPVwiYXV0b1wiXSBUaGUgd2lkdGggb2YgdGhlIHRhcmdldCBlbGVtZW50IHRvIHNob3cgdGhlIGltYWdlIDxrbz7snbTrr7jsp4Drpbwg67O07Jes7KSEIOuMgOyDgSDsmpTshozsnZgg64SI67mEPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW29wdGlvbnMuaGVpZ2h0PVwiYXV0b1wiXSBUaGUgaGVpZ2h0IG9mIHRoZSB0YXJnZXQgZWxlbWVudCB0byBzaG93IHRoZSBpbWFnZSA8a28+7J2066+47KeA66W8IOuztOyXrOykhCDrjIDsg4Eg7JqU7IaM7J2YIOuGkuydtDwva28+XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9IZWlnaHQ9dHJ1ZV0gV2hldGhlciB0byBhdXRvbWF0aWNhbGx5IHNldCB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZSBhcmVhIHRvIG1hdGNoIHRoZSBvcmlnaW5hbCBpbWFnZSdzIHByb3BvcnRpb24gPGtvPuybkOuzuCDsnbTrr7jsp4Ag67mE7Jyo7JeQIOunnuqyjCDsnbTrr7jsp4Ag7JiB7Jet7J2YIOuGkuydtOulvCDsnpDrj5nsnLzroZwg7ISk7KCV7ZWg7KeAIOyXrOu2gDwva28+XG4gKiBAcGFyYW0ge051bWJlcltdfSBbb3B0aW9ucy5jb2xSb3c9WzAsIDBdXSBUaGUgY29sdW1uLCByb3cgY29vcmRpbmF0ZXMgb2YgdGhlIGZpcnN0IGZyYW1lIG9mIHRoZSBzcHJpdGUgaW1hZ2UgKGJhc2VkIG9uIDAgaW5kZXgpIDxrbz4g7Iqk7ZSE65287J207Yq4IOydtOuvuOyngCDspJEg7LKY7J2MIOuztOyXrOykhCDtlITroIjsnoTsnZggKGNvbHVtbiwgcm93KSDsooztkZwgKDAgaW5kZXgg6riw67CYKTwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJhbWVJbmRleD0wXSBmcmFtZUluZGV4IHNwZWNpZmllcyB0aGUgaW5kZXggb2YgdGhlIGZyYW1lIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgXCJTcHJpdGUgaW1hZ2VcIi4gVGhlIGZyYW1lSW5kZXggb3JkZXIgaXMgemVyby1iYXNlZCBhbmQgaW5kZXhlZCBpbiBaIGZvcm0gKGxlZnQtdG8tcmlnaHQsIHRvcC10by1ib3R0b20sIGFuZCBuZXdsaW5lIGFnYWluIGZyb20gbGVmdCB0byByaWdodCkuPGJyPi0gY29sUm93IGlzIGVxdWl2YWxlbnQgdG8gZnJhbWVJbmRleC4gSG93ZXZlciwgaWYgY29sUm93IGlzIHNwZWNpZmllZCBhdCB0aGUgc2FtZSB0aW1lLCBjb2xSb3cgdGFrZXMgcHJlY2VkZW5jZS48a28+7Iqk7ZSE65287J207Yq4IOydtOuvuOyngCDspJHsl5DshJwg67O07Jes7KeIIO2UhOugiOyehOydmCDsnbjrjbHsiqTrpbwg7KeA7KCV7ZWp64uI64ukLiBmcmFtZUluZGV4IOyInOyEnOuKlCAw67aA7YSwIOyLnOyeke2VmOupsCBaIO2Yle2DnCjsmbzsqr3sl5DshJwg7Jik66W47Kq9LCDsnITsl5DshJwg7JWE656YLCDqsJztlokg7IucIOuLpOyLnCDsmbzsqr0g67aA7YSwKeuhnCDsnbjrjbHsi7Htlanri4jri6QuPGJyPi0gY29sUm93IOuKlCBmcmFtZUluZGV4IOyZgCDrj5nsnbztlZwg6riw64ql7J2EIO2VqeuLiOuLpC4g64uoLCBjb2xSb3cg6rCAIOuPmeyLnOyXkCDsp4DsoJXrkJwg6rK97JqwIGNvbFJvdyDqsIAg7Jqw7ISg7ZWp64uI64ukLjwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2NhbGU9MV0gU3BpbiBzY2FsZSAoVGhlIGxhcmdlciB0aGUgc3BpbiwgdGhlIG1vcmUpLjxrbz5TcGluIOuwsOycqCAo7YG0IOyImOuhnSDrjZQg66eO7J20IOybgOyngeyehCk8L2tvPlxuICpcbiAqIEBzdXBwb3J0IHtcImllXCI6IFwiOStcIiwgXCJjaFwiIDogXCJsYXRlc3RcIiwgXCJmZlwiIDogXCJsYXRlc3RcIiwgIFwic2ZcIiA6IFwibGF0ZXN0XCIsIFwiZWRnZVwiIDogXCJsYXRlc3RcIiwgXCJpb3NcIiA6IFwiNytcIiwgXCJhblwiIDogXCIyLjMrIChleGNlcHQgMy54KVwifVxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBJbml0aWFsaXplIFNwcml0ZUltYWdlXG4gKlxuICogdmFyIGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbWFnZS1kaXZcIik7XG4gKiB2YXIgc3ByaXRlcyA9IG5ldyBlZy52aWV3MzYwLlNwcml0ZUltYWdlKGVsLCB7XG4gKiBcdGltYWdlVXJsOiBcIi9pbWcvYmFnMzYwLmpwZ1wiLCAvLyByZXF1aXJlZFxuICogXHRyb3dDb3VudDogMjRcbiAqIH0pO1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcHJpdGVJbWFnZSBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcblx0XHRzdXBlcigpO1xuXHRcdGNvbnN0IG9wdCA9IG9wdGlvbnMgfHwge307XG5cblx0XHR0aGlzLl9lbCA9IGVsZW1lbnQ7XG5cdFx0dGhpcy5fcm93Q291bnQgPSBvcHQucm93Q291bnQgfHwgMTtcblx0XHR0aGlzLl9jb2xDb3VudCA9IG9wdC5jb2xDb3VudCB8fCAxO1xuXHRcdHRoaXMuX3RvdGFsQ291bnQgPSB0aGlzLl9yb3dDb3VudCAqIHRoaXMuX2NvbENvdW50Oy8vIHRvdGFsIGZyYW1lc1xuXHRcdHRoaXMuX3dpZHRoID0gb3B0LndpZHRoIHx8IFwiYXV0b1wiO1xuXHRcdHRoaXMuX2hlaWdodCA9IG9wdC5oZWlnaHQgfHwgXCJhdXRvXCI7XG5cdFx0dGhpcy5fYXV0b0hlaWdodCA9IG9wdC5hdXRvSGVpZ2h0ICE9IG51bGwgPyBvcHQuYXV0b0hlaWdodCA6IFwidHJ1ZVwiOyAvLyBJZiBhdXRvSGVpZ2h0IGlzIHNwZWNpZmllZCwgX2hlaWdodCB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuXHRcdHRoaXMuX2NvbFJvdyA9IFswLCAwXTtcblxuXHRcdGlmIChvcHQuY29sUm93KSB7XG5cdFx0XHR0aGlzLl9jb2xSb3cgPSBvcHQuY29sUm93O1xuXHRcdH0gZWxzZSBpZiAob3B0LmZyYW1lSW5kZXgpIHtcblx0XHRcdHRoaXMuc2V0RnJhbWVJbmRleChvcHQuZnJhbWVJbmRleCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZWwuc3R5bGUud2lkdGggPSBTcHJpdGVJbWFnZS5fZ2V0U2l6ZVN0cmluZyh0aGlzLl93aWR0aCk7XG5cdFx0dGhpcy5fZWwuc3R5bGUuaGVpZ2h0ID0gU3ByaXRlSW1hZ2UuX2dldFNpemVTdHJpbmcodGhpcy5faGVpZ2h0KTtcblxuXHRcdGlmICghb3B0LmltYWdlVXJsKSB7XG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKFwiaW1hZ2VFcnJvclwiLCB7XG5cdFx0XHRcdFx0aW1hZ2VVcmw6IG9wdC5pbWFnZVVybFxuXHRcdFx0XHR9KTtcblx0XHRcdH0sIDApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2ltYWdlID0gbmV3IEltYWdlKCk7XG5cdFx0LyoqXG5cdFx0ICogRXZlbnRcblx0XHQgKi9cblx0XHR0aGlzLl9pbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG5cdFx0XHR0aGlzLl9iZyA9IFNwcml0ZUltYWdlLl9jcmVhdGVCZ0Rpdihcblx0XHRcdFx0dGhpcy5faW1hZ2UsIHRoaXMuX3Jvd0NvdW50LCB0aGlzLl9jb2xDb3VudCwgdGhpcy5fYXV0b0hlaWdodCk7XG5cdFx0XHR0aGlzLl9lbC5hcHBlbmRDaGlsZCh0aGlzLl9iZyk7XG5cdFx0XHR0aGlzLnNldENvbFJvdyh0aGlzLl9jb2xSb3dbMF0sIHRoaXMuX2NvbFJvd1sxXSk7XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogRXZlbnRzIHRoYXQgb2NjdXIgd2hlbiBjb21wb25lbnQgbG9hZGluZyBpcyBjb21wbGV0ZVxuXHRcdFx0ICogQGtvIOy7tO2PrOuEjO2KuCDroZzrlKnsnbQg7JmE66OM65CY66m0IOuwnOyDne2VmOuKlCDsnbTrsqTtirhcblx0XHRcdCAqIEBuYW1lIGVnLnZpZXczNjAuU3ByaXRlSW1hZ2UjbG9hZFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gVGhlIG9iamVjdCBvZiBkYXRhIHRvIGJlIHNlbnQgdG8gYW4gZXZlbnQgPGtvPuydtOuypO2KuOyXkCDsoITri6zrkJjripQg642w7J207YSwIOqwneyytDwva28+XG5cdFx0XHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJhbS50YXJnZXQgVGhlIHRhcmdldCBlbGVtZW50IGZvciB3aGljaCB0byBkaXNwbGF5IHRoZSBpbWFnZSA8a28+7J2066+47KeA66W8IOuztOyXrOykhCDrjIDsg4Eg7JeY66as66i87Yq4PC9rbz5cblx0XHRcdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmFtLmJnRWxlbWVudCBHZW5lcmF0ZWQgYmFja2dyb3VuZCBpbWFnZSBlbGVtZW50IDxrbz7sg53shLHrkJwgYmFja2dyb3VuZCDsnbTrr7jsp4Ag7JeY66as66i87Yq4PC9rbz5cblx0XHRcdCAqXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICpcblx0XHRcdCAqIHNwcml0ZXMub24oe1xuXHRcdFx0ICpcdFwibG9hZFwiIDogZnVuY3Rpb24oZXZ0KSB7XG5cdFx0XHQgKlx0XHRjb25zb2xlLmxvZyhcImxvYWQgZXZlbnQgZmlyZWQgLSBlLnRhcmdldFwiLCBlLnRhcmdldCwgXCJlLmJnRWxlbWVudFwiLCBlLmJnRWxlbWVudCk7XG5cdFx0XHQgKlx0fVxuXHRcdFx0ICogfSk7XG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcihcImxvYWRcIiwge1xuXHRcdFx0XHR0YXJnZXQ6IHRoaXMuX2VsLFxuXHRcdFx0XHRiZ0VsZW1lbnQ6IHRoaXMuX2JnXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHRoaXMuX2F1dG9QbGF5UmVzZXJ2ZWRJbmZvKSB7XG5cdFx0XHRcdHRoaXMucGxheSh0aGlzLl9hdXRvUGxheVJlc2VydmVkSW5mbyk7XG5cdFx0XHRcdHRoaXMuX2F1dG9QbGF5UmVzZXJ2ZWRJbmZvID0gbnVsbDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy5faW1hZ2Uub25lcnJvciA9IGUgPT4ge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBBbiBldmVudCB0aGF0IG9jY3VycyB3aGVuIHRoZSBpbWFnZSBpbmRleCBpcyBjaGFuZ2VkIGJ5IHRoZSB1c2VyJ3MgbGVmdCAvIHJpZ2h0IHBhbm5pbmdcblx0XHRcdCAqIEBrbyDsgqzsmqnsnpDsnZgg7KKM7JqwIFBhbm5pbmcg7JeQIOydmO2VtCDsnbTrr7jsp4Ag7J24642x7Iqk6rCAIOuzgOqyveuQmOyXiOydhOuVjCDrsJzsg53tlZjripQg7J2067Kk7Yq4XG5cdFx0XHQgKiBAbmFtZSBlZy52aWV3MzYwLlNwcml0ZUltYWdlI2ltYWdlRXJyb3Jcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIFRoZSBvYmplY3Qgb2YgZGF0YSB0byBiZSBzZW50IHRvIGFuIGV2ZW50IDxrbz7snbTrsqTtirjsl5Ag7KCE64us65CY64qUIOuNsOydtO2EsCDqsJ3ssrQ8L2tvPlxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtLmltYWdlVXJsIFVzZXItc3BlY2lmaWVkIGltYWdlIFVSTCA8a28+7IKs7Jqp7J6Q6rCAIOyngOygle2VnCDsnbTrr7jsp4AgVVJMPC9rbz5cblx0XHRcdCAqXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICpcblx0XHRcdCAqIHNwcml0ZXMub24oe1xuXHRcdFx0ICpcdFwiaW1hZ2VFcnJvclwiIDogZnVuY3Rpb24oZXZ0KSB7XG5cdFx0XHQgKlx0XHQvLyBFcnJvciBoYW5kbGluZ1xuXHRcdFx0ICpcdFx0Y29uc29sZS5sb2coZS5pbWFnZVVybCk7XG5cdFx0XHQgKlx0fVxuXHRcdFx0ICogfSk7XG5cdFx0XHQgKi9cblx0XHRcdHRoaXMudHJpZ2dlcihcImltYWdlRXJyb3JcIiwge1xuXHRcdFx0XHRpbWFnZVVybDogb3B0LmltYWdlVXJsXG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0dGhpcy5faW1hZ2Uuc3JjID0gb3B0LmltYWdlVXJsO1xuXHR9XG5cblx0c3RhdGljIF9jcmVhdGVCZ0RpdihpbWcsIHJvd0NvdW50LCBjb2xDb3VudCwgYXV0b0hlaWdodCkge1xuXHRcdGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuXHRcdGVsLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHtpbWcuc3JjfSlgO1xuXHRcdGVsLnN0eWxlLmJhY2tncm91bmRTaXplID0gYCR7Y29sQ291bnQgKiAxMDB9JSAke3Jvd0NvdW50ICogMTAwfSVgO1xuXG5cdFx0Y29uc3QgdW5pdFdpZHRoID0gaW1nLndpZHRoIC8gY29sQ291bnQ7XG5cdFx0Y29uc3QgdW5pdEhlaWdodCA9IGltZy5oZWlnaHQgLyByb3dDb3VudDtcblxuXHRcdGlmIChhdXRvSGVpZ2h0KSB7XG5cdFx0XHRjb25zdCByID0gdW5pdEhlaWdodCAvIHVuaXRXaWR0aDtcblxuXHRcdFx0ZWwuc3R5bGUucGFkZGluZ0JvdHRvbSA9IGAke3IgKiAxMDB9JWA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuXHRcdH1cblxuXHRcdHJldHVybiBlbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgdGhlIGZyYW1lSW5kZXggb2YgdGhlIGZyYW1lIHRvIGJlIHNob3duIGluIHRoZSBzcHJpdGUgaW1hZ2UuXG5cdCAqIEBrbyDsiqTtlITrnbzsnbTtirgg7J2066+47KeAIOykkSDrs7Tsl6zsp4gg7ZSE66CI7J6E7J2YIGZyYW1lSW5kZXgg6rCS7J2EIOyngOyglVxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuU3ByaXRlSW1hZ2Ujc2V0RnJhbWVJbmRleFxuXHQgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVJbmRleCBmcmFtZSBpbmRleCBvZiBhIGZyYW1lPGtvPu2UhOugiOyehOydmCDsnbjrjbHsiqQ8L2tvPlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBzcHJpdGVzLnNldEZyYW1lSW5kZXgoMCwgMSk7Ly8gY29sID0gMCwgcm93ID0gMVxuXHQgKi9cblx0c2V0RnJhbWVJbmRleChpbmRleCkge1xuXHRcdGNvbnN0IGNvbFJvdyA9IHRoaXMudG9Db2xSb3coaW5kZXgpO1xuXG5cdFx0dGhpcy5zZXRDb2xSb3coY29sUm93WzBdLCBjb2xSb3dbMV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGZyYW1lSW5kZXggb2YgdGhlIGZyYW1lIHRvIGJlIHNob3duIGluIHRoZSBzcHJpdGUgaW1hZ2UuXG5cdCAqIEBrbyDsiqTtlITrnbzsnbTtirgg7J2066+47KeAIOykkSDrs7Tsl6zsp4DripQg7ZSE66CI7J6E7J2YIGluZGV4IOqwkuydhCDrsJjtmZhcblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlNwcml0ZUltYWdlI2dldEZyYW1lSW5kZXhcblx0ICogQHJldHVybiB7TnVtYmVyfSBmcmFtZSBpbmRleCA8a28+ZnJhbWUg7J24642x7IqkPC9rbz5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogdmFyIGZyYW1lSW5kZXggPSBzcHJpdGVzLmdldEZyYW1lSW5kZXgoKTsgLy8gZWcuIGZyYW1lSW5kZXggPSAxXG5cdCAqXG5cdCAqL1xuXHRnZXRGcmFtZUluZGV4KCkge1xuXHRcdHJldHVybiB0aGlzLl9jb2xSb3dbMV0gKiB0aGlzLl9jb2xDb3VudCArIHRoaXMuX2NvbFJvd1swXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgdGhlIGNvbCBhbmQgcm93IHZhbHVlcyBvZiB0aGUgZnJhbWUgdG8gYmUgc2hvd24gaW4gdGhlIHNwcml0ZSBpbWFnZS5cblx0ICogQGtvIOyKpO2UhOudvOydtO2KuCDsnbTrr7jsp4Ag7KSRIOuztOyXrOyniCDtlITroIjsnoTsnZggY29sLCByb3cg6rCS7J2EIOyngOyglVxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuU3ByaXRlSW1hZ2Ujc2V0Q29sUm93XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2wgQ29sdW1uIG51bWJlciBvZiBhIGZyYW1lPGtvPu2UhOugiOyehOydmCDtlonqsJI8L2tvPlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcm93IFJvdyBudW1iZXIgb2YgYSBmcmFtZTxrbz7tlITroIjsnoTsnZgg7Je06rCSPC9rbz5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogc3ByaXRlcy5zZXRsQ29sUm93KDEsIDIpOyAvLyBjb2wgPSAxLCByb3cgPSAyXG5cdCAqL1xuXHRzZXRDb2xSb3coY29sLCByb3cpIHtcblx0XHRpZiAocm93ID4gdGhpcy5fcm93Q291bnQgLSAxIHx8IGNvbCA+IHRoaXMuX2NvbENvdW50IC0gMSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9iZykge1xuXHRcdFx0dGhpcy5fYmcuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gYCR7LWNvbCAqIDEwMH0lICR7LXJvdyAqIDEwMH0lYDtcblx0XHR9XG5cblx0XHR0aGlzLl9jb2xSb3cgPSBbY29sLCByb3ddO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNvbCBhbmQgcm93IHZhbHVlcyBvZiB0aGUgZnJhbWUgdG8gYmUgc2hvd24gaW4gdGhlIHNwcml0ZSBpbWFnZS5cblx0ICogQGtvIOyKpO2UhOudvOydtO2KuCDsnbTrr7jsp4Ag7KSRIOuztOyXrOyngOuKlCDtlITroIjsnoTsnZggY29sLCByb3cg6rCS7J2E7ZmY67CY7ZmYXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5TcHJpdGVJbWFnZSNnZWxDb2xSb3dcblx0ICogQHJldHVybiB7TnVtYmVyW119IEFycmF5IGNvbnRhaW5pbmcgY29sLCByb3c8a28+Y29sLCByb3cg7KCV67O066W8IOuLtOuKlCDrsLDsl7Q8L2tvPlxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiB2YXIgY29sUm93ID0gc3ByaXRlcy5nZXRsQ29sUm93KCk7XG5cdCAqIC8vIGNvbFJvdyA9IFsxLCAyXSAtIGluZGV4IG9mIGNvbCBpcyAxLCBpbmRleCBvZiByb3cgaXMgMlxuXHQgKlxuXHQgKi9cblx0Z2V0Q29sUm93KCkge1xuXHRcdHJldHVybiB0aGlzLl9jb2xSb3c7XG5cdH1cblxuXHRzdGF0aWMgX2dldFNpemVTdHJpbmcoc2l6ZSkge1xuXHRcdGlmICh0eXBlb2Ygc2l6ZSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0cmV0dXJuIGAke3NpemV9cHhgO1xuXHRcdH1cblxuXHRcdHJldHVybiBzaXplO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0b3AgcGxheWluZ1xuXHQgKiBAa28gcGxheSDrkJjqs6Ag7J6I642YIO2UhOugiOyehCDsnqzsg53snYQg7KSR7KeA7ZWp64uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuU3ByaXRlSW1hZ2Ujc3RvcFxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiB2aWV3ZXIuc3RvcCgpO1xuXHQgKlxuXHQgKi9cblx0c3RvcCgpIHtcblx0XHRpZiAodGhpcy5fYXV0b1BsYXlUaW1lcikge1xuXHRcdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLl9hdXRvUGxheVRpbWVyKTtcblx0XHRcdHRoaXMuX2F1dG9QbGF5VGltZXIgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTd2l0Y2hlcyBmcmFtZXMgc2VxdWVudGlhbGx5IGluIHRoZSAnaW50ZXJ2YWwnIHN0YXJ0aW5nIGZyb20gdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgZnJhbWUgYW5kIHBsYXlzIGFsbCBmcmFtZXMgYnkgJ3BsYXlDb3VudCcuXG5cdCAqIEBrbyDtmITsnqwg67O07Jes7KeA6rOgIOyeiOuKlCDtlITroIjsnoTsnYQg7Iuc7J6R7Jy866GcICdpbnRlcnZhbCcg6rCE6rKp7Jy866GcIOyInOywqOyggeycvOuhnCDtlITroIjsnoTsnYQg7KCE7ZmY7ZWY66mwIOuqqOuToCDtlITroIjsnoTsnYQgJ3BsYXlDb3VudCcg66eM7YG8IOyerOyDne2VnOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlNwcml0ZUltYWdlI3BsYXlcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIFRoZSBwYXJhbWV0ZXIgb2JqZWN0PGtvPu2MjOudvOuvuO2EsCDqsJ3ssrQ8L2tvPlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtLmludGVydmFsPTEwMDAgLyB0b3RhbEZyYW1lQ291bnRdIEludGVyZnJhbWUgSW50ZXJ2YWwgLSBpbiBtaWxsaXNlY29uZHM8a28+7ZSE66CI7J6E6rCEIOqwhOqyqSAtIOuwgOumrOyEuOy7qOuTnCDri6jsnIQ8L2tvPlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3BhcmFtLnBsYXlDb3VudD0wXSBQbGF5Q291bnQgPSAxIGluIHdoaWNoIGFsbCBmcmFtZXMgYXJlIHJlcHJvZHVjZWQgb25jZSwgYW5kIHBsYXlDb3VudCA9IG4gaW4gd2hpY2ggYWxsIGZyYW1lcyBhcmUgcmVwZWF0ZWQgbiB0aW1lcy4gcGxheUNvdW50ID0gMCBpbiB3aGljaCBhbGwgZnJhbWVzIGFyZSByZXBlYXRlZCBpbmZpbml0ZWx5PGtvPuuqqOuToCDtlITroIjsnoTsnYQgMe2ajOyUqSDsnqzsg53tlZwg6rKD7J20IHBsYXlDb3VudCA9IDEsIOuqqOuToCDtlITroIjsnoTsnYQgbiDtmowg7J6s7IOB7ZWcIOqyg+ydtCBwbGF5Q291bnQgPSBuIOydtCDrkJzri6QuIDAgZG1zIOustO2VnOuwmOuztTwva28+XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIHZpZXdlci5wbGF5KHthbmdsZTogMTYsIHBsYXlDb3VudDogMX0pO1xuXHQgKlxuXHQgKi9cblx0cGxheSh7aW50ZXJ2YWwsIHBsYXlDb3VudH0gPSB7aW50ZXJ2YWw6IDEwMDAgLyB0aGlzLl90b3RhbENvdW50LCBwbGF5Q291bnQ6IDB9KSB7XG5cdFx0aWYgKCF0aGlzLl9iZykge1xuXHRcdFx0dGhpcy5fYXV0b1BsYXlSZXNlcnZlZEluZm8gPSB7aW50ZXJ2YWwsIHBsYXlDb3VudH07XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2F1dG9QbGF5VGltZXIpIHtcblx0XHRcdGNsZWFySW50ZXJ2YWwodGhpcy5fYXV0b1BsYXlUaW1lcik7XG5cdFx0XHR0aGlzLl9hdXRvUGxheVRpbWVyID0gbnVsbDtcblx0XHR9XG5cblx0XHRsZXQgZnJhbWVJbmRleCA9IHRoaXMuZ2V0RnJhbWVJbmRleCgpO1xuXHRcdGxldCBjb3VudCA9IDA7XG5cdFx0bGV0IGZyYW1lQ291bnQgPSAwOyAvLyBmb3IgY2hlY2tpbmcgMSBjeWNsZVxuXG5cdFx0dGhpcy5fYXV0b1BsYXlUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcblx0XHRcdGZyYW1lSW5kZXggJT0gdGhpcy5fdG90YWxDb3VudDtcblx0XHRcdGNvbnN0IGNvbFJvdyA9IHRoaXMudG9Db2xSb3coZnJhbWVJbmRleCk7XG5cblx0XHRcdHRoaXMuc2V0Q29sUm93KGNvbFJvd1swXSwgY29sUm93WzFdKTtcblx0XHRcdGZyYW1lSW5kZXgrKztcblxuXHRcdFx0Ly8gRG9uZSAxIEN5Y2xlP1xuXHRcdFx0aWYgKCsrZnJhbWVDb3VudCA9PT0gdGhpcy5fdG90YWxDb3VudCkge1xuXHRcdFx0XHRmcmFtZUNvdW50ID0gMDtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHBsYXlDb3VudCA+IDAgJiYgY291bnQgPT09IHBsYXlDb3VudCkge1xuXHRcdFx0XHRjbGVhckludGVydmFsKHRoaXMuX2F1dG9QbGF5VGltZXIpO1xuXHRcdFx0fVxuXHRcdH0sIGludGVydmFsKTtcblx0fVxuXG5cdHRvQ29sUm93KGZyYW1lSW5kZXgpIHtcblx0XHRjb25zdCBjb2xDb3VudCA9IHRoaXMuX2NvbENvdW50O1xuXHRcdGNvbnN0IHJvd0NvdW50ID0gdGhpcy5fcm93Q291bnQ7XG5cblx0XHRpZiAoZnJhbWVJbmRleCA8IDApIHtcblx0XHRcdHJldHVybiBbMCwgMF07XG5cdFx0fSBlbHNlIGlmIChmcmFtZUluZGV4ID49IHRoaXMuX3RvdGFsQ291bnQpIHtcblx0XHRcdHJldHVybiBbY29sQ291bnQgLSAxLCByb3dDb3VudCAtIDFdO1xuXHRcdH1cblxuXHRcdGNvbnN0IGNvbCA9IGZyYW1lSW5kZXggJSBjb2xDb3VudDtcblx0XHRjb25zdCByb3cgPSBNYXRoLmZsb29yKGZyYW1lSW5kZXggLyBjb2xDb3VudCk7XG5cblx0XHQvLyBjb25zb2xlLmxvZyhmcmFtZUluZGV4LCBjb2wsIHJvdyk7XG5cdFx0cmV0dXJuIFtjb2wsIHJvd107XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9TcGluVmlld2VyL1Nwcml0ZUltYWdlLmpzIiwiaW1wb3J0IHt3aW5kb3csIHNjcmVlbiwgb3JpZW50YXRpb24gYXMgd2luT3JpZW50YXRpb259IGZyb20gXCIuL2Jyb3dzZXJcIjtcbmltcG9ydCB7Z2xNYXRyaXh9IGZyb20gXCIuLi91dGlscy9tYXRoLXV0aWxcIjtcblxuLy8gU2luZ2xldG9uXG5sZXQgc2NyZWVuUm90YXRpb25BbmdsZUluc3QgPSBudWxsO1xubGV0IHJlZkNvdW50ID0gMDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NyZWVuUm90YXRpb25BbmdsZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHJlZkNvdW50Kys7XG5cblx0XHRpZiAoc2NyZWVuUm90YXRpb25BbmdsZUluc3QpIHtcblx0XHRcdHJldHVybiBzY3JlZW5Sb3RhdGlvbkFuZ2xlSW5zdDtcblx0XHR9XG5cdFx0LyogZXNsaW50LWRpc2FibGUgKi9cblx0XHRzY3JlZW5Sb3RhdGlvbkFuZ2xlSW5zdCA9IHRoaXM7XG5cdFx0LyogZXNsaW50LWVuYWJsZSAqL1xuXHRcdHRoaXMuX29uRGV2aWNlT3JpZW50YXRpb24gPSB0aGlzLl9vbkRldmljZU9yaWVudGF0aW9uLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSA9IHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKTtcblxuXHRcdHRoaXMuX3NwaW5SID0gMDtcblxuXHRcdHRoaXMuX3NjcmVlbk9yaWVudGF0aW9uQW5nbGUgPSAwO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZGV2aWNlb3JpZW50YXRpb25cIiwgdGhpcy5fb25EZXZpY2VPcmllbnRhdGlvbik7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKTtcblx0fVxuXG5cdF9vbkRldmljZU9yaWVudGF0aW9uKGUpIHtcblx0XHRpZiAoZS5iZXRhID09PSBudWxsIHx8IGUuZ2FtbWEgPT09IG51bGwpIHtcblx0XHRcdC8vIChDaHJvbWUpIGRldmljZW9yaWVudGF0aW9uIGlzIGZpcmVkIHdpdGggaW52YWxpZCBpbmZvcm1hdGlvbiB7YWxwaGE9bnVsbCwgYmV0YT1udWxsLCAuLi59IGRlc3BpdGUgb2Ygbm90IGRpc3BhdGNoaW5nIGl0LiBXZSBza2lwIGl0LlxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJhZGlhblxuXHRcdGNvbnN0IGJldGFSID0gZ2xNYXRyaXgudG9SYWRpYW4oZS5iZXRhKTtcblx0XHRjb25zdCBnYW1tYVIgPSBnbE1hdHJpeC50b1JhZGlhbihlLmdhbW1hKTtcblxuXHRcdC8qIHNwaW5SIHJhbmdlID0gWy0xODAsIDE4MF0sIGxlZnQgc2lkZTogMCB+IC0xODAoZGVnKSwgcmlnaHQgc2lkZTogMCB+IDE4MChkZWcpICovXG5cdFx0dGhpcy5fc3BpblIgPSBNYXRoLmF0YW4yKE1hdGguY29zKGJldGFSKSAqIE1hdGguc2luKGdhbW1hUiksIE1hdGguc2luKGJldGFSKSk7XG5cdH1cblxuXHRfb25PcmllbnRhdGlvbkNoYW5nZShlKSB7XG5cdFx0aWYgKHNjcmVlbiAmJiBzY3JlZW4ub3JpZW50YXRpb24gJiYgc2NyZWVuLm9yaWVudGF0aW9uLmFuZ2xlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX3NjcmVlbk9yaWVudGF0aW9uQW5nbGUgPSBzY3JlZW4ub3JpZW50YXRpb24uYW5nbGU7XG5cdFx0fSBlbHNlIGlmICh3aW5PcmllbnRhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLl9zY3JlZW5PcmllbnRhdGlvbkFuZ2xlID0gd2luT3JpZW50YXRpb24gPj0gMCA/IHdpbk9yaWVudGF0aW9uIDogMzYwICsgd2luT3JpZW50YXRpb247XG5cdFx0fVxuXHR9XG5cblx0Z2V0UmFkaWFuKCkge1xuXHRcdC8vIEpvaW4gd2l0aCBzY3JlZW4gb3JpZW50YXRpb25cblx0XHQvLyB0aGlzLl90ZXN0VmFsID0gdGhpcy5fc3BpblIgKyBcIiwgXCIgKyB0aGlzLl9zY3JlZW5PcmllbnRhdGlvbkFuZ2xlICsgXCIsIFwiICsgd2luZG93Lm9yaWVudGF0aW9uO1xuXHRcdHJldHVybiB0aGlzLl9zcGluUiArIGdsTWF0cml4LnRvUmFkaWFuKHRoaXMuX3NjcmVlbk9yaWVudGF0aW9uQW5nbGUpO1xuXHR9XG5cblx0dW5yZWYoKSB7XG5cdFx0aWYgKC0tcmVmQ291bnQgPiAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkZXZpY2VvcmllbnRhdGlvblwiLCB0aGlzLl9vbkRldmljZU9yaWVudGF0aW9uKTtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpO1xuXG5cdFx0dGhpcy5fc3BpblIgPSAwO1xuXHRcdHRoaXMuX3NjcmVlbk9yaWVudGF0aW9uQW5nbGUgPSAwO1xuXHRcdC8qIGVzbGludC1kaXNhYmxlICovXG5cdFx0c2NyZWVuUm90YXRpb25BbmdsZUluc3QgPSBudWxsO1xuXHRcdC8qIGVzbGludC1lbmFibGUgKi9cblx0XHRyZWZDb3VudCA9IDA7XG5cdH1cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1lhd1BpdGNoQ29udHJvbC9TY3JlZW5Sb3RhdGlvbkFuZ2xlLmpzIiwiaW1wb3J0IFlhd1BpdGNoQ29udHJvbCBmcm9tIFwiLi9ZYXdQaXRjaENvbnRyb2xcIjtcbmltcG9ydCB7XG5cdENPTlRST0xfTU9ERV9WUixcblx0Q09OVFJPTF9NT0RFX1lBV1BJVENILFxuXHRUT1VDSF9ESVJFQ1RJT05fQUxMLFxuXHRUT1VDSF9ESVJFQ1RJT05fWUFXLFxuXHRUT1VDSF9ESVJFQ1RJT05fUElUQ0gsXG5cdFRPVUNIX0RJUkVDVElPTl9OT05FLFxufSBmcm9tIFwiLi9jb25zdHNcIjtcblxuLy8gRXhwb3NlIERldmljZU9yaWVudGF0aW9uQ29udHJvbHMgc3ViIG1vZHVsZSBmb3IgdGVzdCBwdXJwb3NlXG5ZYXdQaXRjaENvbnRyb2wuQ09OVFJPTF9NT0RFX1ZSID0gQ09OVFJPTF9NT0RFX1ZSO1xuWWF3UGl0Y2hDb250cm9sLkNPTlRST0xfTU9ERV9ZQVdQSVRDSCA9IENPTlRST0xfTU9ERV9ZQVdQSVRDSDtcbllhd1BpdGNoQ29udHJvbC5UT1VDSF9ESVJFQ1RJT05fQUxMID0gVE9VQ0hfRElSRUNUSU9OX0FMTDtcbllhd1BpdGNoQ29udHJvbC5UT1VDSF9ESVJFQ1RJT05fWUFXID0gVE9VQ0hfRElSRUNUSU9OX1lBVztcbllhd1BpdGNoQ29udHJvbC5UT1VDSF9ESVJFQ1RJT05fUElUQ0ggPSBUT1VDSF9ESVJFQ1RJT05fUElUQ0g7XG5ZYXdQaXRjaENvbnRyb2wuVE9VQ0hfRElSRUNUSU9OX05PTkUgPSBUT1VDSF9ESVJFQ1RJT05fTk9ORTtcblxuLy8gbW9kdWxlLmV4cG9ydHMgPSBZYXdQaXRjaDtcbmV4cG9ydCB7XG5cdFlhd1BpdGNoQ29udHJvbFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9ZYXdQaXRjaENvbnRyb2wvaW5kZXguanMiLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbmltcG9ydCBQb3NlUHJlZGljdG9yIGZyb20gXCJ3ZWJ2ci1wb2x5ZmlsbC9zcmMvc2Vuc29yLWZ1c2lvbi9wb3NlLXByZWRpY3RvclwiO1xuaW1wb3J0IE1hdGhVdGlsIGZyb20gXCJ3ZWJ2ci1wb2x5ZmlsbC9zcmMvbWF0aC11dGlsXCI7XG5pbXBvcnQgVXRpbCBmcm9tIFwid2VidnItcG9seWZpbGwvc3JjL3V0aWxcIjtcbmltcG9ydCB7d2luZG93fSBmcm9tIFwiLi4vYnJvd3NlclwiO1xuaW1wb3J0IHtxdWF0fSBmcm9tIFwiLi4vLi4vdXRpbHMvbWF0aC11dGlsXCI7XG5pbXBvcnQgRGV2aWNlTW90aW9uIGZyb20gXCIuL0RldmljZU1vdGlvblwiO1xuaW1wb3J0IENvbXBsZW1lbnRhcnlGaWx0ZXIgZnJvbSBcIi4vQ29tcGxlbWVudGFyeUZpbHRlclwiO1xuXG5jb25zdCBLX0ZJTFRFUiA9IDAuOTg7XG5jb25zdCBQUkVESUNUSU9OX1RJTUVfUyA9IDAuMDQwO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGdXNpb25Qb3NlU2Vuc29yIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuZGV2aWNlTW90aW9uID0gbmV3IERldmljZU1vdGlvbigpO1xuXG5cdFx0dGhpcy5hY2NlbGVyb21ldGVyID0gbmV3IE1hdGhVdGlsLlZlY3RvcjMoKTtcblx0XHR0aGlzLmd5cm9zY29wZSA9IG5ldyBNYXRoVXRpbC5WZWN0b3IzKCk7XG5cblx0XHR0aGlzLl9vbkRldmljZU1vdGlvbkNoYW5nZSA9IHRoaXMuX29uRGV2aWNlTW90aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5fb25TY3JlZW5PcmllbnRhdGlvbkNoYW5nZSA9IHRoaXMuX29uU2NyZWVuT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKTtcblxuXHRcdHRoaXMuZmlsdGVyID0gbmV3IENvbXBsZW1lbnRhcnlGaWx0ZXIoS19GSUxURVIpO1xuXHRcdHRoaXMucG9zZVByZWRpY3RvciA9IG5ldyBQb3NlUHJlZGljdG9yKFBSRURJQ1RJT05fVElNRV9TKTtcblxuXHRcdHRoaXMuZmlsdGVyVG9Xb3JsZFEgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuXG5cdFx0dGhpcy5pc0ZpcmVmb3hBbmRyb2lkID0gVXRpbC5pc0ZpcmVmb3hBbmRyb2lkKCk7XG5cdFx0dGhpcy5pc0lPUyA9IFV0aWwuaXNJT1MoKTtcblx0XHR0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcblxuXHRcdC8vIFNldCB0aGUgZmlsdGVyIHRvIHdvcmxkIHRyYW5zZm9ybSwgZGVwZW5kaW5nIG9uIE9TLlxuXHRcdGlmICh0aGlzLmlzSU9TKSB7XG5cdFx0XHR0aGlzLmZpbHRlclRvV29ybGRRLnNldEZyb21BeGlzQW5nbGUobmV3IE1hdGhVdGlsLlZlY3RvcjMoMSwgMCwgMCksIE1hdGguUEkgLyAyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5maWx0ZXJUb1dvcmxkUS5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBNYXRoVXRpbC5WZWN0b3IzKDEsIDAsIDApLCAtTWF0aC5QSSAvIDIpO1xuXHRcdH1cblxuXHRcdHRoaXMuaW52ZXJzZVdvcmxkVG9TY3JlZW5RID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcblx0XHR0aGlzLndvcmxkVG9TY3JlZW5RID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcblx0XHR0aGlzLm9yaWdpbmFsUG9zZUFkanVzdFEgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuXHRcdHRoaXMub3JpZ2luYWxQb3NlQWRqdXN0US5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBNYXRoVXRpbC5WZWN0b3IzKDAsIDAsIDEpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LXdpbmRvdy5vcmllbnRhdGlvbiAqIE1hdGguUEkgLyAxODApO1xuXG5cdFx0dGhpcy5fc2V0U2NyZWVuVHJhbnNmb3JtKCk7XG5cdFx0Ly8gQWRqdXN0IHRoaXMgZmlsdGVyIGZvciBiZWluZyBpbiBsYW5kc2NhcGUgbW9kZS5cblx0XHRpZiAoVXRpbC5pc0xhbmRzY2FwZU1vZGUoKSkge1xuXHRcdFx0dGhpcy5maWx0ZXJUb1dvcmxkUS5tdWx0aXBseSh0aGlzLmludmVyc2VXb3JsZFRvU2NyZWVuUSk7XG5cdFx0fVxuXG5cdFx0Ly8gS2VlcCB0cmFjayBvZiBhIHJlc2V0IHRyYW5zZm9ybSBmb3IgcmVzZXRTZW5zb3IuXG5cdFx0dGhpcy5yZXNldFEgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuXG5cdFx0dGhpcy5kZXZpY2VNb3Rpb24ub24oXCJkZXZpY2Vtb3Rpb25cIiwgdGhpcy5fb25EZXZpY2VNb3Rpb25DaGFuZ2UpO1xuXHRcdHRoaXMuZW5hYmxlKCk7XG5cdH1cblx0ZW5hYmxlKCkge1xuXHRcdGlmICh0aGlzLmlzRW5hYmxlZCgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuZGV2aWNlTW90aW9uLmVuYWJsZSgpO1xuXHRcdHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCB0aGlzLl9vblNjcmVlbk9yaWVudGF0aW9uQ2hhbmdlKTtcblx0fVxuXHRkaXNhYmxlKCkge1xuXHRcdGlmICghdGhpcy5pc0VuYWJsZWQoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLmRldmljZU1vdGlvbi5kaXNhYmxlKCk7XG5cdFx0dGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCB0aGlzLl9vblNjcmVlbk9yaWVudGF0aW9uQ2hhbmdlKTtcblx0fVxuXHRpc0VuYWJsZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lzRW5hYmxlZDtcblx0fVxuXHRkZXN0cm95KCkge1xuXHRcdHRoaXMuZGlzYWJsZSgpO1xuXHRcdHRoaXMuZGV2aWNlTW90aW9uID0gbnVsbDtcblx0fVxuXHRfdHJpZ2dlckNoYW5nZSgpIHtcblx0XHRjb25zdCBvcmllbnRhdGlvbiA9IHRoaXMuZ2V0T3JpZW50YXRpb24oKTtcblxuXHRcdC8vIGlmIG9yaWVudGF0aW9uIGlzIG5vdCBwcmVwYXJlZC4gZG9uJ3QgdHJpZ2dlciBjaGFuZ2UgZXZlbnRcblx0XHRpZiAoIW9yaWVudGF0aW9uKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9wcmV2T3JpZW50YXRpb24pIHtcblx0XHRcdHRoaXMuX3ByZXZPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChxdWF0LmVxdWFscyh0aGlzLl9wcmV2T3JpZW50YXRpb24sIG9yaWVudGF0aW9uKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMudHJpZ2dlcihcImNoYW5nZVwiLCB7cXVhdGVybmlvbjogb3JpZW50YXRpb259KTtcblx0fVxuXHRnZXRPcmllbnRhdGlvbigpIHtcblx0XHQvLyBDb252ZXJ0IGZyb20gZmlsdGVyIHNwYWNlIHRvIHRoZSB0aGUgc2FtZSBzeXN0ZW0gdXNlZCBieSB0aGVcblx0XHQvLyBkZXZpY2VvcmllbnRhdGlvbiBldmVudC5cblx0XHRjb25zdCBvcmllbnRhdGlvbiA9IHRoaXMuZmlsdGVyLmdldE9yaWVudGF0aW9uKCk7XG5cblx0XHRpZiAoIW9yaWVudGF0aW9uKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBQcmVkaWN0IG9yaWVudGF0aW9uLlxuXHRcdGxldCBvdXQgPSB0aGlzLl9jb252ZXJ0RnVzaW9uVG9QcmVkaWN0ZWQob3JpZW50YXRpb24pO1xuXG5cdFx0Ly8gcmV0dXJuIHF1YXRlcm5pb24gYXMgZ2xtYXRyaXggcXVhdGVybmlvbiBvYmplY3Rcblx0XHRvdXQgPSBxdWF0LmZyb21WYWx1ZXMoXG5cdFx0XHRvdXQueCxcblx0XHRcdG91dC55LFxuXHRcdFx0b3V0LnosXG5cdFx0XHRvdXQud1xuXHRcdCk7XG5cblx0XHRyZXR1cm4gcXVhdC5ub3JtYWxpemUob3V0LCBvdXQpO1xuXHR9XG5cdF9jb252ZXJ0RnVzaW9uVG9QcmVkaWN0ZWQob3JpZW50YXRpb24pIHtcblx0XHQvLyBQcmVkaWN0IG9yaWVudGF0aW9uLlxuXHRcdHRoaXMucHJlZGljdGVkUSA9XG5cdFx0XHR0aGlzLnBvc2VQcmVkaWN0b3IuZ2V0UHJlZGljdGlvbihvcmllbnRhdGlvbiwgdGhpcy5neXJvc2NvcGUsIHRoaXMucHJldmlvdXNUaW1lc3RhbXBTKTtcblxuXHRcdC8vIENvbnZlcnQgdG8gVEhSRUUgY29vcmRpbmF0ZSBzeXN0ZW06IC1aIGZvcndhcmQsIFkgdXAsIFggcmlnaHQuXG5cdFx0Y29uc3Qgb3V0ID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcblxuXHRcdG91dC5jb3B5KHRoaXMuZmlsdGVyVG9Xb3JsZFEpO1xuXHRcdG91dC5tdWx0aXBseSh0aGlzLnJlc2V0USk7XG5cdFx0b3V0Lm11bHRpcGx5KHRoaXMucHJlZGljdGVkUSk7XG5cdFx0b3V0Lm11bHRpcGx5KHRoaXMud29ybGRUb1NjcmVlblEpO1xuXG5cdFx0cmV0dXJuIG91dDtcblx0fVxuXHRfb25EZXZpY2VNb3Rpb25DaGFuZ2Uoe2lucHV0RXZlbnR9KSB7XG5cdFx0Y29uc3QgZGV2aWNlTW90aW9uID0gaW5wdXRFdmVudDtcblx0XHRjb25zdCBhY2NHcmF2aXR5ID0gZGV2aWNlTW90aW9uLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHk7XG5cdFx0Y29uc3Qgcm90UmF0ZSA9IGRldmljZU1vdGlvbi5hZGp1c3RlZFJvdGF0aW9uUmF0ZSB8fCBkZXZpY2VNb3Rpb24ucm90YXRpb25SYXRlO1xuXHRcdGxldCB0aW1lc3RhbXBTID0gZGV2aWNlTW90aW9uLnRpbWVTdGFtcCAvIDEwMDA7XG5cblx0XHQvLyBGaXJlZm94IEFuZHJvaWQgdGltZVN0YW1wIHJldHVybnMgb25lIHRob3VzYW5kdGggb2YgYSBtaWxsaXNlY29uZC5cblx0XHRpZiAodGhpcy5pc0ZpcmVmb3hBbmRyb2lkKSB7XG5cdFx0XHR0aW1lc3RhbXBTIC89IDEwMDA7XG5cdFx0fVxuXG5cdFx0dGhpcy5hY2NlbGVyb21ldGVyLnNldCgtYWNjR3Jhdml0eS54LCAtYWNjR3Jhdml0eS55LCAtYWNjR3Jhdml0eS56KTtcblx0XHR0aGlzLmd5cm9zY29wZS5zZXQocm90UmF0ZS5hbHBoYSwgcm90UmF0ZS5iZXRhLCByb3RSYXRlLmdhbW1hKTtcblxuXHRcdC8vIFdpdGggaU9TIGFuZCBGaXJlZm94IEFuZHJvaWQsIHJvdGF0aW9uUmF0ZSBpcyByZXBvcnRlZCBpbiBkZWdyZWVzLFxuXHRcdC8vIHNvIHdlIGZpcnN0IGNvbnZlcnQgdG8gcmFkaWFucy5cblx0XHRpZiAodGhpcy5pc0lPUyB8fCB0aGlzLmlzRmlyZWZveEFuZHJvaWQpIHtcblx0XHRcdHRoaXMuZ3lyb3Njb3BlLm11bHRpcGx5U2NhbGFyKE1hdGguUEkgLyAxODApO1xuXHRcdH1cblxuXHRcdHRoaXMuZmlsdGVyLmFkZEFjY2VsTWVhc3VyZW1lbnQodGhpcy5hY2NlbGVyb21ldGVyLCB0aW1lc3RhbXBTKTtcblx0XHR0aGlzLmZpbHRlci5hZGRHeXJvTWVhc3VyZW1lbnQodGhpcy5neXJvc2NvcGUsIHRpbWVzdGFtcFMpO1xuXG5cdFx0dGhpcy5fdHJpZ2dlckNoYW5nZSgpO1xuXG5cdFx0dGhpcy5wcmV2aW91c1RpbWVzdGFtcFMgPSB0aW1lc3RhbXBTO1xuXHR9XG5cdF9vblNjcmVlbk9yaWVudGF0aW9uQ2hhbmdlKHNjcmVlbk9yaWVudGF0aW9uKSB7XG5cdFx0dGhpcy5fc2V0U2NyZWVuVHJhbnNmb3JtKHdpbmRvdy5vcmllbnRhdGlvbik7XG5cdH1cblx0X3NldFNjcmVlblRyYW5zZm9ybSgpIHtcblx0XHR0aGlzLndvcmxkVG9TY3JlZW5RLnNldCgwLCAwLCAwLCAxKTtcblx0XHRzd2l0Y2ggKHdpbmRvdy5vcmllbnRhdGlvbikge1xuXHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgOTA6XG5cdFx0XHRcdHRoaXMud29ybGRUb1NjcmVlblEuc2V0RnJvbUF4aXNBbmdsZShuZXcgTWF0aFV0aWwuVmVjdG9yMygwLCAwLCAxKSwgOTAgLyAtMTgwICogTWF0aC5QSSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAtOTA6XG5cdFx0XHRcdHRoaXMud29ybGRUb1NjcmVlblEuc2V0RnJvbUF4aXNBbmdsZShuZXcgTWF0aFV0aWwuVmVjdG9yMygwLCAwLCAxKSwgLTkwIC8gLTE4MCAqIE1hdGguUEkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMTgwOlxuXHRcdFx0XHR0aGlzLndvcmxkVG9TY3JlZW5RLnNldEZyb21BeGlzQW5nbGUobmV3IE1hdGhVdGlsLlZlY3RvcjMoMCwgMCwgMSksIDE4MCAvIC0xODAgKiBNYXRoLlBJKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0dGhpcy5pbnZlcnNlV29ybGRUb1NjcmVlblEuY29weSh0aGlzLndvcmxkVG9TY3JlZW5RKTtcblx0XHR0aGlzLmludmVyc2VXb3JsZFRvU2NyZWVuUS5pbnZlcnNlKCk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9ZYXdQaXRjaENvbnRyb2wvaW5wdXQvRnVzaW9uUG9zZVNlbnNvci5qcyIsImNvbnN0IHV0aWwgPSB7fTtcblxuZnVuY3Rpb24gdG9BeGlzKHNvdXJjZSwgb2Zmc2V0KSB7XG5cdHJldHVybiBvZmZzZXQucmVkdWNlKChhY2MsIHYsIGkpID0+IHtcblx0XHRpZiAoc291cmNlW2ldKSB7XG5cdFx0XHRhY2Nbc291cmNlW2ldXSA9IHY7XG5cdFx0fVxuXHRcdHJldHVybiBhY2M7XG5cdH0sIHt9KTtcbn1cblxudXRpbC50b0F4aXMgPSB0b0F4aXM7XG5cbmV4cG9ydCBkZWZhdWx0IHV0aWw7XG5leHBvcnQge3RvQXhpc307XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvWWF3UGl0Y2hDb250cm9sL3V0aWxzLmpzIiwidmFyIEVOVElUSUVTID0gW1snQWFjdXRlJywgWzE5M11dLCBbJ2FhY3V0ZScsIFsyMjVdXSwgWydBYnJldmUnLCBbMjU4XV0sIFsnYWJyZXZlJywgWzI1OV1dLCBbJ2FjJywgWzg3NjZdXSwgWydhY2QnLCBbODc2N11dLCBbJ2FjRScsIFs4NzY2LCA4MTldXSwgWydBY2lyYycsIFsxOTRdXSwgWydhY2lyYycsIFsyMjZdXSwgWydhY3V0ZScsIFsxODBdXSwgWydBY3knLCBbMTA0MF1dLCBbJ2FjeScsIFsxMDcyXV0sIFsnQUVsaWcnLCBbMTk4XV0sIFsnYWVsaWcnLCBbMjMwXV0sIFsnYWYnLCBbODI4OV1dLCBbJ0FmcicsIFsxMjAwNjhdXSwgWydhZnInLCBbMTIwMDk0XV0sIFsnQWdyYXZlJywgWzE5Ml1dLCBbJ2FncmF2ZScsIFsyMjRdXSwgWydhbGVmc3ltJywgWzg1MDFdXSwgWydhbGVwaCcsIFs4NTAxXV0sIFsnQWxwaGEnLCBbOTEzXV0sIFsnYWxwaGEnLCBbOTQ1XV0sIFsnQW1hY3InLCBbMjU2XV0sIFsnYW1hY3InLCBbMjU3XV0sIFsnYW1hbGcnLCBbMTA4MTVdXSwgWydhbXAnLCBbMzhdXSwgWydBTVAnLCBbMzhdXSwgWydhbmRhbmQnLCBbMTA4MzddXSwgWydBbmQnLCBbMTA4MzVdXSwgWydhbmQnLCBbODc0M11dLCBbJ2FuZGQnLCBbMTA4NDRdXSwgWydhbmRzbG9wZScsIFsxMDg0MF1dLCBbJ2FuZHYnLCBbMTA4NDJdXSwgWydhbmcnLCBbODczNl1dLCBbJ2FuZ2UnLCBbMTA2NjBdXSwgWydhbmdsZScsIFs4NzM2XV0sIFsnYW5nbXNkYWEnLCBbMTA2NjRdXSwgWydhbmdtc2RhYicsIFsxMDY2NV1dLCBbJ2FuZ21zZGFjJywgWzEwNjY2XV0sIFsnYW5nbXNkYWQnLCBbMTA2NjddXSwgWydhbmdtc2RhZScsIFsxMDY2OF1dLCBbJ2FuZ21zZGFmJywgWzEwNjY5XV0sIFsnYW5nbXNkYWcnLCBbMTA2NzBdXSwgWydhbmdtc2RhaCcsIFsxMDY3MV1dLCBbJ2FuZ21zZCcsIFs4NzM3XV0sIFsnYW5ncnQnLCBbODczNV1dLCBbJ2FuZ3J0dmInLCBbODg5NF1dLCBbJ2FuZ3J0dmJkJywgWzEwNjUzXV0sIFsnYW5nc3BoJywgWzg3MzhdXSwgWydhbmdzdCcsIFsxOTddXSwgWydhbmd6YXJyJywgWzkwODRdXSwgWydBb2dvbicsIFsyNjBdXSwgWydhb2dvbicsIFsyNjFdXSwgWydBb3BmJywgWzEyMDEyMF1dLCBbJ2FvcGYnLCBbMTIwMTQ2XV0sIFsnYXBhY2lyJywgWzEwODYzXV0sIFsnYXAnLCBbODc3Nl1dLCBbJ2FwRScsIFsxMDg2NF1dLCBbJ2FwZScsIFs4Nzc4XV0sIFsnYXBpZCcsIFs4Nzc5XV0sIFsnYXBvcycsIFszOV1dLCBbJ0FwcGx5RnVuY3Rpb24nLCBbODI4OV1dLCBbJ2FwcHJveCcsIFs4Nzc2XV0sIFsnYXBwcm94ZXEnLCBbODc3OF1dLCBbJ0FyaW5nJywgWzE5N11dLCBbJ2FyaW5nJywgWzIyOV1dLCBbJ0FzY3InLCBbMTE5OTY0XV0sIFsnYXNjcicsIFsxMTk5OTBdXSwgWydBc3NpZ24nLCBbODc4OF1dLCBbJ2FzdCcsIFs0Ml1dLCBbJ2FzeW1wJywgWzg3NzZdXSwgWydhc3ltcGVxJywgWzg3ODFdXSwgWydBdGlsZGUnLCBbMTk1XV0sIFsnYXRpbGRlJywgWzIyN11dLCBbJ0F1bWwnLCBbMTk2XV0sIFsnYXVtbCcsIFsyMjhdXSwgWydhd2NvbmludCcsIFs4NzU1XV0sIFsnYXdpbnQnLCBbMTA3NjldXSwgWydiYWNrY29uZycsIFs4NzgwXV0sIFsnYmFja2Vwc2lsb24nLCBbMTAxNF1dLCBbJ2JhY2twcmltZScsIFs4MjQ1XV0sIFsnYmFja3NpbScsIFs4NzY1XV0sIFsnYmFja3NpbWVxJywgWzg5MDldXSwgWydCYWNrc2xhc2gnLCBbODcyNl1dLCBbJ0JhcnYnLCBbMTA5ODNdXSwgWydiYXJ2ZWUnLCBbODg5M11dLCBbJ2JhcndlZCcsIFs4OTY1XV0sIFsnQmFyd2VkJywgWzg5NjZdXSwgWydiYXJ3ZWRnZScsIFs4OTY1XV0sIFsnYmJyaycsIFs5MTQxXV0sIFsnYmJya3RicmsnLCBbOTE0Ml1dLCBbJ2Jjb25nJywgWzg3ODBdXSwgWydCY3knLCBbMTA0MV1dLCBbJ2JjeScsIFsxMDczXV0sIFsnYmRxdW8nLCBbODIyMl1dLCBbJ2JlY2F1cycsIFs4NzU3XV0sIFsnYmVjYXVzZScsIFs4NzU3XV0sIFsnQmVjYXVzZScsIFs4NzU3XV0sIFsnYmVtcHR5dicsIFsxMDY3Ml1dLCBbJ2JlcHNpJywgWzEwMTRdXSwgWydiZXJub3UnLCBbODQ5Ml1dLCBbJ0Jlcm5vdWxsaXMnLCBbODQ5Ml1dLCBbJ0JldGEnLCBbOTE0XV0sIFsnYmV0YScsIFs5NDZdXSwgWydiZXRoJywgWzg1MDJdXSwgWydiZXR3ZWVuJywgWzg4MTJdXSwgWydCZnInLCBbMTIwMDY5XV0sIFsnYmZyJywgWzEyMDA5NV1dLCBbJ2JpZ2NhcCcsIFs4ODk4XV0sIFsnYmlnY2lyYycsIFs5NzExXV0sIFsnYmlnY3VwJywgWzg4OTldXSwgWydiaWdvZG90JywgWzEwNzUyXV0sIFsnYmlnb3BsdXMnLCBbMTA3NTNdXSwgWydiaWdvdGltZXMnLCBbMTA3NTRdXSwgWydiaWdzcWN1cCcsIFsxMDc1OF1dLCBbJ2JpZ3N0YXInLCBbOTczM11dLCBbJ2JpZ3RyaWFuZ2xlZG93bicsIFs5NjYxXV0sIFsnYmlndHJpYW5nbGV1cCcsIFs5NjUxXV0sIFsnYmlndXBsdXMnLCBbMTA3NTZdXSwgWydiaWd2ZWUnLCBbODg5N11dLCBbJ2JpZ3dlZGdlJywgWzg4OTZdXSwgWydia2Fyb3cnLCBbMTA1MDldXSwgWydibGFja2xvemVuZ2UnLCBbMTA3MzFdXSwgWydibGFja3NxdWFyZScsIFs5NjQyXV0sIFsnYmxhY2t0cmlhbmdsZScsIFs5NjUyXV0sIFsnYmxhY2t0cmlhbmdsZWRvd24nLCBbOTY2Ml1dLCBbJ2JsYWNrdHJpYW5nbGVsZWZ0JywgWzk2NjZdXSwgWydibGFja3RyaWFuZ2xlcmlnaHQnLCBbOTY1Nl1dLCBbJ2JsYW5rJywgWzkyNTFdXSwgWydibGsxMicsIFs5NjE4XV0sIFsnYmxrMTQnLCBbOTYxN11dLCBbJ2JsazM0JywgWzk2MTldXSwgWydibG9jaycsIFs5NjA4XV0sIFsnYm5lJywgWzYxLCA4NDIxXV0sIFsnYm5lcXVpdicsIFs4ODAxLCA4NDIxXV0sIFsnYk5vdCcsIFsxMDk4OV1dLCBbJ2Jub3QnLCBbODk3Nl1dLCBbJ0JvcGYnLCBbMTIwMTIxXV0sIFsnYm9wZicsIFsxMjAxNDddXSwgWydib3QnLCBbODg2OV1dLCBbJ2JvdHRvbScsIFs4ODY5XV0sIFsnYm93dGllJywgWzg5MDRdXSwgWydib3hib3gnLCBbMTA2OTddXSwgWydib3hkbCcsIFs5NDg4XV0sIFsnYm94ZEwnLCBbOTU1N11dLCBbJ2JveERsJywgWzk1NThdXSwgWydib3hETCcsIFs5NTU5XV0sIFsnYm94ZHInLCBbOTQ4NF1dLCBbJ2JveGRSJywgWzk1NTRdXSwgWydib3hEcicsIFs5NTU1XV0sIFsnYm94RFInLCBbOTU1Nl1dLCBbJ2JveGgnLCBbOTQ3Ml1dLCBbJ2JveEgnLCBbOTU1Ml1dLCBbJ2JveGhkJywgWzk1MTZdXSwgWydib3hIZCcsIFs5NTcyXV0sIFsnYm94aEQnLCBbOTU3M11dLCBbJ2JveEhEJywgWzk1NzRdXSwgWydib3hodScsIFs5NTI0XV0sIFsnYm94SHUnLCBbOTU3NV1dLCBbJ2JveGhVJywgWzk1NzZdXSwgWydib3hIVScsIFs5NTc3XV0sIFsnYm94bWludXMnLCBbODg2M11dLCBbJ2JveHBsdXMnLCBbODg2Ml1dLCBbJ2JveHRpbWVzJywgWzg4NjRdXSwgWydib3h1bCcsIFs5NDk2XV0sIFsnYm94dUwnLCBbOTU2M11dLCBbJ2JveFVsJywgWzk1NjRdXSwgWydib3hVTCcsIFs5NTY1XV0sIFsnYm94dXInLCBbOTQ5Ml1dLCBbJ2JveHVSJywgWzk1NjBdXSwgWydib3hVcicsIFs5NTYxXV0sIFsnYm94VVInLCBbOTU2Ml1dLCBbJ2JveHYnLCBbOTQ3NF1dLCBbJ2JveFYnLCBbOTU1M11dLCBbJ2JveHZoJywgWzk1MzJdXSwgWydib3h2SCcsIFs5NTc4XV0sIFsnYm94VmgnLCBbOTU3OV1dLCBbJ2JveFZIJywgWzk1ODBdXSwgWydib3h2bCcsIFs5NTA4XV0sIFsnYm94dkwnLCBbOTU2OV1dLCBbJ2JveFZsJywgWzk1NzBdXSwgWydib3hWTCcsIFs5NTcxXV0sIFsnYm94dnInLCBbOTUwMF1dLCBbJ2JveHZSJywgWzk1NjZdXSwgWydib3hWcicsIFs5NTY3XV0sIFsnYm94VlInLCBbOTU2OF1dLCBbJ2JwcmltZScsIFs4MjQ1XV0sIFsnYnJldmUnLCBbNzI4XV0sIFsnQnJldmUnLCBbNzI4XV0sIFsnYnJ2YmFyJywgWzE2Nl1dLCBbJ2JzY3InLCBbMTE5OTkxXV0sIFsnQnNjcicsIFs4NDkyXV0sIFsnYnNlbWknLCBbODI3MV1dLCBbJ2JzaW0nLCBbODc2NV1dLCBbJ2JzaW1lJywgWzg5MDldXSwgWydic29sYicsIFsxMDY5M11dLCBbJ2Jzb2wnLCBbOTJdXSwgWydic29saHN1YicsIFsxMDE4NF1dLCBbJ2J1bGwnLCBbODIyNl1dLCBbJ2J1bGxldCcsIFs4MjI2XV0sIFsnYnVtcCcsIFs4NzgyXV0sIFsnYnVtcEUnLCBbMTA5MjZdXSwgWydidW1wZScsIFs4NzgzXV0sIFsnQnVtcGVxJywgWzg3ODJdXSwgWydidW1wZXEnLCBbODc4M11dLCBbJ0NhY3V0ZScsIFsyNjJdXSwgWydjYWN1dGUnLCBbMjYzXV0sIFsnY2FwYW5kJywgWzEwODIwXV0sIFsnY2FwYnJjdXAnLCBbMTA4MjVdXSwgWydjYXBjYXAnLCBbMTA4MjddXSwgWydjYXAnLCBbODc0NV1dLCBbJ0NhcCcsIFs4OTE0XV0sIFsnY2FwY3VwJywgWzEwODIzXV0sIFsnY2FwZG90JywgWzEwODE2XV0sIFsnQ2FwaXRhbERpZmZlcmVudGlhbEQnLCBbODUxN11dLCBbJ2NhcHMnLCBbODc0NSwgNjUwMjRdXSwgWydjYXJldCcsIFs4MjU3XV0sIFsnY2Fyb24nLCBbNzExXV0sIFsnQ2F5bGV5cycsIFs4NDkzXV0sIFsnY2NhcHMnLCBbMTA4MjldXSwgWydDY2Fyb24nLCBbMjY4XV0sIFsnY2Nhcm9uJywgWzI2OV1dLCBbJ0NjZWRpbCcsIFsxOTldXSwgWydjY2VkaWwnLCBbMjMxXV0sIFsnQ2NpcmMnLCBbMjY0XV0sIFsnY2NpcmMnLCBbMjY1XV0sIFsnQ2NvbmludCcsIFs4NzUyXV0sIFsnY2N1cHMnLCBbMTA4MjhdXSwgWydjY3Vwc3NtJywgWzEwODMyXV0sIFsnQ2RvdCcsIFsyNjZdXSwgWydjZG90JywgWzI2N11dLCBbJ2NlZGlsJywgWzE4NF1dLCBbJ0NlZGlsbGEnLCBbMTg0XV0sIFsnY2VtcHR5dicsIFsxMDY3NF1dLCBbJ2NlbnQnLCBbMTYyXV0sIFsnY2VudGVyZG90JywgWzE4M11dLCBbJ0NlbnRlckRvdCcsIFsxODNdXSwgWydjZnInLCBbMTIwMDk2XV0sIFsnQ2ZyJywgWzg0OTNdXSwgWydDSGN5JywgWzEwNjNdXSwgWydjaGN5JywgWzEwOTVdXSwgWydjaGVjaycsIFsxMDAwM11dLCBbJ2NoZWNrbWFyaycsIFsxMDAwM11dLCBbJ0NoaScsIFs5MzVdXSwgWydjaGknLCBbOTY3XV0sIFsnY2lyYycsIFs3MTBdXSwgWydjaXJjZXEnLCBbODc5MV1dLCBbJ2NpcmNsZWFycm93bGVmdCcsIFs4NjM0XV0sIFsnY2lyY2xlYXJyb3dyaWdodCcsIFs4NjM1XV0sIFsnY2lyY2xlZGFzdCcsIFs4ODU5XV0sIFsnY2lyY2xlZGNpcmMnLCBbODg1OF1dLCBbJ2NpcmNsZWRkYXNoJywgWzg4NjFdXSwgWydDaXJjbGVEb3QnLCBbODg1N11dLCBbJ2NpcmNsZWRSJywgWzE3NF1dLCBbJ2NpcmNsZWRTJywgWzk0MTZdXSwgWydDaXJjbGVNaW51cycsIFs4ODU0XV0sIFsnQ2lyY2xlUGx1cycsIFs4ODUzXV0sIFsnQ2lyY2xlVGltZXMnLCBbODg1NV1dLCBbJ2NpcicsIFs5Njc1XV0sIFsnY2lyRScsIFsxMDY5MV1dLCBbJ2NpcmUnLCBbODc5MV1dLCBbJ2NpcmZuaW50JywgWzEwNzY4XV0sIFsnY2lybWlkJywgWzEwOTkxXV0sIFsnY2lyc2NpcicsIFsxMDY5MF1dLCBbJ0Nsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzU0XV0sIFsnY2x1YnMnLCBbOTgyN11dLCBbJ2NsdWJzdWl0JywgWzk4MjddXSwgWydjb2xvbicsIFs1OF1dLCBbJ0NvbG9uJywgWzg3NTldXSwgWydDb2xvbmUnLCBbMTA4NjhdXSwgWydjb2xvbmUnLCBbODc4OF1dLCBbJ2NvbG9uZXEnLCBbODc4OF1dLCBbJ2NvbW1hJywgWzQ0XV0sIFsnY29tbWF0JywgWzY0XV0sIFsnY29tcCcsIFs4NzA1XV0sIFsnY29tcGZuJywgWzg3MjhdXSwgWydjb21wbGVtZW50JywgWzg3MDVdXSwgWydjb21wbGV4ZXMnLCBbODQ1MF1dLCBbJ2NvbmcnLCBbODc3M11dLCBbJ2Nvbmdkb3QnLCBbMTA4NjFdXSwgWydDb25ncnVlbnQnLCBbODgwMV1dLCBbJ2NvbmludCcsIFs4NzUwXV0sIFsnQ29uaW50JywgWzg3NTFdXSwgWydDb250b3VySW50ZWdyYWwnLCBbODc1MF1dLCBbJ2NvcGYnLCBbMTIwMTQ4XV0sIFsnQ29wZicsIFs4NDUwXV0sIFsnY29wcm9kJywgWzg3MjBdXSwgWydDb3Byb2R1Y3QnLCBbODcyMF1dLCBbJ2NvcHknLCBbMTY5XV0sIFsnQ09QWScsIFsxNjldXSwgWydjb3B5c3InLCBbODQ3MV1dLCBbJ0NvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnLCBbODc1NV1dLCBbJ2NyYXJyJywgWzg2MjldXSwgWydjcm9zcycsIFsxMDAwN11dLCBbJ0Nyb3NzJywgWzEwNzk5XV0sIFsnQ3NjcicsIFsxMTk5NjZdXSwgWydjc2NyJywgWzExOTk5Ml1dLCBbJ2NzdWInLCBbMTA5NTldXSwgWydjc3ViZScsIFsxMDk2MV1dLCBbJ2NzdXAnLCBbMTA5NjBdXSwgWydjc3VwZScsIFsxMDk2Ml1dLCBbJ2N0ZG90JywgWzg5NDNdXSwgWydjdWRhcnJsJywgWzEwNTUyXV0sIFsnY3VkYXJycicsIFsxMDU0OV1dLCBbJ2N1ZXByJywgWzg5MjZdXSwgWydjdWVzYycsIFs4OTI3XV0sIFsnY3VsYXJyJywgWzg2MzBdXSwgWydjdWxhcnJwJywgWzEwNTU3XV0sIFsnY3VwYnJjYXAnLCBbMTA4MjRdXSwgWydjdXBjYXAnLCBbMTA4MjJdXSwgWydDdXBDYXAnLCBbODc4MV1dLCBbJ2N1cCcsIFs4NzQ2XV0sIFsnQ3VwJywgWzg5MTVdXSwgWydjdXBjdXAnLCBbMTA4MjZdXSwgWydjdXBkb3QnLCBbODg0NV1dLCBbJ2N1cG9yJywgWzEwODIxXV0sIFsnY3VwcycsIFs4NzQ2LCA2NTAyNF1dLCBbJ2N1cmFycicsIFs4NjMxXV0sIFsnY3VyYXJybScsIFsxMDU1Nl1dLCBbJ2N1cmx5ZXFwcmVjJywgWzg5MjZdXSwgWydjdXJseWVxc3VjYycsIFs4OTI3XV0sIFsnY3VybHl2ZWUnLCBbODkxMF1dLCBbJ2N1cmx5d2VkZ2UnLCBbODkxMV1dLCBbJ2N1cnJlbicsIFsxNjRdXSwgWydjdXJ2ZWFycm93bGVmdCcsIFs4NjMwXV0sIFsnY3VydmVhcnJvd3JpZ2h0JywgWzg2MzFdXSwgWydjdXZlZScsIFs4OTEwXV0sIFsnY3V3ZWQnLCBbODkxMV1dLCBbJ2N3Y29uaW50JywgWzg3NTRdXSwgWydjd2ludCcsIFs4NzUzXV0sIFsnY3lsY3R5JywgWzkwMDVdXSwgWydkYWdnZXInLCBbODIyNF1dLCBbJ0RhZ2dlcicsIFs4MjI1XV0sIFsnZGFsZXRoJywgWzg1MDRdXSwgWydkYXJyJywgWzg1OTVdXSwgWydEYXJyJywgWzg2MDldXSwgWydkQXJyJywgWzg2NTldXSwgWydkYXNoJywgWzgyMDhdXSwgWydEYXNodicsIFsxMDk4MF1dLCBbJ2Rhc2h2JywgWzg4NjddXSwgWydkYmthcm93JywgWzEwNTExXV0sIFsnZGJsYWMnLCBbNzMzXV0sIFsnRGNhcm9uJywgWzI3MF1dLCBbJ2RjYXJvbicsIFsyNzFdXSwgWydEY3knLCBbMTA0NF1dLCBbJ2RjeScsIFsxMDc2XV0sIFsnZGRhZ2dlcicsIFs4MjI1XV0sIFsnZGRhcnInLCBbODY1MF1dLCBbJ0REJywgWzg1MTddXSwgWydkZCcsIFs4NTE4XV0sIFsnRERvdHJhaGQnLCBbMTA1MTNdXSwgWydkZG90c2VxJywgWzEwODcxXV0sIFsnZGVnJywgWzE3Nl1dLCBbJ0RlbCcsIFs4NzExXV0sIFsnRGVsdGEnLCBbOTE2XV0sIFsnZGVsdGEnLCBbOTQ4XV0sIFsnZGVtcHR5dicsIFsxMDY3M11dLCBbJ2RmaXNodCcsIFsxMDYyM11dLCBbJ0RmcicsIFsxMjAwNzFdXSwgWydkZnInLCBbMTIwMDk3XV0sIFsnZEhhcicsIFsxMDU5N11dLCBbJ2RoYXJsJywgWzg2NDNdXSwgWydkaGFycicsIFs4NjQyXV0sIFsnRGlhY3JpdGljYWxBY3V0ZScsIFsxODBdXSwgWydEaWFjcml0aWNhbERvdCcsIFs3MjldXSwgWydEaWFjcml0aWNhbERvdWJsZUFjdXRlJywgWzczM11dLCBbJ0RpYWNyaXRpY2FsR3JhdmUnLCBbOTZdXSwgWydEaWFjcml0aWNhbFRpbGRlJywgWzczMl1dLCBbJ2RpYW0nLCBbODkwMF1dLCBbJ2RpYW1vbmQnLCBbODkwMF1dLCBbJ0RpYW1vbmQnLCBbODkwMF1dLCBbJ2RpYW1vbmRzdWl0JywgWzk4MzBdXSwgWydkaWFtcycsIFs5ODMwXV0sIFsnZGllJywgWzE2OF1dLCBbJ0RpZmZlcmVudGlhbEQnLCBbODUxOF1dLCBbJ2RpZ2FtbWEnLCBbOTg5XV0sIFsnZGlzaW4nLCBbODk0Nl1dLCBbJ2RpdicsIFsyNDddXSwgWydkaXZpZGUnLCBbMjQ3XV0sIFsnZGl2aWRlb250aW1lcycsIFs4OTAzXV0sIFsnZGl2b254JywgWzg5MDNdXSwgWydESmN5JywgWzEwMjZdXSwgWydkamN5JywgWzExMDZdXSwgWydkbGNvcm4nLCBbODk5MF1dLCBbJ2RsY3JvcCcsIFs4OTczXV0sIFsnZG9sbGFyJywgWzM2XV0sIFsnRG9wZicsIFsxMjAxMjNdXSwgWydkb3BmJywgWzEyMDE0OV1dLCBbJ0RvdCcsIFsxNjhdXSwgWydkb3QnLCBbNzI5XV0sIFsnRG90RG90JywgWzg0MTJdXSwgWydkb3RlcScsIFs4Nzg0XV0sIFsnZG90ZXFkb3QnLCBbODc4NV1dLCBbJ0RvdEVxdWFsJywgWzg3ODRdXSwgWydkb3RtaW51cycsIFs4NzYwXV0sIFsnZG90cGx1cycsIFs4NzI0XV0sIFsnZG90c3F1YXJlJywgWzg4NjVdXSwgWydkb3VibGViYXJ3ZWRnZScsIFs4OTY2XV0sIFsnRG91YmxlQ29udG91ckludGVncmFsJywgWzg3NTFdXSwgWydEb3VibGVEb3QnLCBbMTY4XV0sIFsnRG91YmxlRG93bkFycm93JywgWzg2NTldXSwgWydEb3VibGVMZWZ0QXJyb3cnLCBbODY1Nl1dLCBbJ0RvdWJsZUxlZnRSaWdodEFycm93JywgWzg2NjBdXSwgWydEb3VibGVMZWZ0VGVlJywgWzEwOTgwXV0sIFsnRG91YmxlTG9uZ0xlZnRBcnJvdycsIFsxMDIzMl1dLCBbJ0RvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdycsIFsxMDIzNF1dLCBbJ0RvdWJsZUxvbmdSaWdodEFycm93JywgWzEwMjMzXV0sIFsnRG91YmxlUmlnaHRBcnJvdycsIFs4NjU4XV0sIFsnRG91YmxlUmlnaHRUZWUnLCBbODg3Ml1dLCBbJ0RvdWJsZVVwQXJyb3cnLCBbODY1N11dLCBbJ0RvdWJsZVVwRG93bkFycm93JywgWzg2NjFdXSwgWydEb3VibGVWZXJ0aWNhbEJhcicsIFs4NzQxXV0sIFsnRG93bkFycm93QmFyJywgWzEwNTE1XV0sIFsnZG93bmFycm93JywgWzg1OTVdXSwgWydEb3duQXJyb3cnLCBbODU5NV1dLCBbJ0Rvd25hcnJvdycsIFs4NjU5XV0sIFsnRG93bkFycm93VXBBcnJvdycsIFs4NjkzXV0sIFsnRG93bkJyZXZlJywgWzc4NV1dLCBbJ2Rvd25kb3duYXJyb3dzJywgWzg2NTBdXSwgWydkb3duaGFycG9vbmxlZnQnLCBbODY0M11dLCBbJ2Rvd25oYXJwb29ucmlnaHQnLCBbODY0Ml1dLCBbJ0Rvd25MZWZ0UmlnaHRWZWN0b3InLCBbMTA1NzZdXSwgWydEb3duTGVmdFRlZVZlY3RvcicsIFsxMDU5MF1dLCBbJ0Rvd25MZWZ0VmVjdG9yQmFyJywgWzEwNTgyXV0sIFsnRG93bkxlZnRWZWN0b3InLCBbODYzN11dLCBbJ0Rvd25SaWdodFRlZVZlY3RvcicsIFsxMDU5MV1dLCBbJ0Rvd25SaWdodFZlY3RvckJhcicsIFsxMDU4M11dLCBbJ0Rvd25SaWdodFZlY3RvcicsIFs4NjQxXV0sIFsnRG93blRlZUFycm93JywgWzg2MTVdXSwgWydEb3duVGVlJywgWzg4NjhdXSwgWydkcmJrYXJvdycsIFsxMDUxMl1dLCBbJ2RyY29ybicsIFs4OTkxXV0sIFsnZHJjcm9wJywgWzg5NzJdXSwgWydEc2NyJywgWzExOTk2N11dLCBbJ2RzY3InLCBbMTE5OTkzXV0sIFsnRFNjeScsIFsxMDI5XV0sIFsnZHNjeScsIFsxMTA5XV0sIFsnZHNvbCcsIFsxMDc0Ml1dLCBbJ0RzdHJvaycsIFsyNzJdXSwgWydkc3Ryb2snLCBbMjczXV0sIFsnZHRkb3QnLCBbODk0NV1dLCBbJ2R0cmknLCBbOTY2M11dLCBbJ2R0cmlmJywgWzk2NjJdXSwgWydkdWFycicsIFs4NjkzXV0sIFsnZHVoYXInLCBbMTA2MDddXSwgWydkd2FuZ2xlJywgWzEwNjYyXV0sIFsnRFpjeScsIFsxMDM5XV0sIFsnZHpjeScsIFsxMTE5XV0sIFsnZHppZ3JhcnInLCBbMTAyMzldXSwgWydFYWN1dGUnLCBbMjAxXV0sIFsnZWFjdXRlJywgWzIzM11dLCBbJ2Vhc3RlcicsIFsxMDg2Ml1dLCBbJ0VjYXJvbicsIFsyODJdXSwgWydlY2Fyb24nLCBbMjgzXV0sIFsnRWNpcmMnLCBbMjAyXV0sIFsnZWNpcmMnLCBbMjM0XV0sIFsnZWNpcicsIFs4NzkwXV0sIFsnZWNvbG9uJywgWzg3ODldXSwgWydFY3knLCBbMTA2OV1dLCBbJ2VjeScsIFsxMTAxXV0sIFsnZUREb3QnLCBbMTA4NzFdXSwgWydFZG90JywgWzI3OF1dLCBbJ2Vkb3QnLCBbMjc5XV0sIFsnZURvdCcsIFs4Nzg1XV0sIFsnZWUnLCBbODUxOV1dLCBbJ2VmRG90JywgWzg3ODZdXSwgWydFZnInLCBbMTIwMDcyXV0sIFsnZWZyJywgWzEyMDA5OF1dLCBbJ2VnJywgWzEwOTA2XV0sIFsnRWdyYXZlJywgWzIwMF1dLCBbJ2VncmF2ZScsIFsyMzJdXSwgWydlZ3MnLCBbMTA5MDJdXSwgWydlZ3Nkb3QnLCBbMTA5MDRdXSwgWydlbCcsIFsxMDkwNV1dLCBbJ0VsZW1lbnQnLCBbODcxMl1dLCBbJ2VsaW50ZXJzJywgWzkxOTFdXSwgWydlbGwnLCBbODQ2N11dLCBbJ2VscycsIFsxMDkwMV1dLCBbJ2Vsc2RvdCcsIFsxMDkwM11dLCBbJ0VtYWNyJywgWzI3NF1dLCBbJ2VtYWNyJywgWzI3NV1dLCBbJ2VtcHR5JywgWzg3MDldXSwgWydlbXB0eXNldCcsIFs4NzA5XV0sIFsnRW1wdHlTbWFsbFNxdWFyZScsIFs5NzIzXV0sIFsnZW1wdHl2JywgWzg3MDldXSwgWydFbXB0eVZlcnlTbWFsbFNxdWFyZScsIFs5NjQzXV0sIFsnZW1zcDEzJywgWzgxOTZdXSwgWydlbXNwMTQnLCBbODE5N11dLCBbJ2Vtc3AnLCBbODE5NV1dLCBbJ0VORycsIFszMzBdXSwgWydlbmcnLCBbMzMxXV0sIFsnZW5zcCcsIFs4MTk0XV0sIFsnRW9nb24nLCBbMjgwXV0sIFsnZW9nb24nLCBbMjgxXV0sIFsnRW9wZicsIFsxMjAxMjRdXSwgWydlb3BmJywgWzEyMDE1MF1dLCBbJ2VwYXInLCBbODkxN11dLCBbJ2VwYXJzbCcsIFsxMDcyM11dLCBbJ2VwbHVzJywgWzEwODY1XV0sIFsnZXBzaScsIFs5NDldXSwgWydFcHNpbG9uJywgWzkxN11dLCBbJ2Vwc2lsb24nLCBbOTQ5XV0sIFsnZXBzaXYnLCBbMTAxM11dLCBbJ2VxY2lyYycsIFs4NzkwXV0sIFsnZXFjb2xvbicsIFs4Nzg5XV0sIFsnZXFzaW0nLCBbODc3MF1dLCBbJ2Vxc2xhbnRndHInLCBbMTA5MDJdXSwgWydlcXNsYW50bGVzcycsIFsxMDkwMV1dLCBbJ0VxdWFsJywgWzEwODY5XV0sIFsnZXF1YWxzJywgWzYxXV0sIFsnRXF1YWxUaWxkZScsIFs4NzcwXV0sIFsnZXF1ZXN0JywgWzg3OTldXSwgWydFcXVpbGlicml1bScsIFs4NjUyXV0sIFsnZXF1aXYnLCBbODgwMV1dLCBbJ2VxdWl2REQnLCBbMTA4NzJdXSwgWydlcXZwYXJzbCcsIFsxMDcyNV1dLCBbJ2VyYXJyJywgWzEwNjA5XV0sIFsnZXJEb3QnLCBbODc4N11dLCBbJ2VzY3InLCBbODQ5NV1dLCBbJ0VzY3InLCBbODQ5Nl1dLCBbJ2VzZG90JywgWzg3ODRdXSwgWydFc2ltJywgWzEwODY3XV0sIFsnZXNpbScsIFs4NzcwXV0sIFsnRXRhJywgWzkxOV1dLCBbJ2V0YScsIFs5NTFdXSwgWydFVEgnLCBbMjA4XV0sIFsnZXRoJywgWzI0MF1dLCBbJ0V1bWwnLCBbMjAzXV0sIFsnZXVtbCcsIFsyMzVdXSwgWydldXJvJywgWzgzNjRdXSwgWydleGNsJywgWzMzXV0sIFsnZXhpc3QnLCBbODcwN11dLCBbJ0V4aXN0cycsIFs4NzA3XV0sIFsnZXhwZWN0YXRpb24nLCBbODQ5Nl1dLCBbJ2V4cG9uZW50aWFsZScsIFs4NTE5XV0sIFsnRXhwb25lbnRpYWxFJywgWzg1MTldXSwgWydmYWxsaW5nZG90c2VxJywgWzg3ODZdXSwgWydGY3knLCBbMTA2MF1dLCBbJ2ZjeScsIFsxMDkyXV0sIFsnZmVtYWxlJywgWzk3OTJdXSwgWydmZmlsaWcnLCBbNjQyNTldXSwgWydmZmxpZycsIFs2NDI1Nl1dLCBbJ2ZmbGxpZycsIFs2NDI2MF1dLCBbJ0ZmcicsIFsxMjAwNzNdXSwgWydmZnInLCBbMTIwMDk5XV0sIFsnZmlsaWcnLCBbNjQyNTddXSwgWydGaWxsZWRTbWFsbFNxdWFyZScsIFs5NzI0XV0sIFsnRmlsbGVkVmVyeVNtYWxsU3F1YXJlJywgWzk2NDJdXSwgWydmamxpZycsIFsxMDIsIDEwNl1dLCBbJ2ZsYXQnLCBbOTgzN11dLCBbJ2ZsbGlnJywgWzY0MjU4XV0sIFsnZmx0bnMnLCBbOTY0OV1dLCBbJ2Zub2YnLCBbNDAyXV0sIFsnRm9wZicsIFsxMjAxMjVdXSwgWydmb3BmJywgWzEyMDE1MV1dLCBbJ2ZvcmFsbCcsIFs4NzA0XV0sIFsnRm9yQWxsJywgWzg3MDRdXSwgWydmb3JrJywgWzg5MTZdXSwgWydmb3JrdicsIFsxMDk2OV1dLCBbJ0ZvdXJpZXJ0cmYnLCBbODQ5N11dLCBbJ2ZwYXJ0aW50JywgWzEwNzY1XV0sIFsnZnJhYzEyJywgWzE4OV1dLCBbJ2ZyYWMxMycsIFs4NTMxXV0sIFsnZnJhYzE0JywgWzE4OF1dLCBbJ2ZyYWMxNScsIFs4NTMzXV0sIFsnZnJhYzE2JywgWzg1MzddXSwgWydmcmFjMTgnLCBbODUzOV1dLCBbJ2ZyYWMyMycsIFs4NTMyXV0sIFsnZnJhYzI1JywgWzg1MzRdXSwgWydmcmFjMzQnLCBbMTkwXV0sIFsnZnJhYzM1JywgWzg1MzVdXSwgWydmcmFjMzgnLCBbODU0MF1dLCBbJ2ZyYWM0NScsIFs4NTM2XV0sIFsnZnJhYzU2JywgWzg1MzhdXSwgWydmcmFjNTgnLCBbODU0MV1dLCBbJ2ZyYWM3OCcsIFs4NTQyXV0sIFsnZnJhc2wnLCBbODI2MF1dLCBbJ2Zyb3duJywgWzg5OTRdXSwgWydmc2NyJywgWzExOTk5NV1dLCBbJ0ZzY3InLCBbODQ5N11dLCBbJ2dhY3V0ZScsIFs1MDFdXSwgWydHYW1tYScsIFs5MTVdXSwgWydnYW1tYScsIFs5NDddXSwgWydHYW1tYWQnLCBbOTg4XV0sIFsnZ2FtbWFkJywgWzk4OV1dLCBbJ2dhcCcsIFsxMDg4Nl1dLCBbJ0dicmV2ZScsIFsyODZdXSwgWydnYnJldmUnLCBbMjg3XV0sIFsnR2NlZGlsJywgWzI5MF1dLCBbJ0djaXJjJywgWzI4NF1dLCBbJ2djaXJjJywgWzI4NV1dLCBbJ0djeScsIFsxMDQzXV0sIFsnZ2N5JywgWzEwNzVdXSwgWydHZG90JywgWzI4OF1dLCBbJ2dkb3QnLCBbMjg5XV0sIFsnZ2UnLCBbODgwNV1dLCBbJ2dFJywgWzg4MDddXSwgWydnRWwnLCBbMTA4OTJdXSwgWydnZWwnLCBbODkyM11dLCBbJ2dlcScsIFs4ODA1XV0sIFsnZ2VxcScsIFs4ODA3XV0sIFsnZ2Vxc2xhbnQnLCBbMTA4NzhdXSwgWydnZXNjYycsIFsxMDkyMV1dLCBbJ2dlcycsIFsxMDg3OF1dLCBbJ2dlc2RvdCcsIFsxMDg4MF1dLCBbJ2dlc2RvdG8nLCBbMTA4ODJdXSwgWydnZXNkb3RvbCcsIFsxMDg4NF1dLCBbJ2dlc2wnLCBbODkyMywgNjUwMjRdXSwgWydnZXNsZXMnLCBbMTA5MDBdXSwgWydHZnInLCBbMTIwMDc0XV0sIFsnZ2ZyJywgWzEyMDEwMF1dLCBbJ2dnJywgWzg4MTFdXSwgWydHZycsIFs4OTIxXV0sIFsnZ2dnJywgWzg5MjFdXSwgWydnaW1lbCcsIFs4NTAzXV0sIFsnR0pjeScsIFsxMDI3XV0sIFsnZ2pjeScsIFsxMTA3XV0sIFsnZ2xhJywgWzEwOTE3XV0sIFsnZ2wnLCBbODgyM11dLCBbJ2dsRScsIFsxMDg5OF1dLCBbJ2dsaicsIFsxMDkxNl1dLCBbJ2duYXAnLCBbMTA4OTBdXSwgWydnbmFwcHJveCcsIFsxMDg5MF1dLCBbJ2duZScsIFsxMDg4OF1dLCBbJ2duRScsIFs4ODA5XV0sIFsnZ25lcScsIFsxMDg4OF1dLCBbJ2duZXFxJywgWzg4MDldXSwgWydnbnNpbScsIFs4OTM1XV0sIFsnR29wZicsIFsxMjAxMjZdXSwgWydnb3BmJywgWzEyMDE1Ml1dLCBbJ2dyYXZlJywgWzk2XV0sIFsnR3JlYXRlckVxdWFsJywgWzg4MDVdXSwgWydHcmVhdGVyRXF1YWxMZXNzJywgWzg5MjNdXSwgWydHcmVhdGVyRnVsbEVxdWFsJywgWzg4MDddXSwgWydHcmVhdGVyR3JlYXRlcicsIFsxMDkxNF1dLCBbJ0dyZWF0ZXJMZXNzJywgWzg4MjNdXSwgWydHcmVhdGVyU2xhbnRFcXVhbCcsIFsxMDg3OF1dLCBbJ0dyZWF0ZXJUaWxkZScsIFs4ODE5XV0sIFsnR3NjcicsIFsxMTk5NzBdXSwgWydnc2NyJywgWzg0NThdXSwgWydnc2ltJywgWzg4MTldXSwgWydnc2ltZScsIFsxMDg5NF1dLCBbJ2dzaW1sJywgWzEwODk2XV0sIFsnZ3RjYycsIFsxMDkxOV1dLCBbJ2d0Y2lyJywgWzEwODc0XV0sIFsnZ3QnLCBbNjJdXSwgWydHVCcsIFs2Ml1dLCBbJ0d0JywgWzg4MTFdXSwgWydndGRvdCcsIFs4OTE5XV0sIFsnZ3RsUGFyJywgWzEwNjQ1XV0sIFsnZ3RxdWVzdCcsIFsxMDg3Nl1dLCBbJ2d0cmFwcHJveCcsIFsxMDg4Nl1dLCBbJ2d0cmFycicsIFsxMDYxNl1dLCBbJ2d0cmRvdCcsIFs4OTE5XV0sIFsnZ3RyZXFsZXNzJywgWzg5MjNdXSwgWydndHJlcXFsZXNzJywgWzEwODkyXV0sIFsnZ3RybGVzcycsIFs4ODIzXV0sIFsnZ3Ryc2ltJywgWzg4MTldXSwgWydndmVydG5lcXEnLCBbODgwOSwgNjUwMjRdXSwgWydndm5FJywgWzg4MDksIDY1MDI0XV0sIFsnSGFjZWsnLCBbNzExXV0sIFsnaGFpcnNwJywgWzgyMDJdXSwgWydoYWxmJywgWzE4OV1dLCBbJ2hhbWlsdCcsIFs4NDU5XV0sIFsnSEFSRGN5JywgWzEwNjZdXSwgWydoYXJkY3knLCBbMTA5OF1dLCBbJ2hhcnJjaXInLCBbMTA1NjhdXSwgWydoYXJyJywgWzg1OTZdXSwgWydoQXJyJywgWzg2NjBdXSwgWydoYXJydycsIFs4NjIxXV0sIFsnSGF0JywgWzk0XV0sIFsnaGJhcicsIFs4NDYzXV0sIFsnSGNpcmMnLCBbMjkyXV0sIFsnaGNpcmMnLCBbMjkzXV0sIFsnaGVhcnRzJywgWzk4MjldXSwgWydoZWFydHN1aXQnLCBbOTgyOV1dLCBbJ2hlbGxpcCcsIFs4MjMwXV0sIFsnaGVyY29uJywgWzg4ODldXSwgWydoZnInLCBbMTIwMTAxXV0sIFsnSGZyJywgWzg0NjBdXSwgWydIaWxiZXJ0U3BhY2UnLCBbODQ1OV1dLCBbJ2hrc2Vhcm93JywgWzEwNTMzXV0sIFsnaGtzd2Fyb3cnLCBbMTA1MzRdXSwgWydob2FycicsIFs4NzAzXV0sIFsnaG9tdGh0JywgWzg3NjNdXSwgWydob29rbGVmdGFycm93JywgWzg2MTddXSwgWydob29rcmlnaHRhcnJvdycsIFs4NjE4XV0sIFsnaG9wZicsIFsxMjAxNTNdXSwgWydIb3BmJywgWzg0NjFdXSwgWydob3JiYXInLCBbODIxM11dLCBbJ0hvcml6b250YWxMaW5lJywgWzk0NzJdXSwgWydoc2NyJywgWzExOTk5N11dLCBbJ0hzY3InLCBbODQ1OV1dLCBbJ2hzbGFzaCcsIFs4NDYzXV0sIFsnSHN0cm9rJywgWzI5NF1dLCBbJ2hzdHJvaycsIFsyOTVdXSwgWydIdW1wRG93bkh1bXAnLCBbODc4Ml1dLCBbJ0h1bXBFcXVhbCcsIFs4NzgzXV0sIFsnaHlidWxsJywgWzgyNTldXSwgWydoeXBoZW4nLCBbODIwOF1dLCBbJ0lhY3V0ZScsIFsyMDVdXSwgWydpYWN1dGUnLCBbMjM3XV0sIFsnaWMnLCBbODI5MV1dLCBbJ0ljaXJjJywgWzIwNl1dLCBbJ2ljaXJjJywgWzIzOF1dLCBbJ0ljeScsIFsxMDQ4XV0sIFsnaWN5JywgWzEwODBdXSwgWydJZG90JywgWzMwNF1dLCBbJ0lFY3knLCBbMTA0NV1dLCBbJ2llY3knLCBbMTA3N11dLCBbJ2lleGNsJywgWzE2MV1dLCBbJ2lmZicsIFs4NjYwXV0sIFsnaWZyJywgWzEyMDEwMl1dLCBbJ0lmcicsIFs4NDY1XV0sIFsnSWdyYXZlJywgWzIwNF1dLCBbJ2lncmF2ZScsIFsyMzZdXSwgWydpaScsIFs4NTIwXV0sIFsnaWlpaW50JywgWzEwNzY0XV0sIFsnaWlpbnQnLCBbODc0OV1dLCBbJ2lpbmZpbicsIFsxMDcxNl1dLCBbJ2lpb3RhJywgWzg0ODldXSwgWydJSmxpZycsIFszMDZdXSwgWydpamxpZycsIFszMDddXSwgWydJbWFjcicsIFsyOThdXSwgWydpbWFjcicsIFsyOTldXSwgWydpbWFnZScsIFs4NDY1XV0sIFsnSW1hZ2luYXJ5SScsIFs4NTIwXV0sIFsnaW1hZ2xpbmUnLCBbODQ2NF1dLCBbJ2ltYWdwYXJ0JywgWzg0NjVdXSwgWydpbWF0aCcsIFszMDVdXSwgWydJbScsIFs4NDY1XV0sIFsnaW1vZicsIFs4ODg3XV0sIFsnaW1wZWQnLCBbNDM3XV0sIFsnSW1wbGllcycsIFs4NjU4XV0sIFsnaW5jYXJlJywgWzg0NTNdXSwgWydpbicsIFs4NzEyXV0sIFsnaW5maW4nLCBbODczNF1dLCBbJ2luZmludGllJywgWzEwNzE3XV0sIFsnaW5vZG90JywgWzMwNV1dLCBbJ2ludGNhbCcsIFs4ODkwXV0sIFsnaW50JywgWzg3NDddXSwgWydJbnQnLCBbODc0OF1dLCBbJ2ludGVnZXJzJywgWzg0ODRdXSwgWydJbnRlZ3JhbCcsIFs4NzQ3XV0sIFsnaW50ZXJjYWwnLCBbODg5MF1dLCBbJ0ludGVyc2VjdGlvbicsIFs4ODk4XV0sIFsnaW50bGFyaGsnLCBbMTA3NzVdXSwgWydpbnRwcm9kJywgWzEwODEyXV0sIFsnSW52aXNpYmxlQ29tbWEnLCBbODI5MV1dLCBbJ0ludmlzaWJsZVRpbWVzJywgWzgyOTBdXSwgWydJT2N5JywgWzEwMjVdXSwgWydpb2N5JywgWzExMDVdXSwgWydJb2dvbicsIFszMDJdXSwgWydpb2dvbicsIFszMDNdXSwgWydJb3BmJywgWzEyMDEyOF1dLCBbJ2lvcGYnLCBbMTIwMTU0XV0sIFsnSW90YScsIFs5MjFdXSwgWydpb3RhJywgWzk1M11dLCBbJ2lwcm9kJywgWzEwODEyXV0sIFsnaXF1ZXN0JywgWzE5MV1dLCBbJ2lzY3InLCBbMTE5OTk4XV0sIFsnSXNjcicsIFs4NDY0XV0sIFsnaXNpbicsIFs4NzEyXV0sIFsnaXNpbmRvdCcsIFs4OTQ5XV0sIFsnaXNpbkUnLCBbODk1M11dLCBbJ2lzaW5zJywgWzg5NDhdXSwgWydpc2luc3YnLCBbODk0N11dLCBbJ2lzaW52JywgWzg3MTJdXSwgWydpdCcsIFs4MjkwXV0sIFsnSXRpbGRlJywgWzI5Nl1dLCBbJ2l0aWxkZScsIFsyOTddXSwgWydJdWtjeScsIFsxMDMwXV0sIFsnaXVrY3knLCBbMTExMF1dLCBbJ0l1bWwnLCBbMjA3XV0sIFsnaXVtbCcsIFsyMzldXSwgWydKY2lyYycsIFszMDhdXSwgWydqY2lyYycsIFszMDldXSwgWydKY3knLCBbMTA0OV1dLCBbJ2pjeScsIFsxMDgxXV0sIFsnSmZyJywgWzEyMDA3N11dLCBbJ2pmcicsIFsxMjAxMDNdXSwgWydqbWF0aCcsIFs1NjddXSwgWydKb3BmJywgWzEyMDEyOV1dLCBbJ2pvcGYnLCBbMTIwMTU1XV0sIFsnSnNjcicsIFsxMTk5NzNdXSwgWydqc2NyJywgWzExOTk5OV1dLCBbJ0pzZXJjeScsIFsxMDMyXV0sIFsnanNlcmN5JywgWzExMTJdXSwgWydKdWtjeScsIFsxMDI4XV0sIFsnanVrY3knLCBbMTEwOF1dLCBbJ0thcHBhJywgWzkyMl1dLCBbJ2thcHBhJywgWzk1NF1dLCBbJ2thcHBhdicsIFsxMDA4XV0sIFsnS2NlZGlsJywgWzMxMF1dLCBbJ2tjZWRpbCcsIFszMTFdXSwgWydLY3knLCBbMTA1MF1dLCBbJ2tjeScsIFsxMDgyXV0sIFsnS2ZyJywgWzEyMDA3OF1dLCBbJ2tmcicsIFsxMjAxMDRdXSwgWydrZ3JlZW4nLCBbMzEyXV0sIFsnS0hjeScsIFsxMDYxXV0sIFsna2hjeScsIFsxMDkzXV0sIFsnS0pjeScsIFsxMDM2XV0sIFsna2pjeScsIFsxMTE2XV0sIFsnS29wZicsIFsxMjAxMzBdXSwgWydrb3BmJywgWzEyMDE1Nl1dLCBbJ0tzY3InLCBbMTE5OTc0XV0sIFsna3NjcicsIFsxMjAwMDBdXSwgWydsQWFycicsIFs4NjY2XV0sIFsnTGFjdXRlJywgWzMxM11dLCBbJ2xhY3V0ZScsIFszMTRdXSwgWydsYWVtcHR5dicsIFsxMDY3Nl1dLCBbJ2xhZ3JhbicsIFs4NDY2XV0sIFsnTGFtYmRhJywgWzkyM11dLCBbJ2xhbWJkYScsIFs5NTVdXSwgWydsYW5nJywgWzEwMjE2XV0sIFsnTGFuZycsIFsxMDIxOF1dLCBbJ2xhbmdkJywgWzEwNjQxXV0sIFsnbGFuZ2xlJywgWzEwMjE2XV0sIFsnbGFwJywgWzEwODg1XV0sIFsnTGFwbGFjZXRyZicsIFs4NDY2XV0sIFsnbGFxdW8nLCBbMTcxXV0sIFsnbGFycmInLCBbODY3Nl1dLCBbJ2xhcnJiZnMnLCBbMTA1MjddXSwgWydsYXJyJywgWzg1OTJdXSwgWydMYXJyJywgWzg2MDZdXSwgWydsQXJyJywgWzg2NTZdXSwgWydsYXJyZnMnLCBbMTA1MjVdXSwgWydsYXJyaGsnLCBbODYxN11dLCBbJ2xhcnJscCcsIFs4NjE5XV0sIFsnbGFycnBsJywgWzEwNTUzXV0sIFsnbGFycnNpbScsIFsxMDYxMV1dLCBbJ2xhcnJ0bCcsIFs4NjEwXV0sIFsnbGF0YWlsJywgWzEwNTIxXV0sIFsnbEF0YWlsJywgWzEwNTIzXV0sIFsnbGF0JywgWzEwOTIzXV0sIFsnbGF0ZScsIFsxMDkyNV1dLCBbJ2xhdGVzJywgWzEwOTI1LCA2NTAyNF1dLCBbJ2xiYXJyJywgWzEwNTA4XV0sIFsnbEJhcnInLCBbMTA1MTBdXSwgWydsYmJyaycsIFsxMDA5OF1dLCBbJ2xicmFjZScsIFsxMjNdXSwgWydsYnJhY2snLCBbOTFdXSwgWydsYnJrZScsIFsxMDYzNV1dLCBbJ2xicmtzbGQnLCBbMTA2MzldXSwgWydsYnJrc2x1JywgWzEwNjM3XV0sIFsnTGNhcm9uJywgWzMxN11dLCBbJ2xjYXJvbicsIFszMThdXSwgWydMY2VkaWwnLCBbMzE1XV0sIFsnbGNlZGlsJywgWzMxNl1dLCBbJ2xjZWlsJywgWzg5NjhdXSwgWydsY3ViJywgWzEyM11dLCBbJ0xjeScsIFsxMDUxXV0sIFsnbGN5JywgWzEwODNdXSwgWydsZGNhJywgWzEwNTUwXV0sIFsnbGRxdW8nLCBbODIyMF1dLCBbJ2xkcXVvcicsIFs4MjIyXV0sIFsnbGRyZGhhcicsIFsxMDU5OV1dLCBbJ2xkcnVzaGFyJywgWzEwNTcxXV0sIFsnbGRzaCcsIFs4NjI2XV0sIFsnbGUnLCBbODgwNF1dLCBbJ2xFJywgWzg4MDZdXSwgWydMZWZ0QW5nbGVCcmFja2V0JywgWzEwMjE2XV0sIFsnTGVmdEFycm93QmFyJywgWzg2NzZdXSwgWydsZWZ0YXJyb3cnLCBbODU5Ml1dLCBbJ0xlZnRBcnJvdycsIFs4NTkyXV0sIFsnTGVmdGFycm93JywgWzg2NTZdXSwgWydMZWZ0QXJyb3dSaWdodEFycm93JywgWzg2NDZdXSwgWydsZWZ0YXJyb3d0YWlsJywgWzg2MTBdXSwgWydMZWZ0Q2VpbGluZycsIFs4OTY4XV0sIFsnTGVmdERvdWJsZUJyYWNrZXQnLCBbMTAyMTRdXSwgWydMZWZ0RG93blRlZVZlY3RvcicsIFsxMDU5M11dLCBbJ0xlZnREb3duVmVjdG9yQmFyJywgWzEwNTg1XV0sIFsnTGVmdERvd25WZWN0b3InLCBbODY0M11dLCBbJ0xlZnRGbG9vcicsIFs4OTcwXV0sIFsnbGVmdGhhcnBvb25kb3duJywgWzg2MzddXSwgWydsZWZ0aGFycG9vbnVwJywgWzg2MzZdXSwgWydsZWZ0bGVmdGFycm93cycsIFs4NjQ3XV0sIFsnbGVmdHJpZ2h0YXJyb3cnLCBbODU5Nl1dLCBbJ0xlZnRSaWdodEFycm93JywgWzg1OTZdXSwgWydMZWZ0cmlnaHRhcnJvdycsIFs4NjYwXV0sIFsnbGVmdHJpZ2h0YXJyb3dzJywgWzg2NDZdXSwgWydsZWZ0cmlnaHRoYXJwb29ucycsIFs4NjUxXV0sIFsnbGVmdHJpZ2h0c3F1aWdhcnJvdycsIFs4NjIxXV0sIFsnTGVmdFJpZ2h0VmVjdG9yJywgWzEwNTc0XV0sIFsnTGVmdFRlZUFycm93JywgWzg2MTJdXSwgWydMZWZ0VGVlJywgWzg4NjddXSwgWydMZWZ0VGVlVmVjdG9yJywgWzEwNTg2XV0sIFsnbGVmdHRocmVldGltZXMnLCBbODkwN11dLCBbJ0xlZnRUcmlhbmdsZUJhcicsIFsxMDcwM11dLCBbJ0xlZnRUcmlhbmdsZScsIFs4ODgyXV0sIFsnTGVmdFRyaWFuZ2xlRXF1YWwnLCBbODg4NF1dLCBbJ0xlZnRVcERvd25WZWN0b3InLCBbMTA1NzddXSwgWydMZWZ0VXBUZWVWZWN0b3InLCBbMTA1OTJdXSwgWydMZWZ0VXBWZWN0b3JCYXInLCBbMTA1ODRdXSwgWydMZWZ0VXBWZWN0b3InLCBbODYzOV1dLCBbJ0xlZnRWZWN0b3JCYXInLCBbMTA1NzhdXSwgWydMZWZ0VmVjdG9yJywgWzg2MzZdXSwgWydsRWcnLCBbMTA4OTFdXSwgWydsZWcnLCBbODkyMl1dLCBbJ2xlcScsIFs4ODA0XV0sIFsnbGVxcScsIFs4ODA2XV0sIFsnbGVxc2xhbnQnLCBbMTA4NzddXSwgWydsZXNjYycsIFsxMDkyMF1dLCBbJ2xlcycsIFsxMDg3N11dLCBbJ2xlc2RvdCcsIFsxMDg3OV1dLCBbJ2xlc2RvdG8nLCBbMTA4ODFdXSwgWydsZXNkb3RvcicsIFsxMDg4M11dLCBbJ2xlc2cnLCBbODkyMiwgNjUwMjRdXSwgWydsZXNnZXMnLCBbMTA4OTldXSwgWydsZXNzYXBwcm94JywgWzEwODg1XV0sIFsnbGVzc2RvdCcsIFs4OTE4XV0sIFsnbGVzc2VxZ3RyJywgWzg5MjJdXSwgWydsZXNzZXFxZ3RyJywgWzEwODkxXV0sIFsnTGVzc0VxdWFsR3JlYXRlcicsIFs4OTIyXV0sIFsnTGVzc0Z1bGxFcXVhbCcsIFs4ODA2XV0sIFsnTGVzc0dyZWF0ZXInLCBbODgyMl1dLCBbJ2xlc3NndHInLCBbODgyMl1dLCBbJ0xlc3NMZXNzJywgWzEwOTEzXV0sIFsnbGVzc3NpbScsIFs4ODE4XV0sIFsnTGVzc1NsYW50RXF1YWwnLCBbMTA4NzddXSwgWydMZXNzVGlsZGUnLCBbODgxOF1dLCBbJ2xmaXNodCcsIFsxMDYyMF1dLCBbJ2xmbG9vcicsIFs4OTcwXV0sIFsnTGZyJywgWzEyMDA3OV1dLCBbJ2xmcicsIFsxMjAxMDVdXSwgWydsZycsIFs4ODIyXV0sIFsnbGdFJywgWzEwODk3XV0sIFsnbEhhcicsIFsxMDU5NF1dLCBbJ2xoYXJkJywgWzg2MzddXSwgWydsaGFydScsIFs4NjM2XV0sIFsnbGhhcnVsJywgWzEwNjAyXV0sIFsnbGhibGsnLCBbOTYwNF1dLCBbJ0xKY3knLCBbMTAzM11dLCBbJ2xqY3knLCBbMTExM11dLCBbJ2xsYXJyJywgWzg2NDddXSwgWydsbCcsIFs4ODEwXV0sIFsnTGwnLCBbODkyMF1dLCBbJ2xsY29ybmVyJywgWzg5OTBdXSwgWydMbGVmdGFycm93JywgWzg2NjZdXSwgWydsbGhhcmQnLCBbMTA2MDNdXSwgWydsbHRyaScsIFs5NzIyXV0sIFsnTG1pZG90JywgWzMxOV1dLCBbJ2xtaWRvdCcsIFszMjBdXSwgWydsbW91c3RhY2hlJywgWzkxMzZdXSwgWydsbW91c3QnLCBbOTEzNl1dLCBbJ2xuYXAnLCBbMTA4ODldXSwgWydsbmFwcHJveCcsIFsxMDg4OV1dLCBbJ2xuZScsIFsxMDg4N11dLCBbJ2xuRScsIFs4ODA4XV0sIFsnbG5lcScsIFsxMDg4N11dLCBbJ2xuZXFxJywgWzg4MDhdXSwgWydsbnNpbScsIFs4OTM0XV0sIFsnbG9hbmcnLCBbMTAyMjBdXSwgWydsb2FycicsIFs4NzAxXV0sIFsnbG9icmsnLCBbMTAyMTRdXSwgWydsb25nbGVmdGFycm93JywgWzEwMjI5XV0sIFsnTG9uZ0xlZnRBcnJvdycsIFsxMDIyOV1dLCBbJ0xvbmdsZWZ0YXJyb3cnLCBbMTAyMzJdXSwgWydsb25nbGVmdHJpZ2h0YXJyb3cnLCBbMTAyMzFdXSwgWydMb25nTGVmdFJpZ2h0QXJyb3cnLCBbMTAyMzFdXSwgWydMb25nbGVmdHJpZ2h0YXJyb3cnLCBbMTAyMzRdXSwgWydsb25nbWFwc3RvJywgWzEwMjM2XV0sIFsnbG9uZ3JpZ2h0YXJyb3cnLCBbMTAyMzBdXSwgWydMb25nUmlnaHRBcnJvdycsIFsxMDIzMF1dLCBbJ0xvbmdyaWdodGFycm93JywgWzEwMjMzXV0sIFsnbG9vcGFycm93bGVmdCcsIFs4NjE5XV0sIFsnbG9vcGFycm93cmlnaHQnLCBbODYyMF1dLCBbJ2xvcGFyJywgWzEwNjI5XV0sIFsnTG9wZicsIFsxMjAxMzFdXSwgWydsb3BmJywgWzEyMDE1N11dLCBbJ2xvcGx1cycsIFsxMDc5N11dLCBbJ2xvdGltZXMnLCBbMTA4MDRdXSwgWydsb3dhc3QnLCBbODcyN11dLCBbJ2xvd2JhcicsIFs5NV1dLCBbJ0xvd2VyTGVmdEFycm93JywgWzg2MDFdXSwgWydMb3dlclJpZ2h0QXJyb3cnLCBbODYwMF1dLCBbJ2xveicsIFs5Njc0XV0sIFsnbG96ZW5nZScsIFs5Njc0XV0sIFsnbG96ZicsIFsxMDczMV1dLCBbJ2xwYXInLCBbNDBdXSwgWydscGFybHQnLCBbMTA2NDNdXSwgWydscmFycicsIFs4NjQ2XV0sIFsnbHJjb3JuZXInLCBbODk5MV1dLCBbJ2xyaGFyJywgWzg2NTFdXSwgWydscmhhcmQnLCBbMTA2MDVdXSwgWydscm0nLCBbODIwNl1dLCBbJ2xydHJpJywgWzg4OTVdXSwgWydsc2FxdW8nLCBbODI0OV1dLCBbJ2xzY3InLCBbMTIwMDAxXV0sIFsnTHNjcicsIFs4NDY2XV0sIFsnbHNoJywgWzg2MjRdXSwgWydMc2gnLCBbODYyNF1dLCBbJ2xzaW0nLCBbODgxOF1dLCBbJ2xzaW1lJywgWzEwODkzXV0sIFsnbHNpbWcnLCBbMTA4OTVdXSwgWydsc3FiJywgWzkxXV0sIFsnbHNxdW8nLCBbODIxNl1dLCBbJ2xzcXVvcicsIFs4MjE4XV0sIFsnTHN0cm9rJywgWzMyMV1dLCBbJ2xzdHJvaycsIFszMjJdXSwgWydsdGNjJywgWzEwOTE4XV0sIFsnbHRjaXInLCBbMTA4NzNdXSwgWydsdCcsIFs2MF1dLCBbJ0xUJywgWzYwXV0sIFsnTHQnLCBbODgxMF1dLCBbJ2x0ZG90JywgWzg5MThdXSwgWydsdGhyZWUnLCBbODkwN11dLCBbJ2x0aW1lcycsIFs4OTA1XV0sIFsnbHRsYXJyJywgWzEwNjE0XV0sIFsnbHRxdWVzdCcsIFsxMDg3NV1dLCBbJ2x0cmknLCBbOTY2N11dLCBbJ2x0cmllJywgWzg4ODRdXSwgWydsdHJpZicsIFs5NjY2XV0sIFsnbHRyUGFyJywgWzEwNjQ2XV0sIFsnbHVyZHNoYXInLCBbMTA1NzBdXSwgWydsdXJ1aGFyJywgWzEwNTk4XV0sIFsnbHZlcnRuZXFxJywgWzg4MDgsIDY1MDI0XV0sIFsnbHZuRScsIFs4ODA4LCA2NTAyNF1dLCBbJ21hY3InLCBbMTc1XV0sIFsnbWFsZScsIFs5Nzk0XV0sIFsnbWFsdCcsIFsxMDAxNl1dLCBbJ21hbHRlc2UnLCBbMTAwMTZdXSwgWydNYXAnLCBbMTA1MDFdXSwgWydtYXAnLCBbODYxNF1dLCBbJ21hcHN0bycsIFs4NjE0XV0sIFsnbWFwc3RvZG93bicsIFs4NjE1XV0sIFsnbWFwc3RvbGVmdCcsIFs4NjEyXV0sIFsnbWFwc3RvdXAnLCBbODYxM11dLCBbJ21hcmtlcicsIFs5NjQ2XV0sIFsnbWNvbW1hJywgWzEwNzkzXV0sIFsnTWN5JywgWzEwNTJdXSwgWydtY3knLCBbMTA4NF1dLCBbJ21kYXNoJywgWzgyMTJdXSwgWydtRERvdCcsIFs4NzYyXV0sIFsnbWVhc3VyZWRhbmdsZScsIFs4NzM3XV0sIFsnTWVkaXVtU3BhY2UnLCBbODI4N11dLCBbJ01lbGxpbnRyZicsIFs4NDk5XV0sIFsnTWZyJywgWzEyMDA4MF1dLCBbJ21mcicsIFsxMjAxMDZdXSwgWydtaG8nLCBbODQ4N11dLCBbJ21pY3JvJywgWzE4MV1dLCBbJ21pZGFzdCcsIFs0Ml1dLCBbJ21pZGNpcicsIFsxMDk5Ml1dLCBbJ21pZCcsIFs4NzM5XV0sIFsnbWlkZG90JywgWzE4M11dLCBbJ21pbnVzYicsIFs4ODYzXV0sIFsnbWludXMnLCBbODcyMl1dLCBbJ21pbnVzZCcsIFs4NzYwXV0sIFsnbWludXNkdScsIFsxMDc5NF1dLCBbJ01pbnVzUGx1cycsIFs4NzIzXV0sIFsnbWxjcCcsIFsxMDk3MV1dLCBbJ21sZHInLCBbODIzMF1dLCBbJ21ucGx1cycsIFs4NzIzXV0sIFsnbW9kZWxzJywgWzg4NzFdXSwgWydNb3BmJywgWzEyMDEzMl1dLCBbJ21vcGYnLCBbMTIwMTU4XV0sIFsnbXAnLCBbODcyM11dLCBbJ21zY3InLCBbMTIwMDAyXV0sIFsnTXNjcicsIFs4NDk5XV0sIFsnbXN0cG9zJywgWzg3NjZdXSwgWydNdScsIFs5MjRdXSwgWydtdScsIFs5NTZdXSwgWydtdWx0aW1hcCcsIFs4ODg4XV0sIFsnbXVtYXAnLCBbODg4OF1dLCBbJ25hYmxhJywgWzg3MTFdXSwgWydOYWN1dGUnLCBbMzIzXV0sIFsnbmFjdXRlJywgWzMyNF1dLCBbJ25hbmcnLCBbODczNiwgODQwMl1dLCBbJ25hcCcsIFs4Nzc3XV0sIFsnbmFwRScsIFsxMDg2NCwgODI0XV0sIFsnbmFwaWQnLCBbODc3OSwgODI0XV0sIFsnbmFwb3MnLCBbMzI5XV0sIFsnbmFwcHJveCcsIFs4Nzc3XV0sIFsnbmF0dXJhbCcsIFs5ODM4XV0sIFsnbmF0dXJhbHMnLCBbODQ2OV1dLCBbJ25hdHVyJywgWzk4MzhdXSwgWyduYnNwJywgWzE2MF1dLCBbJ25idW1wJywgWzg3ODIsIDgyNF1dLCBbJ25idW1wZScsIFs4NzgzLCA4MjRdXSwgWyduY2FwJywgWzEwODE5XV0sIFsnTmNhcm9uJywgWzMyN11dLCBbJ25jYXJvbicsIFszMjhdXSwgWydOY2VkaWwnLCBbMzI1XV0sIFsnbmNlZGlsJywgWzMyNl1dLCBbJ25jb25nJywgWzg3NzVdXSwgWyduY29uZ2RvdCcsIFsxMDg2MSwgODI0XV0sIFsnbmN1cCcsIFsxMDgxOF1dLCBbJ05jeScsIFsxMDUzXV0sIFsnbmN5JywgWzEwODVdXSwgWyduZGFzaCcsIFs4MjExXV0sIFsnbmVhcmhrJywgWzEwNTMyXV0sIFsnbmVhcnInLCBbODU5OV1dLCBbJ25lQXJyJywgWzg2NjNdXSwgWyduZWFycm93JywgWzg1OTldXSwgWyduZScsIFs4ODAwXV0sIFsnbmVkb3QnLCBbODc4NCwgODI0XV0sIFsnTmVnYXRpdmVNZWRpdW1TcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVUaGlja1NwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVRoaW5TcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVWZXJ5VGhpblNwYWNlJywgWzgyMDNdXSwgWyduZXF1aXYnLCBbODgwMl1dLCBbJ25lc2VhcicsIFsxMDUzNl1dLCBbJ25lc2ltJywgWzg3NzAsIDgyNF1dLCBbJ05lc3RlZEdyZWF0ZXJHcmVhdGVyJywgWzg4MTFdXSwgWydOZXN0ZWRMZXNzTGVzcycsIFs4ODEwXV0sIFsnbmV4aXN0JywgWzg3MDhdXSwgWyduZXhpc3RzJywgWzg3MDhdXSwgWydOZnInLCBbMTIwMDgxXV0sIFsnbmZyJywgWzEyMDEwN11dLCBbJ25nRScsIFs4ODA3LCA4MjRdXSwgWyduZ2UnLCBbODgxN11dLCBbJ25nZXEnLCBbODgxN11dLCBbJ25nZXFxJywgWzg4MDcsIDgyNF1dLCBbJ25nZXFzbGFudCcsIFsxMDg3OCwgODI0XV0sIFsnbmdlcycsIFsxMDg3OCwgODI0XV0sIFsnbkdnJywgWzg5MjEsIDgyNF1dLCBbJ25nc2ltJywgWzg4MjFdXSwgWyduR3QnLCBbODgxMSwgODQwMl1dLCBbJ25ndCcsIFs4ODE1XV0sIFsnbmd0cicsIFs4ODE1XV0sIFsnbkd0dicsIFs4ODExLCA4MjRdXSwgWyduaGFycicsIFs4NjIyXV0sIFsnbmhBcnInLCBbODY1NF1dLCBbJ25ocGFyJywgWzEwOTk0XV0sIFsnbmknLCBbODcxNV1dLCBbJ25pcycsIFs4OTU2XV0sIFsnbmlzZCcsIFs4OTU0XV0sIFsnbml2JywgWzg3MTVdXSwgWydOSmN5JywgWzEwMzRdXSwgWyduamN5JywgWzExMTRdXSwgWydubGFycicsIFs4NjAyXV0sIFsnbmxBcnInLCBbODY1M11dLCBbJ25sZHInLCBbODIyOV1dLCBbJ25sRScsIFs4ODA2LCA4MjRdXSwgWydubGUnLCBbODgxNl1dLCBbJ25sZWZ0YXJyb3cnLCBbODYwMl1dLCBbJ25MZWZ0YXJyb3cnLCBbODY1M11dLCBbJ25sZWZ0cmlnaHRhcnJvdycsIFs4NjIyXV0sIFsnbkxlZnRyaWdodGFycm93JywgWzg2NTRdXSwgWydubGVxJywgWzg4MTZdXSwgWydubGVxcScsIFs4ODA2LCA4MjRdXSwgWydubGVxc2xhbnQnLCBbMTA4NzcsIDgyNF1dLCBbJ25sZXMnLCBbMTA4NzcsIDgyNF1dLCBbJ25sZXNzJywgWzg4MTRdXSwgWyduTGwnLCBbODkyMCwgODI0XV0sIFsnbmxzaW0nLCBbODgyMF1dLCBbJ25MdCcsIFs4ODEwLCA4NDAyXV0sIFsnbmx0JywgWzg4MTRdXSwgWydubHRyaScsIFs4OTM4XV0sIFsnbmx0cmllJywgWzg5NDBdXSwgWyduTHR2JywgWzg4MTAsIDgyNF1dLCBbJ25taWQnLCBbODc0MF1dLCBbJ05vQnJlYWsnLCBbODI4OF1dLCBbJ05vbkJyZWFraW5nU3BhY2UnLCBbMTYwXV0sIFsnbm9wZicsIFsxMjAxNTldXSwgWydOb3BmJywgWzg0NjldXSwgWydOb3QnLCBbMTA5ODhdXSwgWydub3QnLCBbMTcyXV0sIFsnTm90Q29uZ3J1ZW50JywgWzg4MDJdXSwgWydOb3RDdXBDYXAnLCBbODgxM11dLCBbJ05vdERvdWJsZVZlcnRpY2FsQmFyJywgWzg3NDJdXSwgWydOb3RFbGVtZW50JywgWzg3MTNdXSwgWydOb3RFcXVhbCcsIFs4ODAwXV0sIFsnTm90RXF1YWxUaWxkZScsIFs4NzcwLCA4MjRdXSwgWydOb3RFeGlzdHMnLCBbODcwOF1dLCBbJ05vdEdyZWF0ZXInLCBbODgxNV1dLCBbJ05vdEdyZWF0ZXJFcXVhbCcsIFs4ODE3XV0sIFsnTm90R3JlYXRlckZ1bGxFcXVhbCcsIFs4ODA3LCA4MjRdXSwgWydOb3RHcmVhdGVyR3JlYXRlcicsIFs4ODExLCA4MjRdXSwgWydOb3RHcmVhdGVyTGVzcycsIFs4ODI1XV0sIFsnTm90R3JlYXRlclNsYW50RXF1YWwnLCBbMTA4NzgsIDgyNF1dLCBbJ05vdEdyZWF0ZXJUaWxkZScsIFs4ODIxXV0sIFsnTm90SHVtcERvd25IdW1wJywgWzg3ODIsIDgyNF1dLCBbJ05vdEh1bXBFcXVhbCcsIFs4NzgzLCA4MjRdXSwgWydub3RpbicsIFs4NzEzXV0sIFsnbm90aW5kb3QnLCBbODk0OSwgODI0XV0sIFsnbm90aW5FJywgWzg5NTMsIDgyNF1dLCBbJ25vdGludmEnLCBbODcxM11dLCBbJ25vdGludmInLCBbODk1MV1dLCBbJ25vdGludmMnLCBbODk1MF1dLCBbJ05vdExlZnRUcmlhbmdsZUJhcicsIFsxMDcwMywgODI0XV0sIFsnTm90TGVmdFRyaWFuZ2xlJywgWzg5MzhdXSwgWydOb3RMZWZ0VHJpYW5nbGVFcXVhbCcsIFs4OTQwXV0sIFsnTm90TGVzcycsIFs4ODE0XV0sIFsnTm90TGVzc0VxdWFsJywgWzg4MTZdXSwgWydOb3RMZXNzR3JlYXRlcicsIFs4ODI0XV0sIFsnTm90TGVzc0xlc3MnLCBbODgxMCwgODI0XV0sIFsnTm90TGVzc1NsYW50RXF1YWwnLCBbMTA4NzcsIDgyNF1dLCBbJ05vdExlc3NUaWxkZScsIFs4ODIwXV0sIFsnTm90TmVzdGVkR3JlYXRlckdyZWF0ZXInLCBbMTA5MTQsIDgyNF1dLCBbJ05vdE5lc3RlZExlc3NMZXNzJywgWzEwOTEzLCA4MjRdXSwgWydub3RuaScsIFs4NzE2XV0sIFsnbm90bml2YScsIFs4NzE2XV0sIFsnbm90bml2YicsIFs4OTU4XV0sIFsnbm90bml2YycsIFs4OTU3XV0sIFsnTm90UHJlY2VkZXMnLCBbODgzMl1dLCBbJ05vdFByZWNlZGVzRXF1YWwnLCBbMTA5MjcsIDgyNF1dLCBbJ05vdFByZWNlZGVzU2xhbnRFcXVhbCcsIFs4OTI4XV0sIFsnTm90UmV2ZXJzZUVsZW1lbnQnLCBbODcxNl1dLCBbJ05vdFJpZ2h0VHJpYW5nbGVCYXInLCBbMTA3MDQsIDgyNF1dLCBbJ05vdFJpZ2h0VHJpYW5nbGUnLCBbODkzOV1dLCBbJ05vdFJpZ2h0VHJpYW5nbGVFcXVhbCcsIFs4OTQxXV0sIFsnTm90U3F1YXJlU3Vic2V0JywgWzg4NDcsIDgyNF1dLCBbJ05vdFNxdWFyZVN1YnNldEVxdWFsJywgWzg5MzBdXSwgWydOb3RTcXVhcmVTdXBlcnNldCcsIFs4ODQ4LCA4MjRdXSwgWydOb3RTcXVhcmVTdXBlcnNldEVxdWFsJywgWzg5MzFdXSwgWydOb3RTdWJzZXQnLCBbODgzNCwgODQwMl1dLCBbJ05vdFN1YnNldEVxdWFsJywgWzg4NDBdXSwgWydOb3RTdWNjZWVkcycsIFs4ODMzXV0sIFsnTm90U3VjY2VlZHNFcXVhbCcsIFsxMDkyOCwgODI0XV0sIFsnTm90U3VjY2VlZHNTbGFudEVxdWFsJywgWzg5MjldXSwgWydOb3RTdWNjZWVkc1RpbGRlJywgWzg4MzEsIDgyNF1dLCBbJ05vdFN1cGVyc2V0JywgWzg4MzUsIDg0MDJdXSwgWydOb3RTdXBlcnNldEVxdWFsJywgWzg4NDFdXSwgWydOb3RUaWxkZScsIFs4NzY5XV0sIFsnTm90VGlsZGVFcXVhbCcsIFs4NzcyXV0sIFsnTm90VGlsZGVGdWxsRXF1YWwnLCBbODc3NV1dLCBbJ05vdFRpbGRlVGlsZGUnLCBbODc3N11dLCBbJ05vdFZlcnRpY2FsQmFyJywgWzg3NDBdXSwgWyducGFyYWxsZWwnLCBbODc0Ml1dLCBbJ25wYXInLCBbODc0Ml1dLCBbJ25wYXJzbCcsIFsxMTAwNSwgODQyMV1dLCBbJ25wYXJ0JywgWzg3MDYsIDgyNF1dLCBbJ25wb2xpbnQnLCBbMTA3NzJdXSwgWyducHInLCBbODgzMl1dLCBbJ25wcmN1ZScsIFs4OTI4XV0sIFsnbnByZWMnLCBbODgzMl1dLCBbJ25wcmVjZXEnLCBbMTA5MjcsIDgyNF1dLCBbJ25wcmUnLCBbMTA5MjcsIDgyNF1dLCBbJ25yYXJyYycsIFsxMDU0NywgODI0XV0sIFsnbnJhcnInLCBbODYwM11dLCBbJ25yQXJyJywgWzg2NTVdXSwgWyducmFycncnLCBbODYwNSwgODI0XV0sIFsnbnJpZ2h0YXJyb3cnLCBbODYwM11dLCBbJ25SaWdodGFycm93JywgWzg2NTVdXSwgWyducnRyaScsIFs4OTM5XV0sIFsnbnJ0cmllJywgWzg5NDFdXSwgWyduc2MnLCBbODgzM11dLCBbJ25zY2N1ZScsIFs4OTI5XV0sIFsnbnNjZScsIFsxMDkyOCwgODI0XV0sIFsnTnNjcicsIFsxMTk5NzddXSwgWyduc2NyJywgWzEyMDAwM11dLCBbJ25zaG9ydG1pZCcsIFs4NzQwXV0sIFsnbnNob3J0cGFyYWxsZWwnLCBbODc0Ml1dLCBbJ25zaW0nLCBbODc2OV1dLCBbJ25zaW1lJywgWzg3NzJdXSwgWyduc2ltZXEnLCBbODc3Ml1dLCBbJ25zbWlkJywgWzg3NDBdXSwgWyduc3BhcicsIFs4NzQyXV0sIFsnbnNxc3ViZScsIFs4OTMwXV0sIFsnbnNxc3VwZScsIFs4OTMxXV0sIFsnbnN1YicsIFs4ODM2XV0sIFsnbnN1YkUnLCBbMTA5NDksIDgyNF1dLCBbJ25zdWJlJywgWzg4NDBdXSwgWyduc3Vic2V0JywgWzg4MzQsIDg0MDJdXSwgWyduc3Vic2V0ZXEnLCBbODg0MF1dLCBbJ25zdWJzZXRlcXEnLCBbMTA5NDksIDgyNF1dLCBbJ25zdWNjJywgWzg4MzNdXSwgWyduc3VjY2VxJywgWzEwOTI4LCA4MjRdXSwgWyduc3VwJywgWzg4MzddXSwgWyduc3VwRScsIFsxMDk1MCwgODI0XV0sIFsnbnN1cGUnLCBbODg0MV1dLCBbJ25zdXBzZXQnLCBbODgzNSwgODQwMl1dLCBbJ25zdXBzZXRlcScsIFs4ODQxXV0sIFsnbnN1cHNldGVxcScsIFsxMDk1MCwgODI0XV0sIFsnbnRnbCcsIFs4ODI1XV0sIFsnTnRpbGRlJywgWzIwOV1dLCBbJ250aWxkZScsIFsyNDFdXSwgWydudGxnJywgWzg4MjRdXSwgWydudHJpYW5nbGVsZWZ0JywgWzg5MzhdXSwgWydudHJpYW5nbGVsZWZ0ZXEnLCBbODk0MF1dLCBbJ250cmlhbmdsZXJpZ2h0JywgWzg5MzldXSwgWydudHJpYW5nbGVyaWdodGVxJywgWzg5NDFdXSwgWydOdScsIFs5MjVdXSwgWydudScsIFs5NTddXSwgWydudW0nLCBbMzVdXSwgWydudW1lcm8nLCBbODQ3MF1dLCBbJ251bXNwJywgWzgxOTldXSwgWydudmFwJywgWzg3ODEsIDg0MDJdXSwgWydudmRhc2gnLCBbODg3Nl1dLCBbJ252RGFzaCcsIFs4ODc3XV0sIFsnblZkYXNoJywgWzg4NzhdXSwgWyduVkRhc2gnLCBbODg3OV1dLCBbJ252Z2UnLCBbODgwNSwgODQwMl1dLCBbJ252Z3QnLCBbNjIsIDg0MDJdXSwgWydudkhhcnInLCBbMTA1MDBdXSwgWydudmluZmluJywgWzEwNzE4XV0sIFsnbnZsQXJyJywgWzEwNDk4XV0sIFsnbnZsZScsIFs4ODA0LCA4NDAyXV0sIFsnbnZsdCcsIFs2MCwgODQwMl1dLCBbJ252bHRyaWUnLCBbODg4NCwgODQwMl1dLCBbJ252ckFycicsIFsxMDQ5OV1dLCBbJ252cnRyaWUnLCBbODg4NSwgODQwMl1dLCBbJ252c2ltJywgWzg3NjQsIDg0MDJdXSwgWydud2FyaGsnLCBbMTA1MzFdXSwgWydud2FycicsIFs4NTk4XV0sIFsnbndBcnInLCBbODY2Ml1dLCBbJ253YXJyb3cnLCBbODU5OF1dLCBbJ253bmVhcicsIFsxMDUzNV1dLCBbJ09hY3V0ZScsIFsyMTFdXSwgWydvYWN1dGUnLCBbMjQzXV0sIFsnb2FzdCcsIFs4ODU5XV0sIFsnT2NpcmMnLCBbMjEyXV0sIFsnb2NpcmMnLCBbMjQ0XV0sIFsnb2NpcicsIFs4ODU4XV0sIFsnT2N5JywgWzEwNTRdXSwgWydvY3knLCBbMTA4Nl1dLCBbJ29kYXNoJywgWzg4NjFdXSwgWydPZGJsYWMnLCBbMzM2XV0sIFsnb2RibGFjJywgWzMzN11dLCBbJ29kaXYnLCBbMTA4MDhdXSwgWydvZG90JywgWzg4NTddXSwgWydvZHNvbGQnLCBbMTA2ODRdXSwgWydPRWxpZycsIFszMzhdXSwgWydvZWxpZycsIFszMzldXSwgWydvZmNpcicsIFsxMDY4N11dLCBbJ09mcicsIFsxMjAwODJdXSwgWydvZnInLCBbMTIwMTA4XV0sIFsnb2dvbicsIFs3MzFdXSwgWydPZ3JhdmUnLCBbMjEwXV0sIFsnb2dyYXZlJywgWzI0Ml1dLCBbJ29ndCcsIFsxMDY4OV1dLCBbJ29oYmFyJywgWzEwNjc3XV0sIFsnb2htJywgWzkzN11dLCBbJ29pbnQnLCBbODc1MF1dLCBbJ29sYXJyJywgWzg2MzRdXSwgWydvbGNpcicsIFsxMDY4Nl1dLCBbJ29sY3Jvc3MnLCBbMTA2ODNdXSwgWydvbGluZScsIFs4MjU0XV0sIFsnb2x0JywgWzEwNjg4XV0sIFsnT21hY3InLCBbMzMyXV0sIFsnb21hY3InLCBbMzMzXV0sIFsnT21lZ2EnLCBbOTM3XV0sIFsnb21lZ2EnLCBbOTY5XV0sIFsnT21pY3JvbicsIFs5MjddXSwgWydvbWljcm9uJywgWzk1OV1dLCBbJ29taWQnLCBbMTA2NzhdXSwgWydvbWludXMnLCBbODg1NF1dLCBbJ09vcGYnLCBbMTIwMTM0XV0sIFsnb29wZicsIFsxMjAxNjBdXSwgWydvcGFyJywgWzEwNjc5XV0sIFsnT3BlbkN1cmx5RG91YmxlUXVvdGUnLCBbODIyMF1dLCBbJ09wZW5DdXJseVF1b3RlJywgWzgyMTZdXSwgWydvcGVycCcsIFsxMDY4MV1dLCBbJ29wbHVzJywgWzg4NTNdXSwgWydvcmFycicsIFs4NjM1XV0sIFsnT3InLCBbMTA4MzZdXSwgWydvcicsIFs4NzQ0XV0sIFsnb3JkJywgWzEwODQ1XV0sIFsnb3JkZXInLCBbODUwMF1dLCBbJ29yZGVyb2YnLCBbODUwMF1dLCBbJ29yZGYnLCBbMTcwXV0sIFsnb3JkbScsIFsxODZdXSwgWydvcmlnb2YnLCBbODg4Nl1dLCBbJ29yb3InLCBbMTA4MzhdXSwgWydvcnNsb3BlJywgWzEwODM5XV0sIFsnb3J2JywgWzEwODQzXV0sIFsnb1MnLCBbOTQxNl1dLCBbJ09zY3InLCBbMTE5OTc4XV0sIFsnb3NjcicsIFs4NTAwXV0sIFsnT3NsYXNoJywgWzIxNl1dLCBbJ29zbGFzaCcsIFsyNDhdXSwgWydvc29sJywgWzg4NTZdXSwgWydPdGlsZGUnLCBbMjEzXV0sIFsnb3RpbGRlJywgWzI0NV1dLCBbJ290aW1lc2FzJywgWzEwODA2XV0sIFsnT3RpbWVzJywgWzEwODA3XV0sIFsnb3RpbWVzJywgWzg4NTVdXSwgWydPdW1sJywgWzIxNF1dLCBbJ291bWwnLCBbMjQ2XV0sIFsnb3ZiYXInLCBbOTAyMV1dLCBbJ092ZXJCYXInLCBbODI1NF1dLCBbJ092ZXJCcmFjZScsIFs5MTgyXV0sIFsnT3ZlckJyYWNrZXQnLCBbOTE0MF1dLCBbJ092ZXJQYXJlbnRoZXNpcycsIFs5MTgwXV0sIFsncGFyYScsIFsxODJdXSwgWydwYXJhbGxlbCcsIFs4NzQxXV0sIFsncGFyJywgWzg3NDFdXSwgWydwYXJzaW0nLCBbMTA5OTVdXSwgWydwYXJzbCcsIFsxMTAwNV1dLCBbJ3BhcnQnLCBbODcwNl1dLCBbJ1BhcnRpYWxEJywgWzg3MDZdXSwgWydQY3knLCBbMTA1NV1dLCBbJ3BjeScsIFsxMDg3XV0sIFsncGVyY250JywgWzM3XV0sIFsncGVyaW9kJywgWzQ2XV0sIFsncGVybWlsJywgWzgyNDBdXSwgWydwZXJwJywgWzg4NjldXSwgWydwZXJ0ZW5rJywgWzgyNDFdXSwgWydQZnInLCBbMTIwMDgzXV0sIFsncGZyJywgWzEyMDEwOV1dLCBbJ1BoaScsIFs5MzRdXSwgWydwaGknLCBbOTY2XV0sIFsncGhpdicsIFs5ODFdXSwgWydwaG1tYXQnLCBbODQ5OV1dLCBbJ3Bob25lJywgWzk3NDJdXSwgWydQaScsIFs5MjhdXSwgWydwaScsIFs5NjBdXSwgWydwaXRjaGZvcmsnLCBbODkxNl1dLCBbJ3BpdicsIFs5ODJdXSwgWydwbGFuY2snLCBbODQ2M11dLCBbJ3BsYW5ja2gnLCBbODQ2Ml1dLCBbJ3BsYW5rdicsIFs4NDYzXV0sIFsncGx1c2FjaXInLCBbMTA3ODddXSwgWydwbHVzYicsIFs4ODYyXV0sIFsncGx1c2NpcicsIFsxMDc4Nl1dLCBbJ3BsdXMnLCBbNDNdXSwgWydwbHVzZG8nLCBbODcyNF1dLCBbJ3BsdXNkdScsIFsxMDc4OV1dLCBbJ3BsdXNlJywgWzEwODY2XV0sIFsnUGx1c01pbnVzJywgWzE3N11dLCBbJ3BsdXNtbicsIFsxNzddXSwgWydwbHVzc2ltJywgWzEwNzkwXV0sIFsncGx1c3R3bycsIFsxMDc5MV1dLCBbJ3BtJywgWzE3N11dLCBbJ1BvaW5jYXJlcGxhbmUnLCBbODQ2MF1dLCBbJ3BvaW50aW50JywgWzEwNzczXV0sIFsncG9wZicsIFsxMjAxNjFdXSwgWydQb3BmJywgWzg0NzNdXSwgWydwb3VuZCcsIFsxNjNdXSwgWydwcmFwJywgWzEwOTM1XV0sIFsnUHInLCBbMTA5MzldXSwgWydwcicsIFs4ODI2XV0sIFsncHJjdWUnLCBbODgyOF1dLCBbJ3ByZWNhcHByb3gnLCBbMTA5MzVdXSwgWydwcmVjJywgWzg4MjZdXSwgWydwcmVjY3VybHllcScsIFs4ODI4XV0sIFsnUHJlY2VkZXMnLCBbODgyNl1dLCBbJ1ByZWNlZGVzRXF1YWwnLCBbMTA5MjddXSwgWydQcmVjZWRlc1NsYW50RXF1YWwnLCBbODgyOF1dLCBbJ1ByZWNlZGVzVGlsZGUnLCBbODgzMF1dLCBbJ3ByZWNlcScsIFsxMDkyN11dLCBbJ3ByZWNuYXBwcm94JywgWzEwOTM3XV0sIFsncHJlY25lcXEnLCBbMTA5MzNdXSwgWydwcmVjbnNpbScsIFs4OTM2XV0sIFsncHJlJywgWzEwOTI3XV0sIFsncHJFJywgWzEwOTMxXV0sIFsncHJlY3NpbScsIFs4ODMwXV0sIFsncHJpbWUnLCBbODI0Ml1dLCBbJ1ByaW1lJywgWzgyNDNdXSwgWydwcmltZXMnLCBbODQ3M11dLCBbJ3BybmFwJywgWzEwOTM3XV0sIFsncHJuRScsIFsxMDkzM11dLCBbJ3BybnNpbScsIFs4OTM2XV0sIFsncHJvZCcsIFs4NzE5XV0sIFsnUHJvZHVjdCcsIFs4NzE5XV0sIFsncHJvZmFsYXInLCBbOTAwNl1dLCBbJ3Byb2ZsaW5lJywgWzg5NzhdXSwgWydwcm9mc3VyZicsIFs4OTc5XV0sIFsncHJvcCcsIFs4NzMzXV0sIFsnUHJvcG9ydGlvbmFsJywgWzg3MzNdXSwgWydQcm9wb3J0aW9uJywgWzg3NTldXSwgWydwcm9wdG8nLCBbODczM11dLCBbJ3Byc2ltJywgWzg4MzBdXSwgWydwcnVyZWwnLCBbODg4MF1dLCBbJ1BzY3InLCBbMTE5OTc5XV0sIFsncHNjcicsIFsxMjAwMDVdXSwgWydQc2knLCBbOTM2XV0sIFsncHNpJywgWzk2OF1dLCBbJ3B1bmNzcCcsIFs4MjAwXV0sIFsnUWZyJywgWzEyMDA4NF1dLCBbJ3FmcicsIFsxMjAxMTBdXSwgWydxaW50JywgWzEwNzY0XV0sIFsncW9wZicsIFsxMjAxNjJdXSwgWydRb3BmJywgWzg0NzRdXSwgWydxcHJpbWUnLCBbODI3OV1dLCBbJ1FzY3InLCBbMTE5OTgwXV0sIFsncXNjcicsIFsxMjAwMDZdXSwgWydxdWF0ZXJuaW9ucycsIFs4NDYxXV0sIFsncXVhdGludCcsIFsxMDc3NF1dLCBbJ3F1ZXN0JywgWzYzXV0sIFsncXVlc3RlcScsIFs4Nzk5XV0sIFsncXVvdCcsIFszNF1dLCBbJ1FVT1QnLCBbMzRdXSwgWydyQWFycicsIFs4NjY3XV0sIFsncmFjZScsIFs4NzY1LCA4MTddXSwgWydSYWN1dGUnLCBbMzQwXV0sIFsncmFjdXRlJywgWzM0MV1dLCBbJ3JhZGljJywgWzg3MzBdXSwgWydyYWVtcHR5dicsIFsxMDY3NV1dLCBbJ3JhbmcnLCBbMTAyMTddXSwgWydSYW5nJywgWzEwMjE5XV0sIFsncmFuZ2QnLCBbMTA2NDJdXSwgWydyYW5nZScsIFsxMDY2MV1dLCBbJ3JhbmdsZScsIFsxMDIxN11dLCBbJ3JhcXVvJywgWzE4N11dLCBbJ3JhcnJhcCcsIFsxMDYxM11dLCBbJ3JhcnJiJywgWzg2NzddXSwgWydyYXJyYmZzJywgWzEwNTI4XV0sIFsncmFycmMnLCBbMTA1NDddXSwgWydyYXJyJywgWzg1OTRdXSwgWydSYXJyJywgWzg2MDhdXSwgWydyQXJyJywgWzg2NThdXSwgWydyYXJyZnMnLCBbMTA1MjZdXSwgWydyYXJyaGsnLCBbODYxOF1dLCBbJ3JhcnJscCcsIFs4NjIwXV0sIFsncmFycnBsJywgWzEwNTY1XV0sIFsncmFycnNpbScsIFsxMDYxMl1dLCBbJ1JhcnJ0bCcsIFsxMDUxOF1dLCBbJ3JhcnJ0bCcsIFs4NjExXV0sIFsncmFycncnLCBbODYwNV1dLCBbJ3JhdGFpbCcsIFsxMDUyMl1dLCBbJ3JBdGFpbCcsIFsxMDUyNF1dLCBbJ3JhdGlvJywgWzg3NThdXSwgWydyYXRpb25hbHMnLCBbODQ3NF1dLCBbJ3JiYXJyJywgWzEwNTA5XV0sIFsnckJhcnInLCBbMTA1MTFdXSwgWydSQmFycicsIFsxMDUxMl1dLCBbJ3JiYnJrJywgWzEwMDk5XV0sIFsncmJyYWNlJywgWzEyNV1dLCBbJ3JicmFjaycsIFs5M11dLCBbJ3JicmtlJywgWzEwNjM2XV0sIFsncmJya3NsZCcsIFsxMDYzOF1dLCBbJ3JicmtzbHUnLCBbMTA2NDBdXSwgWydSY2Fyb24nLCBbMzQ0XV0sIFsncmNhcm9uJywgWzM0NV1dLCBbJ1JjZWRpbCcsIFszNDJdXSwgWydyY2VkaWwnLCBbMzQzXV0sIFsncmNlaWwnLCBbODk2OV1dLCBbJ3JjdWInLCBbMTI1XV0sIFsnUmN5JywgWzEwNTZdXSwgWydyY3knLCBbMTA4OF1dLCBbJ3JkY2EnLCBbMTA1NTFdXSwgWydyZGxkaGFyJywgWzEwNjAxXV0sIFsncmRxdW8nLCBbODIyMV1dLCBbJ3JkcXVvcicsIFs4MjIxXV0sIFsnQ2xvc2VDdXJseURvdWJsZVF1b3RlJywgWzgyMjFdXSwgWydyZHNoJywgWzg2MjddXSwgWydyZWFsJywgWzg0NzZdXSwgWydyZWFsaW5lJywgWzg0NzVdXSwgWydyZWFscGFydCcsIFs4NDc2XV0sIFsncmVhbHMnLCBbODQ3N11dLCBbJ1JlJywgWzg0NzZdXSwgWydyZWN0JywgWzk2NDVdXSwgWydyZWcnLCBbMTc0XV0sIFsnUkVHJywgWzE3NF1dLCBbJ1JldmVyc2VFbGVtZW50JywgWzg3MTVdXSwgWydSZXZlcnNlRXF1aWxpYnJpdW0nLCBbODY1MV1dLCBbJ1JldmVyc2VVcEVxdWlsaWJyaXVtJywgWzEwNjA3XV0sIFsncmZpc2h0JywgWzEwNjIxXV0sIFsncmZsb29yJywgWzg5NzFdXSwgWydyZnInLCBbMTIwMTExXV0sIFsnUmZyJywgWzg0NzZdXSwgWydySGFyJywgWzEwNTk2XV0sIFsncmhhcmQnLCBbODY0MV1dLCBbJ3JoYXJ1JywgWzg2NDBdXSwgWydyaGFydWwnLCBbMTA2MDRdXSwgWydSaG8nLCBbOTI5XV0sIFsncmhvJywgWzk2MV1dLCBbJ3Job3YnLCBbMTAwOV1dLCBbJ1JpZ2h0QW5nbGVCcmFja2V0JywgWzEwMjE3XV0sIFsnUmlnaHRBcnJvd0JhcicsIFs4Njc3XV0sIFsncmlnaHRhcnJvdycsIFs4NTk0XV0sIFsnUmlnaHRBcnJvdycsIFs4NTk0XV0sIFsnUmlnaHRhcnJvdycsIFs4NjU4XV0sIFsnUmlnaHRBcnJvd0xlZnRBcnJvdycsIFs4NjQ0XV0sIFsncmlnaHRhcnJvd3RhaWwnLCBbODYxMV1dLCBbJ1JpZ2h0Q2VpbGluZycsIFs4OTY5XV0sIFsnUmlnaHREb3VibGVCcmFja2V0JywgWzEwMjE1XV0sIFsnUmlnaHREb3duVGVlVmVjdG9yJywgWzEwNTg5XV0sIFsnUmlnaHREb3duVmVjdG9yQmFyJywgWzEwNTgxXV0sIFsnUmlnaHREb3duVmVjdG9yJywgWzg2NDJdXSwgWydSaWdodEZsb29yJywgWzg5NzFdXSwgWydyaWdodGhhcnBvb25kb3duJywgWzg2NDFdXSwgWydyaWdodGhhcnBvb251cCcsIFs4NjQwXV0sIFsncmlnaHRsZWZ0YXJyb3dzJywgWzg2NDRdXSwgWydyaWdodGxlZnRoYXJwb29ucycsIFs4NjUyXV0sIFsncmlnaHRyaWdodGFycm93cycsIFs4NjQ5XV0sIFsncmlnaHRzcXVpZ2Fycm93JywgWzg2MDVdXSwgWydSaWdodFRlZUFycm93JywgWzg2MTRdXSwgWydSaWdodFRlZScsIFs4ODY2XV0sIFsnUmlnaHRUZWVWZWN0b3InLCBbMTA1ODddXSwgWydyaWdodHRocmVldGltZXMnLCBbODkwOF1dLCBbJ1JpZ2h0VHJpYW5nbGVCYXInLCBbMTA3MDRdXSwgWydSaWdodFRyaWFuZ2xlJywgWzg4ODNdXSwgWydSaWdodFRyaWFuZ2xlRXF1YWwnLCBbODg4NV1dLCBbJ1JpZ2h0VXBEb3duVmVjdG9yJywgWzEwNTc1XV0sIFsnUmlnaHRVcFRlZVZlY3RvcicsIFsxMDU4OF1dLCBbJ1JpZ2h0VXBWZWN0b3JCYXInLCBbMTA1ODBdXSwgWydSaWdodFVwVmVjdG9yJywgWzg2MzhdXSwgWydSaWdodFZlY3RvckJhcicsIFsxMDU3OV1dLCBbJ1JpZ2h0VmVjdG9yJywgWzg2NDBdXSwgWydyaW5nJywgWzczMF1dLCBbJ3Jpc2luZ2RvdHNlcScsIFs4Nzg3XV0sIFsncmxhcnInLCBbODY0NF1dLCBbJ3JsaGFyJywgWzg2NTJdXSwgWydybG0nLCBbODIwN11dLCBbJ3Jtb3VzdGFjaGUnLCBbOTEzN11dLCBbJ3Jtb3VzdCcsIFs5MTM3XV0sIFsncm5taWQnLCBbMTA5OTBdXSwgWydyb2FuZycsIFsxMDIyMV1dLCBbJ3JvYXJyJywgWzg3MDJdXSwgWydyb2JyaycsIFsxMDIxNV1dLCBbJ3JvcGFyJywgWzEwNjMwXV0sIFsncm9wZicsIFsxMjAxNjNdXSwgWydSb3BmJywgWzg0NzddXSwgWydyb3BsdXMnLCBbMTA3OThdXSwgWydyb3RpbWVzJywgWzEwODA1XV0sIFsnUm91bmRJbXBsaWVzJywgWzEwNjA4XV0sIFsncnBhcicsIFs0MV1dLCBbJ3JwYXJndCcsIFsxMDY0NF1dLCBbJ3JwcG9saW50JywgWzEwNzcwXV0sIFsncnJhcnInLCBbODY0OV1dLCBbJ1JyaWdodGFycm93JywgWzg2NjddXSwgWydyc2FxdW8nLCBbODI1MF1dLCBbJ3JzY3InLCBbMTIwMDA3XV0sIFsnUnNjcicsIFs4NDc1XV0sIFsncnNoJywgWzg2MjVdXSwgWydSc2gnLCBbODYyNV1dLCBbJ3JzcWInLCBbOTNdXSwgWydyc3F1bycsIFs4MjE3XV0sIFsncnNxdW9yJywgWzgyMTddXSwgWydDbG9zZUN1cmx5UXVvdGUnLCBbODIxN11dLCBbJ3J0aHJlZScsIFs4OTA4XV0sIFsncnRpbWVzJywgWzg5MDZdXSwgWydydHJpJywgWzk2NTddXSwgWydydHJpZScsIFs4ODg1XV0sIFsncnRyaWYnLCBbOTY1Nl1dLCBbJ3J0cmlsdHJpJywgWzEwNzAyXV0sIFsnUnVsZURlbGF5ZWQnLCBbMTA3NDBdXSwgWydydWx1aGFyJywgWzEwNjAwXV0sIFsncngnLCBbODQ3OF1dLCBbJ1NhY3V0ZScsIFszNDZdXSwgWydzYWN1dGUnLCBbMzQ3XV0sIFsnc2JxdW8nLCBbODIxOF1dLCBbJ3NjYXAnLCBbMTA5MzZdXSwgWydTY2Fyb24nLCBbMzUyXV0sIFsnc2Nhcm9uJywgWzM1M11dLCBbJ1NjJywgWzEwOTQwXV0sIFsnc2MnLCBbODgyN11dLCBbJ3NjY3VlJywgWzg4MjldXSwgWydzY2UnLCBbMTA5MjhdXSwgWydzY0UnLCBbMTA5MzJdXSwgWydTY2VkaWwnLCBbMzUwXV0sIFsnc2NlZGlsJywgWzM1MV1dLCBbJ1NjaXJjJywgWzM0OF1dLCBbJ3NjaXJjJywgWzM0OV1dLCBbJ3NjbmFwJywgWzEwOTM4XV0sIFsnc2NuRScsIFsxMDkzNF1dLCBbJ3NjbnNpbScsIFs4OTM3XV0sIFsnc2Nwb2xpbnQnLCBbMTA3NzFdXSwgWydzY3NpbScsIFs4ODMxXV0sIFsnU2N5JywgWzEwNTddXSwgWydzY3knLCBbMTA4OV1dLCBbJ3Nkb3RiJywgWzg4NjVdXSwgWydzZG90JywgWzg5MDFdXSwgWydzZG90ZScsIFsxMDg1NF1dLCBbJ3NlYXJoaycsIFsxMDUzM11dLCBbJ3NlYXJyJywgWzg2MDBdXSwgWydzZUFycicsIFs4NjY0XV0sIFsnc2VhcnJvdycsIFs4NjAwXV0sIFsnc2VjdCcsIFsxNjddXSwgWydzZW1pJywgWzU5XV0sIFsnc2Vzd2FyJywgWzEwNTM3XV0sIFsnc2V0bWludXMnLCBbODcyNl1dLCBbJ3NldG1uJywgWzg3MjZdXSwgWydzZXh0JywgWzEwMDM4XV0sIFsnU2ZyJywgWzEyMDA4Nl1dLCBbJ3NmcicsIFsxMjAxMTJdXSwgWydzZnJvd24nLCBbODk5NF1dLCBbJ3NoYXJwJywgWzk4MzldXSwgWydTSENIY3knLCBbMTA2NV1dLCBbJ3NoY2hjeScsIFsxMDk3XV0sIFsnU0hjeScsIFsxMDY0XV0sIFsnc2hjeScsIFsxMDk2XV0sIFsnU2hvcnREb3duQXJyb3cnLCBbODU5NV1dLCBbJ1Nob3J0TGVmdEFycm93JywgWzg1OTJdXSwgWydzaG9ydG1pZCcsIFs4NzM5XV0sIFsnc2hvcnRwYXJhbGxlbCcsIFs4NzQxXV0sIFsnU2hvcnRSaWdodEFycm93JywgWzg1OTRdXSwgWydTaG9ydFVwQXJyb3cnLCBbODU5M11dLCBbJ3NoeScsIFsxNzNdXSwgWydTaWdtYScsIFs5MzFdXSwgWydzaWdtYScsIFs5NjNdXSwgWydzaWdtYWYnLCBbOTYyXV0sIFsnc2lnbWF2JywgWzk2Ml1dLCBbJ3NpbScsIFs4NzY0XV0sIFsnc2ltZG90JywgWzEwODU4XV0sIFsnc2ltZScsIFs4NzcxXV0sIFsnc2ltZXEnLCBbODc3MV1dLCBbJ3NpbWcnLCBbMTA5MTBdXSwgWydzaW1nRScsIFsxMDkxMl1dLCBbJ3NpbWwnLCBbMTA5MDldXSwgWydzaW1sRScsIFsxMDkxMV1dLCBbJ3NpbW5lJywgWzg3NzRdXSwgWydzaW1wbHVzJywgWzEwNzg4XV0sIFsnc2ltcmFycicsIFsxMDYxMF1dLCBbJ3NsYXJyJywgWzg1OTJdXSwgWydTbWFsbENpcmNsZScsIFs4NzI4XV0sIFsnc21hbGxzZXRtaW51cycsIFs4NzI2XV0sIFsnc21hc2hwJywgWzEwODAzXV0sIFsnc21lcGFyc2wnLCBbMTA3MjRdXSwgWydzbWlkJywgWzg3MzldXSwgWydzbWlsZScsIFs4OTk1XV0sIFsnc210JywgWzEwOTIyXV0sIFsnc210ZScsIFsxMDkyNF1dLCBbJ3NtdGVzJywgWzEwOTI0LCA2NTAyNF1dLCBbJ1NPRlRjeScsIFsxMDY4XV0sIFsnc29mdGN5JywgWzExMDBdXSwgWydzb2xiYXInLCBbOTAyM11dLCBbJ3NvbGInLCBbMTA2OTJdXSwgWydzb2wnLCBbNDddXSwgWydTb3BmJywgWzEyMDEzOF1dLCBbJ3NvcGYnLCBbMTIwMTY0XV0sIFsnc3BhZGVzJywgWzk4MjRdXSwgWydzcGFkZXN1aXQnLCBbOTgyNF1dLCBbJ3NwYXInLCBbODc0MV1dLCBbJ3NxY2FwJywgWzg4NTFdXSwgWydzcWNhcHMnLCBbODg1MSwgNjUwMjRdXSwgWydzcWN1cCcsIFs4ODUyXV0sIFsnc3FjdXBzJywgWzg4NTIsIDY1MDI0XV0sIFsnU3FydCcsIFs4NzMwXV0sIFsnc3FzdWInLCBbODg0N11dLCBbJ3Nxc3ViZScsIFs4ODQ5XV0sIFsnc3FzdWJzZXQnLCBbODg0N11dLCBbJ3Nxc3Vic2V0ZXEnLCBbODg0OV1dLCBbJ3Nxc3VwJywgWzg4NDhdXSwgWydzcXN1cGUnLCBbODg1MF1dLCBbJ3Nxc3Vwc2V0JywgWzg4NDhdXSwgWydzcXN1cHNldGVxJywgWzg4NTBdXSwgWydzcXVhcmUnLCBbOTYzM11dLCBbJ1NxdWFyZScsIFs5NjMzXV0sIFsnU3F1YXJlSW50ZXJzZWN0aW9uJywgWzg4NTFdXSwgWydTcXVhcmVTdWJzZXQnLCBbODg0N11dLCBbJ1NxdWFyZVN1YnNldEVxdWFsJywgWzg4NDldXSwgWydTcXVhcmVTdXBlcnNldCcsIFs4ODQ4XV0sIFsnU3F1YXJlU3VwZXJzZXRFcXVhbCcsIFs4ODUwXV0sIFsnU3F1YXJlVW5pb24nLCBbODg1Ml1dLCBbJ3NxdWFyZicsIFs5NjQyXV0sIFsnc3F1JywgWzk2MzNdXSwgWydzcXVmJywgWzk2NDJdXSwgWydzcmFycicsIFs4NTk0XV0sIFsnU3NjcicsIFsxMTk5ODJdXSwgWydzc2NyJywgWzEyMDAwOF1dLCBbJ3NzZXRtbicsIFs4NzI2XV0sIFsnc3NtaWxlJywgWzg5OTVdXSwgWydzc3RhcmYnLCBbODkwMl1dLCBbJ1N0YXInLCBbODkwMl1dLCBbJ3N0YXInLCBbOTczNF1dLCBbJ3N0YXJmJywgWzk3MzNdXSwgWydzdHJhaWdodGVwc2lsb24nLCBbMTAxM11dLCBbJ3N0cmFpZ2h0cGhpJywgWzk4MV1dLCBbJ3N0cm5zJywgWzE3NV1dLCBbJ3N1YicsIFs4ODM0XV0sIFsnU3ViJywgWzg5MTJdXSwgWydzdWJkb3QnLCBbMTA5NDFdXSwgWydzdWJFJywgWzEwOTQ5XV0sIFsnc3ViZScsIFs4ODM4XV0sIFsnc3ViZWRvdCcsIFsxMDk0N11dLCBbJ3N1Ym11bHQnLCBbMTA5NDVdXSwgWydzdWJuRScsIFsxMDk1NV1dLCBbJ3N1Ym5lJywgWzg4NDJdXSwgWydzdWJwbHVzJywgWzEwOTQzXV0sIFsnc3VicmFycicsIFsxMDYxN11dLCBbJ3N1YnNldCcsIFs4ODM0XV0sIFsnU3Vic2V0JywgWzg5MTJdXSwgWydzdWJzZXRlcScsIFs4ODM4XV0sIFsnc3Vic2V0ZXFxJywgWzEwOTQ5XV0sIFsnU3Vic2V0RXF1YWwnLCBbODgzOF1dLCBbJ3N1YnNldG5lcScsIFs4ODQyXV0sIFsnc3Vic2V0bmVxcScsIFsxMDk1NV1dLCBbJ3N1YnNpbScsIFsxMDk1MV1dLCBbJ3N1YnN1YicsIFsxMDk2NV1dLCBbJ3N1YnN1cCcsIFsxMDk2M11dLCBbJ3N1Y2NhcHByb3gnLCBbMTA5MzZdXSwgWydzdWNjJywgWzg4MjddXSwgWydzdWNjY3VybHllcScsIFs4ODI5XV0sIFsnU3VjY2VlZHMnLCBbODgyN11dLCBbJ1N1Y2NlZWRzRXF1YWwnLCBbMTA5MjhdXSwgWydTdWNjZWVkc1NsYW50RXF1YWwnLCBbODgyOV1dLCBbJ1N1Y2NlZWRzVGlsZGUnLCBbODgzMV1dLCBbJ3N1Y2NlcScsIFsxMDkyOF1dLCBbJ3N1Y2NuYXBwcm94JywgWzEwOTM4XV0sIFsnc3VjY25lcXEnLCBbMTA5MzRdXSwgWydzdWNjbnNpbScsIFs4OTM3XV0sIFsnc3VjY3NpbScsIFs4ODMxXV0sIFsnU3VjaFRoYXQnLCBbODcxNV1dLCBbJ3N1bScsIFs4NzIxXV0sIFsnU3VtJywgWzg3MjFdXSwgWydzdW5nJywgWzk4MzRdXSwgWydzdXAxJywgWzE4NV1dLCBbJ3N1cDInLCBbMTc4XV0sIFsnc3VwMycsIFsxNzldXSwgWydzdXAnLCBbODgzNV1dLCBbJ1N1cCcsIFs4OTEzXV0sIFsnc3VwZG90JywgWzEwOTQyXV0sIFsnc3VwZHN1YicsIFsxMDk2OF1dLCBbJ3N1cEUnLCBbMTA5NTBdXSwgWydzdXBlJywgWzg4MzldXSwgWydzdXBlZG90JywgWzEwOTQ4XV0sIFsnU3VwZXJzZXQnLCBbODgzNV1dLCBbJ1N1cGVyc2V0RXF1YWwnLCBbODgzOV1dLCBbJ3N1cGhzb2wnLCBbMTAxODVdXSwgWydzdXBoc3ViJywgWzEwOTY3XV0sIFsnc3VwbGFycicsIFsxMDYxOV1dLCBbJ3N1cG11bHQnLCBbMTA5NDZdXSwgWydzdXBuRScsIFsxMDk1Nl1dLCBbJ3N1cG5lJywgWzg4NDNdXSwgWydzdXBwbHVzJywgWzEwOTQ0XV0sIFsnc3Vwc2V0JywgWzg4MzVdXSwgWydTdXBzZXQnLCBbODkxM11dLCBbJ3N1cHNldGVxJywgWzg4MzldXSwgWydzdXBzZXRlcXEnLCBbMTA5NTBdXSwgWydzdXBzZXRuZXEnLCBbODg0M11dLCBbJ3N1cHNldG5lcXEnLCBbMTA5NTZdXSwgWydzdXBzaW0nLCBbMTA5NTJdXSwgWydzdXBzdWInLCBbMTA5NjRdXSwgWydzdXBzdXAnLCBbMTA5NjZdXSwgWydzd2FyaGsnLCBbMTA1MzRdXSwgWydzd2FycicsIFs4NjAxXV0sIFsnc3dBcnInLCBbODY2NV1dLCBbJ3N3YXJyb3cnLCBbODYwMV1dLCBbJ3N3bndhcicsIFsxMDUzOF1dLCBbJ3N6bGlnJywgWzIyM11dLCBbJ1RhYicsIFs5XV0sIFsndGFyZ2V0JywgWzg5ODJdXSwgWydUYXUnLCBbOTMyXV0sIFsndGF1JywgWzk2NF1dLCBbJ3RicmsnLCBbOTE0MF1dLCBbJ1RjYXJvbicsIFszNTZdXSwgWyd0Y2Fyb24nLCBbMzU3XV0sIFsnVGNlZGlsJywgWzM1NF1dLCBbJ3RjZWRpbCcsIFszNTVdXSwgWydUY3knLCBbMTA1OF1dLCBbJ3RjeScsIFsxMDkwXV0sIFsndGRvdCcsIFs4NDExXV0sIFsndGVscmVjJywgWzg5ODFdXSwgWydUZnInLCBbMTIwMDg3XV0sIFsndGZyJywgWzEyMDExM11dLCBbJ3RoZXJlNCcsIFs4NzU2XV0sIFsndGhlcmVmb3JlJywgWzg3NTZdXSwgWydUaGVyZWZvcmUnLCBbODc1Nl1dLCBbJ1RoZXRhJywgWzkyMF1dLCBbJ3RoZXRhJywgWzk1Ml1dLCBbJ3RoZXRhc3ltJywgWzk3N11dLCBbJ3RoZXRhdicsIFs5NzddXSwgWyd0aGlja2FwcHJveCcsIFs4Nzc2XV0sIFsndGhpY2tzaW0nLCBbODc2NF1dLCBbJ1RoaWNrU3BhY2UnLCBbODI4NywgODIwMl1dLCBbJ1RoaW5TcGFjZScsIFs4MjAxXV0sIFsndGhpbnNwJywgWzgyMDFdXSwgWyd0aGthcCcsIFs4Nzc2XV0sIFsndGhrc2ltJywgWzg3NjRdXSwgWydUSE9STicsIFsyMjJdXSwgWyd0aG9ybicsIFsyNTRdXSwgWyd0aWxkZScsIFs3MzJdXSwgWydUaWxkZScsIFs4NzY0XV0sIFsnVGlsZGVFcXVhbCcsIFs4NzcxXV0sIFsnVGlsZGVGdWxsRXF1YWwnLCBbODc3M11dLCBbJ1RpbGRlVGlsZGUnLCBbODc3Nl1dLCBbJ3RpbWVzYmFyJywgWzEwODAxXV0sIFsndGltZXNiJywgWzg4NjRdXSwgWyd0aW1lcycsIFsyMTVdXSwgWyd0aW1lc2QnLCBbMTA4MDBdXSwgWyd0aW50JywgWzg3NDldXSwgWyd0b2VhJywgWzEwNTM2XV0sIFsndG9wYm90JywgWzkwMTRdXSwgWyd0b3BjaXInLCBbMTA5OTNdXSwgWyd0b3AnLCBbODg2OF1dLCBbJ1RvcGYnLCBbMTIwMTM5XV0sIFsndG9wZicsIFsxMjAxNjVdXSwgWyd0b3Bmb3JrJywgWzEwOTcwXV0sIFsndG9zYScsIFsxMDUzN11dLCBbJ3RwcmltZScsIFs4MjQ0XV0sIFsndHJhZGUnLCBbODQ4Ml1dLCBbJ1RSQURFJywgWzg0ODJdXSwgWyd0cmlhbmdsZScsIFs5NjUzXV0sIFsndHJpYW5nbGVkb3duJywgWzk2NjNdXSwgWyd0cmlhbmdsZWxlZnQnLCBbOTY2N11dLCBbJ3RyaWFuZ2xlbGVmdGVxJywgWzg4ODRdXSwgWyd0cmlhbmdsZXEnLCBbODc5Nl1dLCBbJ3RyaWFuZ2xlcmlnaHQnLCBbOTY1N11dLCBbJ3RyaWFuZ2xlcmlnaHRlcScsIFs4ODg1XV0sIFsndHJpZG90JywgWzk3MDhdXSwgWyd0cmllJywgWzg3OTZdXSwgWyd0cmltaW51cycsIFsxMDgxMF1dLCBbJ1RyaXBsZURvdCcsIFs4NDExXV0sIFsndHJpcGx1cycsIFsxMDgwOV1dLCBbJ3RyaXNiJywgWzEwNzAxXV0sIFsndHJpdGltZScsIFsxMDgxMV1dLCBbJ3RycGV6aXVtJywgWzkxODZdXSwgWydUc2NyJywgWzExOTk4M11dLCBbJ3RzY3InLCBbMTIwMDA5XV0sIFsnVFNjeScsIFsxMDYyXV0sIFsndHNjeScsIFsxMDk0XV0sIFsnVFNIY3knLCBbMTAzNV1dLCBbJ3RzaGN5JywgWzExMTVdXSwgWydUc3Ryb2snLCBbMzU4XV0sIFsndHN0cm9rJywgWzM1OV1dLCBbJ3R3aXh0JywgWzg4MTJdXSwgWyd0d29oZWFkbGVmdGFycm93JywgWzg2MDZdXSwgWyd0d29oZWFkcmlnaHRhcnJvdycsIFs4NjA4XV0sIFsnVWFjdXRlJywgWzIxOF1dLCBbJ3VhY3V0ZScsIFsyNTBdXSwgWyd1YXJyJywgWzg1OTNdXSwgWydVYXJyJywgWzg2MDddXSwgWyd1QXJyJywgWzg2NTddXSwgWydVYXJyb2NpcicsIFsxMDU2OV1dLCBbJ1VicmN5JywgWzEwMzhdXSwgWyd1YnJjeScsIFsxMTE4XV0sIFsnVWJyZXZlJywgWzM2NF1dLCBbJ3VicmV2ZScsIFszNjVdXSwgWydVY2lyYycsIFsyMTldXSwgWyd1Y2lyYycsIFsyNTFdXSwgWydVY3knLCBbMTA1OV1dLCBbJ3VjeScsIFsxMDkxXV0sIFsndWRhcnInLCBbODY0NV1dLCBbJ1VkYmxhYycsIFszNjhdXSwgWyd1ZGJsYWMnLCBbMzY5XV0sIFsndWRoYXInLCBbMTA2MDZdXSwgWyd1ZmlzaHQnLCBbMTA2MjJdXSwgWydVZnInLCBbMTIwMDg4XV0sIFsndWZyJywgWzEyMDExNF1dLCBbJ1VncmF2ZScsIFsyMTddXSwgWyd1Z3JhdmUnLCBbMjQ5XV0sIFsndUhhcicsIFsxMDU5NV1dLCBbJ3VoYXJsJywgWzg2MzldXSwgWyd1aGFycicsIFs4NjM4XV0sIFsndWhibGsnLCBbOTYwMF1dLCBbJ3VsY29ybicsIFs4OTg4XV0sIFsndWxjb3JuZXInLCBbODk4OF1dLCBbJ3VsY3JvcCcsIFs4OTc1XV0sIFsndWx0cmknLCBbOTcyMF1dLCBbJ1VtYWNyJywgWzM2Ml1dLCBbJ3VtYWNyJywgWzM2M11dLCBbJ3VtbCcsIFsxNjhdXSwgWydVbmRlckJhcicsIFs5NV1dLCBbJ1VuZGVyQnJhY2UnLCBbOTE4M11dLCBbJ1VuZGVyQnJhY2tldCcsIFs5MTQxXV0sIFsnVW5kZXJQYXJlbnRoZXNpcycsIFs5MTgxXV0sIFsnVW5pb24nLCBbODg5OV1dLCBbJ1VuaW9uUGx1cycsIFs4ODQ2XV0sIFsnVW9nb24nLCBbMzcwXV0sIFsndW9nb24nLCBbMzcxXV0sIFsnVW9wZicsIFsxMjAxNDBdXSwgWyd1b3BmJywgWzEyMDE2Nl1dLCBbJ1VwQXJyb3dCYXInLCBbMTA1MTRdXSwgWyd1cGFycm93JywgWzg1OTNdXSwgWydVcEFycm93JywgWzg1OTNdXSwgWydVcGFycm93JywgWzg2NTddXSwgWydVcEFycm93RG93bkFycm93JywgWzg2NDVdXSwgWyd1cGRvd25hcnJvdycsIFs4NTk3XV0sIFsnVXBEb3duQXJyb3cnLCBbODU5N11dLCBbJ1VwZG93bmFycm93JywgWzg2NjFdXSwgWydVcEVxdWlsaWJyaXVtJywgWzEwNjA2XV0sIFsndXBoYXJwb29ubGVmdCcsIFs4NjM5XV0sIFsndXBoYXJwb29ucmlnaHQnLCBbODYzOF1dLCBbJ3VwbHVzJywgWzg4NDZdXSwgWydVcHBlckxlZnRBcnJvdycsIFs4NTk4XV0sIFsnVXBwZXJSaWdodEFycm93JywgWzg1OTldXSwgWyd1cHNpJywgWzk2NV1dLCBbJ1Vwc2knLCBbOTc4XV0sIFsndXBzaWgnLCBbOTc4XV0sIFsnVXBzaWxvbicsIFs5MzNdXSwgWyd1cHNpbG9uJywgWzk2NV1dLCBbJ1VwVGVlQXJyb3cnLCBbODYxM11dLCBbJ1VwVGVlJywgWzg4NjldXSwgWyd1cHVwYXJyb3dzJywgWzg2NDhdXSwgWyd1cmNvcm4nLCBbODk4OV1dLCBbJ3VyY29ybmVyJywgWzg5ODldXSwgWyd1cmNyb3AnLCBbODk3NF1dLCBbJ1VyaW5nJywgWzM2Nl1dLCBbJ3VyaW5nJywgWzM2N11dLCBbJ3VydHJpJywgWzk3MjFdXSwgWydVc2NyJywgWzExOTk4NF1dLCBbJ3VzY3InLCBbMTIwMDEwXV0sIFsndXRkb3QnLCBbODk0NF1dLCBbJ1V0aWxkZScsIFszNjBdXSwgWyd1dGlsZGUnLCBbMzYxXV0sIFsndXRyaScsIFs5NjUzXV0sIFsndXRyaWYnLCBbOTY1Ml1dLCBbJ3V1YXJyJywgWzg2NDhdXSwgWydVdW1sJywgWzIyMF1dLCBbJ3V1bWwnLCBbMjUyXV0sIFsndXdhbmdsZScsIFsxMDY2M11dLCBbJ3ZhbmdydCcsIFsxMDY1Ml1dLCBbJ3ZhcmVwc2lsb24nLCBbMTAxM11dLCBbJ3ZhcmthcHBhJywgWzEwMDhdXSwgWyd2YXJub3RoaW5nJywgWzg3MDldXSwgWyd2YXJwaGknLCBbOTgxXV0sIFsndmFycGknLCBbOTgyXV0sIFsndmFycHJvcHRvJywgWzg3MzNdXSwgWyd2YXJyJywgWzg1OTddXSwgWyd2QXJyJywgWzg2NjFdXSwgWyd2YXJyaG8nLCBbMTAwOV1dLCBbJ3ZhcnNpZ21hJywgWzk2Ml1dLCBbJ3ZhcnN1YnNldG5lcScsIFs4ODQyLCA2NTAyNF1dLCBbJ3ZhcnN1YnNldG5lcXEnLCBbMTA5NTUsIDY1MDI0XV0sIFsndmFyc3Vwc2V0bmVxJywgWzg4NDMsIDY1MDI0XV0sIFsndmFyc3Vwc2V0bmVxcScsIFsxMDk1NiwgNjUwMjRdXSwgWyd2YXJ0aGV0YScsIFs5NzddXSwgWyd2YXJ0cmlhbmdsZWxlZnQnLCBbODg4Ml1dLCBbJ3ZhcnRyaWFuZ2xlcmlnaHQnLCBbODg4M11dLCBbJ3ZCYXInLCBbMTA5ODRdXSwgWydWYmFyJywgWzEwOTg3XV0sIFsndkJhcnYnLCBbMTA5ODVdXSwgWydWY3knLCBbMTA0Ml1dLCBbJ3ZjeScsIFsxMDc0XV0sIFsndmRhc2gnLCBbODg2Nl1dLCBbJ3ZEYXNoJywgWzg4NzJdXSwgWydWZGFzaCcsIFs4ODczXV0sIFsnVkRhc2gnLCBbODg3NV1dLCBbJ1ZkYXNobCcsIFsxMDk4Ml1dLCBbJ3ZlZWJhcicsIFs4ODkxXV0sIFsndmVlJywgWzg3NDRdXSwgWydWZWUnLCBbODg5N11dLCBbJ3ZlZWVxJywgWzg3OTRdXSwgWyd2ZWxsaXAnLCBbODk0Ml1dLCBbJ3ZlcmJhcicsIFsxMjRdXSwgWydWZXJiYXInLCBbODIxNF1dLCBbJ3ZlcnQnLCBbMTI0XV0sIFsnVmVydCcsIFs4MjE0XV0sIFsnVmVydGljYWxCYXInLCBbODczOV1dLCBbJ1ZlcnRpY2FsTGluZScsIFsxMjRdXSwgWydWZXJ0aWNhbFNlcGFyYXRvcicsIFsxMDA3Ml1dLCBbJ1ZlcnRpY2FsVGlsZGUnLCBbODc2OF1dLCBbJ1ZlcnlUaGluU3BhY2UnLCBbODIwMl1dLCBbJ1ZmcicsIFsxMjAwODldXSwgWyd2ZnInLCBbMTIwMTE1XV0sIFsndmx0cmknLCBbODg4Ml1dLCBbJ3Zuc3ViJywgWzg4MzQsIDg0MDJdXSwgWyd2bnN1cCcsIFs4ODM1LCA4NDAyXV0sIFsnVm9wZicsIFsxMjAxNDFdXSwgWyd2b3BmJywgWzEyMDE2N11dLCBbJ3Zwcm9wJywgWzg3MzNdXSwgWyd2cnRyaScsIFs4ODgzXV0sIFsnVnNjcicsIFsxMTk5ODVdXSwgWyd2c2NyJywgWzEyMDAxMV1dLCBbJ3ZzdWJuRScsIFsxMDk1NSwgNjUwMjRdXSwgWyd2c3VibmUnLCBbODg0MiwgNjUwMjRdXSwgWyd2c3VwbkUnLCBbMTA5NTYsIDY1MDI0XV0sIFsndnN1cG5lJywgWzg4NDMsIDY1MDI0XV0sIFsnVnZkYXNoJywgWzg4NzRdXSwgWyd2emlnemFnJywgWzEwNjUwXV0sIFsnV2NpcmMnLCBbMzcyXV0sIFsnd2NpcmMnLCBbMzczXV0sIFsnd2VkYmFyJywgWzEwODQ3XV0sIFsnd2VkZ2UnLCBbODc0M11dLCBbJ1dlZGdlJywgWzg4OTZdXSwgWyd3ZWRnZXEnLCBbODc5M11dLCBbJ3dlaWVycCcsIFs4NDcyXV0sIFsnV2ZyJywgWzEyMDA5MF1dLCBbJ3dmcicsIFsxMjAxMTZdXSwgWydXb3BmJywgWzEyMDE0Ml1dLCBbJ3dvcGYnLCBbMTIwMTY4XV0sIFsnd3AnLCBbODQ3Ml1dLCBbJ3dyJywgWzg3NjhdXSwgWyd3cmVhdGgnLCBbODc2OF1dLCBbJ1dzY3InLCBbMTE5OTg2XV0sIFsnd3NjcicsIFsxMjAwMTJdXSwgWyd4Y2FwJywgWzg4OThdXSwgWyd4Y2lyYycsIFs5NzExXV0sIFsneGN1cCcsIFs4ODk5XV0sIFsneGR0cmknLCBbOTY2MV1dLCBbJ1hmcicsIFsxMjAwOTFdXSwgWyd4ZnInLCBbMTIwMTE3XV0sIFsneGhhcnInLCBbMTAyMzFdXSwgWyd4aEFycicsIFsxMDIzNF1dLCBbJ1hpJywgWzkyNl1dLCBbJ3hpJywgWzk1OF1dLCBbJ3hsYXJyJywgWzEwMjI5XV0sIFsneGxBcnInLCBbMTAyMzJdXSwgWyd4bWFwJywgWzEwMjM2XV0sIFsneG5pcycsIFs4OTU1XV0sIFsneG9kb3QnLCBbMTA3NTJdXSwgWydYb3BmJywgWzEyMDE0M11dLCBbJ3hvcGYnLCBbMTIwMTY5XV0sIFsneG9wbHVzJywgWzEwNzUzXV0sIFsneG90aW1lJywgWzEwNzU0XV0sIFsneHJhcnInLCBbMTAyMzBdXSwgWyd4ckFycicsIFsxMDIzM11dLCBbJ1hzY3InLCBbMTE5OTg3XV0sIFsneHNjcicsIFsxMjAwMTNdXSwgWyd4c3FjdXAnLCBbMTA3NThdXSwgWyd4dXBsdXMnLCBbMTA3NTZdXSwgWyd4dXRyaScsIFs5NjUxXV0sIFsneHZlZScsIFs4ODk3XV0sIFsneHdlZGdlJywgWzg4OTZdXSwgWydZYWN1dGUnLCBbMjIxXV0sIFsneWFjdXRlJywgWzI1M11dLCBbJ1lBY3knLCBbMTA3MV1dLCBbJ3lhY3knLCBbMTEwM11dLCBbJ1ljaXJjJywgWzM3NF1dLCBbJ3ljaXJjJywgWzM3NV1dLCBbJ1ljeScsIFsxMDY3XV0sIFsneWN5JywgWzEwOTldXSwgWyd5ZW4nLCBbMTY1XV0sIFsnWWZyJywgWzEyMDA5Ml1dLCBbJ3lmcicsIFsxMjAxMThdXSwgWydZSWN5JywgWzEwMzFdXSwgWyd5aWN5JywgWzExMTFdXSwgWydZb3BmJywgWzEyMDE0NF1dLCBbJ3lvcGYnLCBbMTIwMTcwXV0sIFsnWXNjcicsIFsxMTk5ODhdXSwgWyd5c2NyJywgWzEyMDAxNF1dLCBbJ1lVY3knLCBbMTA3MF1dLCBbJ3l1Y3knLCBbMTEwMl1dLCBbJ3l1bWwnLCBbMjU1XV0sIFsnWXVtbCcsIFszNzZdXSwgWydaYWN1dGUnLCBbMzc3XV0sIFsnemFjdXRlJywgWzM3OF1dLCBbJ1pjYXJvbicsIFszODFdXSwgWyd6Y2Fyb24nLCBbMzgyXV0sIFsnWmN5JywgWzEwNDddXSwgWyd6Y3knLCBbMTA3OV1dLCBbJ1pkb3QnLCBbMzc5XV0sIFsnemRvdCcsIFszODBdXSwgWyd6ZWV0cmYnLCBbODQ4OF1dLCBbJ1plcm9XaWR0aFNwYWNlJywgWzgyMDNdXSwgWydaZXRhJywgWzkxOF1dLCBbJ3pldGEnLCBbOTUwXV0sIFsnemZyJywgWzEyMDExOV1dLCBbJ1pmcicsIFs4NDg4XV0sIFsnWkhjeScsIFsxMDQ2XV0sIFsnemhjeScsIFsxMDc4XV0sIFsnemlncmFycicsIFs4NjY5XV0sIFsnem9wZicsIFsxMjAxNzFdXSwgWydab3BmJywgWzg0ODRdXSwgWydac2NyJywgWzExOTk4OV1dLCBbJ3pzY3InLCBbMTIwMDE1XV0sIFsnendqJywgWzgyMDVdXSwgWyd6d25qJywgWzgyMDRdXV07XG5cbnZhciBhbHBoYUluZGV4ID0ge307XG52YXIgY2hhckluZGV4ID0ge307XG5cbmNyZWF0ZUluZGV4ZXMoYWxwaGFJbmRleCwgY2hhckluZGV4KTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSHRtbDVFbnRpdGllcygpIHt9XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYoIz9bXFx3XFxkXSspOz8vZywgZnVuY3Rpb24ocywgZW50aXR5KSB7XG4gICAgICAgIHZhciBjaHI7XG4gICAgICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBlbnRpdHkuY2hhckF0KDEpID09PSAneCcgP1xuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMikudG9Mb3dlckNhc2UoKSwgMTYpIDpcbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDEpKTtcblxuICAgICAgICAgICAgaWYgKCEoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpKSB7XG4gICAgICAgICAgICAgICAgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNociA9IGFscGhhSW5kZXhbZW50aXR5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hyIHx8IHM7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmRlY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGFySW5mbyA9IGNoYXJJbmRleFtzdHIuY2hhckNvZGVBdChpKV07XG4gICAgICAgIGlmIChjaGFySW5mbykge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gY2hhckluZm9bc3RyLmNoYXJDb2RlQXQoaSArIDEpXTtcbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxwaGEgPSBjaGFySW5mb1snJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgY2hhckluZm8gPSBjaGFySW5kZXhbY107XG4gICAgICAgIGlmIChjaGFySW5mbykge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gY2hhckluZm9bc3RyLmNoYXJDb2RlQXQoaSArIDEpXTtcbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxwaGEgPSBjaGFySW5mb1snJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8IDMyIHx8IGMgPiAxMjYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgaSsrXG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbHBoYUluZGV4IFBhc3NlZCBieSByZWZlcmVuY2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY2hhckluZGV4IFBhc3NlZCBieSByZWZlcmVuY2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluZGV4ZXMoYWxwaGFJbmRleCwgY2hhckluZGV4KSB7XG4gICAgdmFyIGkgPSBFTlRJVElFUy5sZW5ndGg7XG4gICAgdmFyIF9yZXN1bHRzID0gW107XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgZSA9IEVOVElUSUVTW2ldO1xuICAgICAgICB2YXIgYWxwaGEgPSBlWzBdO1xuICAgICAgICB2YXIgY2hhcnMgPSBlWzFdO1xuICAgICAgICB2YXIgY2hyID0gY2hhcnNbMF07XG4gICAgICAgIHZhciBhZGRDaGFyID0gKGNociA8IDMyIHx8IGNociA+IDEyNikgfHwgY2hyID09PSA2MiB8fCBjaHIgPT09IDYwIHx8IGNociA9PT0gMzggfHwgY2hyID09PSAzNCB8fCBjaHIgPT09IDM5O1xuICAgICAgICB2YXIgY2hhckluZm87XG4gICAgICAgIGlmIChhZGRDaGFyKSB7XG4gICAgICAgICAgICBjaGFySW5mbyA9IGNoYXJJbmRleFtjaHJdID0gY2hhckluZGV4W2Nocl0gfHwge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJzWzFdKSB7XG4gICAgICAgICAgICB2YXIgY2hyMiA9IGNoYXJzWzFdO1xuICAgICAgICAgICAgYWxwaGFJbmRleFthbHBoYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocikgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjIpO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChhZGRDaGFyICYmIChjaGFySW5mb1tjaHIyXSA9IGFscGhhKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbHBoYUluZGV4W2FscGhhXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goYWRkQ2hhciAmJiAoY2hhckluZm9bJyddID0gYWxwaGEpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sNUVudGl0aWVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2h0bWwtZW50aXRpZXMvbGliL2h0bWw1LWVudGl0aWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQge1lhd1BpdGNoQ29udHJvbH0gZnJvbSBcIi4vWWF3UGl0Y2hDb250cm9sXCI7XG5pbXBvcnQge1Bhbm9WaWV3ZXJ9IGZyb20gXCIuL1Bhbm9WaWV3ZXJcIjtcbmltcG9ydCB7U3BpblZpZXdlciwgU3ByaXRlSW1hZ2V9IGZyb20gXCIuL1NwaW5WaWV3ZXJcIjtcblxuY29uc3QgVkVSU0lPTiA9IFwiMy4wLjAtcmNcIjtcblxuZXhwb3J0IHtcblx0WWF3UGl0Y2hDb250cm9sLFxuXHRQYW5vVmlld2VyLFxuXHRTcGluVmlld2VyLFxuXHRTcHJpdGVJbWFnZSxcblx0VkVSU0lPTlxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG4vKiBlc2xpbnQgcHJlZmVyLWRlc3RydWN0dXJpbmc6IG9mZiAqL1xuXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG52YXIgc3RyaXBBbnNpID0gcmVxdWlyZSgnc3RyaXAtYW5zaScpO1xudmFyIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJykuZ2V0TG9nZ2VyKCd3ZWJwYWNrLWRldi1zZXJ2ZXInKTtcbnZhciBzb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xudmFyIG92ZXJsYXkgPSByZXF1aXJlKCcuL292ZXJsYXknKTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpIHtcbiAgLy8gYGRvY3VtZW50LmN1cnJlbnRTY3JpcHRgIGlzIHRoZSBtb3N0IGFjY3VyYXRlIHdheSB0byBmaW5kIHRoZSBjdXJyZW50IHNjcmlwdCxcbiAgLy8gYnV0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gYWxsIGJyb3dzZXJzLlxuICBpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gIH1cbiAgLy8gRmFsbCBiYWNrIHRvIGdldHRpbmcgYWxsIHNjcmlwdHMgaW4gdGhlIGRvY3VtZW50LlxuICB2YXIgc2NyaXB0RWxlbWVudHMgPSBkb2N1bWVudC5zY3JpcHRzIHx8IFtdO1xuICB2YXIgY3VycmVudFNjcmlwdCA9IHNjcmlwdEVsZW1lbnRzW3NjcmlwdEVsZW1lbnRzLmxlbmd0aCAtIDFdO1xuICBpZiAoY3VycmVudFNjcmlwdCkge1xuICAgIHJldHVybiBjdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gIH1cbiAgLy8gRmFpbCBhcyB0aGVyZSB3YXMgbm8gc2NyaXB0IHRvIHVzZS5cbiAgdGhyb3cgbmV3IEVycm9yKCdbV0RTXSBGYWlsZWQgdG8gZ2V0IGN1cnJlbnQgc2NyaXB0IHNvdXJjZS4nKTtcbn1cblxudmFyIHVybFBhcnRzID0gdm9pZCAwO1xudmFyIGhvdFJlbG9hZCA9IHRydWU7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIHFzID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC50b0xvd2VyQ2FzZSgpO1xuICBob3RSZWxvYWQgPSBxcy5pbmRleE9mKCdob3RyZWxvYWQ9ZmFsc2UnKSA9PT0gLTE7XG59XG5pZiAodHlwZW9mIF9fcmVzb3VyY2VRdWVyeSA9PT0gJ3N0cmluZycgJiYgX19yZXNvdXJjZVF1ZXJ5KSB7XG4gIC8vIElmIHRoaXMgYnVuZGxlIGlzIGlubGluZWQsIHVzZSB0aGUgcmVzb3VyY2UgcXVlcnkgdG8gZ2V0IHRoZSBjb3JyZWN0IHVybC5cbiAgdXJsUGFydHMgPSB1cmwucGFyc2UoX19yZXNvdXJjZVF1ZXJ5LnN1YnN0cigxKSk7XG59IGVsc2Uge1xuICAvLyBFbHNlLCBnZXQgdGhlIHVybCBmcm9tIHRoZSA8c2NyaXB0PiB0aGlzIGZpbGUgd2FzIGNhbGxlZCB3aXRoLlxuICB2YXIgc2NyaXB0SG9zdCA9IGdldEN1cnJlbnRTY3JpcHRTb3VyY2UoKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gIHNjcmlwdEhvc3QgPSBzY3JpcHRIb3N0LnJlcGxhY2UoL1xcL1teXFwvXSskLywgJycpO1xuICB1cmxQYXJ0cyA9IHVybC5wYXJzZShzY3JpcHRIb3N0IHx8ICcvJywgZmFsc2UsIHRydWUpO1xufVxuXG5pZiAoIXVybFBhcnRzLnBvcnQgfHwgdXJsUGFydHMucG9ydCA9PT0gJzAnKSB7XG4gIHVybFBhcnRzLnBvcnQgPSBzZWxmLmxvY2F0aW9uLnBvcnQ7XG59XG5cbnZhciBfaG90ID0gZmFsc2U7XG52YXIgaW5pdGlhbCA9IHRydWU7XG52YXIgY3VycmVudEhhc2ggPSAnJztcbnZhciB1c2VXYXJuaW5nT3ZlcmxheSA9IGZhbHNlO1xudmFyIHVzZUVycm9yT3ZlcmxheSA9IGZhbHNlO1xudmFyIHVzZVByb2dyZXNzID0gZmFsc2U7XG5cbnZhciBJTkZPID0gJ2luZm8nO1xudmFyIFdBUk5JTkcgPSAnd2FybmluZyc7XG52YXIgRVJST1IgPSAnZXJyb3InO1xudmFyIE5PTkUgPSAnbm9uZSc7XG5cbi8vIFNldCB0aGUgZGVmYXVsdCBsb2cgbGV2ZWxcbmxvZy5zZXREZWZhdWx0TGV2ZWwoSU5GTyk7XG5cbi8vIFNlbmQgbWVzc2FnZXMgdG8gdGhlIG91dHNpZGUsIHNvIHBsdWdpbnMgY2FuIGNvbnN1bWUgaXQuXG5mdW5jdGlvbiBzZW5kTXNnKHR5cGUsIGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlID09PSAndW5kZWZpbmVkJyB8fCAhKHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSkpKSB7XG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICB0eXBlOiAnd2VicGFjaycgKyB0eXBlLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0sICcqJyk7XG4gIH1cbn1cblxudmFyIG9uU29ja2V0TXNnID0ge1xuICBob3Q6IGZ1bmN0aW9uIGhvdCgpIHtcbiAgICBfaG90ID0gdHJ1ZTtcbiAgICBsb2cuaW5mbygnW1dEU10gSG90IE1vZHVsZSBSZXBsYWNlbWVudCBlbmFibGVkLicpO1xuICB9LFxuICBpbnZhbGlkOiBmdW5jdGlvbiBpbnZhbGlkKCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBBcHAgdXBkYXRlZC4gUmVjb21waWxpbmcuLi4nKTtcbiAgICAvLyBmaXhlcyAjMTA0Mi4gb3ZlcmxheSBkb2Vzbid0IGNsZWFyIGlmIGVycm9ycyBhcmUgZml4ZWQgYnV0IHdhcm5pbmdzIHJlbWFpbi5cbiAgICBpZiAodXNlV2FybmluZ092ZXJsYXkgfHwgdXNlRXJyb3JPdmVybGF5KSBvdmVybGF5LmNsZWFyKCk7XG4gICAgc2VuZE1zZygnSW52YWxpZCcpO1xuICB9LFxuICBoYXNoOiBmdW5jdGlvbiBoYXNoKF9oYXNoKSB7XG4gICAgY3VycmVudEhhc2ggPSBfaGFzaDtcbiAgfSxcblxuICAnc3RpbGwtb2snOiBmdW5jdGlvbiBzdGlsbE9rKCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBOb3RoaW5nIGNoYW5nZWQuJyk7XG4gICAgaWYgKHVzZVdhcm5pbmdPdmVybGF5IHx8IHVzZUVycm9yT3ZlcmxheSkgb3ZlcmxheS5jbGVhcigpO1xuICAgIHNlbmRNc2coJ1N0aWxsT2snKTtcbiAgfSxcbiAgJ2xvZy1sZXZlbCc6IGZ1bmN0aW9uIGxvZ0xldmVsKGxldmVsKSB7XG4gICAgdmFyIGhvdEN0eCA9IHJlcXVpcmUuY29udGV4dCgnd2VicGFjay9ob3QnLCBmYWxzZSwgL15cXC5cXC9sb2ckLyk7XG4gICAgaWYgKGhvdEN0eC5rZXlzKCkuaW5kZXhPZignLi9sb2cnKSAhPT0gLTEpIHtcbiAgICAgIGhvdEN0eCgnLi9sb2cnKS5zZXRMb2dMZXZlbChsZXZlbCk7XG4gICAgfVxuICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgIGNhc2UgSU5GTzpcbiAgICAgIGNhc2UgRVJST1I6XG4gICAgICAgIGxvZy5zZXRMZXZlbChsZXZlbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBXQVJOSU5HOlxuICAgICAgICAvLyBsb2dsZXZlbCdzIHdhcm5pbmcgbmFtZSBpcyBkaWZmZXJlbnQgZnJvbSB3ZWJwYWNrJ3NcbiAgICAgICAgbG9nLnNldExldmVsKCd3YXJuJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBOT05FOlxuICAgICAgICBsb2cuZGlzYWJsZUFsbCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxvZy5lcnJvcignW1dEU10gVW5rbm93biBjbGllbnRMb2dMZXZlbCBcXCcnICsgbGV2ZWwgKyAnXFwnJyk7XG4gICAgfVxuICB9LFxuICBvdmVybGF5OiBmdW5jdGlvbiBvdmVybGF5KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICB1c2VXYXJuaW5nT3ZlcmxheSA9IGZhbHNlO1xuICAgICAgICB1c2VFcnJvck92ZXJsYXkgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgdXNlV2FybmluZ092ZXJsYXkgPSB2YWx1ZS53YXJuaW5ncztcbiAgICAgICAgdXNlRXJyb3JPdmVybGF5ID0gdmFsdWUuZXJyb3JzO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKF9wcm9ncmVzcykge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB1c2VQcm9ncmVzcyA9IF9wcm9ncmVzcztcbiAgICB9XG4gIH0sXG5cbiAgJ3Byb2dyZXNzLXVwZGF0ZSc6IGZ1bmN0aW9uIHByb2dyZXNzVXBkYXRlKGRhdGEpIHtcbiAgICBpZiAodXNlUHJvZ3Jlc3MpIGxvZy5pbmZvKCdbV0RTXSAnICsgZGF0YS5wZXJjZW50ICsgJyUgLSAnICsgZGF0YS5tc2cgKyAnLicpO1xuICB9LFxuICBvazogZnVuY3Rpb24gb2soKSB7XG4gICAgc2VuZE1zZygnT2snKTtcbiAgICBpZiAodXNlV2FybmluZ092ZXJsYXkgfHwgdXNlRXJyb3JPdmVybGF5KSBvdmVybGF5LmNsZWFyKCk7XG4gICAgaWYgKGluaXRpYWwpIHJldHVybiBpbml0aWFsID0gZmFsc2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmV0dXJuLWFzc2lnblxuICAgIHJlbG9hZEFwcCgpO1xuICB9LFxuXG4gICdjb250ZW50LWNoYW5nZWQnOiBmdW5jdGlvbiBjb250ZW50Q2hhbmdlZCgpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQ29udGVudCBiYXNlIGNoYW5nZWQuIFJlbG9hZGluZy4uLicpO1xuICAgIHNlbGYubG9jYXRpb24ucmVsb2FkKCk7XG4gIH0sXG4gIHdhcm5pbmdzOiBmdW5jdGlvbiB3YXJuaW5ncyhfd2FybmluZ3MpIHtcbiAgICBsb2cud2FybignW1dEU10gV2FybmluZ3Mgd2hpbGUgY29tcGlsaW5nLicpO1xuICAgIHZhciBzdHJpcHBlZFdhcm5pbmdzID0gX3dhcm5pbmdzLm1hcChmdW5jdGlvbiAod2FybmluZykge1xuICAgICAgcmV0dXJuIHN0cmlwQW5zaSh3YXJuaW5nKTtcbiAgICB9KTtcbiAgICBzZW5kTXNnKCdXYXJuaW5ncycsIHN0cmlwcGVkV2FybmluZ3MpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaXBwZWRXYXJuaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgbG9nLndhcm4oc3RyaXBwZWRXYXJuaW5nc1tpXSk7XG4gICAgfVxuICAgIGlmICh1c2VXYXJuaW5nT3ZlcmxheSkgb3ZlcmxheS5zaG93TWVzc2FnZShfd2FybmluZ3MpO1xuXG4gICAgaWYgKGluaXRpYWwpIHJldHVybiBpbml0aWFsID0gZmFsc2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmV0dXJuLWFzc2lnblxuICAgIHJlbG9hZEFwcCgpO1xuICB9LFxuICBlcnJvcnM6IGZ1bmN0aW9uIGVycm9ycyhfZXJyb3JzKSB7XG4gICAgbG9nLmVycm9yKCdbV0RTXSBFcnJvcnMgd2hpbGUgY29tcGlsaW5nLiBSZWxvYWQgcHJldmVudGVkLicpO1xuICAgIHZhciBzdHJpcHBlZEVycm9ycyA9IF9lcnJvcnMubWFwKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmV0dXJuIHN0cmlwQW5zaShlcnJvcik7XG4gICAgfSk7XG4gICAgc2VuZE1zZygnRXJyb3JzJywgc3RyaXBwZWRFcnJvcnMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaXBwZWRFcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxvZy5lcnJvcihzdHJpcHBlZEVycm9yc1tpXSk7XG4gICAgfVxuICAgIGlmICh1c2VFcnJvck92ZXJsYXkpIG92ZXJsYXkuc2hvd01lc3NhZ2UoX2Vycm9ycyk7XG4gIH0sXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcihfZXJyb3IpIHtcbiAgICBsb2cuZXJyb3IoX2Vycm9yKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGxvZy5lcnJvcignW1dEU10gRGlzY29ubmVjdGVkIScpO1xuICAgIHNlbmRNc2coJ0Nsb3NlJyk7XG4gIH1cbn07XG5cbnZhciBob3N0bmFtZSA9IHVybFBhcnRzLmhvc3RuYW1lO1xudmFyIHByb3RvY29sID0gdXJsUGFydHMucHJvdG9jb2w7XG5cbi8vIGNoZWNrIGlwdjQgYW5kIGlwdjYgYGFsbCBob3N0bmFtZWBcbmlmIChob3N0bmFtZSA9PT0gJzAuMC4wLjAnIHx8IGhvc3RuYW1lID09PSAnOjonKSB7XG4gIC8vIHdoeSBkbyB3ZSBuZWVkIHRoaXMgY2hlY2s/XG4gIC8vIGhvc3RuYW1lIG4vYSBmb3IgZmlsZSBwcm90b2NvbCAoZXhhbXBsZSwgd2hlbiB1c2luZyBlbGVjdHJvbiwgaW9uaWMpXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMzg0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gIGlmIChzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICYmICEhfnNlbGYubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cCcpKSB7XG4gICAgaG9zdG5hbWUgPSBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lO1xuICB9XG59XG5cbi8vIGBob3N0bmFtZWAgY2FuIGJlIGVtcHR5IHdoZW4gdGhlIHNjcmlwdCBwYXRoIGlzIHJlbGF0aXZlLiBJbiB0aGF0IGNhc2UsIHNwZWNpZnlpbmdcbi8vIGEgcHJvdG9jb2wgd291bGQgcmVzdWx0IGluIGFuIGludmFsaWQgVVJMLlxuLy8gV2hlbiBodHRwcyBpcyB1c2VkIGluIHRoZSBhcHAsIHNlY3VyZSB3ZWJzb2NrZXRzIGFyZSBhbHdheXMgbmVjZXNzYXJ5XG4vLyBiZWNhdXNlIHRoZSBicm93c2VyIGRvZXNuJ3QgYWNjZXB0IG5vbi1zZWN1cmUgd2Vic29ja2V0cy5cbmlmIChob3N0bmFtZSAmJiAoc2VsZi5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgfHwgdXJsUGFydHMuaG9zdG5hbWUgPT09ICcwLjAuMC4wJykpIHtcbiAgcHJvdG9jb2wgPSBzZWxmLmxvY2F0aW9uLnByb3RvY29sO1xufVxuXG52YXIgc29ja2V0VXJsID0gdXJsLmZvcm1hdCh7XG4gIHByb3RvY29sOiBwcm90b2NvbCxcbiAgYXV0aDogdXJsUGFydHMuYXV0aCxcbiAgaG9zdG5hbWU6IGhvc3RuYW1lLFxuICBwb3J0OiB1cmxQYXJ0cy5wb3J0LFxuICBwYXRobmFtZTogdXJsUGFydHMucGF0aCA9PSBudWxsIHx8IHVybFBhcnRzLnBhdGggPT09ICcvJyA/ICcvc29ja2pzLW5vZGUnIDogdXJsUGFydHMucGF0aFxufSk7XG5cbnNvY2tldChzb2NrZXRVcmwsIG9uU29ja2V0TXNnKTtcblxudmFyIGlzVW5sb2FkaW5nID0gZmFsc2U7XG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgaXNVbmxvYWRpbmcgPSB0cnVlO1xufSk7XG5cbmZ1bmN0aW9uIHJlbG9hZEFwcCgpIHtcbiAgaWYgKGlzVW5sb2FkaW5nIHx8ICFob3RSZWxvYWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKF9ob3QpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIGhvdCB1cGRhdGUuLi4nKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmVcbiAgICB2YXIgaG90RW1pdHRlciA9IHJlcXVpcmUoJ3dlYnBhY2svaG90L2VtaXR0ZXInKTtcbiAgICBob3RFbWl0dGVyLmVtaXQoJ3dlYnBhY2tIb3RVcGRhdGUnLCBjdXJyZW50SGFzaCk7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLndpbmRvdykge1xuICAgICAgLy8gYnJvYWRjYXN0IHVwZGF0ZSB0byB3aW5kb3dcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2UoJ3dlYnBhY2tIb3RVcGRhdGUnICsgY3VycmVudEhhc2gsICcqJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciByb290V2luZG93ID0gc2VsZjtcbiAgICAvLyB1c2UgcGFyZW50IHdpbmRvdyBmb3IgcmVsb2FkIChpbiBjYXNlIHdlJ3JlIGluIGFuIGlmcmFtZSB3aXRoIG5vIHZhbGlkIHNyYylcbiAgICB2YXIgaW50ZXJ2YWxJZCA9IHNlbGYuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJvb3RXaW5kb3cubG9jYXRpb24ucHJvdG9jb2wgIT09ICdhYm91dDonKSB7XG4gICAgICAgIC8vIHJlbG9hZCBpbW1lZGlhdGVseSBpZiBwcm90b2NvbCBpcyB2YWxpZFxuICAgICAgICBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3RXaW5kb3cgPSByb290V2luZG93LnBhcmVudDtcbiAgICAgICAgaWYgKHJvb3RXaW5kb3cucGFyZW50ID09PSByb290V2luZG93KSB7XG4gICAgICAgICAgLy8gaWYgcGFyZW50IGVxdWFscyBjdXJyZW50IHdpbmRvdyB3ZSd2ZSByZWFjaGVkIHRoZSByb290IHdoaWNoIHdvdWxkIGNvbnRpbnVlIGZvcmV2ZXIsIHNvIHRyaWdnZXIgYSByZWxvYWQgYW55d2F5c1xuICAgICAgICAgIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKSB7XG4gICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIHVwZGF0ZWQuIFJlbG9hZGluZy4uLicpO1xuICAgIHJvb3RXaW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjayktZGV2LXNlcnZlci9jbGllbnQ/aHR0cDovLzEwLjY2LjEwMC41Njo4MDgwXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJudWxsXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zdHJpbmctcmVwbGFjZS13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanM/aWQ9cTAxM3lvMzhrNGI3MzA3NWN1bDNkaSEod2VicGFjayktZGV2LXNlcnZlci9jbGllbnQ/aHR0cDovMTAuNjYuMTAwLjU2OjgwODAiLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcblxuY29uc3QgU1RBVFVTID0ge1xuXHRcIk5PTkVcIjogMCxcblx0XCJMT0FESU5HXCI6IDEsXG5cdFwiTE9BREVEXCI6IDIsXG5cdFwiRVJST1JcIjogM1xufTtcblxuY29uc3QgRVZFTlQgPSB7XG5cdFwiUkVBRFlTVEFURUNIQU5HRVwiOiBcInJlYWR5c3RhdGVjaGFuZ2VcIlxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW1hZ2VMb2FkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvcihpbWFnZSkge1xuXHRcdC8vIFN1cGVyIGNvbnN0cnVjdG9yXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuX2ltYWdlID0gbnVsbDtcblx0XHR0aGlzLl9vbmNlSGFuZGxlcnMgPSBbXTtcblx0XHR0aGlzLl9sb2FkU3RhdHVzID0gU1RBVFVTLk5PTkU7XG5cblx0XHRpbWFnZSAmJiB0aGlzLnNldChpbWFnZSk7XG5cdH1cblxuXHRnZXQoKSB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXHRcdFx0aWYgKCF0aGlzLl9pbWFnZSkge1xuXHRcdFx0XHRyZWooXCJJbWFnZUxvYWRlcjogaW1hZ2UgaXMgbm90IGRlZmllbmRcIik7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2xvYWRTdGF0dXMgPT09IFNUQVRVUy5MT0FERUQpIHtcblx0XHRcdFx0cmVzKHRoaXMuZ2V0RWxlbWVudCgpKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fbG9hZFN0YXR1cyA9PT0gU1RBVFVTLkxPQURJTkcpIHtcblx0XHRcdFx0LyogQ2hlY2sgaXNNYXliZUxvYWRlZCgpIGZpcnN0IGJlY2F1c2UgdGhlcmUgbWF5IGhhdmVcblx0XHRcdFx0XHRwb3NpYmlsaXRpZXMgdGhhdCBpbWFnZSBhbHJlYWR5IGxvYWRlZCBiZWZvcmUgZ2V0IGlzIGNhbGxlZC5cblx0XHRcdFx0XHRmb3IgZXhhbXBsZSBjYWxsaW5nIGdldCBvbiBleHRlcm5hbCBpbWFnZSBvbmxvYWQgY2FsbGJhY2suKi9cblx0XHRcdFx0aWYgKEltYWdlTG9hZGVyLmlzTWF5YmVMb2FkZWQodGhpcy5faW1hZ2UpKSB7XG5cdFx0XHRcdFx0dGhpcy5fbG9hZFN0YXR1cyA9IFNUQVRVUy5MT0FERUQ7XG5cdFx0XHRcdFx0cmVzKHRoaXMuZ2V0RWxlbWVudCgpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLm9uKEVWRU5ULlJFQURZU1RBVEVDSEFOR0UsIGUgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKGUudHlwZSA9PT0gU1RBVFVTLkxPQURFRCkge1xuXHRcdFx0XHRcdFx0XHRyZXModGhpcy5nZXRFbGVtZW50KCkpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmVqKFwiSW1hZ2VMb2FkZXI6IGZhaWxlZCB0byBsb2FkIGltYWdlcy5cIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlaihcIkltYWdlTG9hZGVyOiBmYWlsZWQgdG8gbG9hZCBpbWFnZXNcIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIGltYWdlIGltZyBlbGVtZW50IG9yIGltZyB1cmwgb3IgYXJyYXkgb2YgaW1nIGVsZW1lbnQgb3IgYXJyYXkgb2YgaW1nIHVybFxuXHQgKi9cblx0c2V0KGltYWdlKSB7XG5cdFx0dGhpcy5fbG9hZFN0YXR1cyA9IFNUQVRVUy5MT0FESU5HO1xuXG5cdFx0dGhpcy5faW1hZ2UgPSBJbWFnZUxvYWRlci5jcmVhdGVFbGVtZW50KGltYWdlKTtcblxuXHRcdGlmIChJbWFnZUxvYWRlci5pc01heWJlTG9hZGVkKHRoaXMuX2ltYWdlKSkge1xuXHRcdFx0dGhpcy5fbG9hZFN0YXR1cyA9IFNUQVRVUy5MT0FERUQ7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5vbmNlTG9hZGVkKFxuXHRcdFx0dGhpcy5faW1hZ2UsXG5cdFx0XHQoKSA9PiB7XG5cdFx0XHRcdHRoaXMuX2xvYWRTdGF0dXMgPSBTVEFUVVMuTE9BREVEO1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoRVZFTlQuUkVBRFlTVEFURUNIQU5HRSwge1xuXHRcdFx0XHRcdHR5cGU6IFNUQVRVUy5MT0FERURcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0KCkgPT4ge1xuXHRcdFx0XHR0aGlzLl9sb2FkU3RhdHVzID0gU1RBVFVTLkVSUk9SO1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoRVZFTlQuUkVBRFlTVEFURUNIQU5HRSwge1xuXHRcdFx0XHRcdHR5cGU6IFNUQVRVUy5FUlJPUlxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHQpO1xuXHR9XG5cblx0c3RhdGljIGNyZWF0ZUVsZW1lbnQoaW1hZ2UpIHtcblx0XHRjb25zdCBpbWFnZXMgPSBpbWFnZSBpbnN0YW5jZW9mIEFycmF5ID8gaW1hZ2UgOiBbaW1hZ2VdO1xuXG5cdFx0cmV0dXJuIGltYWdlcy5tYXAoaW1nID0+IHtcblx0XHRcdGxldCBfaW1nID0gaW1nO1xuXG5cdFx0XHRpZiAodHlwZW9mIGltZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRfaW1nID0gbmV3IEltYWdlKCk7XG5cdFx0XHRcdF9pbWcuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuXHRcdFx0XHRfaW1nLnNyYyA9IGltZztcblx0XHRcdH1cblx0XHRcdHJldHVybiBfaW1nO1xuXHRcdH0pO1xuXHR9XG5cblx0Z2V0RWxlbWVudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2UubGVuZ3RoID09PSAxID8gdGhpcy5faW1hZ2VbMF0gOiB0aGlzLl9pbWFnZTtcblx0fVxuXG5cdHN0YXRpYyBpc01heWJlTG9hZGVkKGltYWdlKSB7XG5cdFx0cmV0dXJuIGltYWdlIGluc3RhbmNlb2YgSW1hZ2UgP1xuXHRcdFx0aW1hZ2UuY29tcGxldGUgJiYgaW1hZ2UubmF0dXJhbFdpZHRoICE9PSAwIDpcblx0XHRcdCFpbWFnZS5zb21lKGltZyA9PiAhaW1nLmNvbXBsZXRlIHx8IGltZy5uYXR1cmFsV2lkdGggPT09IDApO1xuXHR9XG5cblx0b25jZUxvYWRlZCh0YXJnZXQsIG9ubG9hZCwgb25lcnJvcikge1xuXHRcdGNvbnN0IHRhcmdldHMgPSB0YXJnZXQgaW5zdGFuY2VvZiBBcnJheSA/IHRhcmdldCA6IFt0YXJnZXRdO1xuXHRcdGNvbnN0IHRhcmdldHNOb3RMb2FkZWQgPSB0YXJnZXRzLmZpbHRlcihpbWcgPT4gIUltYWdlTG9hZGVyLmlzTWF5YmVMb2FkZWQoaW1nKSk7XG5cdFx0Y29uc3QgbG9hZFByb21pc2VzID0gdGFyZ2V0c05vdExvYWRlZC5tYXAoaW1nID0+IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXHRcdFx0dGhpcy5fb25jZShpbWcsIFwibG9hZFwiLCAoKSA9PiAocmVzKGltZykpKTtcblx0XHRcdHRoaXMuX29uY2UoaW1nLCBcImVycm9yXCIsICgpID0+IChyZWooaW1nKSkpO1xuXHRcdH0pKTtcblxuXHRcdFByb21pc2UuYWxsKGxvYWRQcm9taXNlcykudGhlbihcblx0XHRcdHJlc3VsdCA9PiAob25sb2FkKHRhcmdldHMubGVuZ3RoID09PSAxID8gdGFyZ2V0c1swXSA6IHRhcmdldHMpKSxcblx0XHRcdHJlYXNvbiA9PiAob25lcnJvcihyZWFzb24pKVxuXHRcdCk7XG5cdH1cblxuXHRfb25jZSh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG5cdFx0Y29uc3QgZm4gPSBldmVudCA9PiB7XG5cdFx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbik7XG5cdFx0XHRsaXN0ZW5lcihldmVudCk7XG5cdFx0fTtcblxuXHRcdHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuKTtcblx0XHR0aGlzLl9vbmNlSGFuZGxlcnMucHVzaCh7dGFyZ2V0LCB0eXBlLCBmbn0pO1xuXHR9XG5cblx0Z2V0U3RhdHVzKCkge1xuXHRcdHJldHVybiB0aGlzLl9sb2FkU3RhdHVzO1xuXHR9XG5cblx0ZGVzdHJveSgpIHtcblx0XHR0aGlzLl9vbmNlSGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IHtcblx0XHRcdGhhbmRsZXIudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoaGFuZGxlci50eXBlLCBoYW5kbGVyLmZuKTtcblx0XHR9KTtcblx0XHR0aGlzLl9vbmNlSGFuZGxlcnMgPSBbXTtcblx0XHR0aGlzLl9pbWFnZS5zcmMgPSBcIlwiO1xuXHRcdHRoaXMuX2ltYWdlID0gbnVsbDtcblx0XHR0aGlzLl9sb2FkU3RhdHVzID0gU1RBVFVTLk5PTkU7XG5cdH1cbn1cblxuSW1hZ2VMb2FkZXIuU1RBVFVTID0gU1RBVFVTO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1Bhbm9JbWFnZVJlbmRlcmVyL0ltYWdlTG9hZGVyLmpzIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG5pbXBvcnQgSW1hZ2VMb2FkZXIgZnJvbSBcIi4vSW1hZ2VMb2FkZXJcIjtcbmltcG9ydCBWaWRlb0xvYWRlciBmcm9tIFwiLi9WaWRlb0xvYWRlclwiO1xuaW1wb3J0IFdlYkdMVXRpbHMgZnJvbSBcIi4vV2ViR0xVdGlsc1wiO1xuaW1wb3J0IEN1YmVSZW5kZXJlciBmcm9tIFwiLi9yZW5kZXJlci9DdWJlUmVuZGVyZXJcIjtcbmltcG9ydCBTcGhlcmVSZW5kZXJlciBmcm9tIFwiLi9yZW5kZXJlci9TcGhlcmVSZW5kZXJlclwiO1xuaW1wb3J0IHtnbE1hdHJpeCwgbWF0NCwgcXVhdH0gZnJvbSBcIi4uL3V0aWxzL21hdGgtdXRpbC5qc1wiO1xuaW1wb3J0IHtkZXZpY2VQaXhlbFJhdGlvfSBmcm9tIFwiLi9icm93c2VyXCI7XG5pbXBvcnQge1BST0pFQ1RJT05fVFlQRX0gZnJvbSBcIi4uL1Bhbm9WaWV3ZXIvY29uc3RzXCI7XG5cbmNvbnN0IEltYWdlVHlwZSA9IFBST0pFQ1RJT05fVFlQRTtcblxubGV0IERFVklDRV9QSVhFTF9SQVRJTyA9IGRldmljZVBpeGVsUmF0aW8gfHwgMTtcblxuLy8gREVWSUNFX1BJWEVMX1JBVElPIOqwgCAy66W8IOy0iOqzvO2VmOuKlCDqsr3smrDripQg66as7IaM7IqkIOuCreu5hOydtOuvgOuhnCAy66GcIOunnuy2mOuLpC5cbmlmIChERVZJQ0VfUElYRUxfUkFUSU8gPiAyKSB7XG5cdERFVklDRV9QSVhFTF9SQVRJTyA9IDI7XG59XG5cbi8vIGRlZmluZSBjdXN0b20gZXZlbnRzIG5hbWVcbi8qKlxuICogVE9ETzogaG93IHRvIG1hbmFnZSBldmVudHMvZXJyb3J0eXBlIHdpdGggUGFub1ZpZXdlclxuICpcbiAqIEkgdGhpbmsgcmVuZGVyZXIgZXZlbnRzIHNob3VsZCBiZSBzZXBlcmF0ZWQgZnJvbSB2aWV3ZXIgZXZlbnRzIGFsdGhvdWdoIGl0IGhhcyBzYW1lIG5hbWUuXG4gKi9cbmNvbnN0IEVWRU5UUyA9IHtcblx0QklORF9URVhUVVJFOiBcImJpbmRUZXh0dXJlXCIsXG5cdElNQUdFX0xPQURFRDogXCJpbWFnZUxvYWRlZFwiLFxuXHRFUlJPUjogXCJlcnJvclwiLFxuXHRSRU5ERVJJTkdfQ09OVEVYVF9MT1NUOiBcInJlbmRlcmluZ0NvbnRleHRMb3N0XCIsXG5cdFJFTkRFUklOR19DT05URVhUX1JFU1RPUkU6IFwicmVuZGVyaW5nQ29udGV4dFJlc3RvcmVcIixcbn07XG5cbmNvbnN0IEVSUk9SX1RZUEUgPSB7XG5cdElOVkFMSURfREVWSUNFOiAxMCxcblx0Tk9fV0VCR0w6IDExLFxuXHRGQUlMX0lNQUdFX0xPQUQ6IDEyXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYW5vSW1hZ2VSZW5kZXJlciBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKGltYWdlLCB3aWR0aCwgaGVpZ2h0LCBpc1ZpZGVvLCBzcGhlcmljYWxDb25maWcsIHJlbmRlcmluZ0NvbnRleHRBdHRyaWJ1dGVzKSB7XG5cdFx0Ly8gU3VwZXIgY29uc3RydWN0b3Jcblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5zcGhlcmljYWxDb25maWcgPSBzcGhlcmljYWxDb25maWc7XG5cdFx0dGhpcy5maWVsZE9mVmlldyA9IHNwaGVyaWNhbENvbmZpZy5maWVsZE9mVmlldztcblxuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuXHRcdHRoaXMuX2xhc3RRdWF0ZXJuaW9uID0gbnVsbDtcblx0XHR0aGlzLl9sYXN0WWF3ID0gbnVsbDtcblx0XHR0aGlzLl9sYXN0UGl0Y2ggPSBudWxsO1xuXHRcdHRoaXMuX2xhc3RGaWVsZE9mVmlldyA9IG51bGw7XG5cblx0XHR0aGlzLnBNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXHRcdHRoaXMubXZNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG5cdFx0Ly8gaW5pdGlhbHppZSBwTWF0cml4XG5cdFx0bWF0NC5wZXJzcGVjdGl2ZSh0aGlzLnBNYXRyaXgsIGdsTWF0cml4LnRvUmFkaWFuKHRoaXMuZmllbGRPZlZpZXcpLCB3aWR0aCAvIGhlaWdodCwgMC4xLCAxMDApO1xuXG5cdFx0dGhpcy50ZXh0dXJlQ29vcmRCdWZmZXIgPSBudWxsO1xuXHRcdHRoaXMudmVydGV4QnVmZmVyID0gbnVsbDtcblx0XHR0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcblx0XHR0aGlzLmNhbnZhcyA9IHRoaXMuX2luaXRDYW52YXMod2lkdGgsIGhlaWdodCk7XG5cdFx0dGhpcy5fcmVuZGVyaW5nQ29udGV4dEF0dHJpYnV0ZXMgPSByZW5kZXJpbmdDb250ZXh0QXR0cmlidXRlcztcblx0XHR0aGlzLl9pbWFnZSA9IG51bGw7XG5cdFx0dGhpcy5faW1hZ2VDb25maWcgPSBudWxsO1xuXHRcdHRoaXMuX2ltYWdlSXNSZWFkeSA9IGZhbHNlO1xuXHRcdHRoaXMuX3Nob3VsZEZvcmNlRHJhdyA9IGZhbHNlO1xuXHRcdHRoaXMuX2tlZXBVcGRhdGUgPSBmYWxzZTsgLy8gRmxhZyB0byBzcGVjaWZ5ICdjb250aW51b3VzIHVwZGF0ZScgb24gdmlkZW8gZXZlbiB3aGVuIHN0aWxsLlxuXG5cdFx0dGhpcy5fb25Db250ZW50TG9hZCA9IFx0dGhpcy5fb25Db250ZW50TG9hZC5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuX29uQ29udGVudEVycm9yID0gXHR0aGlzLl9vbkNvbnRlbnRFcnJvci5iaW5kKHRoaXMpO1xuXG5cdFx0aWYgKGltYWdlKSB7XG5cdFx0XHR0aGlzLnNldEltYWdlKHtcblx0XHRcdFx0aW1hZ2UsXG5cdFx0XHRcdGltYWdlVHlwZTogc3BoZXJpY2FsQ29uZmlnLmltYWdlVHlwZSxcblx0XHRcdFx0aXNWaWRlbyxcblx0XHRcdFx0Y3ViZW1hcENvbmZpZzogc3BoZXJpY2FsQ29uZmlnLmN1YmVtYXBDb25maWdcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGdldENvbnRlbnQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlO1xuXHR9XG5cblx0c2V0SW1hZ2Uoe2ltYWdlLCBpbWFnZVR5cGUsIGlzVmlkZW8gPSBmYWxzZSwgY3ViZW1hcENvbmZpZ30pIHtcblx0XHR0aGlzLl9pbWFnZUlzUmVhZHkgPSBmYWxzZTtcblx0XHR0aGlzLl9pc1ZpZGVvID0gaXNWaWRlbztcblx0XHR0aGlzLl9pbWFnZUNvbmZpZyA9IE9iamVjdC5hc3NpZ24oXG5cdFx0XHR7XG5cdFx0XHRcdG9yZGVyOiBcIlJMVURCRlwiLFxuXHRcdFx0XHR0aWxlQ29uZmlnOiB7XG5cdFx0XHRcdFx0ZmxpcEhpcm96b250YWw6IGZhbHNlLFxuXHRcdFx0XHRcdHJvdGF0aW9uOiAwXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRjdWJlbWFwQ29uZmlnXG5cdFx0KTtcblx0XHR0aGlzLl9zZXRJbWFnZVR5cGUoaW1hZ2VUeXBlKTtcblxuXHRcdGlmICh0aGlzLl9jb250ZW50TG9hZGVyKSB7XG5cdFx0XHR0aGlzLl9jb250ZW50TG9hZGVyLmRlc3Ryb3koKTtcblx0XHR9XG5cblx0XHRpZiAoaXNWaWRlbykge1xuXHRcdFx0dGhpcy5fY29udGVudExvYWRlciA9IG5ldyBWaWRlb0xvYWRlcigpO1xuXHRcdFx0dGhpcy5fa2VlcFVwZGF0ZSA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2NvbnRlbnRMb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIoKTtcblx0XHRcdHRoaXMuX2tlZXBVcGRhdGUgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBpbWcgZWxlbWVudCBvciBpbWcgdXJsXG5cdFx0dGhpcy5fY29udGVudExvYWRlci5zZXQoaW1hZ2UpO1xuXG5cdFx0Ly8g7J2066+47KeA7J2YIOyCrOydtOymiOulvCDsupDsi5ztlZzri6QuXG5cdFx0Ly8gaW1hZ2UgaXMgcmVmZXJlbmNlIGZvciBjb250ZW50IGluIGNvbnRlbnRMb2FkZXIsIHNvIGl0IG1heSBiZSBub3QgdmFsaWQgaWYgY29udGVudExvYWRlciBpcyBkZXN0cm95ZWQuXG5cdFx0dGhpcy5faW1hZ2UgPSB0aGlzLl9jb250ZW50TG9hZGVyLmdldEVsZW1lbnQoKTtcblxuXHRcdHJldHVybiB0aGlzLl9jb250ZW50TG9hZGVyLmdldCgpXG5cdFx0XHQudGhlbih0aGlzLl9vbkNvbnRlbnRMb2FkLCB0aGlzLl9vbkNvbnRlbnRFcnJvcilcblx0XHRcdC5jYXRjaChlID0+IHNldFRpbWVvdXQoKCkgPT4geyB0aHJvdyBlOyB9KSk7Ly8gUHJldmVudCBleGNlcHRpb25zIGZyb20gYmVpbmcgaXNvbGF0ZWQgaW4gcHJvbWlzZSBjaGFpbi5cblx0fVxuXG5cdF9zZXRJbWFnZVR5cGUoaW1hZ2VUeXBlKSB7XG5cdFx0aWYgKCFpbWFnZVR5cGUgfHwgdGhpcy5faW1hZ2VUeXBlID09PSBpbWFnZVR5cGUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9pbWFnZVR5cGUgPSBpbWFnZVR5cGU7XG5cdFx0dGhpcy5faXNDdWJlTWFwID0gaW1hZ2VUeXBlID09PSBJbWFnZVR5cGUuQ1VCRU1BUDtcblx0XHR0aGlzLl9yZW5kZXJlciA9IHRoaXMuX2lzQ3ViZU1hcCA/IEN1YmVSZW5kZXJlciA6IFNwaGVyZVJlbmRlcmVyO1xuXHRcdHRoaXMuX2luaXRXZWJHTCgpO1xuXHR9XG5cblx0X2luaXRDYW52YXMod2lkdGgsIGhlaWdodCkge1xuXHRcdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cblx0XHRjYW52YXMud2lkdGggPSB3aWR0aDtcblx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdGNhbnZhcy5zdHlsZS5ib3R0b20gPSAwO1xuXHRcdGNhbnZhcy5zdHlsZS5sZWZ0ID0gMDtcblx0XHRjYW52YXMuc3R5bGUucmlnaHQgPSAwO1xuXHRcdGNhbnZhcy5zdHlsZS50b3AgPSAwO1xuXHRcdGNhbnZhcy5zdHlsZS5tYXJnaW4gPSBcImF1dG9cIjtcblx0XHRjYW52YXMuc3R5bGUubWF4SGVpZ2h0ID0gXCIxMDAlXCI7XG5cdFx0Y2FudmFzLnN0eWxlLm1heFdpZHRoID0gXCIxMDAlXCI7XG5cdFx0Y2FudmFzLnN0eWxlLm91dGxpbmUgPSBcIm5vbmVcIjtcblx0XHRjYW52YXMuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cblx0XHR0aGlzLl9vbldlYmdsY29udGV4dGxvc3QgPSB0aGlzLl9vbldlYmdsY29udGV4dGxvc3QuYmluZCh0aGlzKTtcblx0XHR0aGlzLl9vbldlYmdsY29udGV4dHJlc3RvcmVkID0gdGhpcy5fb25XZWJnbGNvbnRleHRyZXN0b3JlZC5iaW5kKHRoaXMpO1xuXG5cdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsIHRoaXMuX29uV2ViZ2xjb250ZXh0bG9zdCk7XG5cdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRyZXN0b3JlZFwiLCB0aGlzLl9vbldlYmdsY29udGV4dHJlc3RvcmVkKTtcblxuXHRcdHJldHVybiBjYW52YXM7XG5cdH1cblxuXHRfb25Db250ZW50RXJyb3IoZXJyb3IpIHtcblx0XHR0aGlzLl9pbWFnZUlzUmVhZHkgPSBmYWxzZTtcblx0XHR0aGlzLl9pbWFnZSA9IG51bGw7XG5cdFx0dGhpcy50cmlnZ2VyKEVWRU5UUy5FUlJPUiwge1xuXHRcdFx0dHlwZTogRVJST1JfVFlQRS5GQUlMX0lNQUdFX0xPQUQsXG5cdFx0XHRtZXNzYWdlOiBcImZhaWxlZCB0byBsb2FkIGltYWdlXCJcblx0XHR9KTtcblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdF90cmlnZ2VyQ29udGVudExvYWQoKSB7XG5cdFx0dGhpcy50cmlnZ2VyKEVWRU5UUy5JTUFHRV9MT0FERUQsIHtcblx0XHRcdGNvbnRlbnQ6IHRoaXMuX2ltYWdlLFxuXHRcdFx0aXNWaWRlbzogdGhpcy5faXNWaWRlbyxcblx0XHRcdHByb2plY3Rpb25UeXBlOiB0aGlzLl9pbWFnZVR5cGVcblx0XHR9KTtcblx0fVxuXHRfb25Db250ZW50TG9hZChpbWFnZSkge1xuXHRcdHRoaXMuX2ltYWdlSXNSZWFkeSA9IHRydWU7XG5cblx0XHR0aGlzLl90cmlnZ2VyQ29udGVudExvYWQoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlzSW1hZ2VMb2FkZWQoKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5faW1hZ2UgJiYgdGhpcy5faW1hZ2VJc1JlYWR5ICYmXG5cdFx0XHQoIXRoaXMuX2lzVmlkZW8gfHwgdGhpcy5faW1hZ2UucmVhZHlTdGF0ZSA+PSAyIC8qIEhBVkVfQ1VSUkVOVF9EQVRBICovKTtcblx0fVxuXG5cdGJpbmRUZXh0dXJlKCkge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblx0XHRcdGlmICghdGhpcy5fY29udGVudExvYWRlcikge1xuXHRcdFx0XHRyZWooXCJJbWFnZUxvYWRlciBpcyBub3QgaW5pdGlhbGl6ZWRcIik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fY29udGVudExvYWRlci5nZXQoKVxuXHRcdFx0XHQudGhlbigoKSA9PiB0aGlzLl9iaW5kVGV4dHVyZSgpLCByZWopXG5cdFx0XHRcdC50aGVuKHJlcyk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyDrtoDrqqgg7JeY66as66i87Yq47JeQIGNhbnZhcyDrpbwg67aZ7J6EXG5cdGF0dGFjaFRvKHBhcmVudEVsZW1lbnQpIHtcblx0XHR0aGlzLmRldGFjaCgpO1xuXHRcdHBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuXHR9XG5cblx0Zm9yY2VDb250ZXh0TG9zcygpIHtcblx0XHRpZiAodGhpcy5oYXNSZW5kZXJpbmdDb250ZXh0KCkpIHtcblx0XHRcdGNvbnN0IGxvc2VDb250ZXh0RXh0ZW5zaW9uID0gdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKTtcblxuXHRcdFx0aWYgKGxvc2VDb250ZXh0RXh0ZW5zaW9uKSB7XG5cdFx0XHRcdGxvc2VDb250ZXh0RXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8g67aA66qoIOyXmOumrOuovO2KuOyXkOyEnCBjYW52YXMg66W8IOygnOqxsFxuXHRkZXRhY2goKSB7XG5cdFx0aWYgKHRoaXMuY2FudmFzLnBhcmVudEVsZW1lbnQpIHtcblx0XHRcdHRoaXMuY2FudmFzLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuXHRcdH1cblx0fVxuXG5cdGRlc3Ryb3koKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRlbnRMb2FkZXIpIHtcblx0XHRcdHRoaXMuX2NvbnRlbnRMb2FkZXIuZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZGV0YWNoKCk7XG5cdFx0dGhpcy5mb3JjZUNvbnRleHRMb3NzKCk7XG5cblx0XHR0aGlzLm9mZigpO1xuXG5cdFx0dGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dGxvc3RcIiwgdGhpcy5fb25XZWJnbGNvbnRleHRsb3N0KTtcblx0XHR0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0cmVzdG9yZWRcIiwgdGhpcy5fb25XZWJnbGNvbnRleHRyZXN0b3JlZCk7XG5cdH1cblxuXHRoYXNSZW5kZXJpbmdDb250ZXh0KCkge1xuXHRcdGlmICghKHRoaXMuY29udGV4dCAmJiAhdGhpcy5jb250ZXh0LmlzQ29udGV4dExvc3QoKSkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0dGhpcy5jb250ZXh0ICYmXG5cdFx0XHQhdGhpcy5jb250ZXh0LmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5zaGFkZXJQcm9ncmFtLCB0aGlzLmNvbnRleHQuTElOS19TVEFUVVMpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0X29uV2ViZ2xjb250ZXh0bG9zdChlKSB7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdHRoaXMudHJpZ2dlcihFVkVOVFMuUkVOREVSSU5HX0NPTlRFWFRfTE9TVCk7XG5cdH1cblxuXHRfb25XZWJnbGNvbnRleHRyZXN0b3JlZChlKSB7XG5cdFx0dGhpcy5faW5pdFdlYkdMKCk7XG5cdFx0dGhpcy50cmlnZ2VyKEVWRU5UUy5SRU5ERVJJTkdfQ09OVEVYVF9SRVNUT1JFKTtcblx0fVxuXG5cdHVwZGF0ZUZpZWxkT2ZWaWV3KGZpZWxkT2ZWaWV3KSB7XG5cdFx0dGhpcy5maWVsZE9mVmlldyA9IGZpZWxkT2ZWaWV3O1xuXHRcdHRoaXMuX3VwZGF0ZVZpZXdwb3J0KCk7XG5cdH1cblxuXHR1cGRhdGVWaWV3cG9ydERpbWVuc2lvbnMod2lkdGgsIGhlaWdodCkge1xuXHRcdGxldCB2aWV3UG9ydENoYW5nZWQgPSBmYWxzZTtcblxuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuXHRcdGNvbnN0IHcgPSB3aWR0aCAqIERFVklDRV9QSVhFTF9SQVRJTztcblx0XHRjb25zdCBoID0gaGVpZ2h0ICogREVWSUNFX1BJWEVMX1JBVElPO1xuXG5cdFx0aWYgKHcgIT09IHRoaXMuY2FudmFzLndpZHRoKSB7XG5cdFx0XHR0aGlzLmNhbnZhcy53aWR0aCA9IHc7XG5cdFx0XHR2aWV3UG9ydENoYW5nZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChoICE9PSB0aGlzLmNhbnZhcy5oZWlnaHQpIHtcblx0XHRcdHRoaXMuY2FudmFzLmhlaWdodCA9IGg7XG5cdFx0XHR2aWV3UG9ydENoYW5nZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICghdmlld1BvcnRDaGFuZ2VkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlVmlld3BvcnQoKTtcblx0XHR0aGlzLl9zaG91bGRGb3JjZURyYXcgPSB0cnVlO1xuXHR9XG5cblx0X3VwZGF0ZVZpZXdwb3J0KCkge1xuXHRcdG1hdDQucGVyc3BlY3RpdmUoXG5cdFx0XHR0aGlzLnBNYXRyaXgsXG5cdFx0XHRnbE1hdHJpeC50b1JhZGlhbih0aGlzLmZpZWxkT2ZWaWV3KSxcblx0XHRcdHRoaXMuY2FudmFzLndpZHRoIC8gdGhpcy5jYW52YXMuaGVpZ2h0LFxuXHRcdFx0MC4xLFxuXHRcdFx0MTAwKTtcblxuXHRcdHRoaXMuY29udGV4dC52aWV3cG9ydCgwLCAwLCB0aGlzLmNvbnRleHQuZHJhd2luZ0J1ZmZlcldpZHRoLCB0aGlzLmNvbnRleHQuZHJhd2luZ0J1ZmZlckhlaWdodCk7XG5cdH1cblxuXHRfaW5pdFdlYkdMKCkge1xuXHRcdC8vIFRPRE86IEZvbGxvd2luZyBjb2RlIGRvZXMgbmVlZCB0byBiZSBleGVjdXRlZCBvbmx5IGlmIHdpZHRoL2hlaWdodCwgY3ViaWNTdHJpcCBwcm9wZXJ0eSBpcyBjaGFuZ2VkLlxuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLl9pbml0UmVuZGVyaW5nQ29udGV4dCgpO1xuXHRcdFx0dGhpcy51cGRhdGVWaWV3cG9ydERpbWVuc2lvbnModGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG5cdFx0XHRpZiAodGhpcy5zaGFkZXJQcm9ncmFtKSB7XG5cdFx0XHRcdHRoaXMuY29udGV4dC5kZWxldGVQcm9ncmFtKHRoaXMuc2hhZGVyUHJvZ3JhbSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2hhZGVyUHJvZ3JhbSA9IHRoaXMuX2luaXRTaGFkZXJQcm9ncmFtKHRoaXMuY29udGV4dCk7XG5cdFx0XHRpZiAoIXRoaXMuc2hhZGVyUHJvZ3JhbSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBpbnRpYWxpemUgc2hhZGVyczogJHtXZWJHTFV0aWxzLmdldEVycm9yTmFtZUZyb21XZWJHTEVycm9yQ29kZSh0aGlzLmNvbnRleHQuZ2V0RXJyb3IoKSl9YCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1ZmZlcnMgZm9yIHNoYWRlclxuXHRcdFx0dGhpcy5faW5pdEJ1ZmZlcnMoKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoRVZFTlRTLkVSUk9SLCB7XG5cdFx0XHRcdHR5cGU6IEVSUk9SX1RZUEUuTk9fV0VCR0wsXG5cdFx0XHRcdG1lc3NhZ2U6IFwibm8gd2ViZ2wgc3VwcG9ydFwiXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvLyDsupTrsoTsiqTrpbwg7Yis66qF7Jy866GcIOyxhOyatOuLpC5cblx0XHR0aGlzLmNvbnRleHQuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcblx0XHRjb25zdCB0ZXh0dXJlVGFyZ2V0ID0gdGhpcy5faXNDdWJlTWFwID8gdGhpcy5jb250ZXh0LlRFWFRVUkVfQ1VCRV9NQVAgOiB0aGlzLmNvbnRleHQuVEVYVFVSRV8yRDtcblxuXHRcdGlmICh0aGlzLnRleHR1cmUpIHtcblx0XHRcdHRoaXMuY29udGV4dC5kZWxldGVUZXh0dXJlKHRoaXMudGV4dHVyZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy50ZXh0dXJlID0gV2ViR0xVdGlscy5jcmVhdGVUZXh0dXJlKHRoaXMuY29udGV4dCwgdGV4dHVyZVRhcmdldCk7XG5cdH1cblxuXHRfaW5pdFJlbmRlcmluZ0NvbnRleHQoKSB7XG5cdFx0aWYgKHRoaXMuaGFzUmVuZGVyaW5nQ29udGV4dCgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTFJlbmRlcmluZ0NvbnRleHQgbm90IGF2YWlsYWJsZS5cIik7XG5cdFx0fVxuXG5cdFx0dGhpcy5jb250ZXh0ID0gV2ViR0xVdGlscy5nZXRXZWJnbENvbnRleHQodGhpcy5jYW52YXMsIHRoaXMuX3JlbmRlcmluZ0NvbnRleHRBdHRyaWJ1dGVzKTtcblxuXHRcdGlmICghdGhpcy5jb250ZXh0KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gYWNxdWlyZSAzRCByZW5kZXJpbmcgY29udGV4dFwiKTtcblx0XHR9XG5cdH1cblxuXHRfaW5pdFNoYWRlclByb2dyYW0oZ2wpIHtcblx0XHRjb25zdCB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSB0aGlzLl9yZW5kZXJlci5nZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKTtcblx0XHRjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBXZWJHTFV0aWxzLmNyZWF0ZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4U2hhZGVyU291cmNlKTtcblxuXHRcdGlmICghdmVydGV4U2hhZGVyKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSB0aGlzLl9yZW5kZXJlci5nZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpO1xuXHRcdGNvbnN0IGZyYWdtZW50U2hhZGVyID0gV2ViR0xVdGlscy5jcmVhdGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuXG5cdFx0aWYgKCFmcmFnbWVudFNoYWRlcikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGNvbnN0IHNoYWRlclByb2dyYW0gPSBXZWJHTFV0aWxzLmNyZWF0ZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpO1xuXG5cdFx0aWYgKCFzaGFkZXJQcm9ncmFtKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRnbC51c2VQcm9ncmFtKHNoYWRlclByb2dyYW0pO1xuXHRcdHNoYWRlclByb2dyYW0udmVydGV4UG9zaXRpb25BdHRyaWJ1dGUgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihzaGFkZXJQcm9ncmFtLCBcImFWZXJ0ZXhQb3NpdGlvblwiKTtcblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzaGFkZXJQcm9ncmFtLnZlcnRleFBvc2l0aW9uQXR0cmlidXRlKTtcblx0XHRzaGFkZXJQcm9ncmFtLnBNYXRyaXhVbmlmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlclByb2dyYW0sIFwidVBNYXRyaXhcIik7XG5cdFx0c2hhZGVyUHJvZ3JhbS5tdk1hdHJpeFVuaWZvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgXCJ1TVZNYXRyaXhcIik7XG5cdFx0c2hhZGVyUHJvZ3JhbS5zYW1wbGVyVW5pZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXJQcm9ncmFtLCBcInVTYW1wbGVyXCIpO1xuXHRcdHNoYWRlclByb2dyYW0udGV4dHVyZUNvb3JkQXR0cmlidXRlID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgXCJhVGV4dHVyZUNvb3JkXCIpO1xuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlclByb2dyYW0udGV4dHVyZUNvb3JkQXR0cmlidXRlKTtcblxuXHRcdC8vIGNsZWFyIGJ1ZmZlclxuXHRcdGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUIHwgZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcblx0XHQvLyBVc2UgVEVYVFVSRTBcblx0XHRnbC51bmlmb3JtMWkoc2hhZGVyUHJvZ3JhbS5zYW1wbGVyVW5pZm9ybSwgMCk7XG5cblx0XHRyZXR1cm4gc2hhZGVyUHJvZ3JhbTtcblx0fVxuXG5cdF9pbml0QnVmZmVycygpIHtcblx0XHRjb25zdCB2ZXJ0ZXhQb3NpdGlvbkRhdGEgPSB0aGlzLl9yZW5kZXJlci5nZXRWZXJ0ZXhQb3NpdGlvbkRhdGEoKTtcblx0XHRjb25zdCBpbmRleERhdGEgPSB0aGlzLl9yZW5kZXJlci5nZXRJbmRleERhdGEoKTtcblx0XHRjb25zdCB0ZXh0dXJlQ29vcmREYXRhID0gdGhpcy5fcmVuZGVyZXIuZ2V0VGV4dHVyZUNvb3JkRGF0YSh0aGlzLl9pbWFnZUNvbmZpZyk7XG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG5cblx0XHR0aGlzLnZlcnRleEJ1ZmZlciA9IFdlYkdMVXRpbHMuaW5pdEJ1ZmZlcihcblx0XHRcdGdsLCBnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkodmVydGV4UG9zaXRpb25EYXRhKSwgMyxcblx0XHRcdHRoaXMuc2hhZGVyUHJvZ3JhbS52ZXJ0ZXhQb3NpdGlvbkF0dHJpYnV0ZSk7XG5cblx0XHR0aGlzLmluZGV4QnVmZmVyID0gV2ViR0xVdGlscy5pbml0QnVmZmVyKFxuXHRcdFx0Z2wsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBuZXcgVWludDE2QXJyYXkoaW5kZXhEYXRhKSwgMSk7XG5cblx0XHR0aGlzLnRleHR1cmVDb29yZEJ1ZmZlciA9IFdlYkdMVXRpbHMuaW5pdEJ1ZmZlcihcblx0XHRcdGdsLCBnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkodGV4dHVyZUNvb3JkRGF0YSksIHRoaXMuX2lzQ3ViZU1hcCA/IDMgOiAyLFxuXHRcdFx0dGhpcy5zaGFkZXJQcm9ncmFtLnRleHR1cmVDb29yZEF0dHJpYnV0ZSk7XG5cdH1cblxuXHRfYmluZFRleHR1cmUoKSB7XG5cdFx0dGhpcy5fcmVuZGVyZXIuYmluZFRleHR1cmUoXG5cdFx0XHR0aGlzLmNvbnRleHQsXG5cdFx0XHR0aGlzLnRleHR1cmUsXG5cdFx0XHR0aGlzLl9pbWFnZSxcblx0XHRcdHRoaXMuX2ltYWdlQ29uZmlnLFxuXHRcdCk7XG5cdFx0dGhpcy5fc2hvdWxkRm9yY2VEcmF3ID0gdHJ1ZTtcblxuXHRcdHRoaXMudHJpZ2dlcihFVkVOVFMuQklORF9URVhUVVJFKTtcblx0fVxuXG5cdF91cGRhdGVUZXh0dXJlKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLnVwZGF0ZVRleHR1cmUoXG5cdFx0XHR0aGlzLmNvbnRleHQsXG5cdFx0XHR0aGlzLl9pbWFnZSxcblx0XHRcdHRoaXMuX2ltYWdlQ29uZmlnLFxuXHRcdCk7XG5cdH1cblxuXHRrZWVwVXBkYXRlKGRvVXBkYXRlKSB7XG5cdFx0aWYgKGRvVXBkYXRlICYmIHRoaXMuaXNJbWFnZUxvYWRlZCgpID09PSBmYWxzZSkge1xuXHRcdFx0Ly8gRm9yY2UgdG8gZHJhdyBhIGZyYW1lIGFmdGVyIGltYWdlIGlzIGxvYWRlZCBvbiByZW5kZXIoKVxuXHRcdFx0dGhpcy5fc2hvdWxkRm9yY2VEcmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHR0aGlzLl9rZWVwVXBkYXRlID0gZG9VcGRhdGU7XG5cdH1cblxuXHRyZW5kZXJXaXRoUXVhdGVybmlvbihxdWF0ZXJuaW9uLCBmaWVsZE9mVmlldykge1xuXHRcdGlmICghdGhpcy5pc0ltYWdlTG9hZGVkKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fa2VlcFVwZGF0ZSA9PT0gZmFsc2UgJiZcblx0XHRcdHRoaXMuX2xhc3RRdWF0ZXJuaW9uICYmIHF1YXQuZXhhY3RFcXVhbHModGhpcy5fbGFzdFF1YXRlcm5pb24sIHF1YXRlcm5pb24pICYmXG5cdFx0XHR0aGlzLmZpZWxkT2ZWaWV3ICYmIHRoaXMuZmllbGRPZlZpZXcgPT09IGZpZWxkT2ZWaWV3ICYmXG5cdFx0XHR0aGlzLl9zaG91bGRGb3JjZURyYXcgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlZmllbGRPZlZpZXcgb25seSBpZiBmaWVsZE9mVmlldyBpcyBjaGFuZ2VkLlxuXHRcdGlmIChmaWVsZE9mVmlldyAhPT0gdW5kZWZpbmVkICYmIGZpZWxkT2ZWaWV3ICE9PSB0aGlzLmZpZWxkT2ZWaWV3KSB7XG5cdFx0XHR0aGlzLnVwZGF0ZUZpZWxkT2ZWaWV3KGZpZWxkT2ZWaWV3KTtcblx0XHR9XG5cblx0XHRsZXQgb3V0UTtcblxuXHRcdGlmICghdGhpcy5faXNDdWJlTWFwKSB7XG5cdFx0XHQvLyBUT0RPOiBSZW1vdmUgdGhpcyB5YXcgcmV2aXNpb24gYnkgY29ycmVjdGluZyBzaGFkZXJcblx0XHRcdG91dFEgPSBxdWF0LnJvdGF0ZVkocXVhdC5jcmVhdGUoKSwgcXVhdGVybmlvbiwgZ2xNYXRyaXgudG9SYWRpYW4oOTApKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3V0USA9IHF1YXRlcm5pb247XG5cdFx0fVxuXG5cdFx0dGhpcy5tdk1hdHJpeCA9IG1hdDQuZnJvbVF1YXQobWF0NC5jcmVhdGUoKSwgb3V0USk7XG5cblx0XHR0aGlzLl9kcmF3KCk7XG5cblx0XHR0aGlzLl9sYXN0UXVhdGVybmlvbiA9IHF1YXQuY2xvbmUocXVhdGVybmlvbik7XG5cdFx0aWYgKHRoaXMuX3Nob3VsZEZvcmNlRHJhdykge1xuXHRcdFx0dGhpcy5fc2hvdWxkRm9yY2VEcmF3ID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0cmVuZGVyKHlhdywgcGl0Y2gsIGZpZWxkT2ZWaWV3KSB7XG5cdFx0aWYgKCF0aGlzLmlzSW1hZ2VMb2FkZWQoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9rZWVwVXBkYXRlID09PSBmYWxzZSAmJlxuXHRcdFx0XHR0aGlzLl9sYXN0WWF3ICE9PSBudWxsICYmIHRoaXMuX2xhc3RZYXcgPT09IHlhdyAmJlxuXHRcdFx0XHR0aGlzLl9sYXN0UGl0Y2ggIT09IG51bGwgJiYgdGhpcy5fbGFzdFBpdGNoID09PSBwaXRjaCAmJlxuXHRcdFx0XHR0aGlzLmZpZWxkT2ZWaWV3ICYmIHRoaXMuZmllbGRPZlZpZXcgPT09IGZpZWxkT2ZWaWV3ICYmXG5cdFx0XHRcdHRoaXMuX3Nob3VsZEZvcmNlRHJhdyA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmaWVsZE9mVmlldyDqsIAg7KG07J6s7ZWY66m07IScIOq4sOyhtOydmCDqsJLqs7wg64uk66W8IOqyveyasOyXkOunjCDsl4XrjbDsnbTtirgg7Zi47LacXG5cdFx0aWYgKGZpZWxkT2ZWaWV3ICE9PSB1bmRlZmluZWQgJiYgZmllbGRPZlZpZXcgIT09IHRoaXMuZmllbGRPZlZpZXcpIHtcblx0XHRcdHRoaXMudXBkYXRlRmllbGRPZlZpZXcoZmllbGRPZlZpZXcpO1xuXHRcdH1cblxuXHRcdG1hdDQuaWRlbnRpdHkodGhpcy5tdk1hdHJpeCk7XG5cdFx0bWF0NC5yb3RhdGVYKHRoaXMubXZNYXRyaXgsIHRoaXMubXZNYXRyaXgsIC1nbE1hdHJpeC50b1JhZGlhbihwaXRjaCkpO1xuXHRcdG1hdDQucm90YXRlWSh0aGlzLm12TWF0cml4LCB0aGlzLm12TWF0cml4LFxuXHRcdFx0LWdsTWF0cml4LnRvUmFkaWFuKHlhdyAtICh0aGlzLl9pc0N1YmVNYXAgPyAwIDogOTApKSk7XG5cblx0XHR0aGlzLl9kcmF3KCk7XG5cblx0XHR0aGlzLl9sYXN0WWF3ID0geWF3O1xuXHRcdHRoaXMuX2xhc3RQaXRjaCA9IHBpdGNoO1xuXHRcdGlmICh0aGlzLl9zaG91bGRGb3JjZURyYXcpIHtcblx0XHRcdHRoaXMuX3Nob3VsZEZvcmNlRHJhdyA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdF9kcmF3KCkge1xuXHRcdGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuXG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLnNoYWRlclByb2dyYW0ucE1hdHJpeFVuaWZvcm0sIGZhbHNlLCB0aGlzLnBNYXRyaXgpO1xuXHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5zaGFkZXJQcm9ncmFtLm12TWF0cml4VW5pZm9ybSwgZmFsc2UsIHRoaXMubXZNYXRyaXgpO1xuXG5cdFx0aWYgKHRoaXMuX2lzVmlkZW8gJiYgdGhpcy5fa2VlcFVwZGF0ZSkge1xuXHRcdFx0dGhpcy5fdXBkYXRlVGV4dHVyZSgpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmluZGV4QnVmZmVyKSB7XG5cdFx0XHRnbC5kcmF3RWxlbWVudHMoXG5cdFx0XHRcdGdsLlRSSUFOR0xFUywgdGhpcy5pbmRleEJ1ZmZlci5udW1JdGVtcywgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuXHRcdH1cblx0fVxufVxuXG5QYW5vSW1hZ2VSZW5kZXJlci5FVkVOVFMgPSBFVkVOVFM7XG5QYW5vSW1hZ2VSZW5kZXJlci5FUlJPUl9UWVBFID0gRVJST1JfVFlQRTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9QYW5vSW1hZ2VSZW5kZXJlci5qcyIsIi8vIGltcG9ydCBBZ2VudCBmcm9tIFwiQGVnanMvYWdlbnRcIjtcblxuLyogUmVmIGh0dHBzOi8vd3d3Lnczc2Nob29scy5jb20vdGFncy9hdl9wcm9wX3JlYWR5c3RhdGUuYXNwICovXG5jb25zdCBSRUFEWV9TVEFUVVMgPSB7XG5cdEhBVkVfTk9USElORzogMCwgLy8gbm8gaW5mb3JtYXRpb24gd2hldGhlciBvciBub3QgdGhlIGF1ZGlvL3ZpZGVvIGlzIHJlYWR5XG5cdEhBVkVfTUVUQURBVEE6IDEsIC8vIEhBVkVfTUVUQURBVEEgLSBtZXRhZGF0YSBmb3IgdGhlIGF1ZGlvL3ZpZGVvIGlzIHJlYWR5XG5cdEhBVkVfQ1VSUkVOVF9EQVRBOiAyLCAvLyBkYXRhIGZvciB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiBpcyBhdmFpbGFibGUsIGJ1dCBub3QgZW5vdWdoIGRhdGEgdG8gcGxheSBuZXh0IGZyYW1lL21pbGxpc2Vjb25kXG5cdEhBVkVfRlVUVVJFX0RBVEE6IDMsIC8vIGRhdGEgZm9yIHRoZSBjdXJyZW50IGFuZCBhdCBsZWFzdCB0aGUgbmV4dCBmcmFtZSBpcyBhdmFpbGFibGVcblx0SEFWRV9FTk9VR0hfREFUQTogNCwgLy8gZW5vdWdoIGRhdGEgYXZhaWxhYmxlIHRvIHN0YXJ0IHBsYXlpbmdcblx0Ly8gYmVsb3cgaXMgY3VzdG9tIHN0YXR1cyBmb3IgZmFpbGVkIHRvIGxvYWQgc3RhdHVzXG5cdExPQURJTkdfRkFJTEVEOiAtMVxufTtcblxuY29uc3QgUkVBRFlTVEFURUNIQU5HRV9FVkVOVF9OQU1FID0ge307XG5cblJFQURZU1RBVEVDSEFOR0VfRVZFTlRfTkFNRVtSRUFEWV9TVEFUVVMuSEFWRV9NRVRBREFUQV0gPSBcImxvYWRlZG1ldGFkYXRhXCI7XG5SRUFEWVNUQVRFQ0hBTkdFX0VWRU5UX05BTUVbUkVBRFlfU1RBVFVTLkhBVkVfQ1VSUkVOVF9EQVRBXSA9IFwibG9hZGVkZGF0YVwiO1xuUkVBRFlTVEFURUNIQU5HRV9FVkVOVF9OQU1FW1JFQURZX1NUQVRVUy5IQVZFX0ZVVFVSRV9EQVRBXSA9IFwiY2FucGxheVwiO1xuUkVBRFlTVEFURUNIQU5HRV9FVkVOVF9OQU1FW1JFQURZX1NUQVRVUy5IQVZFX0VOT1VHSF9EQVRBXSA9IFwiY2FucGxheXRocm91Z2hcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlkZW9Mb2FkZXIge1xuXHRjb25zdHJ1Y3Rvcih2aWRlbykge1xuXHRcdHRoaXMuX2hhbmRsZXJzID0gW107XG5cdFx0dGhpcy5fc291cmNlQ291bnQgPSAwO1xuXG5cdFx0Ly8gb24gaU9TIHNhZmFyaSwgJ2xvYWRlZGRhdGEnIHdpbGwgbm90IHRyaWdnZXJlZCB1bmxlc3MgdGhlIHVzZXIgaGl0cyBwbGF5LFxuXHRcdC8vIHNvIHVzZWQgJ2xvYWRlZG1ldGFkYXRhJyBpbnN0ZWFkLlxuXHRcdHRoaXMuX3RocmVzaG9sZFJlYWR5U3RhdGUgPSBSRUFEWV9TVEFUVVMuSEFWRV9NRVRBREFUQTtcblx0XHR0aGlzLl90aHJlc2hvbGRFdmVudE5hbWUgPSBSRUFEWVNUQVRFQ0hBTkdFX0VWRU5UX05BTUVbdGhpcy5fdGhyZXNob2xkUmVhZHlTdGF0ZV07XG5cblx0XHR0aGlzLl9sb2FkU3RhdHVzID0gKHZpZGVvICYmIHZpZGVvLnJlYWR5U3RhdGUpIHx8IFJFQURZX1NUQVRVUy5IQVZFX05PVEhJTkc7XG5cblx0XHR0aGlzLl9vbmVycm9yID0gdGhpcy5fb25lcnJvci5iaW5kKHRoaXMpO1xuXG5cdFx0dmlkZW8gJiYgdGhpcy5zZXQodmlkZW8pO1xuXHR9XG5cblx0X29uZXJyb3IoKSB7XG5cdFx0dGhpcy5fZXJyb3JDb3VudCsrO1xuXHRcdGlmICh0aGlzLl9lcnJvckNvdW50ID49IHRoaXMuX3NvdXJjZUNvdW50KSB7XG5cdFx0XHR0aGlzLl9sb2FkU3RhdHVzID0gUkVBRFlfU1RBVFVTLkxPQURJTkdfRkFJTEVEO1xuXHRcdFx0dGhpcy5fZGV0YWNoRXJyb3JIYW5kbGVyKHRoaXMuX29uZXJyb3IpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdCB8IFN0cmluZ30gdmlkZW8gT2JqZWN0IG9yIFN0cmluZyBjb250YWluaW5nIFZpZGVvIFNvdXJjZSBVUkw8a28+67mE65SU7JikIFVSTCDsoJXrs7Trpbwg64u06rOgIOyeiOuKlCDrrLjsnpDsl7TsnbTrgpgg6rCd7LK0IHt0eXBlLCBzcmN9PC9rbz5cblx0ICovXG5cdF9hcHBlbmRTb3VyY2VFbGVtZW50KHZpZGVvVXJsKSB7XG5cdFx0bGV0IHZpZGVvU3JjO1xuXHRcdGxldCB2aWRlb1R5cGU7XG5cblx0XHRpZiAodHlwZW9mIHZpZGVvVXJsID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHR2aWRlb1NyYyA9IHZpZGVvVXJsLnNyYztcblx0XHRcdHZpZGVvVHlwZSA9IHZpZGVvVXJsLnR5cGU7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdmlkZW9VcmwgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZpZGVvU3JjID0gdmlkZW9Vcmw7XG5cdFx0fVxuXG5cdFx0aWYgKCF2aWRlb1NyYykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGNvbnN0IHNvdXJjZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic291cmNlXCIpO1xuXG5cdFx0c291cmNlRWxlbWVudC5zcmMgPSB2aWRlb1NyYztcblx0XHR2aWRlb1R5cGUgJiYgKHNvdXJjZUVsZW1lbnQudHlwZSA9IHZpZGVvVHlwZSk7XG5cblx0XHR0aGlzLl92aWRlby5hcHBlbmRDaGlsZChzb3VyY2VFbGVtZW50KTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHNldCh2aWRlbykge1xuXHRcdHRoaXMuX3Jlc2V0KCk7IC8vIHJlc2V0IHJlc291cmNlcy5cblxuXHRcdGlmICghdmlkZW8pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodmlkZW8gaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG5cdFx0XHQvLyB2aWRlbyB0YWdcblx0XHRcdHRoaXMuX3ZpZGVvID0gdmlkZW87XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgdmlkZW8gPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZpZGVvID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHQvLyB1cmxcblx0XHRcdHRoaXMuX3ZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuXHRcdFx0dGhpcy5fdmlkZW8uc2V0QXR0cmlidXRlKFwiY3Jvc3NvcmlnaW5cIiwgXCJhbm9ueW1vdXNcIik7XG5cdFx0XHR0aGlzLl92aWRlby5zZXRBdHRyaWJ1dGUoXCJ3ZWJraXQtcGxheXNpbmxpbmVcIiwgXCJcIik7XG5cdFx0XHR0aGlzLl92aWRlby5zZXRBdHRyaWJ1dGUoXCJwbGF5c2lubGluZVwiLCBcIlwiKTtcblxuXHRcdFx0aWYgKHZpZGVvIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0dmlkZW8uZm9yRWFjaCh2ID0+IHRoaXMuX2FwcGVuZFNvdXJjZUVsZW1lbnQodikpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fYXBwZW5kU291cmNlRWxlbWVudCh2aWRlbyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NvdXJjZUNvdW50ID0gdGhpcy5fdmlkZW8ucXVlcnlTZWxlY3RvckFsbChcInNvdXJjZVwiKS5sZW5ndGg7XG5cblx0XHRcdGlmICh0aGlzLl9zb3VyY2VDb3VudCA+IDApIHtcblx0XHRcdFx0aWYgKHRoaXMuX3ZpZGVvLnJlYWR5U3RhdGUgPCB0aGlzLl90aHJlc2hvbGRSZWFkeVN0YXRlKSB7XG5cdFx0XHRcdFx0dGhpcy5fdmlkZW8ubG9hZCgpO1xuXHRcdFx0XHRcdC8vIGF0dGFjaCBsb2FkaW5nIGVycm9yIGxpc3RlbmVyXG5cdFx0XHRcdFx0dGhpcy5fYXR0YWNoRXJyb3JIYW5kbGVyKHRoaXMuX29uZXJyb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl92aWRlbyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0X2F0dGFjaEVycm9ySGFuZGxlcihoYW5kbGVyKSB7XG5cdFx0dGhpcy5fdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGhhbmRsZXIpO1xuXHRcdHRoaXMuX3NvdXJjZXMgPSB0aGlzLl92aWRlby5xdWVyeVNlbGVjdG9yQWxsKFwic291cmNlXCIpO1xuXHRcdFtdLmZvckVhY2guY2FsbCh0aGlzLl9zb3VyY2VzLCBzb3VyY2UgPT4ge1xuXHRcdFx0c291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBoYW5kbGVyKTtcblx0XHR9KTtcblx0fVxuXG5cdF9kZXRhY2hFcnJvckhhbmRsZXIoaGFuZGxlcikge1xuXHRcdHRoaXMuX3ZpZGVvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBoYW5kbGVyKTtcblx0XHRbXS5mb3JFYWNoLmNhbGwodGhpcy5fc291cmNlcywgc291cmNlID0+IHtcblx0XHRcdHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgaGFuZGxlcik7XG5cdFx0fSk7XG5cdH1cblxuXHRnZXQoKSB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXHRcdFx0aWYgKCF0aGlzLl92aWRlbykge1xuXHRcdFx0XHRyZWooXCJWaWRlb0xvYWRlcjogdmlkZW8gaXMgdW5kZWZpbmVkXCIpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9sb2FkU3RhdHVzID09PSBSRUFEWV9TVEFUVVMuTE9BRElOR19GQUlMRUQpIHtcblx0XHRcdFx0cmVqKFwiVmlkZW9Mb2FkZXI6IHZpZGVvIHNvdXJjZSBpcyBpbnZhbGlkXCIpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl92aWRlby5yZWFkeVN0YXRlID49IHRoaXMuX3RocmVzaG9sZFJlYWR5U3RhdGUpIHtcblx0XHRcdFx0cmVzKHRoaXMuX3ZpZGVvKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGNoZWNrIGVycm9yQ250IGFuZCByZWplY3Rcblx0XHRcdFx0Y29uc3QgcmVqZWN0b3IgPSAoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX2xvYWRTdGF0dXMgPT09IFJFQURZX1NUQVRVUy5MT0FESU5HX0ZBSUxFRCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZGV0YWNoRXJyb3JIYW5kbGVyKHJlamVjdG9yKTtcblx0XHRcdFx0XHRcdHJlaihcIlZpZGVvTG9hZGVyOiB2aWRlbyBzb3VyY2UgaXMgaW52YWxpZFwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dGhpcy5fYXR0YWNoRXJyb3JIYW5kbGVyKHJlamVjdG9yKTtcblx0XHRcdFx0dGhpcy5fb25jZSh0aGlzLl90aHJlc2hvbGRFdmVudE5hbWUsICgpID0+IHJlcyh0aGlzLl92aWRlbykpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0Z2V0RWxlbWVudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmlkZW87XG5cdH1cblxuXHRkZXN0cm95KCkge1xuXHRcdHRoaXMuX3Jlc2V0KCk7XG5cdH1cblxuXHRfcmVzZXQoKSB7XG5cdFx0dGhpcy5faGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IHtcblx0XHRcdHRoaXMuX3ZpZGVvLnJlbW92ZUV2ZW50TGlzdGVuZXIoaGFuZGxlci50eXBlLCBoYW5kbGVyLmZuKTtcblx0XHR9KTtcblx0XHR0aGlzLl9oYW5kbGVycyA9IFtdO1xuXHRcdHRoaXMuX3ZpZGVvID0gbnVsbDtcblxuXHRcdHRoaXMuX3NvdXJjZUNvdW50ID0gMDtcblx0XHR0aGlzLl9lcnJvckNvdW50ID0gMDtcblx0fVxuXG5cdF9vbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG5cdFx0Y29uc3QgdGFyZ2V0ID0gdGhpcy5fdmlkZW87XG5cblx0XHRjb25zdCBmbiA9IGV2ZW50ID0+IHtcblx0XHRcdHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuKTtcblx0XHRcdGxpc3RlbmVyKGV2ZW50KTtcblx0XHR9O1xuXG5cdFx0LyogQnkgdXNlQ2FwdHVyZSBtb2RlIGVuYWJsZWQsIHlvdSBjYW4gY2FwdHVyZSB0aGUgZXJyb3IgZXZlbnQgYmVpbmcgZmlyZWQgb24gc291cmNlKGNoaWxkKSovXG5cdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIHRydWUpO1xuXHRcdHRoaXMuX2hhbmRsZXJzLnB1c2goe3R5cGUsIGZufSk7XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9WaWRlb0xvYWRlci5qcyIsImV4cG9ydCBjb25zdCB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcbmV4cG9ydCBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvUGFub0ltYWdlUmVuZGVyZXIvYnJvd3Nlci5qcyIsImltcG9ydCBQYW5vSW1hZ2VSZW5kZXJlciBmcm9tIFwiLi9QYW5vSW1hZ2VSZW5kZXJlclwiO1xuaW1wb3J0IFdlYkdMVXRpbHMgZnJvbSBcIi4vV2ViR0xVdGlsc1wiO1xuXG5leHBvcnQge1xuXHRQYW5vSW1hZ2VSZW5kZXJlcixcblx0V2ViR0xVdGlsc1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9pbmRleC5qcyIsImltcG9ydCBBZ2VudCBmcm9tIFwiQGVnanMvYWdlbnRcIjtcbmltcG9ydCBSZW5kZXJlciBmcm9tIFwiLi9SZW5kZXJlci5qc1wiO1xuaW1wb3J0IHt1dGlsfSBmcm9tIFwiLi4vLi4vdXRpbHMvbWF0aC11dGlsLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1YmVSZW5kZXJlciBleHRlbmRzIFJlbmRlcmVyIHtcblx0c3RhdGljIGdldFZlcnRleFBvc2l0aW9uRGF0YSgpIHtcblx0XHRDdWJlUmVuZGVyZXIuX1ZFUlRFWF9QT1NJVElPTl9EQVRBID1cblx0XHRcdEN1YmVSZW5kZXJlci5fVkVSVEVYX1BPU0lUSU9OX0RBVEEgIT09IG51bGwgPyBDdWJlUmVuZGVyZXIuX1ZFUlRFWF9QT1NJVElPTl9EQVRBIDogW1xuXHRcdFx0XHQvLyBiYWNrXG5cdFx0XHRcdDEsIC0xLCAxLFxuXHRcdFx0XHQtMSwgLTEsIDEsXG5cdFx0XHRcdC0xLCAxLCAxLFxuXHRcdFx0XHQxLCAxLCAxLFxuXG5cdFx0XHRcdC8vIGZyb250XG5cdFx0XHRcdC0xLCAtMSwgLTEsXG5cdFx0XHRcdDEsIC0xLCAtMSxcblx0XHRcdFx0MSwgMSwgLTEsXG5cdFx0XHRcdC0xLCAxLCAtMSxcblxuXHRcdFx0XHQvLyB0b3Bcblx0XHRcdFx0LTEsIDEsIC0xLFxuXHRcdFx0XHQxLCAxLCAtMSxcblx0XHRcdFx0MSwgMSwgMSxcblx0XHRcdFx0LTEsIDEsIDEsXG5cblx0XHRcdFx0Ly8gYm90dG9tXG5cdFx0XHRcdDEsIC0xLCAtMSxcblx0XHRcdFx0LTEsIC0xLCAtMSxcblx0XHRcdFx0LTEsIC0xLCAxLFxuXHRcdFx0XHQxLCAtMSwgMSxcblxuXHRcdFx0XHQvLyByaWdodFxuXHRcdFx0XHQxLCAtMSwgLTEsXG5cdFx0XHRcdDEsIC0xLCAxLFxuXHRcdFx0XHQxLCAxLCAxLFxuXHRcdFx0XHQxLCAxLCAtMSxcblxuXHRcdFx0XHQvLyBsZWZ0XG5cdFx0XHRcdC0xLCAtMSwgMSxcblx0XHRcdFx0LTEsIC0xLCAtMSxcblx0XHRcdFx0LTEsIDEsIC0xLFxuXHRcdFx0XHQtMSwgMSwgMVxuXHRcdFx0XTtcblxuXHRcdHJldHVybiBDdWJlUmVuZGVyZXIuX1ZFUlRFWF9QT1NJVElPTl9EQVRBO1xuXHR9XG5cblx0c3RhdGljIGdldEluZGV4RGF0YSgpIHtcblx0XHRpZiAoQ3ViZVJlbmRlcmVyLl9JTkRFWF9EQVRBKSB7XG5cdFx0XHRyZXR1cm4gQ3ViZVJlbmRlcmVyLl9JTkRFWF9EQVRBO1xuXHRcdH1cblxuXHRcdGNvbnN0IGluZGV4RGF0YSA9IFtdO1xuXHRcdGNvbnN0IHZlcnRleFBvc2l0aW9uRGF0YSA9IEN1YmVSZW5kZXJlci5nZXRWZXJ0ZXhQb3NpdGlvbkRhdGEoKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgKHZlcnRleFBvc2l0aW9uRGF0YS5sZW5ndGggLyAzKTsgaSArPSA0KSB7XG5cdFx0XHRpbmRleERhdGEucHVzaChcblx0XHRcdFx0aSxcblx0XHRcdFx0aSArIDIsXG5cdFx0XHRcdGkgKyAxLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRpICsgMyxcblx0XHRcdFx0aSArIDJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Q3ViZVJlbmRlcmVyLl9JTkRFWF9EQVRBID0gaW5kZXhEYXRhO1xuXHRcdHJldHVybiBpbmRleERhdGE7XG5cdH1cblxuXHRzdGF0aWMgZXh0cmFjdFRpbGVDb25maWcoaW1hZ2VDb25maWcpIHtcblx0XHRsZXQgdGlsZUNvbmZpZyA9XG5cdFx0XHRBcnJheS5pc0FycmF5KGltYWdlQ29uZmlnLnRpbGVDb25maWcpID9cblx0XHRcdFx0aW1hZ2VDb25maWcudGlsZUNvbmZpZyA6IEFycmF5KC4uLkFycmF5KDYpKS5tYXAoKCkgPT4gaW1hZ2VDb25maWcudGlsZUNvbmZpZyk7XG5cblx0XHR0aWxlQ29uZmlnID0gdGlsZUNvbmZpZy5tYXAoXG5cdFx0XHRjb25maWcgPT4gT2JqZWN0LmFzc2lnbih7XG5cdFx0XHRcdGZsaXBIb3Jpem9udGFsOiBmYWxzZSxcblx0XHRcdFx0cm90YXRpb246IDBcblx0XHRcdH0sIGNvbmZpZylcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRpbGVDb25maWc7XG5cdH1cblxuXHRzdGF0aWMgZXh0cmFjdE9yZGVyKGltYWdlQ29uZmlnKSB7XG5cdFx0cmV0dXJuIGltYWdlQ29uZmlnLm9yZGVyIHx8IFwiUkxVREJGXCI7XG5cdH1cblxuXHRzdGF0aWMgZ2V0VGV4dHVyZUNvb3JkRGF0YShpbWFnZUNvbmZpZykge1xuXHRcdGNvbnN0IHZlcnRleE9yZGVyID0gXCJCRlVEUkxcIjtcblx0XHRjb25zdCBvcmRlciA9IEN1YmVSZW5kZXJlci5leHRyYWN0T3JkZXIoaW1hZ2VDb25maWcpO1xuXHRcdGNvbnN0IGJhc2UgPSBDdWJlUmVuZGVyZXIuZ2V0VmVydGV4UG9zaXRpb25EYXRhKCk7XG5cdFx0Y29uc3QgdGlsZUNvbmZpZyA9IEN1YmVSZW5kZXJlci5leHRyYWN0VGlsZUNvbmZpZyhpbWFnZUNvbmZpZyk7XG5cdFx0Y29uc3QgZWxlbVNpemUgPSAzO1xuXHRcdGNvbnN0IHZlcnRleFBlclRpbGUgPSA0O1xuXHRcdGNvbnN0IHRleHR1cmVDb29yZERhdGEgPVxuXHRcdHZlcnRleE9yZGVyLnNwbGl0KFwiXCIpXG5cdFx0Lm1hcChmYWNlID0+IHRpbGVDb25maWdbb3JkZXIuaW5kZXhPZihmYWNlKV0pXG5cdFx0Lm1hcCgoY29uZmlnLCBpKSA9PiB7XG5cdFx0XHRjb25zdCByb3RhdGlvbiA9IHBhcnNlSW50KGNvbmZpZy5yb3RhdGlvbiAvIDkwLCAxMCk7XG5cdFx0XHRjb25zdCBvcmRlcm1hcF8gPSBjb25maWcuZmxpcEhvcml6b250YWwgPyBbMCwgMSwgMiwgM10gOiBbMSwgMCwgMywgMl07XG5cblx0XHRcdGZvciAobGV0IHIgPSAwOyByIDwgTWF0aC5hYnMocm90YXRpb24pOyByKyspIHtcblx0XHRcdFx0aWYgKChjb25maWcuZmxpcEhvcml6b250YWwgJiYgcm90YXRpb24gPiAwKSB8fFxuXHRcdFx0XHRcdCghY29uZmlnLmZsaXBIb3Jpem9udGFsICYmIHJvdGF0aW9uIDwgMCkpIHtcblx0XHRcdFx0XHRvcmRlcm1hcF8ucHVzaChvcmRlcm1hcF8uc2hpZnQoKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3JkZXJtYXBfLnVuc2hpZnQob3JkZXJtYXBfLnBvcCgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBlbGVtUGVyVGlsZSA9IGVsZW1TaXplICogdmVydGV4UGVyVGlsZTtcblx0XHRcdGNvbnN0IHRpbGVWZXJ0ZXggPSBiYXNlLnNsaWNlKGkgKiBlbGVtUGVyVGlsZSwgaSAqIGVsZW1QZXJUaWxlICsgZWxlbVBlclRpbGUpO1xuXHRcdFx0Y29uc3QgdGlsZVRlbXAgPSBbXTtcblxuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCB2ZXJ0ZXhQZXJUaWxlOyBqKyspIHtcblx0XHRcdFx0dGlsZVRlbXBbb3JkZXJtYXBfW2pdXSA9IHRpbGVWZXJ0ZXguc3BsaWNlKDAsIGVsZW1TaXplKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aWxlVGVtcDtcblx0XHR9KVxuXHRcdC5qb2luKClcblx0XHQuc3BsaXQoXCIsXCIpXG5cdFx0Lm1hcCh2ID0+IHBhcnNlSW50KHYsIDEwKSk7XG5cblx0XHRyZXR1cm4gdGV4dHVyZUNvb3JkRGF0YTtcblx0fVxuXG5cdHN0YXRpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKSB7XG5cdFx0cmV0dXJuIGBcblx0XHRcdGF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcblx0XHRcdGF0dHJpYnV0ZSB2ZWMzIGFUZXh0dXJlQ29vcmQ7XG5cdFx0XHR1bmlmb3JtIG1hdDQgdU1WTWF0cml4O1xuXHRcdFx0dW5pZm9ybSBtYXQ0IHVQTWF0cml4O1xuXHRcdFx0dmFyeWluZyBoaWdocCB2ZWMzIHZWZXJ0ZXhEaXJlY3Rpb25WZWN0b3I7XG5cdFx0XHR2b2lkIG1haW4odm9pZCkge1xuXHRcdFx0XHRnbF9Qb3NpdGlvbiA9IHVQTWF0cml4ICogdU1WTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24sIDEuMCk7XG5cdFx0XHRcdHZWZXJ0ZXhEaXJlY3Rpb25WZWN0b3IgPSBhVGV4dHVyZUNvb3JkO1xuXHRcdFx0fWA7XG5cdH1cblxuXHRzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKSB7XG5cdFx0cmV0dXJuIGBcblx0XHRcdHZhcnlpbmcgaGlnaHAgdmVjMyB2VmVydGV4RGlyZWN0aW9uVmVjdG9yO1xuXHRcdFx0dW5pZm9ybSBzYW1wbGVyQ3ViZSB1U2FtcGxlcjtcblx0XHRcdHZvaWQgbWFpbih2b2lkKSB7XG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKHVTYW1wbGVyLCB2VmVydGV4RGlyZWN0aW9uVmVjdG9yKTtcblx0XHRcdH1gO1xuXHR9XG5cblx0c3RhdGljIHVwZGF0ZVRleHR1cmUoZ2wsIGltYWdlLCBpbWFnZUNvbmZpZykge1xuXHRcdGNvbnN0IGJhc2VPcmRlciA9IFwiUkxVREJGXCI7XG5cdFx0Y29uc3Qgb3JkZXIgPSBDdWJlUmVuZGVyZXIuZXh0cmFjdE9yZGVyKGltYWdlQ29uZmlnKTtcblx0XHRjb25zdCBvcmRlck1hcCA9IHt9O1xuXG5cdFx0b3JkZXIuc3BsaXQoXCJcIikuZm9yRWFjaCgodiwgaSkgPT4ge1xuXHRcdFx0b3JkZXJNYXBbdl0gPSBpO1xuXHRcdH0pO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGlmIChpbWFnZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdGZvciAobGV0IHN1cmZhY2VJZHggPSAwOyBzdXJmYWNlSWR4IDwgNjsgc3VyZmFjZUlkeCsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgdGlsZUlkeCA9IG9yZGVyTWFwW2Jhc2VPcmRlcltzdXJmYWNlSWR4XV07XG5cblx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKFxuXHRcdFx0XHRcdFx0Z2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgc3VyZmFjZUlkeCwgMCwgZ2wuUkdCQSxcblx0XHRcdFx0XHRcdGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGltYWdlW3RpbGVJZHhdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgbWF4Q3ViZU1hcFRleHR1cmVTaXplID0gQ3ViZVJlbmRlcmVyLmdldE1heEN1YmVNYXBUZXh0dXJlU2l6ZShnbCwgaW1hZ2UpO1xuXG5cdFx0XHRcdGZvciAobGV0IHN1cmZhY2VJZHggPSAwOyBzdXJmYWNlSWR4IDwgNjsgc3VyZmFjZUlkeCsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgdGlsZUlkeCA9IG9yZGVyTWFwW2Jhc2VPcmRlcltzdXJmYWNlSWR4XV07XG5cdFx0XHRcdFx0Y29uc3QgdGlsZSA9IEN1YmVSZW5kZXJlci5leHRyYWN0VGlsZUZyb21JbWFnZShcblx0XHRcdFx0XHRcdGltYWdlLCB0aWxlSWR4LCBtYXhDdWJlTWFwVGV4dHVyZVNpemVcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChcblx0XHRcdFx0XHRcdGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIHN1cmZhY2VJZHgsIDAsIGdsLlJHQkEsXG5cdFx0XHRcdFx0XHRnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aWxlXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblxuXHRcdH1cblx0fVxuXG5cdHN0YXRpYyBiaW5kVGV4dHVyZShnbCwgdGV4dHVyZSwgaW1hZ2UsIGltYWdlQ29uZmlnKSB7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZSk7XG5cdFx0Q3ViZVJlbmRlcmVyLnVwZGF0ZVRleHR1cmUoZ2wsIGltYWdlLCBpbWFnZUNvbmZpZyk7XG5cdH1cblxuXHRzdGF0aWMgX2dldERpbWVuc2lvbihwaXhlbFNvdXJjZSkge1xuXHRcdGNvbnN0IHdpZHRoID0gcGl4ZWxTb3VyY2UubmF0dXJhbFdpZHRoIHx8IHBpeGVsU291cmNlLnZpZGVvV2lkdGg7XG5cdFx0Y29uc3QgaGVpZ2h0ID0gcGl4ZWxTb3VyY2UubmF0dXJhbEhlaWdodCB8fCBwaXhlbFNvdXJjZS52aWRlb0hlaWdodDtcblxuXHRcdHJldHVybiB7d2lkdGgsIGhlaWdodH07XG5cdH1cblxuXHRzdGF0aWMgZ2V0U291cmNlVGlsZVNpemUoaW1hZ2UpIHtcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLl9nZXREaW1lbnNpb24oaW1hZ2UpO1xuXHRcdGNvbnN0IGFzcGVjdFJhdGlvID0gd2lkdGggLyBoZWlnaHQ7XG5cdFx0bGV0IGlucHV0VGV4dHVyZVNpemU7XG5cblx0XHRpZiAoYXNwZWN0UmF0aW8gPT09IDEgLyA2KSB7XG5cdFx0XHRpbnB1dFRleHR1cmVTaXplID0gd2lkdGg7XG5cdFx0fSBlbHNlIGlmIChhc3BlY3RSYXRpbyA9PT0gNikge1xuXHRcdFx0aW5wdXRUZXh0dXJlU2l6ZSA9IGhlaWdodDtcblx0XHR9IGVsc2UgaWYgKGFzcGVjdFJhdGlvID09PSAyIC8gMykge1xuXHRcdFx0aW5wdXRUZXh0dXJlU2l6ZSA9IHdpZHRoIC8gMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5wdXRUZXh0dXJlU2l6ZSA9IHdpZHRoIC8gMztcblx0XHR9XG5cdFx0cmV0dXJuIGlucHV0VGV4dHVyZVNpemU7XG5cdH1cblxuXHRzdGF0aWMgZXh0cmFjdFRpbGVGcm9tSW1hZ2UoaW1hZ2UsIHRpbGVJZHgsIG91dHB1dFRleHR1cmVTaXplKSB7XG5cdFx0Y29uc3Qge3dpZHRofSA9IHRoaXMuX2dldERpbWVuc2lvbihpbWFnZSk7XG5cdFx0Y29uc3QgaW5wdXRUZXh0dXJlU2l6ZSA9IEN1YmVSZW5kZXJlci5nZXRTb3VyY2VUaWxlU2l6ZShpbWFnZSk7XG5cblx0XHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXG5cdFx0Y2FudmFzLndpZHRoID0gb3V0cHV0VGV4dHVyZVNpemU7XG5cdFx0Y2FudmFzLmhlaWdodCA9IG91dHB1dFRleHR1cmVTaXplO1xuXHRcdGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdGNvbnN0IHRpbGVQZXJSb3cgPSB3aWR0aCAvIGlucHV0VGV4dHVyZVNpemU7XG5cblx0XHRjb25zdCB4ID0gaW5wdXRUZXh0dXJlU2l6ZSAqIHRpbGVJZHggJSAoaW5wdXRUZXh0dXJlU2l6ZSAqIHRpbGVQZXJSb3cpO1xuXHRcdGNvbnN0IHkgPSBwYXJzZUludCh0aWxlSWR4IC8gdGlsZVBlclJvdywgMTApICogKGlucHV0VGV4dHVyZVNpemUpO1xuXG5cdFx0Y29udGV4dC5kcmF3SW1hZ2UoXG5cdFx0XHRpbWFnZSwgeCwgeSxcblx0XHRcdGlucHV0VGV4dHVyZVNpemUsIGlucHV0VGV4dHVyZVNpemUsIDAsIDAsIG91dHB1dFRleHR1cmVTaXplLCBvdXRwdXRUZXh0dXJlU2l6ZVxuXHRcdCk7XG5cdFx0cmV0dXJuIGNhbnZhcztcblx0fVxuXG5cdHN0YXRpYyBnZXRNYXhDdWJlTWFwVGV4dHVyZVNpemUoZ2wsIGltYWdlKSB7XG5cdFx0Y29uc3QgYWdlbnQgPSBBZ2VudCgpO1xuXHRcdGNvbnN0IG1heEN1YmVNYXBUZXh0dXJlU2l6ZSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFKTtcblx0XHRsZXQgX2ltYWdlV2lkdGggPSBDdWJlUmVuZGVyZXIuZ2V0U291cmNlVGlsZVNpemUoaW1hZ2UpO1xuXG5cdFx0aWYgKGFnZW50LmJyb3dzZXIubmFtZSA9PT0gXCJpZVwiICYmIHBhcnNlSW50KGFnZW50LmJyb3dzZXIudmVyc2lvbiwgMTApID09PSAxMSkge1xuXHRcdFx0aWYgKCF1dGlsLmlzUG93ZXJPZlR3byhfaW1hZ2VXaWR0aCkpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCBtYXhDdWJlTWFwVGV4dHVyZVNpemU7IGkgKj0gMikge1xuXHRcdFx0XHRcdGlmIChpIDwgX2ltYWdlV2lkdGgpIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRfaW1hZ2VXaWR0aCA9IGk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gaW9zIDkg7J2YIOqyveyasCDthY3siqTss5Ag7LWc64yA7IKs7J207KaI64qUIDEwMjQg7J2064ukLlxuXHRcdGlmIChhZ2VudC5vcy5uYW1lID09PSBcImlvc1wiICYmIHBhcnNlSW50KGFnZW50Lm9zLnZlcnNpb24sIDEwKSA9PT0gOSkge1xuXHRcdFx0X2ltYWdlV2lkdGggPSAxMDI0O1xuXHRcdH1cblx0XHQvLyBpb3MgOCDsnZgg6rK97JqwIO2FjeyKpOyzkCDstZzrjIDsgqzsnbTspojripQgNTEyIOydtOuLpC5cblx0XHRpZiAoYWdlbnQub3MubmFtZSA9PT0gXCJpb3NcIiAmJiBwYXJzZUludChhZ2VudC5vcy52ZXJzaW9uLCAxMCkgPT09IDgpIHtcblx0XHRcdF9pbWFnZVdpZHRoID0gNTEyO1xuXHRcdH1cblx0XHQvLyBtYXhDdWJlTWFwVGV4dHVyZVNpemUg67O064uk64qUIOyekeqzoCwgaW1hZ2VXaWR0aCDrs7Tri6Qg7YGwIDLsnZgg7Iq57IiYIOykkSDqsIDsnqUg7J6R7J2AIOyImFxuXHRcdHJldHVybiBNYXRoLm1pbihtYXhDdWJlTWFwVGV4dHVyZVNpemUsIF9pbWFnZVdpZHRoKTtcblx0fVxufVxuXG5DdWJlUmVuZGVyZXIuX1ZFUlRFWF9QT1NJVElPTl9EQVRBID0gbnVsbDtcbkN1YmVSZW5kZXJlci5fSU5ERVhfREFUQSA9IG51bGw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvUGFub0ltYWdlUmVuZGVyZXIvcmVuZGVyZXIvQ3ViZVJlbmRlcmVyLmpzIiwiaW1wb3J0IEFnZW50IGZyb20gXCJAZWdqcy9hZ2VudFwiO1xuaW1wb3J0IFJlbmRlcmVyIGZyb20gXCIuL1JlbmRlcmVyLmpzXCI7XG5cbmNvbnN0IGFnZW50ID0gQWdlbnQoKTtcbmNvbnN0IGlzSUUxMSA9IGFnZW50LmJyb3dzZXIubmFtZSA9PT0gXCJpZVwiICYmIGFnZW50LmJyb3dzZXIudmVyc2lvbiA9PT0gXCIxMS4wXCI7XG5sZXQgcGl4ZWxDYW52YXM7XG5sZXQgcGl4ZWxDb250ZXh0O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGhlcmVSZW5kZXJlciBleHRlbmRzIFJlbmRlcmVyIHtcblx0c3RhdGljIGdldFZlcnRleFBvc2l0aW9uRGF0YSgpIHtcblx0XHRyZXR1cm4gU3BoZXJlUmVuZGVyZXIuX1ZFUlRFWF9QT1NJVElPTl9EQVRBO1xuXHR9XG5cblx0c3RhdGljIGdldEluZGV4RGF0YSgpIHtcblx0XHRyZXR1cm4gU3BoZXJlUmVuZGVyZXIuX0lOREVYX0RBVEE7XG5cdH1cblxuXHRzdGF0aWMgZ2V0VGV4dHVyZUNvb3JkRGF0YSgpIHtcblx0XHRyZXR1cm4gU3BoZXJlUmVuZGVyZXIuX1RFWFRVUkVfQ09PUkRfREFUQTtcblx0fVxuXG5cdHN0YXRpYyBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKSB7XG5cdFx0cmV0dXJuIGBcblx0XHRcdGF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcblx0XHRcdGF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG5cdFx0XHR1bmlmb3JtIG1hdDQgdU1WTWF0cml4O1xuXHRcdFx0dW5pZm9ybSBtYXQ0IHVQTWF0cml4O1xuXHRcdFx0dmFyeWluZyBoaWdocCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cdFx0XHR2b2lkIG1haW4odm9pZCkge1xuXHRcdFx0XHRnbF9Qb3NpdGlvbiA9IHVQTWF0cml4ICogdU1WTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24sIDEuMCk7XG5cdFx0XHRcdHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuXHRcdFx0fWA7XG5cdH1cblxuXHRzdGF0aWMgZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKSB7XG5cdFx0cmV0dXJuIGBcblx0XHRcdHZhcnlpbmcgaGlnaHAgdmVjMiB2VGV4dHVyZUNvb3JkO1xuXHRcdFx0dW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG5cdFx0XHR2b2lkIG1haW4odm9pZCkge1xuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoXG5cdFx0XHRcdFx0dVNhbXBsZXIsXG5cdFx0XHRcdFx0dmVjMih2VGV4dHVyZUNvb3JkLnMsIHZUZXh0dXJlQ29vcmQudClcblx0XHRcdFx0KTtcblx0XHRcdH1gO1xuXHR9XG5cblx0c3RhdGljIF9nZXRQaXhlbFNvdXJjZShpbWFnZSkge1xuXHRcdGlmICghcGl4ZWxDYW52YXMpIHtcblx0XHRcdHJldHVybiBpbWFnZTtcblx0XHR9XG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy5fZ2V0RGltZW5zaW9uKGltYWdlKTtcblxuXHRcdGlmIChwaXhlbENhbnZhcy53aWR0aCAhPT0gd2lkdGgpIHtcblx0XHRcdHBpeGVsQ2FudmFzLndpZHRoID0gd2lkdGg7XG5cdFx0fVxuXG5cdFx0aWYgKHBpeGVsQ2FudmFzLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG5cdFx0XHRwaXhlbENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0fVxuXG5cdFx0cGl4ZWxDb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG5cblx0XHRyZXR1cm4gcGl4ZWxDYW52YXM7XG5cdH1cblxuXHRzdGF0aWMgX2dldERpbWVuc2lvbihwaXhlbFNvdXJjZSkge1xuXHRcdGNvbnN0IHdpZHRoID0gcGl4ZWxTb3VyY2UubmF0dXJhbFdpZHRoIHx8IHBpeGVsU291cmNlLnZpZGVvV2lkdGg7XG5cdFx0Y29uc3QgaGVpZ2h0ID0gcGl4ZWxTb3VyY2UubmF0dXJhbEhlaWdodCB8fCBwaXhlbFNvdXJjZS52aWRlb0hlaWdodDtcblxuXHRcdHJldHVybiB7d2lkdGgsIGhlaWdodH07XG5cdH1cblxuXHRzdGF0aWMgdXBkYXRlVGV4dHVyZShnbCwgaW1hZ2UpIHtcblx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuX2dldFBpeGVsU291cmNlKGltYWdlKSk7XG5cdH1cblxuXHRzdGF0aWMgYmluZFRleHR1cmUoZ2wsIHRleHR1cmUsIGltYWdlKSB7XG5cdFx0Ly8gTWFrZSBzdXJlIGltYWdlIGlzbid0IHRvbyBiaWdcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLl9nZXREaW1lbnNpb24oaW1hZ2UpO1xuXHRcdGNvbnN0IHNpemUgPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcblx0XHRjb25zdCBtYXhTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpO1xuXG5cdFx0aWYgKHNpemUgPiBtYXhTaXplKSB7XG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5cdFx0XHRjb25zb2xlLndhcm4oYEltYWdlIHdpZHRoKCR7d2lkdGh9KSBleGNlZWRzIGRldmljZSBsaW1pdCgke21heFNpemV9KSlgKTtcblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChpc0lFMTEgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG5cdFx0XHRwaXhlbENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cdFx0XHRwaXhlbENhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0cGl4ZWxDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0cGl4ZWxDb250ZXh0ID0gcGl4ZWxDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdH1cblxuXHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuXHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuXG5cdFx0U3BoZXJlUmVuZGVyZXIudXBkYXRlVGV4dHVyZShnbCwgaW1hZ2UpO1xuXHR9XG5cblx0c3RhdGljIF9pbml0RGF0YSgpIHtcblx0XHRjb25zdCBsYXRpdHVkZUJhbmRzID0gNjA7XG5cdFx0Y29uc3QgbG9uZ2l0dWRlQmFuZHMgPSA2MDtcblx0XHRjb25zdCByYWRpdXMgPSAyO1xuXG5cdFx0Y29uc3QgdGV4dHVyZUNvb3JkRGF0YSA9IFtdO1xuXHRcdGNvbnN0IHZlcnRleFBvc2l0aW9uRGF0YSA9IFtdO1xuXHRcdGNvbnN0IGluZGV4RGF0YSA9IFtdO1xuXHRcdGxldCBsYXRJZHg7XG5cdFx0bGV0IGxuZ0lkeDtcblxuXHRcdGZvciAobGF0SWR4ID0gMDsgbGF0SWR4IDw9IGxhdGl0dWRlQmFuZHM7IGxhdElkeCsrKSB7XG5cdFx0XHRjb25zdCB0aGV0YSA9IChsYXRJZHggLyBsYXRpdHVkZUJhbmRzIC0gMC41KSAqIE1hdGguUEk7XG5cdFx0XHRjb25zdCBzaW5UaGV0YSA9IE1hdGguc2luKHRoZXRhKTtcblx0XHRcdGNvbnN0IGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xuXG5cdFx0XHRmb3IgKGxuZ0lkeCA9IDA7IGxuZ0lkeCA8PSBsb25naXR1ZGVCYW5kczsgbG5nSWR4KyspIHtcblx0XHRcdFx0Y29uc3QgcGhpID0gKGxuZ0lkeCAvIGxvbmdpdHVkZUJhbmRzIC0gMC41KSAqIDIgKiBNYXRoLlBJO1xuXHRcdFx0XHRjb25zdCBzaW5QaGkgPSBNYXRoLnNpbihwaGkpO1xuXHRcdFx0XHRjb25zdCBjb3NQaGkgPSBNYXRoLmNvcyhwaGkpO1xuXHRcdFx0XHRjb25zdCB4ID0gY29zUGhpICogY29zVGhldGE7XG5cdFx0XHRcdGNvbnN0IHkgPSBzaW5UaGV0YTtcblx0XHRcdFx0Y29uc3QgeiA9IHNpblBoaSAqIGNvc1RoZXRhO1xuXHRcdFx0XHRjb25zdCB1ID0gbG5nSWR4IC8gbG9uZ2l0dWRlQmFuZHM7XG5cdFx0XHRcdGNvbnN0IHYgPSBsYXRJZHggLyBsYXRpdHVkZUJhbmRzO1xuXG5cdFx0XHRcdHRleHR1cmVDb29yZERhdGEucHVzaCh1LCB2KTtcblx0XHRcdFx0dmVydGV4UG9zaXRpb25EYXRhLnB1c2gocmFkaXVzICogeCwgcmFkaXVzICogeSwgcmFkaXVzICogeik7XG5cblx0XHRcdFx0aWYgKGxuZ0lkeCAhPT0gbG9uZ2l0dWRlQmFuZHMgJiYgbGF0SWR4ICE9PSBsYXRpdHVkZUJhbmRzKSB7XG5cdFx0XHRcdFx0Y29uc3QgYSA9IGxhdElkeCAqIChsb25naXR1ZGVCYW5kcyArIDEpICsgbG5nSWR4O1xuXHRcdFx0XHRcdGNvbnN0IGIgPSBhICsgbG9uZ2l0dWRlQmFuZHMgKyAxO1xuXG5cdFx0XHRcdFx0aW5kZXhEYXRhLnB1c2goYSwgYiwgYSArIDEsIGIsIGIgKyAxLCBhICsgMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRTcGhlcmVSZW5kZXJlci5fVkVSVEVYX1BPU0lUSU9OX0RBVEEgPSB2ZXJ0ZXhQb3NpdGlvbkRhdGE7XG5cdFx0U3BoZXJlUmVuZGVyZXIuX1RFWFRVUkVfQ09PUkRfREFUQSA9IHRleHR1cmVDb29yZERhdGE7XG5cdFx0U3BoZXJlUmVuZGVyZXIuX0lOREVYX0RBVEEgPSBpbmRleERhdGE7XG5cdH1cbn1cblxuU3BoZXJlUmVuZGVyZXIuX1ZFUlRFWF9QT1NJVElPTl9EQVRBID0gbnVsbDtcblNwaGVyZVJlbmRlcmVyLl9URVhUVVJFX0NPT1JEX0RBVEEgPSBudWxsO1xuU3BoZXJlUmVuZGVyZXIuX0lOREVYX0RBVEEgPSBudWxsO1xuXG5TcGhlcmVSZW5kZXJlci5faW5pdERhdGEoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9yZW5kZXJlci9TcGhlcmVSZW5kZXJlci5qcyIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIkBlZ2pzL2NvbXBvbmVudFwiO1xuaW1wb3J0IHtcblx0RGV2aWNlTW90aW9uRXZlbnRcbn0gZnJvbSBcIi4vYnJvd3NlclwiO1xuXG5pbXBvcnQge1lhd1BpdGNoQ29udHJvbH0gZnJvbSBcIi4uL1lhd1BpdGNoQ29udHJvbFwiO1xuaW1wb3J0IHtQYW5vSW1hZ2VSZW5kZXJlcn0gZnJvbSBcIi4uL1Bhbm9JbWFnZVJlbmRlcmVyXCI7XG5pbXBvcnQgV2ViR0xVdGlscyBmcm9tIFwiLi4vUGFub0ltYWdlUmVuZGVyZXIvV2ViR0xVdGlsc1wiO1xuaW1wb3J0IHtFUlJPUl9UWVBFLCBFVkVOVFMsIEdZUk9fTU9ERSwgUFJPSkVDVElPTl9UWVBFfSBmcm9tIFwiLi9jb25zdHNcIjtcbmltcG9ydCB7Z2xNYXRyaXh9IGZyb20gXCIuLi91dGlscy9tYXRoLXV0aWwuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFub1ZpZXdlciBleHRlbmRzIENvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBAY2xhc3NkZXNjIDM2MCBtZWRpYSB2aWV3ZXJcblx0ICogQGtvIDM2MCDrr7jrlJTslrQg67ew7Ja0XG5cdCAqIEBjbGFzc1xuXHQgKiBAbmFtZSBlZy52aWV3MzYwLlBhbm9WaWV3ZXJcblx0ICogQGV4dGVuZHMgZWcuQ29tcG9uZW50XG5cdCAqXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBUaGUgY29udGFpbmVyIGVsZW1lbnQgZm9yIHRoZSByZW5kZXJlci4gPGtvPuugjOuNlOufrOydmCDsu6jthYzsnbTrhIgg7JeY66as66i87Yq4PC9rbz5cblx0ICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xJbWFnZX0gY29uZmlnLmltYWdlIElucHV0IGltYWdlIHVybCBvciBlbGVtZW50PGtvPuyeheugpSDsnbTrr7jsp4AgVVJMIO2YueydgCDsl5jrpqzrqLztirgoaW1hZ2Ug7JmAIHZpZGVvIOuRmCDspJEg7ZWY64KY66eMIOyEpOygle2VnOuLpC4pPC9rbz5cblx0ICogQHBhcmFtIHtTdHJpbmd8SFRNTFZpZGVvRWxlbWVudH0gY29uZmlnLnZpZGVvIElucHV0IHZpZGVvIHVybCBvciBlbGVtZW50PGtvPuyeheugpSDruYTrlJTsmKQgVVJMIO2YueydgCDsl5jrpqzrqLztirgoaW1hZ2Ug7JmAIHZpZGVvIOuRmCDspJEg7ZWY64KY66eMIOyEpOygle2VnOuLpC4pPC9rbz5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcucHJvamVjdGlvblR5cGU9ZXF1aXJlY3Rhbmd1bGFyXSBUaGUgdHlwZSBvZiBwcm9qZWN0aW9uOiBlcXVpcmVjdGFuZ3VsYXIsIGN1YmVtYXAgPGtvPlByb2plY3Rpb24g7Jyg7ZiVIDogZXF1aXJlY3Rhbmd1bGFyLCBjdWJlbWFwPC9rbz5cblx0ICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZy5jdWJlbWFwQ29uZmlnIGNvbmZpZyBjdWJlbWFwIHByb2plY3Rpb24gbGF5b3V0LiA8a28+Y3ViZW1hcCBwcm9qZWN0aW9uIHR5cGUg7J2YIOugiOydtOyVhOybg+ydhCDshKTsoJXtlZzri6QuPC9rbz5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGg9d2lkdGggb2YgY29udGFpbmVyXSB0aGUgdmlld2VyJ3Mgd2lkdGguIChpbiBweCkgPGtvPuu3sOyWtOydmCDrhIjruYQgKHB4IOuLqOychCk8L2tvPlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHQ9aGVpZ2h0IG9mIGNvbnRhaW5lcl0gdGhlIHZpZXdlcidzIGhlaWdodC4oaW4gcHgpIDxrbz7rt7DslrTsnZgg64aS7J20IChweCDri6jsnIQpPC9rbz5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueWF3PTBdIEluaXRpYWwgWWF3IG9mIGNhbWVyYSAoaW4gZGVncmVlKSA8a28+7Lm066mU65287J2YIOy0iOq4sCBZYXcgKGRlZ3JlZSDri6jsnIQpPC9rbz5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucGl0Y2g9MF0gSW5pdGlhbCBQaXRjaCBvZiBjYW1lcmEgKGluIGRlZ3JlZSkgPGtvPuy5tOuplOudvOydmCDstIjquLAgUGl0Y2ggKGRlZ3JlZSDri6jsnIQpPC9rbz5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZm92PTY1XSBJbml0aWFsIHZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgb2YgY2FtZXJhIChpbiBkZWdyZWUpIDxrbz7subTrqZTrnbzsnZgg7LSI6riwIOyImOyngSBmaWVsZCBvZiB2aWV3IChkZWdyZWUg64uo7JyEKTwva28+XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaG93UG9sZVBvaW50PWZhbHNlXSBJZiBmYWxzZSwgdGhlIHBvbGUgaXMgbm90IGRpc3BsYXllZCBpbnNpZGUgdGhlIHZpZXdwb3J0IDxrbz5mYWxzZSDsnbgg6rK97JqwLCDqt7nsoJDsnYAg67ew7Y+s7Yq4IOuCtOu2gOyXkCDtkZzsi5zrkJjsp4Ag7JWK7Iq164uI64ukPC9rbz5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnVzZVpvb209dHJ1ZV0gV2hlbiB0cnVlLCBlbmFibGVzIHpvb20gd2l0aCB0aGUgd2hlZWwgYW5kIFBpbmNoIGdlc3R1cmUgPGtvPnRydWUg7J28IOuVjCDtnKAg67CPIOynkeq4sCDsoJzsiqTstrDroZwg7ZmV64yAIC8g7LaV7IaMIO2VoCDsiJgg7J6I7Iq164uI64ukLjwva28+XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy51c2VLZXlib2FyZD10cnVlXSBXaGVuIHRydWUsIGVuYWJsZXMgdGhlIGtleWJvYXJkIG1vdmUga2V5IGNvbnRyb2w6IGF3c2QsIGFycm93IGtleXMgPGtvPnRydWUg7J2066m0IO2CpOuztOuTnCDsnbTrj5kg7YKkIOy7qO2KuOuhpOydhCDtmZzshLHtmZTtlanri4jri6Q6IGF3c2QsIO2ZlOyCtO2RnCDtgqQ8L2tvPlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5neXJvTW9kZT15YXdQaXRjaF0gRW5hYmxlcyBjb250cm9sIHRocm91Z2ggZGV2aWNlIG1vdGlvbi4gKFwibm9uZVwiLCBcInlhd1BpdGNoXCIpIDxrbz7rlJTrsJTsnbTsiqQg7JuA7KeB7J6E7J2EIO2Gte2VnCDsu6jtirjroaTsnYQg7Zmc7ISx7ZmUIO2VqeuLiOuLpC4gKFwibm9uZVwiLCBcInlhd1BpdGNoXCIpIDwva28+XG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcueWF3UmFuZ2U9Wy0xODAsIDE4MF1dIFJhbmdlIG9mIGNvbnRyb2xsYWJsZSBZYXcgdmFsdWVzIDxrbz7soJzslrQg6rCA64ql7ZWcIFlhdyDqsJLsnZgg67KU7JyEPC9rbz5cblx0ICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5waXRjaFJhbmdlPVstOTAsIDkwXV0gUmFuZ2Ugb2YgY29udHJvbGxhYmxlIFBpdGNoIHZhbHVlcyA8a28+7KCc7Ja0IOqwgOuKpe2VnCBQaXRjaCDqsJLsnZgg67KU7JyEPC9rbz5cblx0ICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5mb3ZSYW5nZT1bMzAsIDExMF1dIFJhbmdlIG9mIGNvbnRyb2xsYWJsZSB2ZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IHZhbHVlcyA8a28+7KCc7Ja0IOqwgOuKpe2VnCDsiJjsp4EgZmllbGQgb2YgdmlldyDqsJLsnZgg67KU7JyEPC9rbz5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcudG91Y2hEaXJlY3Rpb249IFBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OLkFMTCg2KV0gRGlyZWN0aW9uIG9mIHRvdWNoIHRoYXQgY2FuIGJlIGNvbnRyb2xsZWQgYnkgdXNlciB7QGxpbmsgZWcuUGFub1ZpZXdlci5UT1VDSF9ESVJFQ1RJT059PGtvPuyCrOyaqeyekOqwgCDthLDsuZjroZwg7KGw7J6RIOqwgOuKpe2VnCDrsKntlqUge0BsaW5rIGVnLlBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OfTwva28+XG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihjb250YWluZXIsIG9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHQvLyBSYWlzZXMgdGhlIGVycm9yIGV2ZW50IGlmIHdlYmdsIGlzIG5vdCBzdXBwb3J0ZWQuXG5cdFx0aWYgKCFXZWJHTFV0aWxzLmlzV2ViR0xBdmFpbGFibGUoKSkge1xuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcihFVkVOVFMuRVJST1IsIHtcblx0XHRcdFx0XHR0eXBlOiBFUlJPUl9UWVBFLk5PX1dFQkdMLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IFwibm8gd2ViZ2wgc3VwcG9ydFwiXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSwgMCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIVdlYkdMVXRpbHMuaXNTdGFibGVXZWJHTCgpKSB7XG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKEVWRU5UUy5FUlJPUiwge1xuXHRcdFx0XHRcdHR5cGU6IEVSUk9SX1RZUEUuSU5WQUxJRF9ERVZJQ0UsXG5cdFx0XHRcdFx0bWVzc2FnZTogXCJibGFja2xpc3RlZCBicm93c2VyXCJcblx0XHRcdFx0fSk7XG5cdFx0XHR9LCAwKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKCEhb3B0aW9ucy5pbWFnZSAmJiAhIW9wdGlvbnMudmlkZW8pIHtcblx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoRVZFTlRTLkVSUk9SLCB7XG5cdFx0XHRcdFx0dHlwZTogRVJST1JfVFlQRS5JTlZBTElEX1JFU09VUkNFLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IFwiU3BlY2lmeWluZyBtdWx0aSByZXNvdWNlcyhib3RoIGltYWdlIGFuZCB2aWRlbykgaXMgbm90IHZhbGlkLlwiXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSwgMCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG5cdFx0dGhpcy5faW1hZ2UgPSBvcHRpb25zLmltYWdlIHx8IG9wdGlvbnMudmlkZW87XG5cdFx0dGhpcy5faXNWaWRlbyA9ICEhb3B0aW9ucy52aWRlbztcblx0XHR0aGlzLl9wcm9qZWN0aW9uVHlwZSA9IG9wdGlvbnMucHJvamVjdGlvblR5cGUgfHwgUFJPSkVDVElPTl9UWVBFLkVRVUlSRUNUQU5HVUxBUjtcblx0XHR0aGlzLl9jdWJlbWFwQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0XHRvcmRlcjogXCJSTFVEQkZcIixcblx0XHRcdHRpbGVDb25maWc6IHtcblx0XHRcdFx0ZmxpcEhpcm96b250YWw6IGZhbHNlLFxuXHRcdFx0XHRyb3RhdGlvbjogMFxuXHRcdFx0fVxuXHRcdH0sIG9wdGlvbnMuY3ViZW1hcENvbmZpZyk7XG5cblx0XHQvLyBJZiB0aGUgd2lkdGggYW5kIGhlaWdodCBhcmUgbm90IHByb3ZpZGVkLCB3aWxsIHVzZSB0aGUgc2l6ZSBvZiB0aGUgY29udGFpbmVyLlxuXHRcdHRoaXMuX3dpZHRoID0gb3B0aW9ucy53aWR0aCB8fCBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpLndpZHRoLCAxMCk7XG5cdFx0dGhpcy5faGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKS5oZWlnaHQsIDEwKTtcblxuXHRcdHRoaXMuX3lhdyA9IG9wdGlvbnMueWF3IHx8IDA7XG5cdFx0dGhpcy5fcGl0Y2ggPSBvcHRpb25zLnBpdGNoIHx8IDA7XG5cdFx0dGhpcy5fZm92ID0gb3B0aW9ucy5mb3YgfHwgNjU7XG5cblx0XHR0aGlzLl9neXJvTW9kZSA9IG9wdGlvbnMuZ3lyb01vZGUgfHwgR1lST19NT0RFLllBV1BJVENIO1xuXHRcdHRoaXMuX3F1YXRlcm5pb24gPSBudWxsO1xuXG5cdFx0dGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLl93aWR0aCAvIHRoaXMuX2hlaWdodDtcblx0XHRjb25zdCBmb3ZSYW5nZSA9IG9wdGlvbnMuZm92UmFuZ2UgfHwgWzMwLCAxMTBdO1xuXHRcdGNvbnN0IHRvdWNoRGlyZWN0aW9uID0gUGFub1ZpZXdlci5faXNWYWxpZFRvdWNoRGlyZWN0aW9uKG9wdGlvbnMudG91Y2hEaXJlY3Rpb24pID9cblx0XHRcdG9wdGlvbnMudG91Y2hEaXJlY3Rpb24gOiBZYXdQaXRjaENvbnRyb2wuVE9VQ0hfRElSRUNUSU9OX0FMTDtcblx0XHRjb25zdCB5YXdQaXRjaENvbmZpZyA9IE9iamVjdC5hc3NpZ24ob3B0aW9ucywge1xuXHRcdFx0ZWxlbWVudDogY29udGFpbmVyLFxuXHRcdFx0eWF3OiB0aGlzLl95YXcsXG5cdFx0XHRwaXRjaDogdGhpcy5fcGl0Y2gsXG5cdFx0XHRmb3Y6IHRoaXMuX2Zvdixcblx0XHRcdGd5cm9Nb2RlOiB0aGlzLl9neXJvTW9kZSxcblx0XHRcdGZvdlJhbmdlLFxuXHRcdFx0YXNwZWN0UmF0aW86IHRoaXMuX2FzcGVjdFJhdGlvLFxuXHRcdFx0dG91Y2hEaXJlY3Rpb25cblx0XHR9KTtcblxuXHRcdHRoaXMuX2lzUmVhZHkgPSBmYWxzZTtcblxuXHRcdHRoaXMuX2luaXRZYXdQaXRjaENvbnRyb2woeWF3UGl0Y2hDb25maWcpO1xuXHRcdHRoaXMuX2luaXRSZW5kZXJlcih0aGlzLl95YXcsIHRoaXMuX3BpdGNoLCB0aGlzLl9mb3YsIHRoaXMuX3Byb2plY3Rpb25UeXBlLCB0aGlzLl9jdWJlbWFwQ29uZmlnKTtcblx0fVxuXG5cdC8qKlxuXHRcdCogR2V0dGluZyB0aGUgdmlkZW8gZWxlbWVudCB0aGF0IHRoZSB2aWV3ZXIgaXMgY3VycmVudGx5IHBsYXlpbmcuIFlvdSBjYW4gdXNlIHRoaXMgZm9yIHBsYXliYWNrLlxuXHRcdCogQGtvIOu3sOyWtOqwgCDtmITsnqwg7IKs7JqpIOykkeyduCDruYTrlJTsmKQg7JqU7IaM66W8IOyWu+yKteuLiOuLpC4g7J20IOyalOyGjOulvCDsnbTsmqntlbQg67mE65SU7Jik7J2YIOy7qO2KuOuhpOydhCDtlaAg7IiYIOyeiOyKteuLiOuLpC5cblx0XHQqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI2dldFZpZGVvXG5cdFx0KiBAcmV0dXJuIHtIVE1MVmlkZW9FbGVtZW50fSBIVE1MVmlkZW9FbGVtZW50PGtvPkhUTUxWaWRlb0VsZW1lbnQ8L2tvPlxuXHRcdCovXG5cdGdldFZpZGVvKCkge1xuXHRcdGlmICghdGhpcy5faXNWaWRlbykge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX3Bob3RvU3BoZXJlUmVuZGVyZXIuZ2V0Q29udGVudCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHRpbmcgdGhlIHZpZGVvIGluZm9ybWF0aW9uIHRvIGJlIHVzZWQgYnkgdGhlIHZpZXdlci5cblx0ICogQGtvIOu3sOyWtOqwgCDsgqzsmqntlaAg7J2066+47KeAIOygleuztOulvCDshKTsoJUg7ZWp64uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNzZXRWaWRlb1xuXHQgKiBAcGFyYW0ge1N0cmluZ3xIVE1MVmlkZW9FbGVtZW50fE9iamVjdH0gdmlkZW8gSW5wdXQgdmlkZW8gdXJsIG9yIGVsZW1lbnQgb3IgY29uZmlnIG9iamVjdDxrbz7snoXroKUg67mE65SU7JikIFVSTCDtmLnsnYAg7JeY66as66i87Yq4IO2YueydgCDshKTsoJXqsJ3ssrTrpbwg7Zmc7JqpKGltYWdlIOyZgCB2aWRlbyDrkZgg7KSRIO2VmOuCmOunjCDshKTsoJXtlZzri6QuKTwva28+XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtLnByb2plY3Rpb25UeXBlPVwiZXF1aXJlY3Rhbmd1bGFyXCJdIFByb2plY3Rpb24gVHlwZTxrbz7tlITroZzsoJ3shZgg7YOA7J6FPC9rbz5cblx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtLmN1YmVtYXBDb25maWcgY29uZmlnIGN1YmVtYXAgcHJvamVjdGlvbiBsYXlvdXQuIDxrbz5jdWJlbWFwIHByb2plY3Rpb24gdHlwZSDsnZgg66CI7J207JWE7JuD7J2EIOyEpOygle2VnOuLpC48L2tvPlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtQYW5vVmlld2VyfSBQYW5vVmlld2VyIGluc3RhbmNlPGtvPlBhbm9WaWV3ZXIg7J247Iqk7YS07IqkPC9rbz5cblx0ICovXG5cdHNldFZpZGVvKHZpZGVvLCBwYXJhbSA9IHt9KSB7XG5cdFx0aWYgKCF2aWRlbykge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRJbWFnZShcblx0XHRcdHZpZGVvLFxuXHRcdFx0e1xuXHRcdFx0XHRwcm9qZWN0aW9uVHlwZTogcGFyYW0ucHJvamVjdGlvblR5cGUsXG5cdFx0XHRcdGlzVmlkZW86IHRydWUsXG5cdFx0XHRcdGN1YmVtYXBDb25maWc6IHBhcmFtLmN1YmVtYXBDb25maWdcblx0XHRcdH1cblx0XHQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHRpbmcgdGhlIGltYWdlIGluZm9ybWF0aW9uIHRoYXQgdGhlIHZpZXdlciBpcyBjdXJyZW50bHkgdXNpbmcuXG5cdCAqIEBrbyDrt7DslrTqsIAg7ZiE7J6sIOyCrOyaqe2VmOqzoOyeiOuKlCDsnbTrr7jsp4Ag7KCV67O066W8IOyWu+yKteuLiOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjZ2V0SW1hZ2Vcblx0ICogQHJldHVybiB7SW1hZ2V9IEltYWdlIE9iamVjdDxrbz7snbTrr7jsp4Ag6rCd7LK0PC9rbz5cblx0ICovXG5cdGdldEltYWdlKCkge1xuXHRcdGlmICh0aGlzLl9pc1ZpZGVvKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlci5nZXRDb250ZW50KCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0dGluZyB0aGUgaW1hZ2UgaW5mb3JtYXRpb24gdG8gYmUgdXNlZCBieSB0aGUgdmlld2VyLlxuXHQgKiBAa28g67ew7Ja06rCAIOyCrOyaqe2VoCDsnbTrr7jsp4Ag7KCV67O066W8IOyEpOyglSDtlanri4jri6QuXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI3NldEltYWdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEltYWdlfE9iamVjdH0gaW1hZ2UgSW5wdXQgaW1hZ2UgdXJsIG9yIGVsZW1lbnQgb3IgY29uZmlnIG9iamVjdDxrbz7snoXroKUg7J2066+47KeAIFVSTCDtmLnsnYAg7JeY66as66i87Yq4IO2YueydgCDshKTsoJXqsJ3ssrTrpbwg7Zmc7JqpKGltYWdlIOyZgCB2aWRlbyDrkZgg7KSRIO2VmOuCmOunjCDshKTsoJXtlZzri6QuKTwva28+XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSBBZGRpdGlvbmFsIGluZm9ybWF0aW9uPGtvPuydtOuvuOyngCDstpTqsIAg7KCV67O0PC9rbz5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbS5wcm9qZWN0aW9uVHlwZT1cImVxdWlyZWN0YW5ndWxhclwiXSBQcm9qZWN0aW9uIFR5cGU8a28+7ZSE66Gc7KCd7IWYIO2DgOyehTwva28+XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbS5jdWJlbWFwQ29uZmlnIGNvbmZpZyBjdWJlbWFwIHByb2plY3Rpb24gbGF5b3V0LiA8a28+Y3ViZW1hcCBwcm9qZWN0aW9uIHR5cGUg7J2YIOugiOydtOyVhOybg+ydhCDshKTsoJXtlZzri6QuPC9rbz5cblx0ICpcblx0ICogQHJldHVybiB7UGFub1ZpZXdlcn0gUGFub1ZpZXdlciBpbnN0YW5jZTxrbz5QYW5vVmlld2VyIOyduOyKpO2EtOyKpDwva28+XG5cdCAqL1xuXHRzZXRJbWFnZShpbWFnZSwgcGFyYW0gPSB7fSkge1xuXHRcdGNvbnN0IGN1YmVtYXBDb25maWcgPSBPYmplY3QuYXNzaWduKHtcblx0XHRcdG9yZGVyOiBcIlJMVURCRlwiLFxuXHRcdFx0dGlsZUNvbmZpZzoge1xuXHRcdFx0XHRmbGlwSGlyb3pvbnRhbDogZmFsc2UsXG5cdFx0XHRcdHJvdGF0aW9uOiAwXG5cdFx0XHR9XG5cdFx0fSwgcGFyYW0uY3ViZW1hcENvbmZpZyk7XG5cdFx0Y29uc3QgaXNWaWRlbyA9ICEhKHBhcmFtLmlzVmlkZW8pO1xuXG5cdFx0aWYgKHRoaXMuX2ltYWdlICYmIHRoaXMuX2lzVmlkZW8gIT09IGlzVmlkZW8pIHtcblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cblx0XHRcdGNvbnNvbGUud2FybihcIkN1cnJlbnRseSBub3Qgc3VwcG9ydGluZyB0byBjaGFuZ2UgY29udGVudCB0eXBlKEltYWdlIDwtLT4gVmlkZW8pXCIpO1xuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIWltYWdlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0aGlzLl9pbWFnZSA9IGltYWdlO1xuXHRcdHRoaXMuX2lzVmlkZW8gPSBpc1ZpZGVvO1xuXHRcdHRoaXMuX3Byb2plY3Rpb25UeXBlID0gcGFyYW0ucHJvamVjdGlvblR5cGUgfHwgUFJPSkVDVElPTl9UWVBFLkVRVUlSRUNUQU5HVUxBUjtcblx0XHR0aGlzLl9jdWJlbWFwQ29uZmlnID0gY3ViZW1hcENvbmZpZztcblxuXHRcdHRoaXMuX2RlYWN0aXZhdGUoKTtcblx0XHR0aGlzLl9pbml0UmVuZGVyZXIodGhpcy5feWF3LCB0aGlzLl9waXRjaCwgdGhpcy5fZm92LCB0aGlzLl9wcm9qZWN0aW9uVHlwZSwgdGhpcy5fY3ViZW1hcENvbmZpZyk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBDYW4gc2V0IHdoZXRoZXIgdGhlIHJlbmRlcmVyIGFsd2F5cyB1cGRhdGVzIHRoZSB0ZXh0dXJlIGFuZCByZW5kZXJzLlxuXHQgKiBAa28g66CM642U65+s6rCAIO2VreyDgSDthY3siqTss5Drpbwg6rCx7Iug7ZWY6rOgIO2ZlOuptOydhCDroIzrjZTrp4Eg7ZWg7KeAIOyXrOu2gOulvCDshKTsoJXtlaAg7IiYIOyeiOuLpC5cblx0ICpcblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIja2VlcFVwZGF0ZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGRvVXBkYXRlIFdoZW4gdHJ1ZSwgdmlld2VyIHdpbGwgYWx3YXlzIHVwZGF0ZSB0ZXh0dXJlIGFuZCByZW5kZXIsIHdoZW4gZmFsc2Ugdmlld2VyIHdpbGwgbm90IHVwZGF0ZSB0ZXh0dXJlIGFuZCByZW5kZXIgb25seSBjYW1lcmEgY29uZmlnIGlzIGNoYW5nZWQuPGtvPlRydWXrqbQsIO2VreyDgSDthY3siqTss5Drpbwg6rCx7Iug7ZWY6rOgIO2ZlOuptOydhCDqt7jrprDri6QuIEZhbHNlIOuptCDthY3siqTss5Ag6rCx7Iug7J2AIO2VmOyngCDslYrsnLzrqbAsIOy5tOuplOudvCDsmpTshozsl5Ag67OA7ZmU6rCAIOyeiOydhCDrlYzsl5Drp4wg7ZmU66m07J2EIOq3uOumsOuLpC48L2tvPlxuXHQgKi9cblx0a2VlcFVwZGF0ZShkb1VwZGF0ZSkge1xuXHRcdHRoaXMuX3Bob3RvU3BoZXJlUmVuZGVyZXIua2VlcFVwZGF0ZShkb1VwZGF0ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHByb2plY3Rpb24gdHlwZSAoZXF1aXJlY3Rhbmd1bGFyL2N1YmUpXG5cdCAqIEBrbyDtlITroZzsoJ3shZgg7YOA7J6FKEVxdWlyZWN0YW5ndWxhciDtmLnsnYAgQ3ViZSnsnYQg67CY7ZmY7ZWc64ukLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNnZXRQcm9qZWN0aW9uVHlwZVxuXHQgKi9cblx0Z2V0UHJvamVjdGlvblR5cGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3Rpb25UeXBlO1xuXHR9XG5cblx0X2luaXRSZW5kZXJlcih5YXcsIHBpdGNoLCBmb3YsIHByb2plY3Rpb25UeXBlLCBjdWJlbWFwQ29uZmlnKSB7XG5cdFx0dGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlciA9IG5ldyBQYW5vSW1hZ2VSZW5kZXJlcihcblx0XHRcdHRoaXMuX2ltYWdlLFxuXHRcdFx0dGhpcy5fd2lkdGgsXG5cdFx0XHR0aGlzLl9oZWlnaHQsXG5cdFx0XHR0aGlzLl9pc1ZpZGVvLFxuXHRcdFx0e1xuXHRcdFx0XHRpbml0aWFsWWF3OiB5YXcsXG5cdFx0XHRcdGluaXRpYWxQaXRjaDogcGl0Y2gsXG5cdFx0XHRcdGZpZWxkT2ZWaWV3OiBmb3YsXG5cdFx0XHRcdGltYWdlVHlwZTogcHJvamVjdGlvblR5cGUsXG5cdFx0XHRcdGN1YmVtYXBDb25maWdcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0dGhpcy5fYmluZFJlbmRlcmVySGFuZGxlcigpO1xuXG5cdFx0dGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlclxuXHRcdFx0LmJpbmRUZXh0dXJlKClcblx0XHRcdC50aGVuKCgpID0+IHRoaXMuX2FjdGl2YXRlKCksICgpID0+IHtcblx0XHRcdFx0dGhpcy5fdHJpZ2dlckV2ZW50KEVWRU5UUy5FUlJPUiwge1xuXHRcdFx0XHRcdHR5cGU6IEVSUk9SX1RZUEUuRkFJTF9CSU5EX1RFWFRVUkUsXG5cdFx0XHRcdFx0bWVzc2FnZTogXCJmYWlsZWQgdG8gYmluZCB0ZXh0dXJlXCJcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0fVxuXG5cdF9iaW5kUmVuZGVyZXJIYW5kbGVyKCkge1xuXHRcdHRoaXMuX3Bob3RvU3BoZXJlUmVuZGVyZXIub24oUGFub0ltYWdlUmVuZGVyZXIuRVZFTlRTLkVSUk9SLCBlID0+IHtcblx0XHRcdHRoaXMudHJpZ2dlcihFVkVOVFMuRVJST1IsIGUpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlci5vbihQYW5vSW1hZ2VSZW5kZXJlci5FVkVOVFMuUkVOREVSSU5HX0NPTlRFWFRfTE9TVCwgZSA9PiB7XG5cdFx0XHR0aGlzLl9kZWFjdGl2YXRlKCk7XG5cdFx0XHR0aGlzLnRyaWdnZXIoRVZFTlRTLkVSUk9SLCB7XG5cdFx0XHRcdHR5cGU6IEVSUk9SX1RZUEUuUkVOREVSSU5HX0NPTlRFWFRfTE9TVCxcblx0XHRcdFx0bWVzc2FnZTogXCJ3ZWJnbCByZW5kZXJpbmcgY29udGV4dCBsb3N0XCJcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0X2luaXRZYXdQaXRjaENvbnRyb2woeWF3UGl0Y2hDb25maWcpIHtcblx0XHR0aGlzLl95YXdQaXRjaENvbnRyb2wgPSBuZXcgWWF3UGl0Y2hDb250cm9sKHlhd1BpdGNoQ29uZmlnKTtcblxuXHRcdHRoaXMuX3lhd1BpdGNoQ29udHJvbC5vbihFVkVOVFMuQU5JTUFUSU9OX0VORCwgZSA9PiB7XG5cdFx0XHR0aGlzLl90cmlnZ2VyRXZlbnQoRVZFTlRTLkFOSU1BVElPTl9FTkQsIGUpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLm9uKFwiY2hhbmdlXCIsIGUgPT4ge1xuXHRcdFx0dGhpcy5feWF3ID0gZS55YXc7XG5cdFx0XHR0aGlzLl9waXRjaCA9IGUucGl0Y2g7XG5cdFx0XHR0aGlzLl9mb3YgPSBlLmZvdjtcblx0XHRcdHRoaXMuX3F1YXRlcm5pb24gPSBlLnF1YXRlcm5pb247XG5cblx0XHRcdHRoaXMuX3RyaWdnZXJFdmVudChFVkVOVFMuVklFV19DSEFOR0UsIGUpO1xuXHRcdH0pO1xuXHR9XG5cblx0X3RyaWdnZXJFdmVudChuYW1lLCBwYXJhbSkge1xuXHRcdGNvbnN0IGV2dCA9IHBhcmFtIHx8IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogRXZlbnRzIHRoYXQgaXMgZmlyZWQgd2hlbiBlcnJvciBvY2N1cnNcblx0XHQgKiBAa28g7JeQ65+sIOuwnOyDnSDsi5wg67Cc7IOd7ZWY64qUIOydtOuypO2KuFxuXHRcdCAqIEBuYW1lIGVnLnZpZXczNjAuUGFub1ZpZXdlciNlcnJvclxuXHRcdCAqIEBldmVudFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSBUaGUgb2JqZWN0IG9mIGRhdGEgdG8gYmUgc2VudCB0byBhbiBldmVudCA8a28+7J2067Kk7Yq47JeQIOyghOuLrOuQmOuKlCDrjbDsnbTthLAg6rCd7LK0PC9rbz5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gcGFyYW0udHlwZSBFcnJvciB0eXBlXG5cdFx0ICogXHRcdDEwOiBJTlZBTElEX0RFVklDRTogVW5zdXBwb3J0ZWQgZGV2aWNlXG5cdFx0ICogXHRcdDExOiBOT19XRUJHTDogV2ViZ2wgbm90IHN1cHBvcnRcblx0XHQgKiBcdFx0MTIsIEZBSUxfSU1BR0VfTE9BRDogRmFpbGVkIHRvIGxvYWQgaW1hZ2Vcblx0XHQgKiBcdFx0MTM6IEZBSUxfQklORF9URVhUVVJFOiBGYWlsZWQgdG8gYmluZCB0ZXh0dXJlXG5cdFx0ICogXHRcdDE0OiBJTlZBTElEX1JFU09VUkNFOiBPbmx5IG9uZSByZXNvdXJjZShpbWFnZSBvciB2aWRlbykgc2hvdWxkIGJlIHNwZWNpZmllZFxuXHRcdCAqIFx0XHQxNTogUkVOREVSSU5HX0NPTlRFWFRfTE9TVDogV2ViR0wgY29udGV4dCBsb3N0IG9jY3VycmVkXG5cdFx0ICogPGtvPuyXkOufrCDsooXrpZhcblx0XHQgKiBcdFx0MTA6IElOVkFMSURfREVWSUNFOiDrr7jsp4Dsm5Ag6riw6riwXG5cdFx0ICogXHRcdDExOiBOT19XRUJHTDogV0VCR0wg66+47KeA7JuQXG5cdFx0ICogXHRcdDEyLCBGQUlMX0lNQUdFX0xPQUQ6IOydtOuvuOyngCDroZzrk5wg7Iuk7YyoXG5cdFx0ICogXHRcdDEzOiBGQUlMX0JJTkRfVEVYVFVSRTog7YWN7Iqk7LOQIOuwlOyduOuUqSDsi6TtjKhcblx0XHQgKiBcdFx0MTQ6IElOVkFMSURfUkVTT1VSQ0U6IOumrOyGjOyKpCDsp4DsoJUg7Jik66WYIChpbWFnZSDtmLnsnYAgdmlkZW8g7KSRIO2VmOuCmOunjCDsp4DsoJXrkJjslrTslbwg7ZWoKVxuXHRcdCAqIFx0XHQxNTogUkVOREVSSU5HX0NPTlRFWFRfTE9TVDogV2ViR0wgY29udGV4dCBsb3N0IOuwnOyDnVxuXHRcdCAqIDwva28+XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtLm1lc3NhZ2UgRXJyb3IgbWVzc2FnZSA8a28+7JeQ65+sIOuplOyLnOyngDwva28+XG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqXG5cdFx0ICogdml3ZXIub24oe1xuXHRcdCAqXHRcImVycm9yXCIgOiBmdW5jdGlvbihldnQpIHtcblx0XHQgKlx0XHQvLyBldnQudHlwZSA9PT0gMTNcblx0XHQgKlx0XHQvLyBldnQubWVzc2FlZyA9PT0gXCJmYWlsZWQgdG8gYmluZCB0ZXh0dXJlXCJcblx0XHQgKiB9KTtcblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIEV2ZW50cyB0aGF0IGlzIGZpcmVkIHdoZW4gUGFub1ZpZXdlciBpcyByZWFkeSB0byBnby5cblx0XHQgKiBAa28gUGFub1ZpZXdlciDqsIAg7KSA67mE65CcIOyDge2DnOyXkCDrsJzsg53tlZjripQg7J2067Kk7Yq4XG5cdFx0ICogQG5hbWUgZWcudmlldzM2MC5QYW5vVmlld2VyI3JlYWR5XG5cdFx0ICogQGV2ZW50XG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqXG5cdFx0ICogdml3ZXIub24oe1xuXHRcdCAqXHRcInJlYWR5XCIgOiBmdW5jdGlvbihldnQpIHtcblx0XHQgKlx0XHQvLyBQYW5vVmlld2VyIGlzIHJlYWR5IHRvIHNob3cgaW1hZ2UgYW5kIGhhbmRsZSB1c2VyIGludGVyYWN0aW9uLlxuXHRcdCAqIH0pO1xuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogRXZlbnRzIHRoYXQgaXMgZmlyZWQgd2hlbiBkaXJlY3Rpb24gb3IgZm92IGlzIGNoYW5nZWQuXG5cdFx0ICogQGtvIFBhbm9WaWV3ZXIg7JeQ7IScIOuwlOudvOuztOqzoCDsnojripQg67Cp7Zal7J2064KYIEZPVijtmZTqsIEp6rCAIOuzgOqyveuQmOyXiOydhOuVjCDrsJzsg53tlZjripQg7J2067Kk7Yq4XG5cdFx0ICogQG5hbWUgZWcudmlldzM2MC5QYW5vVmlld2VyI3ZpZXdDaGFuZ2Vcblx0XHQgKiBAZXZlbnRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW0gVGhlIG9iamVjdCBvZiBkYXRhIHRvIGJlIHNlbnQgdG8gYW4gZXZlbnQgPGtvPuydtOuypO2KuOyXkCDsoITri6zrkJjripQg642w7J207YSwIOqwneyytDwva28+XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtLnlhdyB5YXc8a28+eWF3PC9rbz5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gcGFyYW0ucGl0Y2ggcGl0Y2ggPGtvPnBpdGNoPC9rbz5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gcGFyYW0uZm92IEZpZWxkIG9mIHZpZXcgKGZvdikgPGtvPu2ZlOqwgTwva28+XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKlxuXHRcdCAqIHZpd2VyLm9uKHtcblx0XHQgKlx0XCJ2aWV3Q2hhbmdlXCIgOiBmdW5jdGlvbihldnQpIHtcblx0XHQgKlx0XHQvL2V2dC55YXcsIGV2dC5waXRjaCwgZXZ0LmZvdiBpcyBhdmFpbGFibGUuXG5cdFx0ICogfSk7XG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiBFdmVudHMgdGhhdCBpcyBmaXJlZCB3aGVuIGFuaW1hdGlvbiB3aGljaCBpcyB0cmlnZ2VyZWQgYnkgaW5lcnRpYSBpcyBlbmRlZC5cblx0XHQgKiBAa28g6rSA7ISx7JeQIOydmO2VnCDslaDri4jrqZTsnbTshZgg64+Z7J6R7J20IOyZhOujjOuQmOyXiOydhOuVjCDrsJzsg53tlZjripQg7J2067Kk7Yq4XG5cdFx0ICogQG5hbWUgZWcudmlldzM2MC5QYW5vVmlld2VyI2FuaW1hdGlvbkVuZFxuXHRcdCAqIEBldmVudFxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICpcblx0XHQgKiB2aXdlci5vbih7XG5cdFx0ICpcdFwiYW5pbWF0aW9uRW5kXCIgOiBmdW5jdGlvbihldnQpIHtcblx0XHQgKlx0XHQvLyBhbmltYXRpb24gaXMgZW5kZWQuXG5cdFx0ICogfSk7XG5cdFx0ICovXG5cdFx0cmV0dXJuIHRoaXMudHJpZ2dlcihuYW1lLCBldnQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdoZW4gc2V0IHRydWUsIGVuYWJsZXMgem9vbSB3aXRoIHRoZSB3aGVlbCBhbmQgUGluY2ggZ2VzdHVyZVxuXHQgKiBAa28gdHJ1ZSDroZwg7ISk7KCVIOyLnCDtnKAg67CPIOynkeq4sCDrj5nsnpHsnLzroZwg7ZmV64yAIC8g7LaV7IaMIO2VoCDsiJgg7J6I7Iq164uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNzZXRVc2Vab29tXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlWm9vbVxuXHQgKi9cblx0c2V0VXNlWm9vbSh1c2Vab29tKSB7XG5cdFx0aWYgKHR5cGVvZiB1c2Vab29tICE9PSBcImJvb2xlYW5cIikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX3lhd1BpdGNoQ29udHJvbC5vcHRpb24oXCJ1c2Vab29tXCIsIHVzZVpvb20pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdoZW4gdHJ1ZSwgZW5hYmxlcyB0aGUga2V5Ym9hcmQgbW92ZSBrZXkgY29udHJvbDogYXdzZCwgYXJyb3cga2V5c1xuXHQgKiBAa28gdHJ1ZeydtOuptCDtgqTrs7Trk5wg7J2064+ZIO2CpCDsu6jtirjroaTsnYQg7Zmc7ISx7ZmU7ZWp64uI64ukLiAoYXdzZCwg7ZmU7IK07ZGcIO2CpClcblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjc2V0VXNlS2V5Ym9hcmRcblx0ICogQHBhcmFtIHtCb29sZWFufSB1c2VLZXlib2FyZFxuXHQgKi9cblx0c2V0VXNlS2V5Ym9hcmQodXNlS2V5Ym9hcmQpIHtcblx0XHR0aGlzLl95YXdQaXRjaENvbnRyb2wub3B0aW9uKFwidXNlS2V5Ym9hcmRcIiwgdXNlS2V5Ym9hcmQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgY29udHJvbCB0aHJvdWdoIGRldmljZSBtb3Rpb24uIChcIm5vbmVcIiwgXCJ5YXdQaXRjaFwiKVxuXHQgKiBAa28g65SU67CU7J207IqkIOybgOyngeyehOydhCDthrXtlZwg7Luo7Yq466Gk7J2EIO2ZnOyEse2ZlCDtlanri4jri6QuIChcIm5vbmVcIiwgXCJ5YXdQaXRjaFwiKVxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNzZXRHeXJvTW9kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZ3lyb01vZGVcblx0ICovXG5cdHNldEd5cm9Nb2RlKGd5cm9Nb2RlKSB7XG5cdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcImd5cm9Nb2RlXCIsIGd5cm9Nb2RlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXR0aW5nIHRoZSByYW5nZSBvZiBjb250cm9sbGFibGUgRk9WIHZhbHVlc1xuXHQgKiBAa28g7KCc7Ja0IOqwgOuKpe2VnCBGT1Yg6rCS7J2YIOuylOychCDshKTsoJVcblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjc2V0Rm92UmFuZ2Vcblx0ICogQHBhcmFtIHtBcnJheX0gcmFuZ2Vcblx0ICovXG5cdHNldEZvdlJhbmdlKHJhbmdlKSB7XG5cdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcImZvdlJhbmdlXCIsIHJhbmdlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXR0aW5nIHRoZSByYW5nZSBvZiBjb250cm9sbGFibGUgRk9WIHZhbHVlc1xuXHQgKiBAa28g7KCc7Ja0IOqwgOuKpe2VnCBGT1Yg6rCS7J2YIOuylOychCDqsIDsoLgg7Jik6riwXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI2dldEZvdlJhbmdlXG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKi9cblx0Z2V0Rm92UmFuZ2UoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3lhd1BpdGNoQ29udHJvbC5vcHRpb24oXCJmb3ZSYW5nZVwiKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgc2l6ZSBvZiBjYW52YXMgZWxlbWVudCBieSBpdCdzIGNvbnRhaW5lciBlbGVtZW50J3Mgb3Igc3BlY2lmaWVkIHNpemUuXG5cdCAqIEBrbyDsupTrsoTsiqQg7JeY66as66i87Yq47J2YIO2BrOq4sOulvCDsu6jthYzsnbTrhIgg7JeY66as66i87Yq47J2YIO2BrOq4sOuCmCDsp4DsoJXrkJwg7YGs6riw66GcIOyXheuNsOydtO2KuO2VqeuLiOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjdXBkYXRlVmlld3BvcnREaW1lbnNpb25zXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbc2l6ZV1cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzaXplLndpZHRoPXdpZHRoIG9mIGNvbnRhaW5lcl1cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzaXplLmhlaWdodD1oZWlnaHQgb2YgY29udGFpbmVyXVxuXHQgKi9cblx0dXBkYXRlVmlld3BvcnREaW1lbnNpb25zKHNpemUpIHtcblx0XHRpZiAoIXRoaXMuX2lzUmVhZHkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fd2lkdGggPSAoc2l6ZSAmJiBzaXplLndpZHRoKSB8fFxuXHRcdFx0cGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5fY29udGFpbmVyKS53aWR0aCwgMTApO1xuXHRcdHRoaXMuX2hlaWdodCA9IChzaXplICYmIHNpemUuaGVpZ2h0KSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5fY29udGFpbmVyKS5oZWlnaHQsIDEwKTtcblx0XHR0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuX3dpZHRoIC8gdGhpcy5faGVpZ2h0O1xuXHRcdHRoaXMuX3Bob3RvU3BoZXJlUmVuZGVyZXIudXBkYXRlVmlld3BvcnREaW1lbnNpb25zKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuXHRcdHRoaXMuX3lhd1BpdGNoQ29udHJvbC5vcHRpb24oXCJhc3BlY3RSYXRpb1wiLCB0aGlzLl9hc3BlY3RSYXRpbyk7XG5cblx0XHR0aGlzLmxvb2tBdCh7fSwgMCk7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSB2ZXJ0aWNhbCBmaWVsZCBvZiB2aWV3XG5cdCAqIEBrbyDrt7DslrTsnZgg7IiY7KeBIGZpZWxkIG9mIHZpZXcg6rCS7J2EIOqwgOyguOyYteuLiOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjZ2V0Rm92XG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICovXG5cdGdldEZvdigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZm92O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgaG9yaXpvbnRhbCBmaWVsZCBvZiB2aWV3IGluIGRlZ3JlZVxuXHQgKi9cblx0X2dldEhGb3YoKSB7XG5cdFx0cmV0dXJuIGdsTWF0cml4LnRvRGVncmVlKFxuXHRcdFx0MiAqIE1hdGguYXRhbih0aGlzLl9hc3BlY3RSYXRpbyAqIE1hdGgudGFuKGdsTWF0cml4LnRvUmFkaWFuKHRoaXMuX2ZvdikgLyAyKSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBjdXJyZW50IHlhdyB2YWx1ZVxuXHQgKiBAa28g67ew7Ja07J2YIHlhdyDqsJLsnYQg6rCA7KC47Ji164uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNnZXRZYXdcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKi9cblx0Z2V0WWF3KCkge1xuXHRcdHJldHVybiB0aGlzLl95YXc7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGN1cnJlbnQgcGl0Y2ggdmFsdWVcblx0ICogQGtvIOu3sOyWtOydmCBwaXRjaCDqsJLsnYQg6rCA7KC47Ji164uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNnZXRQaXRjaFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqL1xuXHRnZXRQaXRjaCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGl0Y2g7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSByYW5nZSBvZiBjb250cm9sbGFibGUgWWF3IHZhbHVlc1xuXHQgKiBAa28g7Luo7Yq466GkIOqwgOuKpe2VnCBZYXcg6rWs6rCE7J2EIOqwgOyguOyYteuLiOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjZ2V0WWF3UmFuZ2Vcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqL1xuXHRnZXRZYXdSYW5nZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcInlhd1JhbmdlXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgcmFuZ2Ugb2YgY29udHJvbGxhYmxlIFBpdGNoIHZhbHVlc1xuXHQgKiBAa28g7Luo7Yq466GkIOqwgOuKpe2VnCBQaXRjaCDqtazqsITsnYQg6rCA7KC47Ji164uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNnZXRQaXRjaFJhbmdlXG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKi9cblx0Z2V0UGl0Y2hSYW5nZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcInBpdGNoUmFuZ2VcIik7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRoZSByYW5nZSBvZiBjb250cm9sbGFibGUgWWF3IHZhbHVlc1xuXHQgKiBAa28g7Luo7Yq466GkIOqwgOuKpe2VnCBZYXcg6rWs6rCE7J2EIOyEpOygle2VqeuLiOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjc2V0WWF3UmFuZ2Vcblx0ICogQHBhcmFtIHtBcnJheX0gcmFuZ2Vcblx0ICovXG5cdHNldFlhd1JhbmdlKHlhd1JhbmdlKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3lhd1BpdGNoQ29udHJvbC5vcHRpb24oXCJ5YXdSYW5nZVwiLCB5YXdSYW5nZSk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRoZSByYW5nZSBvZiBjb250cm9sbGFibGUgUGl0Y2ggdmFsdWVzXG5cdCAqIEBrbyDsu6jtirjroaQg6rCA64ql7ZWcIFBpdGNoIOq1rOqwhOydhCDshKTsoJXtlanri4jri6QuXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI3NldFBpdGNoUmFuZ2Vcblx0ICogQHBhcmFtIHtBcnJheX0gcmFuZ2Vcblx0ICovXG5cdHNldFBpdGNoUmFuZ2UocGl0Y2hSYW5nZSkge1xuXHRcdHJldHVybiB0aGlzLl95YXdQaXRjaENvbnRyb2wub3B0aW9uKFwicGl0Y2hSYW5nZVwiLCBwaXRjaFJhbmdlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJZiBmYWxzZSwgdGhlIHBvbGUgaXMgbm90IGRpc3BsYXllZCBpbnNpZGUgdGhlIHZpZXdwb3J0XG5cdCAqIEBrbyBmYWxzZSDsnbgg6rK97JqwLCDtj7TsnYAg67ew7Y+s7Yq4IOuCtOu2gOyXkCDtkZzsi5zrkJjsp4Ag7JWK7Iq164uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNzZXRQaXRjaFJhbmdlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvd1BvbGVQb2ludFxuXHQgKi9cblx0c2V0U2hvd1BvbGVQb2ludChzaG93UG9sZVBvaW50KSB7XG5cdFx0cmV0dXJuIHRoaXMuX3lhd1BpdGNoQ29udHJvbC5vcHRpb24oXCJzaG93UG9sZVBvaW50XCIsIHNob3dQb2xlUG9pbnQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCBhIG5ldyB2aWV3IGJ5IHNldHRpbmcgY2FtZXJhIGNvbmZpZ3VyYXRpb24uIEFueSBwYXJhbWV0ZXJzIG5vdCBzcGVjaWZpZWQgcmVtYWluIHRoZSBzYW1lLlxuXHQgKiBAa28g7Lm066mU6528IOyEpOygleydhCDsp4DsoJXtlZjsl6wg7ZmU66m07J2EIOqwseyLoO2VqeuLiOuLpC4g7KeA7KCV65CY7KeAIOyViuydgCDrp6TqsJwg67OA7IiY64qUIOuPmeydvO2VmOqyjCDsnKDsp4DrkKnri4jri6QuXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI2xvb2tBdFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3JpZW50YXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG9yaWVudGF0aW9uLnlhdyBUYXJnZXQgeWF3IGluIGRlZ3JlZSA8a28+66qp7ZGcIHlhdyAoZGVncmVlIOuLqOychCk8L2tvPlxuXHQgKiBAcGFyYW0ge051bWJlcn0gb3JpZW50YXRpb24ucGl0Y2ggVGFyZ2V0IHBpdGNoIGluIGRlZ3JlZSA8a28+66qp7ZGcIHBpdGNoIChkZWdyZWUg64uo7JyEKTwva28+XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBvcmllbnRhdGlvbi5mb3YgVGFyZ2V0IHZlcnRpY2FsIGZvdiBpbiBkZWdyZWUgPGtvPuuqqe2RnCDsiJjsp4EgZm92IChkZWdyZWUg64uo7JyEKTwva28+XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIDxrbz7slaDri4jrqZTsnbTshZgg7Iuc6rCEICjrsIDrpqwg7LSIKTwva28+XG5cdCAqL1xuXHRsb29rQXQob3JpZW50YXRpb24sIGR1cmF0aW9uKSB7XG5cdFx0aWYgKCF0aGlzLl9pc1JlYWR5KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgeWF3ID0gb3JpZW50YXRpb24ueWF3ICE9PSB1bmRlZmluZWQgPyBvcmllbnRhdGlvbi55YXcgOiB0aGlzLl95YXc7XG5cdFx0Y29uc3QgcGl0Y2ggPSBvcmllbnRhdGlvbi5waXRjaCAhPT0gdW5kZWZpbmVkID8gb3JpZW50YXRpb24ucGl0Y2ggOiB0aGlzLl9waXRjaDtcblx0XHRjb25zdCBwaXRjaFJhbmdlID0gdGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcInBpdGNoUmFuZ2VcIik7XG5cdFx0Y29uc3QgdmVydGljYWxBbmdsZU9mSW1hZ2UgPSBwaXRjaFJhbmdlWzFdIC0gcGl0Y2hSYW5nZVswXTtcblx0XHRsZXQgZm92ID0gb3JpZW50YXRpb24uZm92ICE9PSB1bmRlZmluZWQgPyBvcmllbnRhdGlvbi5mb3YgOiB0aGlzLl9mb3Y7XG5cblx0XHRpZiAodmVydGljYWxBbmdsZU9mSW1hZ2UgPCBmb3YpIHtcblx0XHRcdGZvdiA9IHZlcnRpY2FsQW5nbGVPZkltYWdlO1xuXHRcdH1cblxuXHRcdHRoaXMuX3lhd1BpdGNoQ29udHJvbC5sb29rQXQoe3lhdywgcGl0Y2gsIGZvdn0sIGR1cmF0aW9uKTtcblxuXHRcdGlmIChkdXJhdGlvbiA9PT0gMCkge1xuXHRcdFx0dGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlci5yZW5kZXIoeWF3LCBwaXRjaCwgZm92KTtcblx0XHR9XG5cdH1cblxuXHRfYWN0aXZhdGUoKSB7XG5cdFx0dGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlci5hdHRhY2hUbyh0aGlzLl9jb250YWluZXIpO1xuXHRcdHRoaXMuX3lhd1BpdGNoQ29udHJvbC5lbmFibGUoKTtcblxuXHRcdHRoaXMudXBkYXRlVmlld3BvcnREaW1lbnNpb25zKCk7XG5cblx0XHR0aGlzLl9pc1JlYWR5ID0gdHJ1ZTtcblx0XHR0aGlzLl90cmlnZ2VyRXZlbnQoRVZFTlRTLlJFQURZKTtcblx0XHR0aGlzLl9zdGFydFJlbmRlcigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVyIHRoZSBjYWxsYmFjayBvbiB0aGUgcmFmIHRvIGNhbGwgX3JlbmRlckxvb3AgZXZlcnkgZnJhbWUuXG5cdCAqL1xuXHRfc3RhcnRSZW5kZXIoKSB7XG5cdFx0dGhpcy5fcmVuZGVyTG9vcCA9IHRoaXMuX3JlbmRlckxvb3AuYmluZCh0aGlzKTtcblx0XHR0aGlzLl9yYWZJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fcmVuZGVyTG9vcCk7XG5cdH1cblxuXHRfcmVuZGVyTG9vcCgpIHtcblx0XHRpZiAodGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlcikge1xuXHRcdFx0aWYgKHRoaXMuX3F1YXRlcm5pb24pIHtcblx0XHRcdFx0dGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlci5yZW5kZXJXaXRoUXVhdGVybmlvbih0aGlzLl9xdWF0ZXJuaW9uLCB0aGlzLl9mb3YpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlci5yZW5kZXIodGhpcy5feWF3LCB0aGlzLl9waXRjaCwgdGhpcy5fZm92KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fcmFmSWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckxvb3ApO1xuXHR9XG5cblx0X3N0b3BSZW5kZXIoKSB7XG5cdFx0aWYgKHRoaXMuX3JhZklkKSB7XG5cdFx0XHR3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmFmSWQpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX3JhZklkO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBEZXN0cm95IHdlYmdsIGNvbnRleHQgYW5kIGJsb2NrIHVzZXIgaW50ZXJhY3Rpb24gYW5kIHN0b3AgcmVuZGVyaW5nXG5cdCAqL1xuXHRfZGVhY3RpdmF0ZSgpIHtcblx0XHRpZiAodGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlci5kZXN0cm95KCk7XG5cdFx0XHR0aGlzLl9waG90b1NwaGVyZVJlbmRlcmVyID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5faXNSZWFkeSkge1xuXHRcdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLmRpc2FibGUoKTtcblx0XHRcdHRoaXMuX3N0b3BSZW5kZXIoKTtcblx0XHRcdHRoaXMuX2lzUmVhZHkgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRzdGF0aWMgX2lzVmFsaWRUb3VjaERpcmVjdGlvbihkaXJlY3Rpb24pIHtcblx0XHRyZXR1cm4gZGlyZWN0aW9uID09PSBQYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTi5OT05FIHx8XG5cdFx0XHRkaXJlY3Rpb24gPT09IFBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OLllBVyB8fFxuXHRcdFx0ZGlyZWN0aW9uID09PSBQYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTi5QSVRDSCB8fFxuXHRcdFx0ZGlyZWN0aW9uID09PSBQYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTi5BTEw7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRvdWNoIGRpcmVjdGlvbiBieSB3aGljaCB1c2VyIGNhbiBjb250cm9sLlxuXHQgKiBAa28g7IKs7Jqp7J6Q6rCAIOyhsOyekeqwgOuKpe2VnCDthLDsuZgg67Cp7Zal7J2EIOyngOygle2VnOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjc2V0VG91Y2hEaXJlY3Rpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvbiBvZiB0aGUgdG91Y2guIHtAbGluayBlZy5QYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTn08a28+7Luo7Yq466GkIOqwgOuKpe2VnCDrsKntlqUge0BsaW5rIGVnLlBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OfTwva28+XG5cdCAqIEByZXR1cm4ge2VnLlBhbm9WaWV3ZXJ9IFBhbm9WaWV3ZXIgaW5zdGFuY2Vcblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogcGFub1ZpZXdlciA9IG5ldyBQYW5vVmlld2VyKGVsKTtcblx0ICogLy8gTGltaXQgdGhlIHRvdWNoIGRpcmVjdGlvbiB0byB0aGUgeWF3IGRpcmVjdGlvbiBvbmx5LlxuXHQgKiBwYW5vVmlld2VyLnNldFRvdWNoRGlyZWN0aW9uKFBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OLllBVyk7XG5cdCAqL1xuXHRzZXRUb3VjaERpcmVjdGlvbihkaXJlY3Rpb24pIHtcblx0XHRpZiAoUGFub1ZpZXdlci5faXNWYWxpZFRvdWNoRGlyZWN0aW9uKGRpcmVjdGlvbikpIHtcblx0XHRcdHRoaXMuX3lhd1BpdGNoQ29udHJvbC5vcHRpb24oXCJ0b3VjaERpcmVjdGlvblwiLCBkaXJlY3Rpb24pO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdG91Y2ggZGlyZWN0aW9uIGJ5IHdoaWNoIHVzZXIgY2FuIGNvbnRyb2xcblx0ICogQGtvIOyCrOyaqeyekOqwgCDsobDsnpHqsIDriqXtlZwg7YSw7LmYIOuwqe2WpeydhCDrsJjtmZjtlZzri6QuXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI2dldFRvdWNoRGlyZWN0aW9uXG5cdCAqIEByZXR1cm4ge051bWJlcn0gZGlyZWN0aW9uIG9mIHRoZSB0b3VjaC4ge0BsaW5rIGVnLlBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OfTxrbz7su6jtirjroaQg6rCA64ql7ZWcIOuwqe2WpSB7QGxpbmsgZWcuUGFub1ZpZXdlci5UT1VDSF9ESVJFQ1RJT059PC9rbz5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogcGFub1ZpZXdlciA9IG5ldyBQYW5vVmlld2VyKGVsKTtcblx0ICogLy8gUmV0dXJucyB0aGUgY3VycmVudCB0b3VjaCBkaXJlY3Rpb24uXG5cdCAqIHZhciBkaXIgPSBwYW5vVmlld2VyLmdldFRvdWNoRGlyZWN0aW9uKCk7XG5cdCAqL1xuXHRnZXRUb3VjaERpcmVjdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcInRvdWNoRGlyZWN0aW9uXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlc3Ryb3kgdmlld2VyLiBSZW1vdmUgYWxsIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzIGFuZCByZW1vdmUgdmlld2VyIGNhbnZhcy5cblx0ICogQGtvIOu3sOyWtCDsnbjsiqTthLTsiqTrpbwg7ZW07KCc7ZWp64uI64ukLiDrqqjrk6Ag65Ox66Gd65CcIOydtOuypO2KuOumrOyKpOuEiOulvCDsoJzqsbDtlZjqs6Ag67ew7Ja0IOy6lOuyhOyKpOulvCDsgq3soJztlZzri6QuXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI2Rlc3Ryb3lcblx0ICovXG5cdGRlc3Ryb3koKSB7XG5cdFx0dGhpcy5fZGVhY3RpdmF0ZSgpO1xuXG5cdFx0aWYgKHRoaXMuX3lhd1BpdGNoQ29udHJvbCkge1xuXHRcdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLmRlc3Ryb3koKTtcblx0XHRcdHRoaXMuX3lhd1BpdGNoQ29udHJvbCA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0c3RhdGljIGlzV2ViR0xBdmFpbGFibGUoKSB7XG5cdFx0cmV0dXJuIFdlYkdMVXRpbHMuaXNXZWJHTEF2YWlsYWJsZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgc3VwcG9ydHMgdGhlIGd5cm8gc2Vuc29yLlxuXHQgKiBAa28g7ZiE7J6sIOu4jOudvOyasOyggCDtmZjqsr3snbQg7J6Q7J2066GcIOyEvOyEnOulvCDsp4Dsm5DtlZjripTsp4Ag7Jes67aA66W8IO2ZleyduO2VqeuLiOuLpC5cblx0ICogQGZ1bmN0aW9uIGlzR3lyb1NlbnNvckF2YWlsYWJsZVxuXHQgKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIHRha2UgdGhlIGd5cm8gc2Vuc29yIGF2YWlsYWJpbGl0eSBhcyBhcmd1bWVudCA8a28+7J6Q7J2066GcIOyEvOyEnOulvCDsp4Dsm5DtlZjripTsp4Ag7Jes67aA66W8IOyduOyekOuhnCDrsJvripQg7ZWo7IiYPC9rbz5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGlzR3lyb1NlbnNvckF2YWlsYWJsZShjYWxsYmFjaykge1xuXHRcdGlmICghRGV2aWNlTW90aW9uRXZlbnQpIHtcblx0XHRcdGNhbGxiYWNrICYmIGNhbGxiYWNrKGZhbHNlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgb25EZXZpY2VNb3Rpb25DaGFuZ2U7XG5cblx0XHRmdW5jdGlvbiBjaGVja0d5cm8oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cdFx0XHRcdG9uRGV2aWNlTW90aW9uQ2hhbmdlID0gZnVuY3Rpb24oZGV2aWNlTW90aW9uKSB7XG5cdFx0XHRcdFx0Y29uc3QgaXNHeXJvU2Vuc29yQXZhaWxhYmxlID0gZGV2aWNlTW90aW9uLnJvdGF0aW9uUmF0ZS5hbHBoYSAhPT0gbnVsbDtcblxuXHRcdFx0XHRcdHJlcyhpc0d5cm9TZW5zb3JBdmFpbGFibGUpO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZGV2aWNlbW90aW9uXCIsIG9uRGV2aWNlTW90aW9uQ2hhbmdlKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRpbWVvdXQoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4gcmVzKGZhbHNlKSwgMTAwMCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRQcm9taXNlLnJhY2UoW2NoZWNrR3lybygpLCB0aW1lb3V0KCldKS50aGVuKGlzR3lyb1NlbnNvckF2YWlsYWJsZSA9PiB7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRldmljZW1vdGlvblwiLCBvbkRldmljZU1vdGlvbkNoYW5nZSk7XG5cblx0XHRcdGNhbGxiYWNrICYmIGNhbGxiYWNrKGlzR3lyb1NlbnNvckF2YWlsYWJsZSk7XG5cblx0XHRcdFBhbm9WaWV3ZXIuaXNHeXJvU2Vuc29yQXZhaWxhYmxlID0gZnVuY3Rpb24oZmIpIHtcblx0XHRcdFx0ZmIgJiYgZmIoaXNHeXJvU2Vuc29yQXZhaWxhYmxlKTtcblx0XHRcdFx0cmV0dXJuIGlzR3lyb1NlbnNvckF2YWlsYWJsZTtcblx0XHRcdH07XG5cdFx0fSk7XG5cdH1cbn1cblxuUGFub1ZpZXdlci5FUlJPUl9UWVBFID0gRVJST1JfVFlQRTtcblBhbm9WaWV3ZXIuRVZFTlRTID0gRVZFTlRTO1xuUGFub1ZpZXdlci5Qcm9qZWN0aW9uVHlwZSA9IFBST0pFQ1RJT05fVFlQRTtcbi8qKlxuICogQ29uc3RhbnQgdmFsdWUgZm9yIHRvdWNoIGRpcmVjdGlvbnNcbiAqIEBrbyDthLDsuZgg67Cp7Zal7JeQIOuMgO2VnCDsg4HsiJgg6rCSLlxuICogQG5hbWVzcGFjZVxuICogQG5hbWUgVE9VQ0hfRElSRUNUSU9OXG4gKiBAbWVtYmVyb2YgZWcuUGFub1ZpZXdlclxuICovXG5QYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTiA9IHtcblx0LyoqXG5cdCAqIENvbnN0YW50IHZhbHVlIGZvciBub25lIGRpcmVjdGlvbi5cblx0ICogQGtvIG5vbmUg67Cp7Zal7JeQIOuMgO2VnCDsg4HsiJgg6rCSLlxuXHQgKiBAbmFtZSBOT05FXG5cdCAqIEBtZW1iZXJvZiBlZy5QYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTlxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgMVxuXHQgKi9cblx0Tk9ORTogWWF3UGl0Y2hDb250cm9sLlRPVUNIX0RJUkVDVElPTl9OT05FLFxuXHQvKipcblx0ICogQ29uc3RhbnQgdmFsdWUgZm9yIGhvcml6b250YWwoeWF3KSBkaXJlY3Rpb24uXG5cdCAqIEBrbyBob3Jpem9udGFsKHlhdykg67Cp7Zal7JeQIOuMgO2VnCDsg4HsiJgg6rCSLlxuXHQgKiBAbmFtZSBZQVdcblx0ICogQG1lbWJlcm9mIGVnLlBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OXG5cdCAqIEBjb25zdGFudFxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAZGVmYXVsdCA2XG5cdCAqL1xuXHRZQVc6IFlhd1BpdGNoQ29udHJvbC5UT1VDSF9ESVJFQ1RJT05fWUFXLFxuXHQvKipcblx0ICogQ29uc3RhbnQgdmFsdWUgZm9yIHZlcnRpY2FsIGRpcmVjdGlvbi5cblx0ICogQGtvIHZlcnRpY2FsKHBpdGNoKSDrsKntlqXsl5Ag64yA7ZWcIOyDgeyImCDqsJIuXG5cdCAqIEBuYW1lIFBJVENIXG5cdCAqIEBtZW1iZXJvZiBlZy5QYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTlxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgMjRcblx0ICovXG5cdFBJVENIOiBZYXdQaXRjaENvbnRyb2wuVE9VQ0hfRElSRUNUSU9OX1BJVENILFxuXHQvKipcblx0ICogQ29uc3RhbnQgdmFsdWUgZm9yIGFsbCBkaXJlY3Rpb24uXG5cdCAqIEBrbyBhbGwg67Cp7Zal7JeQIOuMgO2VnCDsg4HsiJgg6rCSLlxuXHQgKiBAbmFtZSBBTExcblx0ICogQG1lbWJlcm9mIGVnLlBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OXG5cdCAqIEBjb25zdGFudFxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAzMFxuXHQgKi9cblx0QUxMOiBZYXdQaXRjaENvbnRyb2wuVE9VQ0hfRElSRUNUSU9OX0FMTFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9QYW5vVmlld2VyL1Bhbm9WaWV3ZXIuanMiLCJjb25zdCB3aW4gPSB3aW5kb3c7XG5cbmV4cG9ydCB7d2luIGFzIHdpbmRvd307XG5leHBvcnQgY29uc3QgRGV2aWNlTW90aW9uRXZlbnQgPSB3aW4uRGV2aWNlTW90aW9uRXZlbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvUGFub1ZpZXdlci9icm93c2VyLmpzIiwiaW1wb3J0IFBhbm9WaWV3ZXIgZnJvbSBcIi4vUGFub1ZpZXdlclwiO1xuXG5leHBvcnQge1xuXHRQYW5vVmlld2VyXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1Bhbm9WaWV3ZXIvaW5kZXguanMiLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbmltcG9ydCBBeGVzLCB7UGFuSW5wdXR9IGZyb20gXCJAZWdqcy9heGVzXCI7XG5pbXBvcnQgU3ByaXRlSW1hZ2UgZnJvbSBcIi4vU3ByaXRlSW1hZ2VcIjtcblxuY29uc3QgREVGQVVMVF9QQU5fU0NBTEUgPSAwLjIxO1xuXG4vKipcbiAqIEBjbGFzcyBlZy52aWV3MzYwLlNwaW5WaWV3ZXJcbiAqIEBjbGFzc2Rlc2MgQSBtb2R1bGUgdXNlZCB0byBkaXNwbGF5cyBlYWNoIGltYWdlIHNlcXVlbnRpYWxseSBhY2NvcmRpbmcgdG8gdGhlIGRpcmVjdGlvbiBvZiB0aGUgdXNlcidzIHRvdWNoIG1vdmVtZW50IChsZWZ0IC8gcmlnaHQpIG9mIHRoZSBzcHJpdGUgaW1hZ2UgdGhhdCBpcyBjb2xsZWN0ZWQgYnkgcm90YXRpbmcgdGhlIG9iamVjdC5cbiAqIEBrbyDrrLzssrQg7KO87JyE66W8IO2ajOyghO2VmOyXrCDstKzsmIHtlZwg7J2066+47KeA65Ok7J2EIOuqqOydgCDsiqTtlITrnbzsnbTtirgg7J2066+47KeA66W8IOyCrOyaqeyekOydmCDthLDsuZgg7J2064+ZIOuwqe2WpSjsoowgLyDsmrApIOyXkCDrlLDrnbwg6rCBIOydtOuvuOyngOuTpOydhCDsiJzssKjsoIHsnLzroZwg67O07Jes7KO864qUIOy7tO2PrOuEjO2KuOyeheuLiOuLpC5cbiAqIEBleHRlbmRzIGVnLkNvbXBvbmVudFxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gc2hvdyB0aGUgaW1hZ2UgPGtvPuydtOuvuOyngOulvCDrs7Tsl6zspIQg64yA7IOBIOyalOyGjDwva28+XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9uIG9iamVjdDxrbz7tjIzrnbzrr7jthLAg6rCd7LK0PC9rbz5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmltYWdlVXJsIFRoZSB1cmwgb2YgdGhlIHNwcml0ZSBpbWFnZSA8a28+7Iqk7ZSE65287J207Yq4IOydtOuvuOyngOydmCB1cmw8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJvd0NvdW50PTFdIE51bWJlciBvZiBob3Jpem9udGFsIGZyYW1lcyBpbiB0aGUgc3ByaXRlIGltYWdlIDxrbz7siqTtlITrnbzsnbTtirgg7J2066+47KeA7J2YIOqwgOuhnCDtlITroIjsnoQg6rCv7IiYPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb2xDb3VudD0xXSBOdW1iZXIgb2YgdmVydGljYWwgZnJhbWVzIGluIHRoZSBzcHJpdGUgaW1hZ2UgPGtvPuyKpO2UhOudvOydtO2KuCDsnbTrr7jsp4DsnZgg7IS466GcIO2UhOugiOyehCDqsK/siJg8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbb3B0aW9ucy53aWR0aD1cImF1dG9cIl0gVGhlIHdpZHRoIG9mIHRoZSB0YXJnZXQgZWxlbWVudCB0byBzaG93IHRoZSBpbWFnZSA8a28+7J2066+47KeA66W8IOuztOyXrOykhCDrjIDsg4Eg7JqU7IaM7J2YIOuEiOu5hDwva28+XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtvcHRpb25zLmhlaWdodD1cImF1dG9cIl0gVGhlIGhlaWdodCBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQgdG8gc2hvdyB0aGUgaW1hZ2UgPGtvPuydtOuvuOyngOulvCDrs7Tsl6zspIQg64yA7IOBIOyalOyGjOydmCDrhpLsnbQ8L2tvPlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvSGVpZ2h0PXRydWVdIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSBzZXQgdGhlIGhlaWdodCBvZiB0aGUgaW1hZ2UgYXJlYSB0byBtYXRjaCB0aGUgb3JpZ2luYWwgaW1hZ2UncyBwcm9wb3J0aW9uIDxrbz7sm5Drs7gg7J2066+47KeAIOu5hOycqOyXkCDrp57qsowg7J2066+47KeAIOyYgeyXreydmCDrhpLsnbTrpbwg7J6Q64+Z7Jy866GcIOyEpOygle2VoOyngCDsl6zrtoA8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJbXX0gW29wdGlvbnMuY29sUm93PVswLCAwXV0gVGhlIGNvbHVtbiwgcm93IGNvb3JkaW5hdGVzIG9mIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGUgc3ByaXRlIGltYWdlIChiYXNlZCBvbiAwIGluZGV4KSA8a28+IOyKpO2UhOudvOydtO2KuCDsnbTrr7jsp4Ag7KSRIOyymOydjCDrs7Tsl6zspIQg7ZSE66CI7J6E7J2YIChjb2x1bW4sIHJvdykg7KKM7ZGcICgwIGluZGV4IOq4sOuwmCk8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNjYWxlPTFdIFNwaW4gc2NhbGUgKFRoZSBsYXJnZXIgdGhlIHNwaW4sIHRoZSBtb3JlKS48a28+U3BpbiDrsLDsnKggKO2BtCDsiJjroZ0g642UIOunjuydtCDsm4Dsp4HsnoQpPC9rbz5cbiAqIEBzdXBwb3J0IHtcImllXCI6IFwiOStcIiwgXCJjaFwiIDogXCJsYXRlc3RcIiwgXCJmZlwiIDogXCJsYXRlc3RcIiwgIFwic2ZcIiA6IFwibGF0ZXN0XCIsIFwiZWRnZVwiIDogXCJsYXRlc3RcIiwgXCJpb3NcIiA6IFwiNytcIiwgXCJhblwiIDogXCIyLjMrIChleGNlcHQgMy54KVwifVxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBJbml0aWFsaXplIFNwaW5WaWV3ZXJcbiAqIHZhciBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHJvZHVjdC0zNjBcIik7XG4gKiB2YXIgdmlld2VyID0gbmV3IGVnLnZpZXczNjAuU3BpblZpZXdlcihlbCwge1xuICogXHRpbWFnZVVybDogXCIvaW1nL2JhZzM2MC5qcGdcIiwgLy8gcmVxdWlyZWRcbiAqIFx0cm93Q291bnQ6IDI0IC8vcmVxdWlyZWRcbiAqIH0pO1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGluVmlld2VyIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucykge1xuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLl9lbCA9IGVsZW1lbnQ7XG5cblx0XHRjb25zdCBvcHQgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGNvbnN0IGNvbENvdW50ID0gb3B0LmNvbENvdW50IHx8IDE7XG5cdFx0Y29uc3Qgcm93Q291bnQgPSBvcHQucm93Q291bnQgfHwgMTtcblxuXHRcdHRoaXMuX3NjYWxlID0gKG9wdC5zY2FsZSB8fCAxKSAqIERFRkFVTFRfUEFOX1NDQUxFO1xuXG5cdFx0dGhpcy5fZnJhbWVDb3VudCA9IGNvbENvdW50ICogcm93Q291bnQ7XG5cblx0XHQvLyBJbml0IFNwcml0ZUltYWdlXG5cdFx0dGhpcy5fc3ByaXRlcyA9IG5ldyBTcHJpdGVJbWFnZShlbGVtZW50LCBvcHQpLm9uKHtcblx0XHRcdFwibG9hZFwiOiBldnQgPT4ge1xuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogRXZlbnRzIHRoYXQgb2NjdXIgd2hlbiBjb21wb25lbnQgbG9hZGluZyBpcyBjb21wbGV0ZVxuXHRcdFx0XHQgKiBAa28g7Lu07Y+s64SM7Yq4IOuhnOuUqeydtCDsmYTro4zrkJjrqbQg67Cc7IOd7ZWY64qUIOydtOuypO2KuFxuXHRcdFx0XHQgKiBAbmFtZSBlZy52aWV3MzYwLlNwaW5WaWV3ZXIjbG9hZFxuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIFRoZSBvYmplY3Qgb2YgZGF0YSB0byBiZSBzZW50IHRvIGFuIGV2ZW50IDxrbz7snbTrsqTtirjsl5Ag7KCE64us65CY64qUIOuNsOydtO2EsCDqsJ3ssrQ8L2tvPlxuXHRcdFx0XHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJhbS50YXJnZXQgVGhlIHRhcmdldCBlbGVtZW50IGZvciB3aGljaCB0byBkaXNwbGF5IHRoZSBpbWFnZSA8a28+7J2066+47KeA66W8IOuztOyXrOykhCDrjIDsg4Eg7JeY66as66i87Yq4PC9rbz5cblx0XHRcdFx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyYW0uYmdFbGVtZW50IEdlbmVyYXRlZCBiYWNrZ3JvdW5kIGltYWdlIGVsZW1lbnQgPGtvPuyDneyEseuQnCBiYWNrZ3JvdW5kIOydtOuvuOyngCDsl5jrpqzrqLztirg8L2tvPlxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiB2aXdlci5vbih7XG5cdFx0XHRcdCAqXHRcImxvYWRcIiA6IGZ1bmN0aW9uKGV2dCkge1xuXHRcdFx0XHQgKlx0XHR0aGlzLnNwaW5CeSh7YW5nbGU6IDM2MCwgZHVyYXRpb246IDMwMH0pO1xuXHRcdFx0XHQgKlx0fVxuXHRcdFx0XHQgKiB9KTtcblx0XHRcdFx0ICovXG5cdFx0XHRcdHRoaXMudHJpZ2dlcihcImxvYWRcIiwgZXZ0KTtcblx0XHRcdH0sXG5cdFx0XHRcImltYWdlRXJyb3JcIjogZXZ0ID0+IHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEFuIGV2ZW50IHRoYXQgb2NjdXJzIHdoZW4gdGhlIGltYWdlIGluZGV4IGlzIGNoYW5nZWQgYnkgdGhlIHVzZXIncyBsZWZ0IC8gcmlnaHQgcGFubmluZ1xuXHRcdFx0XHQgKiBAa28g7IKs7Jqp7J6Q7J2YIOyijOyasCBQYW5uaW5nIOyXkCDsnZjtlbQg7J2066+47KeAIOyduOuNseyKpOqwgCDrs4Dqsr3rkJjsl4jsnYTrlYwg67Cc7IOd7ZWY64qUIOydtOuypO2KuFxuXHRcdFx0XHQgKiBAbmFtZSBlZy52aWV3MzYwLlNwaW5WaWV3ZXIjaW1hZ2VFcnJvclxuXHRcdFx0XHQgKiBAZXZlbnRcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIFRoZSBvYmplY3Qgb2YgZGF0YSB0byBiZSBzZW50IHRvIGFuIGV2ZW50IDxrbz7snbTrsqTtirjsl5Ag7KCE64us65CY64qUIOuNsOydtO2EsCDqsJ3ssrQ8L2tvPlxuXHRcdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW0uaW1hZ2VVcmwgVXNlci1zcGVjaWZpZWQgaW1hZ2UgVVJMIDxrbz7sgqzsmqnsnpDqsIAg7KeA7KCV7ZWcIOydtOuvuOyngCBVUkw8L2tvPlxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiB2aWV3ZXIub24oe1xuXHRcdFx0XHQgKlx0XCJpbWFnZUVycm9yXCIgOiBmdW5jdGlvbihldnQpIHtcblx0XHRcdFx0ICpcdFx0Ly8gRXJyb3IgaGFuZGxpbmdcblx0XHRcdFx0ICpcdFx0Y29uc29sZS5sb2coZS5pbWFnZVVybCk7XG5cdFx0XHRcdCAqXHR9XG5cdFx0XHRcdCAqIH0pO1xuXHRcdFx0XHQgKi9cblx0XHRcdFx0dGhpcy50cmlnZ2VyKFwiaW1hZ2VFcnJvclwiLCB7XG5cdFx0XHRcdFx0aW1hZ2VVcmw6IGV2dC5pbWFnZVVybFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEluaXQgQXhlc1xuXHRcdHRoaXMuX3BhbklucHV0ID0gbmV3IFBhbklucHV0KHRoaXMuX2VsLCB7XG5cdFx0XHRzY2FsZTogW3RoaXMuX3NjYWxlLCB0aGlzLl9zY2FsZV1cblx0XHR9KTtcblx0XHR0aGlzLl9heGVzID0gbmV3IEF4ZXMoe1xuXHRcdFx0YW5nbGU6IHtcblx0XHRcdFx0cmFuZ2U6IFswLCAzNTldLFxuXHRcdFx0XHRjaXJjdWxhcjogdHJ1ZVxuXHRcdFx0fVxuXHRcdH0pLm9uKHtcblx0XHRcdFwiY2hhbmdlXCI6IGV2dCA9PiB7XG5cdFx0XHRcdGNvbnN0IGN1cnIgPSBNYXRoLmZsb29yKGV2dC5wb3MuYW5nbGUgLyAoMzYwIC8gdGhpcy5fZnJhbWVDb3VudCkpO1xuXHRcdFx0XHRjb25zdCBmcmFtZUluZGV4ID0gdGhpcy5fZnJhbWVDb3VudCAtIGN1cnIgLSAxO1xuXG5cdFx0XHRcdHRoaXMuX3Nwcml0ZXMuc2V0RnJhbWVJbmRleChmcmFtZUluZGV4KTtcblxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogQW4gZXZlbnQgdGhhdCBvY2N1cnMgd2hlbiB0aGUgaW1hZ2UgaW5kZXggaXMgY2hhbmdlZCBieSB0aGUgdXNlcidzIGxlZnQgLyByaWdodCBwYW5uaW5nXG5cdFx0XHRcdCAqIEBrbyDsgqzsmqnsnpDsnZgg7KKM7JqwIFBhbm5pbmcg7JeQIOydmO2VtCDsnbTrr7jsp4Ag7J24642x7Iqk6rCAIOuzgOqyveuQmOyXiOydhOuVjCDrsJzsg53tlZjripQg7J2067Kk7Yq4XG5cdFx0XHRcdCAqIEBuYW1lIGVnLnZpZXczNjAuU3BpblZpZXdlciNjaGFuZ2Vcblx0XHRcdFx0ICogQGV2ZW50XG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSBUaGUgb2JqZWN0IG9mIGRhdGEgdG8gYmUgc2VudCB0byBhbiBldmVudCA8a28+7J2067Kk7Yq47JeQIOyghOuLrOuQmOuKlCDrjbDsnbTthLAg6rCd7LK0PC9rbz5cblx0XHRcdFx0ICogQHBhcmFtIHtOdW1iZXJbXX0gcGFyYW0uY29sUm93IENvbHVtbiwgcm93IG9mIHRoZSBmcmFtZSBpbiB0aGUgc3ByaXRlIGltYWdlIDxrbz7siqTtlITrnbzsnbTtirgg7J2066+47KeAIOuCtCDtlITroIjsnoTsnZggY29sdW1uLCByb3c8L2tvPlxuXHRcdFx0XHQgKiBAcGFyYW0ge051bWJlcn0gcGFyYW0uZnJhbWVJbmRleCBJbmRleCB2YWx1ZSB0aGF0IGlzIHNlcXVlbnRpYWxseSBhcHBlbmRlZCBpbiBaIGRpcmVjdGlvbiBiYXNlZCBvbiBjb2wgYW5kIHJvdy48a28+Y29sLCByb3cg66W8IOq4sOuwmOycvOuhnCBaIOuwqe2WpeycvOuhnCDsiJzssKjsoIHsnLzroZwg67aZ7Jes7KeA64qUIGluZGV4IOqwkjwva28+XG5cdFx0XHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbS5hbmdsZSBUaGUgYW5nbGUgdGhhdCBpcyBjdXJyZW50bHkgaW50ZXJuYWxseSBoZWxkIGF0IGFuIGFuZ2xlIGJldHdlZW4gMCBhbmQgMzU5LiAobm90IGEgcmVhbCBwcm9kdWN0IGFuZ2xlKSA8a28+MCB+IDM1OSDrspTsnITsnZgg6rCB64+E66GcIO2YhOyerCDrgrTrtoDsoIHsnLzroZwg7Jyg7KeA7ZWY6rOgIOyeiOuKlCDqsIHrj4QgKOyLpOygnCDsnbTrr7jsp4DsnZgg6rCB64+E6rCAIOyVhOuLmCk8L2tvPlxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiB2aXdlci5vbih7XG5cdFx0XHRcdCAqXHRcImNoYW5nZVwiIDogZnVuY3Rpb24oZXZ0KSB7XG5cdFx0XHRcdCAqXHRcdGNvbnNvbGUubG9nKGV2ZW50LmZyYW1lSW5kZXgsIGV2ZW50LmNvbFJvdywgZXZlbnQuYW5nbGUpOyAgIC8vIGV2ZW50LmNvbFJvdyA9IFswLCA0XSBldmVudC5mcmFtZUluZGV4ID0gNCwgZXZlbnQgPSAzMFxuXHRcdFx0XHQgKlx0fVxuXHRcdFx0XHQgKiB9KTtcblx0XHRcdFx0ICovXG5cdFx0XHRcdHRoaXMudHJpZ2dlcihcImNoYW5nZVwiLCB7XG5cdFx0XHRcdFx0ZnJhbWVJbmRleCxcblx0XHRcdFx0XHRjb2xSb3c6IHRoaXMuX3Nwcml0ZXMuZ2V0Q29sUm93KCksXG5cdFx0XHRcdFx0YW5nbGU6IGV2dC5wb3MuYW5nbGVcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9heGVzLmNvbm5lY3QoXCJhbmdsZVwiLCB0aGlzLl9wYW5JbnB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHNwaW4gc2NhbGVcblx0ICogQGtvIHNjYWxlIOydhCDsobDsoJXtlaAg7IiYIOyeiOuKlCDtlajsiJhcblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlNwaW5WaWV3ZXIjc2V0U2NhbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIFJvdGF0aW9uIG11bHRpcGxlcyBhdCBzcGluLCB0aGUgbGFyZ2VyIHRoZSByb3RhdGlvbjxrbz5TcGluIOyLnCDtmozsoIQg67Cw7IiY6rCSLCDsu6Tsp4gg7IiY66GdIOuNlCDrp47snbQg7ZqM7KCEPC9rbz5cblx0ICpcblx0ICogQHJldHVybiB7T2JqZWN0fSBJbnN0YW5jZSBvZiBTcGluVmlld2VyIDxrbz5TcGluVmlld2VyIOyduOyKpO2EtOyKpDwva28+XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIHZpZXdlci5zZXRTY2FsZSgyKTsvLyBJdCBtb3ZlcyB0d2ljZSBhcyBtdWNoLlxuXHQgKi9cblx0c2V0U2NhbGUoc2NhbGUpIHtcblx0XHRpZiAoaXNOYU4oc2NhbGUpIHx8IHNjYWxlIDwgMCkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2NhbGUgPSBzY2FsZSAqIERFRkFVTFRfUEFOX1NDQUxFO1xuXHRcdHRoaXMuX3BhbklucHV0Lm9wdGlvbnMuc2NhbGUgPSBbdGhpcy5fc2NhbGUsIHRoaXMuX3NjYWxlXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEl0IGdpdmVzIHRoZSBlZmZlY3Qgb2Ygcm90YXRpbmcgYXQgYSBzcGVjaWZpZWQgYW5nbGUgZm9yIGEgY2VydGFpbiBwZXJpb2Qgb2YgdGltZShkdXJhdGlvbikuXG5cdCAqIEBrbyDsp4DsoJXrkJwg6rCB64+EKGFuZ2xlKeuhnCDsnbzsoJUg7Iuc6rCE64+Z7JWIKGR1cmF0aW9uKSDtmozsoITtlZjripQg7Zqo6rO866W8IOykgOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlNwaW5WaWV3ZXIjc3BpbkJ5XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSBUaGUgcGFyYW1ldGVyIG9iamVjdDxrbz7tjIzrnbzrr7jthLAg6rCd7LK0PC9rbz5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbS5hbmdsZT0wXSBhbmdsZTxrbz7tmozsoIQg6rCB64+EPC9rbz5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbS5kdXJhdGlvbj00MDBdIGR1cmF0aW9uPGtvPu2ajOyghO2VoCDsi5zqsIQgLSDrsIDrpqzshLjsu6jrk5wg64uo7JyEPC9rbz5cblx0ICpcblx0ICogQHJldHVybiB7T2JqZWN0fSBJbnN0YW5jZSBvZiBTcGluVmlld2VyIDxrbz5TcGluVmlld2VyIOyduOyKpO2EtOyKpDwva28+XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIHZpZXdlci5zcGluQnkoe2FuZ2xlOiA3MjAsIGR1cmF0aW9uOiA1MDB9KTtcblx0ICovXG5cdHNwaW5CeSh7YW5nbGUgPSAwLCBkdXJhdGlvbiA9IDQwMH0pIHtcblx0XHR0aGlzLl9heGVzLnNldEJ5KHthbmdsZX0sIGR1cmF0aW9uKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU3BpblZpZXdlci9TcGluVmlld2VyLmpzIiwiaW1wb3J0IFNwaW5WaWV3ZXIgZnJvbSBcIi4vU3BpblZpZXdlclwiO1xuaW1wb3J0IFNwcml0ZUltYWdlIGZyb20gXCIuL1Nwcml0ZUltYWdlXCI7XG5cbmV4cG9ydCB7XG5cdFNwaW5WaWV3ZXIsXG5cdFNwcml0ZUltYWdlXG59O1xuXG5TcGluVmlld2VyLlZFUlNJT04gPSBcIjMuMC4wLXJjXCI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvU3BpblZpZXdlci9pbmRleC5qcyIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIkBlZ2pzL2NvbXBvbmVudFwiO1xuaW1wb3J0IEZ1c2lvblBvc2VTZW5zb3IgZnJvbSBcIi4vaW5wdXQvRnVzaW9uUG9zZVNlbnNvclwiO1xuaW1wb3J0IFNjcmVlblJvdGF0aW9uQW5nbGUgZnJvbSBcIi4vU2NyZWVuUm90YXRpb25BbmdsZVwiO1xuaW1wb3J0IHt2ZWMzLCBnbE1hdHJpeCwgcXVhdH0gZnJvbSBcIi4uL3V0aWxzL21hdGgtdXRpbFwiO1xuXG5jb25zdCBPUklHSU5fVkVDVE9SID0gdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDApO1xuY29uc3QgWF9BWElTX1ZFQ1RPUiA9IHZlYzMuZnJvbVZhbHVlcygxLCAwLCAwKTtcbmNvbnN0IFlfQVhJU19WRUNUT1IgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMSwgMCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERldmljZVF1YXRlcm5pb24gZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5fc2NyZWVuUm90YXRpb25BbmdsZSA9IG5ldyBTY3JlZW5Sb3RhdGlvbkFuZ2xlKCk7XG5cdFx0dGhpcy5fZnVzaW9uUG9zZVNlbnNvciA9IG5ldyBGdXNpb25Qb3NlU2Vuc29yKCk7XG5cdFx0dGhpcy5fcXVhdGVybmlvbiA9IHF1YXQuY3JlYXRlKCk7XG5cblx0XHR0aGlzLl9mdXNpb25Qb3NlU2Vuc29yLmVuYWJsZSgpO1xuXHRcdHRoaXMuX2Z1c2lvblBvc2VTZW5zb3Iub24oXCJjaGFuZ2VcIiwgZSA9PiB7XG5cdFx0XHR0aGlzLl9xdWF0ZXJuaW9uID0gZS5xdWF0ZXJuaW9uO1xuXG5cdFx0XHR0aGlzLnRyaWdnZXIoXCJjaGFuZ2VcIiwge2lzVHJ1c3RlZDogdHJ1ZX0pO1xuXHRcdH0pO1xuXHR9XG5cblx0Z2V0Q29tYmluZWRRdWF0ZXJuaW9uKHlhdywgcGl0Y2gpIHtcblx0XHRjb25zdCBkZXZpY2VSID0gdGhpcy5fc2NyZWVuUm90YXRpb25BbmdsZS5nZXRSYWRpYW4oKTtcblxuXHRcdC8vIHJvdGF0ZSB4LWF4aXMgYXJvdW5kIHotYXhpcyBhYm91dCBzY3JlZW4gcm90YXRpb24gYW5nbGUuXG5cdFx0Y29uc3QgcGl0Y2hBeGlzID0gdmVjMy5yb3RhdGVaKHZlYzMuY3JlYXRlKCksIFhfQVhJU19WRUNUT1IsIE9SSUdJTl9WRUNUT1IsIGRldmljZVIpO1xuXHRcdGNvbnN0IHlhd1EgPSBxdWF0LnNldEF4aXNBbmdsZShxdWF0LmNyZWF0ZSgpLCBZX0FYSVNfVkVDVE9SLCBnbE1hdHJpeC50b1JhZGlhbigteWF3KSk7XG5cdFx0Ly8gcm90YXRlIHF1YXRlcm5pb24gYXJvdW5kIG5ldyB4LWF4aXMgYWJvdXQgcGl0Y2ggYW5nbGUuXG5cdFx0Y29uc3QgcGl0Y2hRID0gcXVhdC5zZXRBeGlzQW5nbGUocXVhdC5jcmVhdGUoKSwgcGl0Y2hBeGlzLCBnbE1hdHJpeC50b1JhZGlhbigtcGl0Y2gpKTtcblx0XHRjb25zdCBjb25qID0gcXVhdC5jb25qdWdhdGUocXVhdC5jcmVhdGUoKSwgdGhpcy5fcXVhdGVybmlvbik7XG5cdFx0Ly8gTXVsdGlwbHkgcGl0Y2ggcXVhdGVybmlvbiAtPiBkZXZpY2UgcXVhdGVybmlvbiAtPiB5YXcgcXVhdGVybmlvblxuXHRcdGNvbnN0IG91dFEgPSBxdWF0Lm11bHRpcGx5KHF1YXQuY3JlYXRlKCksIHBpdGNoUSwgY29uaik7XG5cblx0XHRxdWF0Lm11bHRpcGx5KG91dFEsIG91dFEsIHlhd1EpO1xuXHRcdHJldHVybiBvdXRRO1xuXHR9XG5cblx0ZGVzdHJveSgpIHtcblx0XHQvLyBkZXRhY2ggYWxsIGV2ZW50IGhhbmRsZXJcblx0XHR0aGlzLm9mZigpO1xuXG5cdFx0aWYgKHRoaXMuX2Z1c2lvblBvc2VTZW5zb3IpIHtcblx0XHRcdHRoaXMuX2Z1c2lvblBvc2VTZW5zb3Iub2ZmKCk7XG5cdFx0XHR0aGlzLl9mdXNpb25Qb3NlU2Vuc29yLmRlc3Ryb3koKTtcblx0XHRcdHRoaXMuX2Z1c2lvblBvc2VTZW5zb3IgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9zY3JlZW5Sb3RhdGlvbkFuZ2xlKSB7XG5cdFx0XHR0aGlzLl9zY3JlZW5Sb3RhdGlvbkFuZ2xlLnVucmVmKCk7XG5cdFx0XHR0aGlzLl9zY3JlZW5Sb3RhdGlvbkFuZ2xlID0gbnVsbDtcblx0XHR9XG5cdH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9ZYXdQaXRjaENvbnRyb2wvRGV2aWNlUXVhdGVybmlvbi5qcyIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIkBlZ2pzL2NvbXBvbmVudFwiO1xuaW1wb3J0IEF4ZXMsIHtQaW5jaElucHV0LCBNb3ZlS2V5SW5wdXR9IGZyb20gXCJAZWdqcy9heGVzXCI7XG5pbXBvcnQge2dldENvbXB1dGVkU3R5bGUsIFNVUFBPUlRfVE9VQ0gsIFNVUFBPUlRfREVWSUNFTU9USU9OfSBmcm9tIFwiLi9icm93c2VyXCI7XG5pbXBvcnQgV2hlZWxJbnB1dCBmcm9tIFwiLi9pbnB1dC9XaGVlbElucHV0XCI7XG5pbXBvcnQgVGlsdE1vdGlvbklucHV0IGZyb20gXCIuL2lucHV0L1RpbHRNb3Rpb25JbnB1dFwiO1xuaW1wb3J0IFJvdGF0aW9uUGFuSW5wdXQgZnJvbSBcIi4vaW5wdXQvUm90YXRpb25QYW5JbnB1dFwiO1xuaW1wb3J0IERldmljZVF1YXRlcm5pb24gZnJvbSBcIi4vRGV2aWNlUXVhdGVybmlvblwiO1xuaW1wb3J0IHtcblx0dmVjMixcbn0gZnJvbSBcIi4uL3V0aWxzL21hdGgtdXRpbFwiO1xuaW1wb3J0IHtcblx0R1lST19NT0RFLFxuXHRUT1VDSF9ESVJFQ1RJT05fWUFXLFxuXHRUT1VDSF9ESVJFQ1RJT05fUElUQ0gsXG5cdFRPVUNIX0RJUkVDVElPTl9BTEwsXG5cdE1DX0RFQ0VMRVJBVElPTixcblx0TUNfTUFYSU1VTV9EVVJBVElPTixcblx0TUNfQklORF9TQ0FMRSxcblx0TUFYX0ZJRUxEX09GX1ZJRVcsXG5cdFBBTl9TQ0FMRSxcblx0WUFXX1JBTkdFX0hBTEYsXG5cdFBJVENIX1JBTkdFX0hBTEYsXG5cdENJUkNVTEFSX1BJVENIX1JBTkdFX0hBTEZcbn0gZnJvbSBcIi4vY29uc3RzXCI7XG5cbmNvbnN0IERFRkFVTFRfWUFXX1JBTkdFID0gWy1ZQVdfUkFOR0VfSEFMRiwgWUFXX1JBTkdFX0hBTEZdO1xuY29uc3QgREVGQVVMVF9QSVRDSF9SQU5HRSA9IFstUElUQ0hfUkFOR0VfSEFMRiwgUElUQ0hfUkFOR0VfSEFMRl07XG5jb25zdCBDSVJDVUxBUl9QSVRDSF9SQU5HRSA9IFstQ0lSQ1VMQVJfUElUQ0hfUkFOR0VfSEFMRiwgQ0lSQ1VMQVJfUElUQ0hfUkFOR0VfSEFMRl07XG4vKipcbiAqIEEgbW9kdWxlIHVzZWQgdG8gcHJvdmlkZSBjb29yZGluYXRlIGJhc2VkIG9uIHlhdy9waXRjaCBvcmllbnRhdGlvbi4gVGhpcyBtb2R1bGUgcmVjZWl2ZXMgdXNlciB0b3VjaCBhY3Rpb24sIGtleWJvYXJkLCBtb3VzZSBhbmQgZGV2aWNlIG9yaWVudGF0aW9uKGlmIGl0IGV4aXN0cykgYXMgaW5wdXQsIHRoZW4gY29tYmluZXMgdGhlbSBhbmQgY29udmVydHMgaXQgdG8geWF3L3BpdGNoIGNvb3JkaW5hdGVzLlxuICpcbiAqIEBhbGlhcyBlZy5ZYXdQaXRjaENvbnRyb2xcbiAqIEBleHRlbmRzIGVnLkNvbXBvbmVudFxuICpcbiAqIEBzdXBwb3J0IHtcImllXCI6IFwiMTArXCIsIFwiY2hcIiA6IFwibGF0ZXN0XCIsIFwiZmZcIiA6IFwibGF0ZXN0XCIsICBcInNmXCIgOiBcImxhdGVzdFwiLCBcImVkZ2VcIiA6IFwibGF0ZXN0XCIsIFwiaW9zXCIgOiBcIjcrXCIsIFwiYW5cIiA6IFwiMi4zKyAoZXhjZXB0IDMueClcIn1cbiAqL1xuY29uc3QgWWF3UGl0Y2hDb250cm9sID0gY2xhc3MgWWF3UGl0Y2hDb250cm9sIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb24gb2JqZWN0IG9mIHRoZSBlZy5ZYXdQaXRjaCBtb2R1bGVcblx0ICogQHBhcmFtIHtFbGVtZW50fVtvcHRpb25zLmVsZW1lbnQ9bnVsbF0gZWxlbWVudCBBIGJhc2UgZWxlbWVudCBmb3IgdGhlIGVnLllhd1BpdGNoIG1vZHVsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMueWF3PTBdIGluaXRpYWwgeWF3IChkZWdyZWUpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5waXRjaD0wXSBpbml0aWFsIHBpdGNoIChkZWdyZWUpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mb3Y9NjVdIGluaXRpYWwgZmllbGQgb2YgdmlldyAoZGVncmVlKVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb3NuLnNob3dQb2xlUG9pbnQ9dHJ1ZV0gSW5kaWNhdGVzIHdoZXRoZXIgcG9sZSBpcyBzaG93blxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVzZVpvb209dHJ1ZV0gSW5kaWNhdGVzIHdoZXRoZXIgem9vbSBpcyBhdmFpbGFibGVcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VLZXlib2FyZD10cnVlXSBJbmRpY2F0ZXMgd2hldGhlciBrZXlib2FyZCBpcyBlbmFibGVkXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmd5cm9Nb2RlPXlhd1BpdGNoXSBFbmFibGVzIGNvbnRyb2wgdGhyb3VnaCBkZXZpY2UgbW90aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudG91Y2hEaXJlY3Rpb249VE9VQ0hfRElSRUNUSU9OX0FMTF0gRGlyZWN0aW9uIG9mIHRoZSB0b3VjaCBtb3ZlbWVudCAoVE9VQ0hfRElSRUNUSU9OX0FMTDogYWxsLCAgVE9VQ0hfRElSRUNUSU9OX1lBVzogaG9yaXpvbnRhbCwgVE9VQ0hfRElSRUNUSU9OX1BJVENIOiB2ZXJ0aWNhbCwgVE9VQ0hfRElSRUNUSU9OX05PTkU6IG5vIG1vdmUpXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnlhd1JhbmdlPVstMTgwLCAxODBdIFJhbmdlIG9mIHZpc2libGUgeWF3XG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnBpdGNoUmFuZ2U9Wy05MCwgOTBdIFJhbmdlIG9mIHZpc2libGUgcGl0Y2hcblx0ICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuZm92UmFuZ2U9WzMwLCAxMTBdIFJhbmdlIG9mIEZPVlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYXNwZWN0UmF0aW89MV0gQXNwZWN0IFJhdGlvXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdGNvbnN0IG9wdCA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdFx0ZWxlbWVudDogbnVsbCxcblx0XHRcdHlhdzogMCxcblx0XHRcdHBpdGNoOiAwLFxuXHRcdFx0Zm92OiA2NSxcblx0XHRcdHNob3dQb2xlUG9pbnQ6IGZhbHNlLFxuXHRcdFx0dXNlWm9vbTogdHJ1ZSxcblx0XHRcdHVzZUtleWJvYXJkOiB0cnVlLFxuXHRcdFx0Z3lyb01vZGU6IEdZUk9fTU9ERS5ZQVdQSVRDSCxcblx0XHRcdHRvdWNoRGlyZWN0aW9uOiBUT1VDSF9ESVJFQ1RJT05fQUxMLFxuXHRcdFx0eWF3UmFuZ2U6IERFRkFVTFRfWUFXX1JBTkdFLFxuXHRcdFx0cGl0Y2hSYW5nZTogREVGQVVMVF9QSVRDSF9SQU5HRSxcblx0XHRcdGZvdlJhbmdlOiBbMzAsIDExMF0sXG5cdFx0XHRhc3BlY3RSYXRpbzogMSwgLyogVE9ETzogTmVlZCBNYW5kYXRvcnk/ICovXG5cdFx0fSwgb3B0aW9ucyk7XG5cblx0XHR0aGlzLl9lbGVtZW50ID0gb3B0LmVsZW1lbnQ7XG5cdFx0dGhpcy5faW5pdGlhbEZvdiA9IG9wdC5mb3Y7XG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2lzQW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0dGhpcy5fZGV2aWNlUXVhdGVybmlvbiA9IG51bGw7XG5cblx0XHR0aGlzLl9pbml0QXhlcyhvcHQpO1xuXHRcdHRoaXMub3B0aW9uKG9wdCk7XG5cdH1cblxuXHRfaW5pdEF4ZXMob3B0KSB7XG5cdFx0Y29uc3QgeVJhbmdlID0gdGhpcy5fdXBkYXRlWWF3UmFuZ2Uob3B0Lnlhd1JhbmdlLCBvcHQuZm92LCBvcHQuYXNwZWN0UmF0aW8pO1xuXHRcdGNvbnN0IHBSYW5nZSA9IHRoaXMuX3VwZGF0ZVBpdGNoUmFuZ2Uob3B0LnBpdGNoUmFuZ2UsIG9wdC5mb3YsIG9wdC5zaG93UG9sZVBvaW50KTtcblx0XHRjb25zdCB1c2VSb3RhdGlvbiA9IG9wdC5neXJvTW9kZSA9PT0gR1lST19NT0RFLlZSO1xuXG5cdFx0dGhpcy5heGVzUGFuSW5wdXQgPSBuZXcgUm90YXRpb25QYW5JbnB1dCh0aGlzLl9lbGVtZW50LCB7dXNlUm90YXRpb259KTtcblx0XHR0aGlzLmF4ZXNXaGVlbElucHV0ID0gbmV3IFdoZWVsSW5wdXQodGhpcy5fZWxlbWVudCwge3NjYWxlOiA0fSk7XG5cdFx0Ly8gdGhpcy5heGVzVGlsdE1vdGlvbklucHV0ID0gU1VQUE9SVF9ERVZJQ0VNT1RJT04gPyBuZXcgVGlsdE1vdGlvbklucHV0KHRoaXMuX2VsZW1lbnQpIDogbnVsbDtcblx0XHR0aGlzLmF4ZXNUaWx0TW90aW9uSW5wdXQgPSBudWxsO1xuXHRcdHRoaXMuYXhlc1BpbmNoSW5wdXQgPSBTVVBQT1JUX1RPVUNIID8gbmV3IFBpbmNoSW5wdXQodGhpcy5fZWxlbWVudCwge3NjYWxlOiAtMX0pIDogbnVsbDtcblx0XHR0aGlzLmF4ZXNNb3ZlS2V5SW5wdXQgPSBuZXcgTW92ZUtleUlucHV0KHRoaXMuX2VsZW1lbnQsIHtzY2FsZTogWy02LCA2XX0pO1xuXG5cdFx0dGhpcy5heGVzID0gbmV3IEF4ZXMoe1xuXHRcdFx0eWF3OiB7XG5cdFx0XHRcdHJhbmdlOiB5UmFuZ2UsXG5cdFx0XHRcdGNpcmN1bGFyOiBZYXdQaXRjaENvbnRyb2wuaXNDaXJjdWxhcih5UmFuZ2UpLFxuXHRcdFx0XHRib3VuY2U6IFswLCAwXVxuXHRcdFx0fSxcblx0XHRcdHBpdGNoOiB7XG5cdFx0XHRcdHJhbmdlOiBwUmFuZ2UsXG5cdFx0XHRcdGNpcmN1bGFyOiBZYXdQaXRjaENvbnRyb2wuaXNDaXJjdWxhcihwUmFuZ2UpLFxuXHRcdFx0XHRib3VuY2U6IFswLCAwXVxuXHRcdFx0fSxcblx0XHRcdGZvdjoge1xuXHRcdFx0XHRyYW5nZTogb3B0LmZvdlJhbmdlLFxuXHRcdFx0XHRjaXJjdWxhcjogW2ZhbHNlLCBmYWxzZV0sXG5cdFx0XHRcdGJvdW5jZTogWzAsIDBdXG5cdFx0XHR9LFxuXHRcdH0sIHtcblx0XHRcdGRlY2VsZXJhdGlvbjogTUNfREVDRUxFUkFUSU9OLFxuXHRcdFx0bWF4aW11bUR1cmF0aW9uOiBNQ19NQVhJTVVNX0RVUkFUSU9OLFxuXHRcdH0sIHtcblx0XHRcdHlhdzogb3B0Lnlhdyxcblx0XHRcdHBpdGNoOiBvcHQucGl0Y2gsXG5cdFx0XHRmb3Y6IG9wdC5mb3Zcblx0XHR9KVxuXHRcdC5vbih7XG5cdFx0XHRob2xkOiBldnQgPT4ge1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJob2xkXCIsIHtpc1RydXN0ZWQ6IGV2dC5pc1RydXN0ZWR9KTtcblx0XHRcdH0sXG5cdFx0XHRjaGFuZ2U6IGV2dCA9PiB7XG5cdFx0XHRcdGlmIChldnQuZGVsdGEuZm92ICE9PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fc2V0UGFuU2NhbGUoZXZ0LnBvcy5mb3YpO1xuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZUNvbnRyb2xTY2FsZShldnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3RyaWdnZXJDaGFuZ2UoZXZ0KTtcblx0XHRcdH0sXG5cdFx0XHRyZWxlYXNlOiBldnQgPT4ge1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyQ2hhbmdlKGV2dCk7XG5cdFx0XHR9LFxuXHRcdFx0YW5pbWF0aW9uU3RhcnQ6IGV2dCA9PiB7XG5cdFx0XHR9LFxuXHRcdFx0YW5pbWF0aW9uRW5kOiBldnQgPT4ge1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJhbmltYXRpb25FbmRcIiwge2lzVHJ1c3RlZDogZXZ0LmlzVHJ1c3RlZH0pO1xuXHRcdFx0fSxcblx0XHR9KTtcblx0fVxuXG5cdF9zZXRQYW5TY2FsZShmb3YpIHtcblx0XHRjb25zdCBhcmVhSGVpZ2h0ID0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50KS5oZWlnaHQsIDEwKTtcblx0XHRjb25zdCBzY2FsZSA9IE1DX0JJTkRfU0NBTEVbMF0gKiBmb3YgLyB0aGlzLl9pbml0aWFsRm92ICogUEFOX1NDQUxFIC8gYXJlYUhlaWdodDtcblxuXHRcdHRoaXMuYXhlc1BhbklucHV0Lm9wdGlvbnMuc2NhbGUgPSBbc2NhbGUsIHNjYWxlXTtcblx0XHR0aGlzLmF4ZXMub3B0aW9ucy5kZWNlbGVyYXRpb24gPSBNQ19ERUNFTEVSQVRJT04gKiBmb3YgLyBNQVhfRklFTERfT0ZfVklFVztcblx0fVxuXG5cdC8qXG5cdCAqIE92ZXJyaWRlIGNvbXBvbmVudCdzIG9wdGlvbiBtZXRob2Rcblx0ICogdG8gY2FsbCBtZXRob2QgZm9yIHVwZGF0aW5nIHZhbHVlcyB3aGljaCBpcyBhZmZlY3RlZCBieSBvcHRpb24gY2hhbmdlLlxuXHQgKlxuXHQgKiBAcGFyYW0geyp9IGFyZ3Ncblx0ICovXG5cdG9wdGlvbiguLi5hcmdzKSB7XG5cdFx0Y29uc3QgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cblx0XHQvLyBHZXR0ZXJcblx0XHRpZiAoYXJnTGVuID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZ2V0T3B0aW9ucygpO1xuXHRcdH0gZWxzZSBpZiAoYXJnTGVuID09PSAxICYmIHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZ2V0T3B0aW9ucyhhcmdzWzBdKTtcblx0XHR9XG5cblx0XHQvLyBTZXR0ZXJcblx0XHRjb25zdCBiZWZvcmVPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcblx0XHRsZXQgbmV3T3B0aW9ucyA9IHt9O1xuXHRcdGxldCBjaGFuZ2VkS2V5TGlzdCA9IFtdOyAvLyBUT0RPOiBpZiB2YWx1ZSBpcyBub3QgY2hhbmdlZCwgdGhlbiBkbyBub3QgcHVzaCBvbiBjaGFuZ2VkS2V5TGlzdC5cblxuXHRcdGlmIChhcmdMZW4gPT09IDEpIHtcblx0XHRcdGNoYW5nZWRLZXlMaXN0ID0gT2JqZWN0LmtleXMoYXJnc1swXSk7XG5cdFx0XHRuZXdPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYXJnc1swXSk7XG5cdFx0fSBlbHNlIGlmIChhcmdMZW4gPj0gMikge1xuXHRcdFx0Y2hhbmdlZEtleUxpc3QucHVzaChhcmdzWzBdKTtcblx0XHRcdG5ld09wdGlvbnNbYXJnc1swXV0gPSBhcmdzWzFdO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NldE9wdGlvbnModGhpcy5fZ2V0VmFsaWRhdGVkT3B0aW9ucyhuZXdPcHRpb25zKSk7XG5cdFx0dGhpcy5fYXBwbHlPcHRpb25zKGNoYW5nZWRLZXlMaXN0LCBiZWZvcmVPcHRpb25zKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdF9nZXRWYWxpZGF0ZWRPcHRpb25zKG5ld09wdGlvbnMpIHtcblx0XHRpZiAobmV3T3B0aW9ucy55YXdSYW5nZSkge1xuXHRcdFx0bmV3T3B0aW9ucy55YXdSYW5nZSA9XG5cdFx0XHRcdHRoaXMuX2dldFZhbGlkWWF3UmFuZ2UobmV3T3B0aW9ucy55YXdSYW5nZSwgbmV3T3B0aW9ucy5mb3YsIG5ld09wdGlvbnMuYXNwZWN0UmF0aW8pO1xuXHRcdH1cblx0XHRpZiAobmV3T3B0aW9ucy5waXRjaFJhbmdlKSB7XG5cdFx0XHRuZXdPcHRpb25zLnBpdGNoUmFuZ2UgPSB0aGlzLl9nZXRWYWxpZFBpdGNoUmFuZ2UobmV3T3B0aW9ucy5waXRjaFJhbmdlLCBuZXdPcHRpb25zLmZvdik7XG5cdFx0fVxuXHRcdHJldHVybiBuZXdPcHRpb25zO1xuXHR9XG5cblx0X2dldE9wdGlvbnMoa2V5KSB7XG5cdFx0bGV0IHZhbHVlO1xuXG5cdFx0aWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZhbHVlID0gdGhpcy5vcHRpb25zW2tleV07XG5cdFx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHR2YWx1ZSA9IHRoaXMub3B0aW9ucztcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0X3NldE9wdGlvbnMob3B0aW9ucykge1xuXHRcdGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcblx0XHRcdHRoaXMub3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuXHRcdH1cblx0fVxuXG5cdF9hcHBseU9wdGlvbnMoa2V5cywgcHJldk9wdGlvbnMpIHtcblx0XHQvLyBJZiBvbmUgb2YgYmVsb3cgaXMgY2hhbmdlZCwgY2FsbCB1cGRhdGVDb250cm9sU2NhbGUoKVxuXHRcdGlmIChrZXlzLnNvbWUoa2V5ID0+XG5cdFx0XHRcdGtleSA9PT0gXCJzaG93UG9sZVBvaW50XCIgfHwga2V5ID09PSBcImZvdlwiIHx8IGtleSA9PT0gXCJhc3BlY3RSYXRpb1wiIHx8XG5cdFx0XHRcdGtleSA9PT0gXCJ5YXdSYW5nZVwiIHx8IGtleSA9PT0gXCJwaXRjaFJhbmdlXCJcblx0XHRcdCkpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUNvbnRyb2xTY2FsZSgpO1xuXHRcdH1cblxuXHRcdGlmIChrZXlzLnNvbWUoa2V5ID0+IGtleSA9PT0gXCJmb3ZSYW5nZVwiKSkge1xuXHRcdFx0Y29uc3QgZm92UmFuZ2UgPSB0aGlzLm9wdGlvbnMuZm92UmFuZ2U7XG5cdFx0XHRjb25zdCBwcmV2Rm92ID0gdGhpcy5heGVzLmdldCgpLmZvdjtcblx0XHRcdGxldCBuZXh0Rm92ID0gdGhpcy5heGVzLmdldCgpLmZvdjtcblxuXHRcdFx0dmVjMi5jb3B5KHRoaXMuYXhlcy5heGlzLmZvdi5yYW5nZSwgZm92UmFuZ2UpO1xuXG5cdFx0XHRpZiAobmV4dEZvdiA8IGZvdlJhbmdlWzBdKSB7XG5cdFx0XHRcdG5leHRGb3YgPSBmb3ZSYW5nZVswXTtcblx0XHRcdH0gZWxzZSBpZiAocHJldkZvdiA+IGZvdlJhbmdlWzFdKSB7XG5cdFx0XHRcdG5leHRGb3YgPSBmb3ZSYW5nZVsxXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHByZXZGb3YgIT09IG5leHRGb3YpIHtcblx0XHRcdFx0dGhpcy5heGVzLnNldFRvKHtcblx0XHRcdFx0XHRmb3Y6IG5leHRGb3Zcblx0XHRcdFx0fSwgMCk7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZUNvbnRyb2xTY2FsZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChrZXlzLnNvbWUoa2V5ID0+IGtleSA9PT0gXCJneXJvTW9kZVwiKSAmJiBTVVBQT1JUX0RFVklDRU1PVElPTikge1xuXHRcdFx0Y29uc3QgZ3lyb01vZGUgPSB0aGlzLm9wdGlvbnMuZ3lyb01vZGU7XG5cblx0XHRcdC8vIERpc2Nvbm5lY3QgZmlyc3Rcblx0XHRcdGlmICh0aGlzLmF4ZXNUaWx0TW90aW9uSW5wdXQpIHtcblx0XHRcdFx0dGhpcy5heGVzLmRpc2Nvbm5lY3QodGhpcy5heGVzVGlsdE1vdGlvbklucHV0KTtcblx0XHRcdFx0dGhpcy5heGVzVGlsdE1vdGlvbklucHV0LmRlc3Ryb3koKTtcblx0XHRcdFx0dGhpcy5heGVzVGlsdE1vdGlvbklucHV0ID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX2RldmljZVF1YXRlcm5pb24pIHtcblx0XHRcdFx0dGhpcy5fZGV2aWNlUXVhdGVybmlvbi5kZXN0cm95KCk7XG5cdFx0XHRcdHRoaXMuX2RldmljZVF1YXRlcm5pb24gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZ3lyb01vZGUgPT09IEdZUk9fTU9ERS5ZQVdQSVRDSCkge1xuXHRcdFx0XHR0aGlzLmF4ZXNUaWx0TW90aW9uSW5wdXQgPSBuZXcgVGlsdE1vdGlvbklucHV0KHRoaXMuX2VsZW1lbnQpO1xuXHRcdFx0XHR0aGlzLmF4ZXMuY29ubmVjdChbXCJ5YXdcIiwgXCJwaXRjaFwiXSwgdGhpcy5heGVzVGlsdE1vdGlvbklucHV0KTtcblx0XHRcdH0gZWxzZSBpZiAoZ3lyb01vZGUgPT09IEdZUk9fTU9ERS5WUikge1xuXHRcdFx0XHR0aGlzLl9pbml0RGV2aWNlUXVhdGVybmlvbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChrZXlzLnNvbWUoa2V5ID0+IGtleSA9PT0gXCJ1c2VLZXlib2FyZFwiKSkge1xuXHRcdFx0Y29uc3QgdXNlS2V5Ym9hcmQgPSB0aGlzLm9wdGlvbnMudXNlS2V5Ym9hcmQ7XG5cblx0XHRcdGlmICh1c2VLZXlib2FyZCkge1xuXHRcdFx0XHR0aGlzLmF4ZXMuY29ubmVjdChbXCJ5YXdcIiwgXCJwaXRjaFwiXSwgdGhpcy5heGVzTW92ZUtleUlucHV0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYXhlcy5kaXNjb25uZWN0KHRoaXMuYXhlc01vdmVLZXlJbnB1dCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGtleXMuc29tZShrZXkgPT4ga2V5ID09PSBcInVzZVpvb21cIikpIHtcblx0XHRcdGNvbnN0IHVzZVpvb20gPSB0aGlzLm9wdGlvbnMudXNlWm9vbTtcblxuXHRcdFx0aWYgKHVzZVpvb20pIHtcblx0XHRcdFx0dGhpcy5heGVzLmNvbm5lY3QoW1wiZm92XCJdLCB0aGlzLmF4ZXNXaGVlbElucHV0KTtcblx0XHRcdFx0dGhpcy5heGVzUGluY2hJbnB1dCAmJiB0aGlzLmF4ZXMuY29ubmVjdChbXCJmb3ZcIl0sIHRoaXMuYXhlc1BpbmNoSW5wdXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5heGVzLmRpc2Nvbm5lY3QodGhpcy5heGVzV2hlZWxJbnB1dCk7XG5cdFx0XHRcdHRoaXMuYXhlc1BpbmNoSW5wdXQgJiYgdGhpcy5heGVzLmRpc2Nvbm5lY3QodGhpcy5heGVzUGluY2hJbnB1dCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGtleXMuc29tZShrZXkgPT4ga2V5ID09PSBcInRvdWNoRGlyZWN0aW9uXCIpKSB7XG5cdFx0XHR0aGlzLl9lbmFibGVkICYmIHRoaXMuX2VuYWJsZVRvdWNoKHRoaXMub3B0aW9ucy50b3VjaERpcmVjdGlvbik7XG5cdFx0fVxuXHR9XG5cblx0X2VuYWJsZVRvdWNoKGRpcmVjdGlvbikge1xuXHRcdGNvbnN0IHlhd0VuYWJsZWQgPSBkaXJlY3Rpb24gJiBUT1VDSF9ESVJFQ1RJT05fWUFXID8gXCJ5YXdcIiA6IG51bGw7XG5cdFx0Y29uc3QgcGl0Y2hFbmFibGVkID0gZGlyZWN0aW9uICYgVE9VQ0hfRElSRUNUSU9OX1BJVENIID8gXCJwaXRjaFwiIDogbnVsbDtcblxuXHRcdHRoaXMuYXhlcy5jb25uZWN0KFt5YXdFbmFibGVkLCBwaXRjaEVuYWJsZWRdLCB0aGlzLmF4ZXNQYW5JbnB1dCk7XG5cdH1cblxuXHRfaW5pdERldmljZVF1YXRlcm5pb24oKSB7XG5cdFx0dGhpcy5fZGV2aWNlUXVhdGVybmlvbiA9IG5ldyBEZXZpY2VRdWF0ZXJuaW9uKCk7XG5cblx0XHR0aGlzLl9kZXZpY2VRdWF0ZXJuaW9uLm9uKFwiY2hhbmdlXCIsIGUgPT4ge1xuXHRcdFx0dGhpcy5fdHJpZ2dlckNoYW5nZShlKTtcblx0XHR9KTtcblx0fVxuXG5cdF9nZXRWYWxpZFlhd1JhbmdlKG5ld1lhd1JhbmdlLCBuZXdGb3YsIG5ld0FzcGVjdFJhdGlvKSB7XG5cdFx0Y29uc3QgcmF0aW8gPSBZYXdQaXRjaENvbnRyb2wuYWRqdXN0QXNwZWN0UmF0aW8obmV3QXNwZWN0UmF0aW8gfHwgdGhpcy5vcHRpb25zLmFzcGVjdFJhdGlvIHx8IDEpO1xuXHRcdGNvbnN0IGZvdiA9IG5ld0ZvdiB8fCB0aGlzLmF4ZXMuZ2V0KCkuZm92O1xuXHRcdGNvbnN0IGhvcml6b250YWxGb3YgPSBmb3YgKiByYXRpbztcblx0XHRjb25zdCBpc1ZhbGlkID0gbmV3WWF3UmFuZ2VbMV0gLSBuZXdZYXdSYW5nZVswXSA+PSBob3Jpem9udGFsRm92O1xuXG5cdFx0aWYgKGlzVmFsaWQpIHtcblx0XHRcdHJldHVybiBuZXdZYXdSYW5nZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy55YXdSYW5nZSB8fCBERUZBVUxUX1lBV19SQU5HRTtcblx0XHR9XG5cdH1cblxuXHRfZ2V0VmFsaWRQaXRjaFJhbmdlKG5ld1BpdGNoUmFuZ2UsIG5ld0Zvdikge1xuXHRcdGNvbnN0IGZvdiA9IG5ld0ZvdiB8fCB0aGlzLmF4ZXMuZ2V0KCkuZm92O1xuXHRcdGNvbnN0IGlzVmFsaWQgPSBuZXdQaXRjaFJhbmdlWzFdIC0gbmV3UGl0Y2hSYW5nZVswXSA+PSBmb3Y7XG5cblx0XHRpZiAoaXNWYWxpZCkge1xuXHRcdFx0cmV0dXJuIG5ld1BpdGNoUmFuZ2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMucGl0Y2hSYW5nZSB8fCBERUZBVUxUX1BJVENIX1JBTkdFO1xuXHRcdH1cblx0fVxuXG5cdHN0YXRpYyBpc0NpcmN1bGFyKHJhbmdlKSB7XG5cdFx0cmV0dXJuIHJhbmdlWzFdIC0gcmFuZ2VbMF0gPCAzNjAgPyBbZmFsc2UsIGZhbHNlXSA6IFt0cnVlLCB0cnVlXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgeWF3L3BpdGNoIG1pbi9tYXggYnkgNSBmYWN0b3Jcblx0ICpcblx0ICogMS4gc2hvd1BvbGVQb2ludFxuXHQgKiAyLiBmb3Zcblx0ICogMy4geWF3UmFuZ2Vcblx0ICogNC4gcGl0Y2hSYW5nZVxuXHQgKiA1LiBhc3BlY3RSYXRpb1xuXHQgKlxuXHQgKiBJZiBvbmUgb2YgYWJvdmUgaXMgY2hhbmdlZCwgY2FsbCB0aGlzIGZ1bmN0aW9uXG5cdCAqL1xuXHRfdXBkYXRlQ29udHJvbFNjYWxlKGNoYW5nZUV2dCkge1xuXHRcdGNvbnN0IG9wdCA9IHRoaXMub3B0aW9ucztcblx0XHRjb25zdCBmb3YgPSB0aGlzLmF4ZXMuZ2V0KCkuZm92O1xuXG5cdFx0Y29uc3QgcFJhbmdlID0gdGhpcy5fdXBkYXRlUGl0Y2hSYW5nZShvcHQucGl0Y2hSYW5nZSwgZm92LCBvcHQuc2hvd1BvbGVQb2ludCk7XG5cdFx0Y29uc3QgeVJhbmdlID0gdGhpcy5fdXBkYXRlWWF3UmFuZ2Uob3B0Lnlhd1JhbmdlLCBmb3YsIG9wdC5hc3BlY3RSYXRpbyk7XG5cblx0XHQvLyBUT0RPOiBJZiBub3QgY2hhbmdlZCE/XG5cdFx0Y29uc3QgcG9zID0gdGhpcy5heGVzLmdldCgpO1xuXHRcdGxldCB5ID0gcG9zLnlhdztcblx0XHRsZXQgcCA9IHBvcy5waXRjaDtcblxuXHRcdHZlYzIuY29weSh0aGlzLmF4ZXMuYXhpcy55YXcucmFuZ2UsIHlSYW5nZSk7XG5cdFx0dmVjMi5jb3B5KHRoaXMuYXhlcy5heGlzLnBpdGNoLnJhbmdlLCBwUmFuZ2UpO1xuXHRcdHRoaXMuYXhlcy5heGlzLnlhdy5jaXJjdWxhciA9IFlhd1BpdGNoQ29udHJvbC5pc0NpcmN1bGFyKHlSYW5nZSk7XG5cdFx0dGhpcy5heGVzLmF4aXMucGl0Y2guY2lyY3VsYXIgPSBZYXdQaXRjaENvbnRyb2wuaXNDaXJjdWxhcihwUmFuZ2UpO1xuXG5cdFx0LyoqXG5cdFx0ICogdXBkYXRlIHlhdy9waXRjaCBieSBpdCdzIHJhbmdlLlxuXHRcdCAqL1xuXHRcdGlmICh5IDwgeVJhbmdlWzBdKSB7XG5cdFx0XHR5ID0geVJhbmdlWzBdO1xuXHRcdH0gZWxzZSBpZiAoeSA+IHlSYW5nZVsxXSkge1xuXHRcdFx0eSA9IHlSYW5nZVsxXTtcblx0XHR9XG5cblx0XHRpZiAocCA8IHBSYW5nZVswXSkge1xuXHRcdFx0cCA9IHBSYW5nZVswXTtcblx0XHR9IGVsc2UgaWYgKHAgPiBwUmFuZ2VbMV0pIHtcblx0XHRcdHAgPSBwUmFuZ2VbMV07XG5cdFx0fVxuXG5cdFx0aWYgKGNoYW5nZUV2dCkge1xuXHRcdFx0Y2hhbmdlRXZ0LnNldCh7XG5cdFx0XHRcdHlhdzogeSxcblx0XHRcdFx0cGl0Y2g6IHAsXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLmF4ZXMuc2V0VG8oe1xuXHRcdFx0eWF3OiB5LFxuXHRcdFx0cGl0Y2g6IHAsXG5cdFx0fSwgMCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdF91cGRhdGVQaXRjaFJhbmdlKHBpdGNoUmFuZ2UsIGZvdiwgc2hvd1BvbGVQb2ludCkge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMuZ3lyb01vZGUgPT09IEdZUk9fTU9ERS5WUikge1xuXHRcdFx0Ly8gQ2lyY3VsYXIgcGl0Y2ggb24gVlJcblx0XHRcdHJldHVybiBDSVJDVUxBUl9QSVRDSF9SQU5HRTtcblx0XHR9XG5cblx0XHRjb25zdCB2ZXJ0aWNhbEFuZ2xlID0gcGl0Y2hSYW5nZVsxXSAtIHBpdGNoUmFuZ2VbMF07XG5cdFx0Y29uc3QgaGFsZkZvdiA9IGZvdiAvIDI7XG5cdFx0Y29uc3QgaXNQYW5vcmFtYSA9IHZlcnRpY2FsQW5nbGUgPCAxODA7XG5cblx0XHRpZiAoc2hvd1BvbGVQb2ludCAmJiAhaXNQYW5vcmFtYSkge1xuXHRcdFx0Ly8gVXNlIGZ1bGwgcGluY2ggcmFuZ2Vcblx0XHRcdHJldHVybiBwaXRjaFJhbmdlLm1hcCh2ID0+ICt2LnRvRml4ZWQoNSkpO1xuXHRcdH1cblxuXHRcdC8vIFJvdW5kIHZhbHVlIGFzIG1vdmFibGVDb29kIGRvLlxuXHRcdHJldHVybiBbcGl0Y2hSYW5nZVswXSArIGhhbGZGb3YsIHBpdGNoUmFuZ2VbMV0gLSBoYWxmRm92XS5tYXAodiA9PiArdi50b0ZpeGVkKDUpKTtcblx0fVxuXG5cdF91cGRhdGVZYXdSYW5nZSh5YXdSYW5nZSwgZm92LCBhc3BlY3RSYXRpbykge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMuZ3lyb01vZGUgPT09IEdZUk9fTU9ERS5WUikge1xuXHRcdFx0cmV0dXJuIERFRkFVTFRfWUFXX1JBTkdFO1xuXHRcdH1cblxuXHRcdGNvbnN0IGhvcml6b250YWxBbmdsZSA9IHlhd1JhbmdlWzFdIC0geWF3UmFuZ2VbMF07XG5cblx0XHQvKipcblx0XHQgKiBGdWxsIDM2MCBNb2RlXG5cdFx0ICovXG5cdFx0aWYgKGhvcml6b250YWxBbmdsZSA+PSAzNjApIHtcblx0XHRcdC8vIERvbid0IGxpbWl0IHlhdyByYW5nZSBvbiBGdWxsIDM2MCBtb2RlLlxuXHRcdFx0cmV0dXJuIHlhd1JhbmdlLm1hcCh2ID0+ICt2LnRvRml4ZWQoNSkpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFBhbm9yYW1hIG1vZGVcblx0XHQgKi9cblx0XHRsZXQgTUFHSUNfTlVNQkVSID0gMTtcblx0XHRjb25zdCByYXRpbyA9IFlhd1BpdGNoQ29udHJvbC5hZGp1c3RBc3BlY3RSYXRpbyhhc3BlY3RSYXRpbyk7XG5cdFx0Y29uc3QgaGFsZkhvcml6b250YWxGb3YgPSBmb3YgLyAyICogcmF0aW87XG5cblx0XHQvLyBUT0RPOiBNYWdpYyBOdW1iZXIgRml4IVxuXHRcdGlmIChob3Jpem9udGFsQW5nbGUgPiAyOTApIHtcblx0XHRcdE1BR0lDX05VTUJFUiA9IDAuNzk0Oy8vIGhvcml6b250YWxBbmdsZSA9IDI4Njtcblx0XHR9IGVsc2UgaWYgKGhvcml6b250YWxBbmdsZSA+IDEyNSkge1xuXHRcdFx0TUFHSUNfTlVNQkVSID0gMC45ODsgLy8gaG9yaXpvbnRhbEFuZ2xlICo9IDAuOTg7XG5cdFx0fVxuXG5cdFx0Ly8gUm91bmQgdmFsdWUgYXMgbW92YWJsZUNvb2QgZG8uXG5cdFx0cmV0dXJuIFtcblx0XHRcdCh5YXdSYW5nZVswXSAqIE1BR0lDX05VTUJFUikgKyBoYWxmSG9yaXpvbnRhbEZvdixcblx0XHRcdCh5YXdSYW5nZVsxXSAqIE1BR0lDX05VTUJFUikgLSBoYWxmSG9yaXpvbnRhbEZvdl0ubWFwKHYgPT4gK3YudG9GaXhlZCg1KSk7XG5cdH1cblxuXHRfdHJpZ2dlckNoYW5nZShldnQpIHtcblx0XHRjb25zdCBwb3MgPSB0aGlzLmF4ZXMuZ2V0KCk7XG5cdFx0Y29uc3Qgb3B0ID0gdGhpcy5vcHRpb25zO1xuXHRcdGNvbnN0IGV2ZW50ID0ge1xuXHRcdFx0dGFyZ2V0RWxlbWVudDogb3B0LmVsZW1lbnQsXG5cdFx0XHRpc1RydXN0ZWQ6IGV2dC5pc1RydXN0ZWQsXG5cdFx0fTtcblxuXHRcdGV2ZW50LnlhdyA9IHBvcy55YXc7XG5cdFx0ZXZlbnQucGl0Y2ggPSBwb3MucGl0Y2g7XG5cdFx0ZXZlbnQuZm92ID0gcG9zLmZvdjtcblxuXHRcdGlmIChvcHQuZ3lyb01vZGUgPT09IEdZUk9fTU9ERS5WUikge1xuXHRcdFx0ZXZlbnQucXVhdGVybmlvbiA9IHRoaXMuX2RldmljZVF1YXRlcm5pb24uZ2V0Q29tYmluZWRRdWF0ZXJuaW9uKHBvcy55YXcsIHBvcy5waXRjaCk7XG5cdFx0fVxuXHRcdHRoaXMudHJpZ2dlcihcImNoYW5nZVwiLCBldmVudCk7XG5cdH1cblxuXHQvLyBUT0RPOiBtYWtlcyBjb25zdGFudCB0byBiZSBsb2dpY1xuXHRzdGF0aWMgYWRqdXN0QXNwZWN0UmF0aW8oaW5wdXQpIHtcblx0XHRjb25zdCBpbnB1dFJhbmdlID0gWzAuNTIwLCAwLjU0MCwgMC41NjMsIDAuNTcwLCAwLjU4NCwgMC41OTAsIDAuNjA5LCAwLjY3MCxcblx0XHRcdDAuNzAyLCAwLjcyMCwgMC43NjAsIDAuNzgwLCAwLjgyMCwgMC45MjAsIDAuOTcwLCAxLjAwLCAxLjA3LCAxLjE0LCAxLjE5LFxuXHRcdFx0MS4yNSwgMS4zMiwgMS4zOCwgMS40MCwgMS40MywgMS41MywgMS42MiwgMS43NiwgMS43NywgMS44NiwgMS45NiwgMi4yNixcblx0XHRcdDIuMzAsIDIuNjAsIDMuMDAsIDUuMDAsIDYuMDBdO1xuXHRcdGNvbnN0IG91dHB1dFJhbmdlID0gWzAuNTEwLCAwLjU0MCwgMC42MDYsIDAuNTYwLCAwLjYyOCwgMC42MzAsIDAuNjQ3LCAwLjcxMCxcblx0XHRcdDAuNzM2LCAwLjc1NywgMC43ODAsIDAuNzcwLCAwLjgwMCwgMC44OTAsIDAuOTc1LCAxLjAwLCAxLjA3LCAxLjEwLCAxLjE1LFxuXHRcdFx0MS4xOCwgMS4yMiwgMS4yNywgMS4zMCwgMS4zMywgMS4zOSwgMS40NSwgMS41NCwgMS41NSwgMS41OCwgMS42MiwgMS43Mixcblx0XHRcdDEuODIsIDEuOTIsIDIuMDAsIDIuMjQsIDIuMzBdO1xuXG5cdFx0bGV0IHJhbmdlSWR4ID0gLTE7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0UmFuZ2UubGVuZ3RoIC0gMTsgaSsrKSB7XG5cdFx0XHRpZiAoaW5wdXRSYW5nZVtpXSA8PSBpbnB1dCAmJiBpbnB1dFJhbmdlW2kgKyAxXSA+PSBpbnB1dCkge1xuXHRcdFx0XHRyYW5nZUlkeCA9IGk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChyYW5nZUlkeCA9PT0gLTEpIHtcblx0XHRcdGlmIChpbnB1dFJhbmdlWzBdID4gaW5wdXQpIHtcblx0XHRcdFx0cmV0dXJuIG91dHB1dFJhbmdlWzBdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG91dHB1dFJhbmdlW291dHB1dFJhbmdlWzBdLmxlbmd0aCAtIDFdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IGlucHV0QSA9IGlucHV0UmFuZ2VbcmFuZ2VJZHhdO1xuXHRcdGNvbnN0IGlucHV0QiA9IGlucHV0UmFuZ2VbcmFuZ2VJZHggKyAxXTtcblx0XHRjb25zdCBvdXRwdXRBID0gb3V0cHV0UmFuZ2VbcmFuZ2VJZHhdO1xuXHRcdGNvbnN0IG91dHB1dEIgPSBvdXRwdXRSYW5nZVtyYW5nZUlkeCArIDFdO1xuXG5cdFx0cmV0dXJuIFlhd1BpdGNoQ29udHJvbC5sZXJwKG91dHB1dEEsIG91dHB1dEIsIChpbnB1dCAtIGlucHV0QSkgLyAoaW5wdXRCIC0gaW5wdXRBKSk7XG5cdH1cblxuXHRzdGF0aWMgbGVycChhLCBiLCBmcmFjdGlvbikge1xuXHRcdHJldHVybiBhICsgZnJhY3Rpb24gKiAoYiAtIGEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuYWJsZSBZYXdQaXRjaCBmdW5jdGlvbmFsaXR5XG5cdCAqXG5cdCAqIEBtZXRob2QgZWcuWWF3UGl0Y2gjZW5hYmxlXG5cdCAqL1xuXHRlbmFibGUoKSB7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIHRvdWNoRGlyZWN0aW9uIGlzIGRlY2lkZWQgYnkgcGFyYW1ldGVyIGlzIHZhbGlkIHN0cmluZyAoUmVmLiBBeGVzLmNvbm5lY3QpXG5cdFx0dGhpcy5fZW5hYmxlVG91Y2godGhpcy5vcHRpb25zLnRvdWNoRGlyZWN0aW9uKTtcblxuXHRcdHRoaXMuX2FwcGx5T3B0aW9ucyhPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMpLCB0aGlzLm9wdGlvbnMpO1xuXHRcdHRoaXMuX3NldFBhblNjYWxlKHRoaXMuZ2V0Rm92KCkpO1xuXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogRGlzYWJsZSBZYXdQaXRjaCBmdW5jdGlvbmFsaXR5XG5cdCAqXG5cdCAqIEBtZXRob2QgZWcuWWF3UGl0Y2gjZGlzYWJsZVxuXHQgKi9cblx0ZGlzYWJsZShwZXJzaXN0T3JpZW50YXRpb24pIHtcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIFRPRE86IENoZWNrIHBlcmlzdE9yaWVudGF0aW9uIGlzIG5lZWRlZCFcblx0XHRpZiAoIXBlcnNpc3RPcmllbnRhdGlvbikge1xuXHRcdFx0dGhpcy5fcmVzZXRPcmllbnRhdGlvbigpO1xuXHRcdH1cblx0XHR0aGlzLmF4ZXMuZGlzY29ubmVjdCgpO1xuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdF9yZXNldE9yaWVudGF0aW9uKCkge1xuXHRcdGNvbnN0IG9wdCA9IHRoaXMub3B0aW9ucztcblxuXHRcdHRoaXMuYXhlcy5zZXRUbyh7XG5cdFx0XHR5YXc6IG9wdC55YXcsXG5cdFx0XHRwaXRjaDogb3B0LnBpdGNoLFxuXHRcdFx0Zm92OiBvcHQuZm92LFxuXHRcdH0sIDApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBTZXQgb25lIG9yIG1vcmUgb2YgeWF3LCBwaXRjaCwgZm92XG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjb29yZGluYXRlIHlhdywgcGl0Y2gsIGZvdlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gQW5pbWF0aW9uIGR1cmF0aW9uLiBpZiBpdCBpcyBhYm92ZSAwIHRoZW4gaXQncyBhbmltYXRlZC5cblx0ICovXG5cdGxvb2tBdCh7eWF3LCBwaXRjaCwgZm92fSwgZHVyYXRpb24pIHtcblx0XHRjb25zdCBwb3MgPSB0aGlzLmF4ZXMuZ2V0KCk7XG5cblx0XHRjb25zdCB5ID0geWF3ID09PSB1bmRlZmluZWQgPyAwIDogeWF3IC0gcG9zLnlhdztcblx0XHRjb25zdCBwID0gcGl0Y2ggPT09IHVuZGVmaW5lZCA/IDAgOiBwaXRjaCAtIHBvcy5waXRjaDtcblx0XHRjb25zdCBmID0gZm92ID09PSB1bmRlZmluZWQgPyAwIDogZm92IC0gcG9zLmZvdjtcblxuXHRcdHRoaXMuYXhlcy5zZXRCeSh7XG5cdFx0XHR5YXc6IHksXG5cdFx0XHRwaXRjaDogcCxcblx0XHRcdGZvdjogZlxuXHRcdH0sIGR1cmF0aW9uKTtcblx0fVxuXG5cdGdldCgpIHtcblx0XHRyZXR1cm4gdGhpcy5heGVzLmdldCgpO1xuXHR9XG5cblx0Z2V0WWF3KCkge1xuXHRcdHJldHVybiB0aGlzLmF4ZXMuZ2V0KCkueWF3O1xuXHR9XG5cblx0Z2V0UGl0Y2goKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXhlcy5nZXQoKS5waXRjaDtcblx0fVxuXG5cdGdldEZvdigpIHtcblx0XHRyZXR1cm4gdGhpcy5heGVzLmdldCgpLmZvdjtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXN0cm95cyBvYmplY3RzXG5cdCAqL1xuXHRkZXN0cm95KCkge1xuXHRcdHRoaXMuYXhlcyAmJiB0aGlzLmF4ZXMuZGVzdHJveSgpO1xuXHRcdHRoaXMuYXhpc1BhbklucHV0ICYmIHRoaXMuYXhpc1BhbklucHV0LmRlc3Ryb3koKTtcblx0XHR0aGlzLmF4ZXNXaGVlbElucHV0ICYmIHRoaXMuYXhlc1doZWVsSW5wdXQuZGVzdHJveSgpO1xuXHRcdHRoaXMuYXhlc1RpbHRNb3Rpb25JbnB1dCAmJiB0aGlzLmF4ZXNUaWx0TW90aW9uSW5wdXQuZGVzdHJveSgpO1xuXHRcdHRoaXMuYXhlc0RldmljZU9yaWVudGF0aW9uSW5wdXQgJiYgdGhpcy5heGVzRGV2aWNlT3JpZW50YXRpb25JbnB1dC5kZXN0cm95KCk7XG5cdFx0dGhpcy5heGVzUGluY2hJbnB1dCAmJiB0aGlzLmF4ZXNQaW5jaElucHV0LmRlc3Ryb3koKTtcblx0XHR0aGlzLmF4ZXNNb3ZlS2V5SW5wdXQgJiYgdGhpcy5heGVzTW92ZUtleUlucHV0LmRlc3Ryb3koKTtcblx0XHR0aGlzLl9kZXZpY2VRdWF0ZXJuaW9uICYmIHRoaXMuX2RldmljZVF1YXRlcm5pb24uZGVzdHJveSgpO1xuXHR9XG59O1xuXG5ZYXdQaXRjaENvbnRyb2wuVkVSU0lPTiA9IFwiMy4wLjAtcmNcIjtcbmV4cG9ydCBkZWZhdWx0IFlhd1BpdGNoQ29udHJvbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9ZYXdQaXRjaENvbnRyb2wvWWF3UGl0Y2hDb250cm9sLmpzIiwiaW1wb3J0IE1hdGhVdGlsIGZyb20gXCJ3ZWJ2ci1wb2x5ZmlsbC9zcmMvbWF0aC11dGlsXCI7XG5pbXBvcnQgQ29tcGxlbWVudGFyeUZpbHRlciBmcm9tIFwid2VidnItcG9seWZpbGwvc3JjL3NlbnNvci1mdXNpb24vY29tcGxlbWVudGFyeS1maWx0ZXJcIjtcblxuQ29tcGxlbWVudGFyeUZpbHRlci5wcm90b3R5cGUucnVuXyA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIXRoaXMuaXNPcmllbnRhdGlvbkluaXRpYWxpemVkKSB7XG5cdFx0dGhpcy5hY2NlbFEgPSB0aGlzLmFjY2VsVG9RdWF0ZXJuaW9uXyh0aGlzLmN1cnJlbnRBY2NlbE1lYXN1cmVtZW50LnNhbXBsZSk7XG5cdFx0dGhpcy5wcmV2aW91c0ZpbHRlclEuY29weSh0aGlzLmFjY2VsUSk7XG5cdFx0dGhpcy5pc09yaWVudGF0aW9uSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGRlbHRhVCA9IHRoaXMuY3VycmVudEd5cm9NZWFzdXJlbWVudC50aW1lc3RhbXBTIC1cblx0dGhpcy5wcmV2aW91c0d5cm9NZWFzdXJlbWVudC50aW1lc3RhbXBTO1xuXG5cdC8vIENvbnZlcnQgZ3lybyByb3RhdGlvbiB2ZWN0b3IgdG8gYSBxdWF0ZXJuaW9uIGRlbHRhLlxuXHRjb25zdCBneXJvRGVsdGFRID0gdGhpcy5neXJvVG9RdWF0ZXJuaW9uRGVsdGFfKHRoaXMuY3VycmVudEd5cm9NZWFzdXJlbWVudC5zYW1wbGUsIGRlbHRhVCk7XG5cblx0dGhpcy5neXJvSW50ZWdyYWxRLm11bHRpcGx5KGd5cm9EZWx0YVEpO1xuXG5cdC8vIGZpbHRlcl8xID0gSyAqIChmaWx0ZXJfMCArIGd5cm8gKiBkVCkgKyAoMSAtIEspICogYWNjZWwuXG5cdHRoaXMuZmlsdGVyUS5jb3B5KHRoaXMucHJldmlvdXNGaWx0ZXJRKTtcblx0dGhpcy5maWx0ZXJRLm11bHRpcGx5KGd5cm9EZWx0YVEpO1xuXG5cdC8vIENhbGN1bGF0ZSB0aGUgZGVsdGEgYmV0d2VlbiB0aGUgY3VycmVudCBlc3RpbWF0ZWQgZ3Jhdml0eSBhbmQgdGhlIHJlYWxcblx0Ly8gZ3Jhdml0eSB2ZWN0b3IgZnJvbSBhY2NlbGVyb21ldGVyLlxuXHRjb25zdCBpbnZGaWx0ZXJRID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcblxuXHRpbnZGaWx0ZXJRLmNvcHkodGhpcy5maWx0ZXJRKTtcblx0aW52RmlsdGVyUS5pbnZlcnNlKCk7XG5cblx0dGhpcy5lc3RpbWF0ZWRHcmF2aXR5LnNldCgwLCAwLCAtMSk7XG5cdHRoaXMuZXN0aW1hdGVkR3Jhdml0eS5hcHBseVF1YXRlcm5pb24oaW52RmlsdGVyUSk7XG5cdHRoaXMuZXN0aW1hdGVkR3Jhdml0eS5ub3JtYWxpemUoKTtcblxuXHR0aGlzLm1lYXN1cmVkR3Jhdml0eS5jb3B5KHRoaXMuY3VycmVudEFjY2VsTWVhc3VyZW1lbnQuc2FtcGxlKTtcblx0dGhpcy5tZWFzdXJlZEdyYXZpdHkubm9ybWFsaXplKCk7XG5cblx0Ly8gQ29tcGFyZSBlc3RpbWF0ZWQgZ3Jhdml0eSB3aXRoIG1lYXN1cmVkIGdyYXZpdHksIGdldCB0aGUgZGVsdGEgcXVhdGVybmlvblxuXHQvLyBiZXR3ZWVuIHRoZSB0d28uXG5cdGNvbnN0IGRlbHRhUSA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG5cblx0ZGVsdGFRLnNldEZyb21Vbml0VmVjdG9ycyh0aGlzLmVzdGltYXRlZEdyYXZpdHksIHRoaXMubWVhc3VyZWRHcmF2aXR5KTtcblx0ZGVsdGFRLmludmVyc2UoKTtcblxuXHQvLyBDYWxjdWxhdGUgdGhlIFNMRVJQIHRhcmdldDogY3VycmVudCBvcmllbnRhdGlvbiBwbHVzIHRoZSBtZWFzdXJlZC1lc3RpbWF0ZWRcblx0Ly8gcXVhdGVybmlvbiBkZWx0YS5cblx0Y29uc3QgdGFyZ2V0USA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG5cblx0dGFyZ2V0US5jb3B5KHRoaXMuZmlsdGVyUSk7XG5cdHRhcmdldFEubXVsdGlwbHkoZGVsdGFRKTtcblxuXHQvLyBTTEVSUCBmYWN0b3I6IDAgaXMgcHVyZSBneXJvLCAxIGlzIHB1cmUgYWNjZWwuXG5cdHRoaXMuZmlsdGVyUS5zbGVycCh0YXJnZXRRLCAxIC0gdGhpcy5rRmlsdGVyKTtcblxuXHR0aGlzLnByZXZpb3VzRmlsdGVyUS5jb3B5KHRoaXMuZmlsdGVyUSk7XG5cblx0aWYgKCF0aGlzLmlzRmlsdGVyUXVhdGVybmlvbkluaXRpYWxpemVkKSB7XG5cdFx0dGhpcy5pc0ZpbHRlclF1YXRlcm5pb25Jbml0aWFsaXplZCA9IHRydWU7XG5cdH1cbn07XG5cbkNvbXBsZW1lbnRhcnlGaWx0ZXIucHJvdG90eXBlLmdldE9yaWVudGF0aW9uID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLmlzRmlsdGVyUXVhdGVybmlvbkluaXRpYWxpemVkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyUTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQ29tcGxlbWVudGFyeUZpbHRlcjtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1lhd1BpdGNoQ29udHJvbC9pbnB1dC9Db21wbGVtZW50YXJ5RmlsdGVyLmpzIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG5pbXBvcnQgQWdlbnQgZnJvbSBcIkBlZ2pzL2FnZW50XCI7XG5pbXBvcnQge3ZlYzN9IGZyb20gXCIuLi8uLi91dGlscy9tYXRoLXV0aWxcIjtcbmltcG9ydCB7d2luZG93fSBmcm9tIFwiLi4vYnJvd3NlclwiO1xuXG5jb25zdCBTVElMTE5FU1NfVEhSRVNIT0xEID0gMjAwOyAvLyBtaWxsaXNlY29uZFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZXZpY2VNb3Rpb24gZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuX29uRGV2aWNlTW90aW9uID0gdGhpcy5fb25EZXZpY2VNb3Rpb24uYmluZCh0aGlzKTtcblx0XHR0aGlzLl9vbkRldmljZU9yaWVudGF0aW9uID0gdGhpcy5fb25EZXZpY2VPcmllbnRhdGlvbi5iaW5kKHRoaXMpO1xuXG5cdFx0dGhpcy5pc0FuZHJvaWQgPSBBZ2VudCgpLm9zLm5hbWUgPT09IFwiYW5kcm9pZFwiO1xuXG5cdFx0dGhpcy5zdGlsbEd5cm9WZWMgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHRoaXMucmF3R3lyb1ZlYyA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0dGhpcy5hZGp1c3RlZEd5cm9WZWMgPSB2ZWMzLmNyZWF0ZSgpO1xuXG5cdFx0dGhpcy5fdGltZXIgPSBudWxsO1xuXG5cdFx0dGhpcy5sYXN0RGV2aWNlbW90aW9uVGltZXN0YW1wID0gMDtcblx0XHR0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcblx0XHR0aGlzLmVuYWJsZSgpO1xuXHR9XG5cdF9vbkRldmljZU9yaWVudGF0aW9uKCkge1xuXHRcdHRoaXMuX3RpbWVyICYmIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG5cdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdGlmICgobmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3REZXZpY2Vtb3Rpb25UaW1lc3RhbXApIDwgU1RJTExORVNTX1RIUkVTSE9MRCkge1xuXHRcdFx0XHR2ZWMzLmNvcHkodGhpcy5zdGlsbEd5cm9WZWMsIHRoaXMucmF3R3lyb1ZlYyk7XG5cdFx0XHR9XG5cdFx0fSwgU1RJTExORVNTX1RIUkVTSE9MRCk7XG5cdH1cblx0X29uRGV2aWNlTW90aW9uKGUpIHtcblx0XHQvLyBkZXNrdG9wIGNocm9tZSB0cmlnZ2VycyBkZXZpY2Vtb3Rpb24gZXZlbnQgd2l0aCBlbXB0aHkgc2Vuc29yIHZhbHVlcy5cblx0XHQvLyBUaG9zZSBldmVudHMgc2hvdWxkIGlnbm9yZWQuXG5cdFx0aWYgKGUuaW50ZXJ2YWwgPT09IDAgfHwgZS5hY2NlbGVyYXRpb24ueCA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmlzQW5kcm9pZCkge1xuXHRcdFx0dmVjMy5zZXQoXG5cdFx0XHRcdHRoaXMucmF3R3lyb1ZlYyxcblx0XHRcdFx0ZS5yb3RhdGlvblJhdGUuYWxwaGEgfHwgMCxcblx0XHRcdFx0ZS5yb3RhdGlvblJhdGUuYmV0YSB8fCAwLFxuXHRcdFx0XHRlLnJvdGF0aW9uUmF0ZS5nYW1tYSB8fCAwKTtcblx0XHRcdHZlYzMuc3VidHJhY3QodGhpcy5hZGp1c3RlZEd5cm9WZWMsIHRoaXMucmF3R3lyb1ZlYywgdGhpcy5zdGlsbEd5cm9WZWMpO1xuXHRcdFx0dGhpcy5sYXN0RGV2aWNlbW90aW9uVGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cblx0XHRcdGUuYWRqdXN0ZWRSb3RhdGlvblJhdGUgPSB7XG5cdFx0XHRcdGFscGhhOiB0aGlzLmFkanVzdGVkR3lyb1ZlY1swXSxcblx0XHRcdFx0YmV0YTogdGhpcy5hZGp1c3RlZEd5cm9WZWNbMV0sXG5cdFx0XHRcdGdhbW1hOiB0aGlzLmFkanVzdGVkR3lyb1ZlY1syXX07XG5cdFx0fVxuXG5cdFx0dGhpcy50cmlnZ2VyKFwiZGV2aWNlbW90aW9uXCIsIHtcblx0XHRcdGlucHV0RXZlbnQ6IGVcblx0XHR9KTtcblx0fVxuXHRlbmFibGUoKSB7XG5cdFx0aWYgKHRoaXMuaXNBbmRyb2lkKSB7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsIHRoaXMuX29uRGV2aWNlT3JpZW50YXRpb24pO1xuXHRcdH1cblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW1vdGlvblwiLCB0aGlzLl9vbkRldmljZU1vdGlvbik7XG5cdFx0dGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcblx0fVxuXHRkaXNhYmxlKCkge1xuXHRcdGlmICh0aGlzLmlzQW5kcm9pZCkge1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkZXZpY2VvcmllbnRhdGlvblwiLCB0aGlzLl9vbkRldmljZU9yaWVudGF0aW9uKTtcblx0XHR9XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkZXZpY2Vtb3Rpb25cIiwgdGhpcy5fb25EZXZpY2VNb3Rpb24pO1xuXHRcdHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuXHR9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvWWF3UGl0Y2hDb250cm9sL2lucHV0L0RldmljZU1vdGlvbi5qcyIsImltcG9ydCBBeGVzLCB7UGFuSW5wdXR9IGZyb20gXCJAZWdqcy9heGVzXCI7XG5pbXBvcnQgU2NyZWVuUm90YXRpb25BbmdsZSBmcm9tIFwiLi4vU2NyZWVuUm90YXRpb25BbmdsZVwiO1xuXG4vKipcbiAqIFJvdGF0aW9uUGFuSW5wdXQgaXMgZXh0ZW5zaW9uIG9mIFBhbklucHV0IHRvIGNvbXBlbnNhdGUgY29vcmRpbmF0ZXMgYnkgc2NyZWVuIHJvdGF0aW9uIGFuZ2xlLlxuICpcbiAqIFRoZSByZWFzb24gZm9yIHVzaW5nIHRoaXMgZnVuY3Rpb24gaXMgdGhhdCBpbiBWUiBtb2RlLFxuICogdGhlIHJvbGwgYW5nbGUgaXMgYWRqdXN0ZWQgaW4gdGhlIGRpcmVjdGlvbiBvcHBvc2l0ZSB0byB0aGUgc2NyZWVuIHJvdGF0aW9uIGFuZ2xlLlxuICpcbiAqIFRoZXJlZm9yZSwgdGhlIGFuZ2xlIHRoYXQgdGhlIHVzZXIgdG91Y2hlcyBhbmQgbW92ZXMgZG9lcyBub3QgbWF0Y2ggdGhlIGFuZ2xlIGF0IHdoaWNoIHRoZSBhY3R1YWwgb2JqZWN0IHNob3VsZCBtb3ZlLlxuICogQGV4dGVuZHMgUGFuSW5wdXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm90YXRpb25QYW5JbnB1dCBleHRlbmRzIFBhbklucHV0IHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdG9yXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbiBvYmplY3Rcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VSb3RhdGlvbl0gIFdoZXRoZXIgdG8gdXNlIHJvdGF0aW9uKG9yIFZSKVxuXHQgKi9cblx0Y29uc3RydWN0b3IoZWwsIG9wdGlvbnMpIHtcblx0XHRzdXBlcihlbCwgb3B0aW9ucyk7XG5cdFx0dGhpcy5fdXNlUm90YXRpb24gPSAhIShvcHRpb25zICYmIG9wdGlvbnMudXNlUm90YXRpb24pO1xuXG5cdFx0dGhpcy5fc2NyZWVuUm90YXRpb25BbmdsZSA9IG51bGw7XG5cdFx0dGhpcy5fdXNlUm90YXRpb24gJiYgKHRoaXMuX3NjcmVlblJvdGF0aW9uQW5nbGUgPSBuZXcgU2NyZWVuUm90YXRpb25BbmdsZSgpKTtcblx0XHR0aGlzLl91c2VyRGlyZWN0aW9uID0gQXhlcy5ESVJFQ1RJT05fQUxMO1xuXHR9XG5cblx0Y29ubmVjdChvYnNlcnZlcikge1xuXHRcdC8vIFVzZXIgaW50ZXRlbmVkIGRpcmVjdGlvblxuXHRcdHRoaXMuX3VzZXJEaXJlY3Rpb24gPSB0aGlzLl9kaXJlY3Rpb247XG5cblx0XHQvLyBJbiBWUiBNb2RlLCBVc2UgQUxMIGRpcmVjdGlvbiBpZiBkaXJlY3Rpb24gaXMgbm90IG5vbmVcblx0XHQvLyBCZWNhdXNlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGlzIGNoYW5nZWQgZHluYW1pY2FsbHkgYnkgc2NyZWVuIHJvdGF0aW9uLlxuXHRcdC8vIHRoaXMuX2RpcmVjdGlvbiBpcyB1c2VkIHRvIGluaXRpYWxpemUgaGFtbWVyanNcblx0XHRpZiAodGhpcy5fdXNlUm90YXRpb24gJiYgKHRoaXMuX2RpcmVjdGlvbiAmIEF4ZXMuRElSRUNUSU9OX0FMTCkpIHtcblx0XHRcdHRoaXMuX2RpcmVjdGlvbiA9IEF4ZXMuRElSRUNUSU9OX0FMTDtcblx0XHR9XG5cblx0XHRzdXBlci5jb25uZWN0KG9ic2VydmVyKTtcblx0fVxuXG5cdGdldE9mZnNldChwcm9wZXJ0aWVzLCB1c2VEaXJlY3Rpb24pIHtcblx0XHRpZiAodGhpcy5fdXNlUm90YXRpb24gPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm4gc3VwZXIuZ2V0T2Zmc2V0KHByb3BlcnRpZXMsIHVzZURpcmVjdGlvbik7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgb2Zmc2V0ID0gc3VwZXIuZ2V0T2Zmc2V0KHByb3BlcnRpZXMsIFt0cnVlLCB0cnVlXSk7XG5cdFx0Y29uc3QgbmV3T2Zmc2V0ID0gWzAsIDBdO1xuXHRcdGNvbnN0IHRoZXRhID0gdGhpcy5fc2NyZWVuUm90YXRpb25BbmdsZS5nZXRSYWRpYW4oKTtcblx0XHRjb25zdCBjb3NUaGV0YSA9IE1hdGguY29zKHRoZXRhKTtcblx0XHRjb25zdCBzaW5UaGV0YSA9IE1hdGguc2luKHRoZXRhKTtcblxuXHRcdG5ld09mZnNldFswXSA9IG9mZnNldFswXSAqIGNvc1RoZXRhIC0gb2Zmc2V0WzFdICogc2luVGhldGE7XG5cdFx0bmV3T2Zmc2V0WzFdID0gb2Zmc2V0WzFdICogY29zVGhldGEgKyBvZmZzZXRbMF0gKiBzaW5UaGV0YTtcblxuXHRcdC8vIFVzZSBvbmx5IHVzZXIgYWxsb3dlZCBkaXJlY3Rpb24uXG5cdFx0aWYgKCEodGhpcy5fdXNlckRpcmVjdGlvbiAmIEF4ZXMuRElSRUNUSU9OX0hPUklaT05UQUwpKSB7XG5cdFx0XHRuZXdPZmZzZXRbMF0gPSAwO1xuXHRcdH0gZWxzZSBpZiAoISh0aGlzLl91c2VyRGlyZWN0aW9uICYgQXhlcy5ESVJFQ1RJT05fVkVSVElDQUwpKSB7XG5cdFx0XHRuZXdPZmZzZXRbMV0gPSAwO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXdPZmZzZXQ7XG5cdH1cblxuXHRkZXN0cm95KCkge1xuXHRcdGlmICh0aGlzLl91c2VSb3RhdGlvbikge1xuXHRcdFx0dGhpcy5fc2NyZWVuUm90YXRpb25BbmdsZSAmJiB0aGlzLl9zY3JlZW5Sb3RhdGlvbkFuZ2xlLnVucmVmKCk7XG5cdFx0fVxuXG5cdFx0c3VwZXIuZGVzdHJveSgpO1xuXHR9XG59XG5cbi8qKlxuICogT3ZlcnJpZGUgZ2V0RGlyZWN0aW9uQnlBbmdsZSB0byByZXR1cm4gRElSRUNUSU9OX0FMTFxuICogUmVmOiBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1heGVzL2lzc3Vlcy85OVxuICpcbiAqIEJ1dCB3ZSBvYmV5IGF4ZXMncyBydWxlLiBJZiBheGVzJ3MgcnVsZSBpcyBwcm9ibGVtLCBsZXQncyBhcHBseSBmb2xsb3dpbmcgY29kZS5cbiAqL1xuLy8gUGFuSW5wdXQuZ2V0RGlyZWN0aW9uQnlBbmdsZSA9IGZ1bmN0aW9uIChhbmdsZSwgdGhyZXNob2xkQW5nbGUpIHtcbi8vIFx0cmV0dXJuIERJUkVDVElPTl9BTEw7XG4vLyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1lhd1BpdGNoQ29udHJvbC9pbnB1dC9Sb3RhdGlvblBhbklucHV0LmpzIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG5pbXBvcnQge3RvQXhpc30gZnJvbSBcIi4uL3V0aWxzXCI7XG5pbXBvcnQgRnVzaW9uUG9zZVNlbnNvciBmcm9tIFwiLi9GdXNpb25Qb3NlU2Vuc29yXCI7XG5pbXBvcnQge1xuXHR1dGlsLFxuXHRxdWF0LFxuXHRST1RBVEVfQ09OU1RBTlQsXG59IGZyb20gXCIuLi8uLi91dGlscy9tYXRoLXV0aWxcIjtcblxuZnVuY3Rpb24gZ2V0RGVsdGFZYXcocHJ2USwgY3VyUSkge1xuXHRjb25zdCB5YXdEZWx0YUJ5WWF3ID0gdXRpbC5nZXRSb3RhdGlvbkRlbHRhKHBydlEsIGN1clEsIFJPVEFURV9DT05TVEFOVC5ZQVdfREVMVEFfQllfWUFXKTtcblx0Y29uc3QgeWF3RGVsdGFCeVJvbGwgPSB1dGlsLmdldFJvdGF0aW9uRGVsdGEocHJ2USwgY3VyUSwgUk9UQVRFX0NPTlNUQU5ULllBV19ERUxUQV9CWV9ST0xMKSAqXG5cdFx0TWF0aC5zaW4odXRpbC5leHRyYWN0UGl0Y2hGcm9tUXVhdChjdXJRKSk7XG5cblx0cmV0dXJuIHlhd0RlbHRhQnlSb2xsICsgeWF3RGVsdGFCeVlhdztcbn1cblxuZnVuY3Rpb24gZ2V0RGVsdGFQaXRjaChwcnZRLCBjdXJRKSB7XG5cdGNvbnN0IHBpdGNoRGVsdGEgPSB1dGlsLmdldFJvdGF0aW9uRGVsdGEocHJ2USwgY3VyUSwgUk9UQVRFX0NPTlNUQU5ULlBJVENIX0RFTFRBKTtcblxuXHRyZXR1cm4gcGl0Y2hEZWx0YTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsdE1vdGlvbklucHV0IGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoZWwsIG9wdGlvbnMpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuZWxlbWVudCA9IGVsO1xuXG5cdFx0dGhpcy5fcHJldlF1YXRlcm5pb24gPSBudWxsO1xuXHRcdHRoaXMuX3F1YXRlcm5pb24gPSBudWxsO1xuXG5cdFx0dGhpcy5mdXNpb25Qb3NlU2Vuc29yID0gbnVsbDtcblxuXHRcdHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdFx0c2NhbGU6IDEsXG5cdFx0XHR0aHJlc2hvbGQ6IDAsXG5cdFx0fSwgb3B0aW9ucyk7XG5cblx0XHR0aGlzLl9vblBvc2VDaGFuZ2UgPSB0aGlzLl9vblBvc2VDaGFuZ2UuYmluZCh0aGlzKTtcblx0fVxuXHRtYXBBeGVzKGF4ZXMpIHtcblx0XHR0aGlzLmF4ZXMgPSBheGVzO1xuXHR9XG5cdGNvbm5lY3Qob2JzZXJ2ZXIpIHtcblx0XHRpZiAodGhpcy5vYnNlcnZlcikge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcblx0XHR0aGlzLmZ1c2lvblBvc2VTZW5zb3IgPSBuZXcgRnVzaW9uUG9zZVNlbnNvcigpO1xuXHRcdHRoaXMuZnVzaW9uUG9zZVNlbnNvci5lbmFibGUoKTtcblx0XHR0aGlzLl9hdHRhY2hFdmVudCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGRpc2Nvbm5lY3QoKSB7XG5cdFx0aWYgKCF0aGlzLm9ic2VydmVyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0aGlzLl9kZXR0YWNoRXZlbnQoKTtcblx0XHR0aGlzLmZ1c2lvblBvc2VTZW5zb3IuZGlzYWJsZSgpO1xuXHRcdHRoaXMuZnVzaW9uUG9zZVNlbnNvci5kZXN0cm95KCk7XG5cdFx0dGhpcy5mdXNpb25Qb3NlU2Vuc29yID0gbnVsbDtcblx0XHR0aGlzLm9ic2VydmVyID0gbnVsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRkZXN0cm95KCkge1xuXHRcdHRoaXMuZGlzY29ubmVjdCgpO1xuXHRcdHRoaXMuZWxlbWVudCA9IG51bGw7XG5cdFx0dGhpcy5vcHRpb25zID0gbnVsbDtcblx0XHR0aGlzLmF4ZXMgPSBudWxsO1xuXHRcdHRoaXMuX3ByZXZRdWF0ZXJuaW9uID0gbnVsbDtcblx0XHR0aGlzLl9xdWF0ZXJuaW9uID0gbnVsbDtcblx0fVxuXHRfb25Qb3NlQ2hhbmdlKGV2ZW50KSB7XG5cdFx0aWYgKCF0aGlzLl9wcmV2UXVhdGVybmlvbikge1xuXHRcdFx0dGhpcy5fcHJldlF1YXRlcm5pb24gPSBxdWF0LmNsb25lKGV2ZW50LnF1YXRlcm5pb24pO1xuXHRcdFx0dGhpcy5fcXVhdGVybmlvbiA9IHF1YXQuY2xvbmUoZXZlbnQucXVhdGVybmlvbik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cXVhdC5jb3B5KHRoaXMuX3ByZXZRdWF0ZXJuaW9uLCB0aGlzLl9xdWF0ZXJuaW9uKTtcblx0XHRxdWF0LmNvcHkodGhpcy5fcXVhdGVybmlvbiwgZXZlbnQucXVhdGVybmlvbik7XG5cblx0XHR0aGlzLm9ic2VydmVyLmNoYW5nZSh0aGlzLCBldmVudCwgdG9BeGlzKHRoaXMuYXhlcywgW1xuXHRcdFx0Z2V0RGVsdGFZYXcodGhpcy5fcHJldlF1YXRlcm5pb24sIHRoaXMuX3F1YXRlcm5pb24pLFxuXHRcdFx0Z2V0RGVsdGFQaXRjaCh0aGlzLl9wcmV2UXVhdGVybmlvbiwgdGhpcy5fcXVhdGVybmlvbilcblx0XHRdKSk7XG5cdH1cblx0X2F0dGFjaEV2ZW50KCkge1xuXHRcdHRoaXMuZnVzaW9uUG9zZVNlbnNvci5vbihcImNoYW5nZVwiLCB0aGlzLl9vblBvc2VDaGFuZ2UpO1xuXHR9XG5cdF9kZXR0YWNoRXZlbnQoKSB7XG5cdFx0dGhpcy5mdXNpb25Qb3NlU2Vuc29yLm9mZihcImNoYW5nZVwiLCB0aGlzLl9vblBvc2VDaGFuZ2UpO1xuXHR9XG59XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9ZYXdQaXRjaENvbnRyb2wvaW5wdXQvVGlsdE1vdGlvbklucHV0LmpzIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG5pbXBvcnQge3RvQXhpc30gZnJvbSBcIi4uL3V0aWxzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdoZWVsSW5wdXQgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvcihlbCwgb3B0aW9ucykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5lbGVtZW50ID0gZWw7XG5cblx0XHR0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRcdHNjYWxlOiAxLFxuXHRcdFx0dGhyZXNob2xkOiAwLFxuXHRcdH0sIG9wdGlvbnMpO1xuXG5cdFx0dGhpcy5fb25XaGVlbCA9IHRoaXMuX29uV2hlZWwuYmluZCh0aGlzKTtcblx0fVxuXHRtYXBBeGVzKGF4ZXMpIHtcblx0XHR0aGlzLmF4ZXMgPSBheGVzO1xuXHR9XG5cdGNvbm5lY3Qob2JzZXJ2ZXIpIHtcblx0XHRpZiAodGhpcy5vYnNlcnZlcikge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcblx0XHR0aGlzLl9hdHRhY2hFdmVudCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGRpc2Nvbm5lY3QoKSB7XG5cdFx0aWYgKCF0aGlzLm9ic2VydmVyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0dGhpcy5vYnNlcnZlciA9IG51bGw7XG5cdFx0dGhpcy5fZGV0dGFjaEV2ZW50KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZGVzdHJveSgpIHtcblx0XHR0aGlzLmRpc2Nvbm5lY3QoKTtcblx0XHR0aGlzLmVsZW1lbnQgPSBudWxsO1xuXHRcdHRoaXMub3B0aW9ucyA9IG51bGw7XG5cdFx0dGhpcy5heGVzID0gbnVsbDtcblx0fVxuXHRfb25XaGVlbChldmVudCkge1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRpZiAoZXZlbnQuZGVsdGFZID09PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5vYnNlcnZlci5jaGFuZ2UodGhpcywgZXZlbnQsIHRvQXhpcyh0aGlzLmF4ZXMsIFtcblx0XHRcdChldmVudC5kZWx0YVkgPCAwID8gLTEgOiAxKSAqIHRoaXMub3B0aW9ucy5zY2FsZVxuXHRcdF0pKTtcblx0fVxuXHRfYXR0YWNoRXZlbnQoKSB7XG5cdFx0dGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB0aGlzLl9vbldoZWVsLCBmYWxzZSk7XG5cdH1cblx0X2RldHRhY2hFdmVudCgpIHtcblx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMuX29uV2hlZWwsIGZhbHNlKTtcblx0fVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1lhd1BpdGNoQ29udHJvbC9pbnB1dC9XaGVlbElucHV0LmpzIiwiLyoqXG4gKiBPcmlnaW5hbCBDb2RlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdG9qaS9nbC1tYXRyaXgvYmxvYi92Mi4zLjIvc3JjL2dsLW1hdHJpeC9tYXQ0LmpzXG4gKiA0eDQgTWF0cml4IHV0aWxcbiAqIG1vZGlmaWVkIGJ5IGVnanNcbiAqL1xuaW1wb3J0IGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuXG4vKipcbiAqIEBjbGFzcyA0eDQgTWF0cml4XG4gKiBAbmFtZSBtYXQ0XG4gKi9cbnZhciBtYXQ0ID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQ0XG4gKlxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xubWF0NC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXMgbm90IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMTAgPSBhWzRdLFxuICAgICAgICBhMTEgPSBhWzVdLFxuICAgICAgICBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzBdICA9IGFbMF07XG4gICAgICAgIG91dFsxXSAgPSBhWzFdO1xuICAgICAgICBvdXRbMl0gID0gYVsyXTtcbiAgICAgICAgb3V0WzNdICA9IGFbM107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzRdID0gYTEwICogYyArIGEyMCAqIHM7XG4gICAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gICAgb3V0WzZdID0gYTEyICogYyArIGEyMiAqIHM7XG4gICAgb3V0WzddID0gYTEzICogYyArIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gICAgb3V0WzldID0gYTIxICogYyAtIGExMSAqIHM7XG4gICAgb3V0WzEwXSA9IGEyMiAqIGMgLSBhMTIgKiBzO1xuICAgIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpcyBub3QgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlWSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbNF0gID0gYVs0XTtcbiAgICAgICAgb3V0WzVdICA9IGFbNV07XG4gICAgICAgIG91dFs2XSAgPSBhWzZdO1xuICAgICAgICBvdXRbN10gID0gYVs3XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjIC0gYTIxICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgICBvdXRbOF0gPSBhMDAgKiBzICsgYTIwICogYztcbiAgICBvdXRbOV0gPSBhMDEgKiBzICsgYTIxICogYztcbiAgICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gICAgb3V0WzExXSA9IGEwMyAqIHMgKyBhMjMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgYSA0eDQgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVF1YXQgPSBmdW5jdGlvbiAob3V0LCBxKSB7XG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB5eCA9IHkgKiB4MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHp4ID0geiAqIHgyLFxuICAgICAgICB6eSA9IHogKiB5MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICBvdXRbMV0gPSB5eCArIHd6O1xuICAgIG91dFsyXSA9IHp4IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcblxuICAgIG91dFs0XSA9IHl4IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtIHh4IC0geno7XG4gICAgb3V0WzZdID0genkgKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuXG4gICAgb3V0WzhdID0genggKyB3eTtcbiAgICBvdXRbOV0gPSB6eSAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgICBvdXRbMTFdID0gMDtcblxuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgVmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5wZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uIChvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMiksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gZjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9ICgyICogZmFyICogbmVhcikgKiBuZjtcbiAgICBvdXRbMTVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtYXQ0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL21hdGhVdGlsL21hdDQuanMiLCIvKipcbiAqIE9yaWdpbmFsIENvZGVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL2dsLW1hdHJpeC9ibG9iL3YyLjMuMi9zcmMvZ2wtbWF0cml4L3F1YXQuanNcbiAqIFF1YXRlcm5pb24gdXRpbFxuICogbW9kaWZpZWQgYnkgZWdqc1xuICovXG5pbXBvcnQgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5cbi8qKlxuICogQGNsYXNzIFF1YXRlcm5pb25cbiAqIEBuYW1lIHF1YXRcbiAqL1xudmFyIHF1YXQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IHF1YXRcbiAqXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICovXG5xdWF0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBjbG9uZVxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6LCB3KSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IHc7XG4gICAgcmV0dXJuIG91dDtcbn07O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBxdWF0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgc291cmNlIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldHMgYSBxdWF0IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFuZCByb3RhdGlvbiBheGlzLFxuICogdGhlbiByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIGFyb3VuZCB3aGljaCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqKi9cbnF1YXQuc2V0QXhpc0FuZ2xlID0gZnVuY3Rpb24ob3V0LCBheGlzLCByYWQpIHtcbiAgICByYWQgPSByYWQgKiAwLjU7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIG91dFswXSA9IHMgKiBheGlzWzBdO1xuICAgIG91dFsxXSA9IHMgKiBheGlzWzFdO1xuICAgIG91dFsyXSA9IHMgKiBheGlzWzJdO1xuICAgIG91dFszXSA9IE1hdGguY29zKHJhZCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41O1xuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnggPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieDtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXogKiBieDtcbiAgICBvdXRbMl0gPSBheiAqIGJ3IC0gYXkgKiBieDtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7XG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieSA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGF4ICogYncgLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5O1xuICAgIG91dFsyXSA9IGF6ICogYncgKyBheCAqIGJ5O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheSAqIGJ5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbmp1Z2F0ZSBvZiBhIHF1YXRcbiAqIElmIHRoZSBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsIHRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gcXVhdC5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgY29uanVnYXRlIG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuY29uanVnYXRlID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXSxcbiAgICAgICAgdyA9IGFbM107XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqeiArIHcqdztcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IHggKiBsZW47XG4gICAgICAgIG91dFsxXSA9IHkgKiBsZW47XG4gICAgICAgIG91dFsyXSA9IHogKiBsZW47XG4gICAgICAgIG91dFszXSA9IHcgKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgVGhlIGZpcnN0IHF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge3F1YXR9IGIgVGhlIHNlY29uZCBxdWF0ZXJuaW9uLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnF1YXQuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICAgIGxldCBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107XG4gICAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkpO1xuICB9XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcXVhdGVybmlvbnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBUaGUgZmlyc3QgcXVhdGVybmlvbi5cbiAqIEBwYXJhbSB7cXVhdH0gYiBUaGUgc2Vjb25kIHF1YXRlcm5pb24uXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xucXVhdC5leGFjdEVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHF1YXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvbWF0aFV0aWwvcXVhdC5qcyIsIi8qKlxuICogT3JpZ2luYWwgQ29kZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3RvamkvZ2wtbWF0cml4L2Jsb2IvdjIuMy4yL3NyYy9nbC1tYXRyaXgvdmVjMi5qc1xuICogMiBEaW1lbnNpb25hbCBWZWN0b3IgVXRpbFxuICogbW9kaWZpZWQgYnkgZWdqc1xuICovXG5pbXBvcnQgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5cbi8qKlxuICogQGNsYXNzIDIgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWMyXG4gKi9cbnZhciB2ZWMyID0ge307XG5cbnZlYzIuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2ZWMyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL21hdGhVdGlsL3ZlYzIuanMiLCIvKipcbiAqIE9yaWdpbmFsIENvZGVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL2dsLW1hdHJpeC9ibG9iL3YyLjMuMi9zcmMvZ2wtbWF0cml4L3ZlYzMuanNcbiAqIDMgRGltZW5zaW9uYWwgVmVjdG9yIFV0aWxcbiAqIG1vZGlmaWVkIGJ5IGVnanNcbiAqL1xuaW1wb3J0IGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuXG4vKipcbiAqIEBjbGFzcyAzIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjM1xuICovXG52YXIgdmVjMyA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcbiAqXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbnZlYzMuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5LCB6KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbnZlYzMuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMzLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqejtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMy5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXTtcblxuICAgIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybVF1YXQgPSBmdW5jdGlvbihvdXQsIGEsIHEpIHtcbiAgICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xuXG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXSxcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICAgICAgICBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcbiAgICAgICAgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG4gICAgICAgIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4LFxuICAgICAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMucm90YXRlWiA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG5cdHZhciBwID0gW10sIHI9W107XG5cdC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblx0cFswXSA9IGFbMF0gLSBiWzBdO1xuXHRwWzFdID0gYVsxXSAtIGJbMV07XG5cdHBbMl0gPSBhWzJdIC0gYlsyXTtcblxuXHQvL3BlcmZvcm0gcm90YXRpb25cblx0clswXSA9IHBbMF0qTWF0aC5jb3MoYykgLSBwWzFdKk1hdGguc2luKGMpO1xuXHRyWzFdID0gcFswXSpNYXRoLnNpbihjKSArIHBbMV0qTWF0aC5jb3MoYyk7XG5cdHJbMl0gPSBwWzJdO1xuXG5cdC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblx0b3V0WzBdID0gclswXSArIGJbMF07XG5cdG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuXHRvdXRbMl0gPSByWzJdICsgYlsyXTtcblxuXHRyZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2ZWMzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL21hdGhVdGlsL3ZlYzMuanMiLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBhbnNpSFRNTFxuXG4vLyBSZWZlcmVuY2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9hbnNpLXJlZ2V4XG52YXIgX3JlZ0FOU0kgPSAvKD86KD86XFx1MDAxYlxcWyl8XFx1MDA5YikoPzooPzpbMC05XXsxLDN9KT8oPzooPzo7WzAtOV17MCwzfSkqKT9bQS1NfGYtbV0pfFxcdTAwMWJbQS1NXS9cblxudmFyIF9kZWZDb2xvcnMgPSB7XG4gIHJlc2V0OiBbJ2ZmZicsICcwMDAnXSwgLy8gW0ZPUkVHUk9VRF9DT0xPUiwgQkFDS0dST1VORF9DT0xPUl1cbiAgYmxhY2s6ICcwMDAnLFxuICByZWQ6ICdmZjAwMDAnLFxuICBncmVlbjogJzIwOTgwNScsXG4gIHllbGxvdzogJ2U4YmYwMycsXG4gIGJsdWU6ICcwMDAwZmYnLFxuICBtYWdlbnRhOiAnZmYwMGZmJyxcbiAgY3lhbjogJzAwZmZlZScsXG4gIGxpZ2h0Z3JleTogJ2YwZjBmMCcsXG4gIGRhcmtncmV5OiAnODg4J1xufVxudmFyIF9zdHlsZXMgPSB7XG4gIDMwOiAnYmxhY2snLFxuICAzMTogJ3JlZCcsXG4gIDMyOiAnZ3JlZW4nLFxuICAzMzogJ3llbGxvdycsXG4gIDM0OiAnYmx1ZScsXG4gIDM1OiAnbWFnZW50YScsXG4gIDM2OiAnY3lhbicsXG4gIDM3OiAnbGlnaHRncmV5J1xufVxudmFyIF9vcGVuVGFncyA9IHtcbiAgJzEnOiAnZm9udC13ZWlnaHQ6Ym9sZCcsIC8vIGJvbGRcbiAgJzInOiAnb3BhY2l0eTowLjUnLCAvLyBkaW1cbiAgJzMnOiAnPGk+JywgLy8gaXRhbGljXG4gICc0JzogJzx1PicsIC8vIHVuZGVyc2NvcmVcbiAgJzgnOiAnZGlzcGxheTpub25lJywgLy8gaGlkZGVuXG4gICc5JzogJzxkZWw+JyAvLyBkZWxldGVcbn1cbnZhciBfY2xvc2VUYWdzID0ge1xuICAnMjMnOiAnPC9pPicsIC8vIHJlc2V0IGl0YWxpY1xuICAnMjQnOiAnPC91PicsIC8vIHJlc2V0IHVuZGVyc2NvcmVcbiAgJzI5JzogJzwvZGVsPicgLy8gcmVzZXQgZGVsZXRlXG59XG5cbjtbMCwgMjEsIDIyLCAyNywgMjgsIDM5LCA0OV0uZm9yRWFjaChmdW5jdGlvbiAobikge1xuICBfY2xvc2VUYWdzW25dID0gJzwvc3Bhbj4nXG59KVxuXG4vKipcbiAqIENvbnZlcnRzIHRleHQgd2l0aCBBTlNJIGNvbG9yIGNvZGVzIHRvIEhUTUwgbWFya3VwLlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBhbnNpSFRNTCAodGV4dCkge1xuICAvLyBSZXR1cm5zIHRoZSB0ZXh0IGlmIHRoZSBzdHJpbmcgaGFzIG5vIEFOU0kgZXNjYXBlIGNvZGUuXG4gIGlmICghX3JlZ0FOU0kudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvLyBDYWNoZSBvcGVuZWQgc2VxdWVuY2UuXG4gIHZhciBhbnNpQ29kZXMgPSBbXVxuICAvLyBSZXBsYWNlIHdpdGggbWFya3VwLlxuICB2YXIgcmV0ID0gdGV4dC5yZXBsYWNlKC9cXDAzM1xcWyhcXGQrKSptL2csIGZ1bmN0aW9uIChtYXRjaCwgc2VxKSB7XG4gICAgdmFyIG90ID0gX29wZW5UYWdzW3NlcV1cbiAgICBpZiAob3QpIHtcbiAgICAgIC8vIElmIGN1cnJlbnQgc2VxdWVuY2UgaGFzIGJlZW4gb3BlbmVkLCBjbG9zZSBpdC5cbiAgICAgIGlmICghIX5hbnNpQ29kZXMuaW5kZXhPZihzZXEpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXh0cmEtYm9vbGVhbi1jYXN0XG4gICAgICAgIGFuc2lDb2Rlcy5wb3AoKVxuICAgICAgICByZXR1cm4gJzwvc3Bhbj4nXG4gICAgICB9XG4gICAgICAvLyBPcGVuIHRhZy5cbiAgICAgIGFuc2lDb2Rlcy5wdXNoKHNlcSlcbiAgICAgIHJldHVybiBvdFswXSA9PT0gJzwnID8gb3QgOiAnPHNwYW4gc3R5bGU9XCInICsgb3QgKyAnO1wiPidcbiAgICB9XG5cbiAgICB2YXIgY3QgPSBfY2xvc2VUYWdzW3NlcV1cbiAgICBpZiAoY3QpIHtcbiAgICAgIC8vIFBvcCBzZXF1ZW5jZVxuICAgICAgYW5zaUNvZGVzLnBvcCgpXG4gICAgICByZXR1cm4gY3RcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH0pXG5cbiAgLy8gTWFrZSBzdXJlIHRhZ3MgYXJlIGNsb3NlZC5cbiAgdmFyIGwgPSBhbnNpQ29kZXMubGVuZ3RoXG4gIDsobCA+IDApICYmIChyZXQgKz0gQXJyYXkobCArIDEpLmpvaW4oJzwvc3Bhbj4nKSlcblxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogQ3VzdG9taXplIGNvbG9ycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvcnMgcmVmZXJlbmNlIHRvIF9kZWZDb2xvcnNcbiAqL1xuYW5zaUhUTUwuc2V0Q29sb3JzID0gZnVuY3Rpb24gKGNvbG9ycykge1xuICBpZiAodHlwZW9mIGNvbG9ycyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bjb2xvcnNgIHBhcmFtZXRlciBtdXN0IGJlIGFuIE9iamVjdC4nKVxuICB9XG5cbiAgdmFyIF9maW5hbENvbG9ycyA9IHt9XG4gIGZvciAodmFyIGtleSBpbiBfZGVmQ29sb3JzKSB7XG4gICAgdmFyIGhleCA9IGNvbG9ycy5oYXNPd25Qcm9wZXJ0eShrZXkpID8gY29sb3JzW2tleV0gOiBudWxsXG4gICAgaWYgKCFoZXgpIHtcbiAgICAgIF9maW5hbENvbG9yc1trZXldID0gX2RlZkNvbG9yc1trZXldXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoJ3Jlc2V0JyA9PT0ga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaGV4ID0gW2hleF1cbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShoZXgpIHx8IGhleC5sZW5ndGggPT09IDAgfHwgaGV4LnNvbWUoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBoICE9PSAnc3RyaW5nJ1xuICAgICAgfSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGFuIEFycmF5IGFuZCBlYWNoIGl0ZW0gY291bGQgb25seSBiZSBhIGhleCBzdHJpbmcsIGUuZy46IEZGMDAwMCcpXG4gICAgICB9XG4gICAgICB2YXIgZGVmSGV4Q29sb3IgPSBfZGVmQ29sb3JzW2tleV1cbiAgICAgIGlmICghaGV4WzBdKSB7XG4gICAgICAgIGhleFswXSA9IGRlZkhleENvbG9yWzBdXG4gICAgICB9XG4gICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMSB8fCAhaGV4WzFdKSB7XG4gICAgICAgIGhleCA9IFtoZXhbMF1dXG4gICAgICAgIGhleC5wdXNoKGRlZkhleENvbG9yWzFdKVxuICAgICAgfVxuXG4gICAgICBoZXggPSBoZXguc2xpY2UoMCwgMilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB2YWx1ZSBvZiBgJyArIGtleSArICdgIHByb3BlcnR5IG11c3QgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKVxuICAgIH1cbiAgICBfZmluYWxDb2xvcnNba2V5XSA9IGhleFxuICB9XG4gIF9zZXRUYWdzKF9maW5hbENvbG9ycylcbn1cblxuLyoqXG4gKiBSZXNldCBjb2xvcnMuXG4gKi9cbmFuc2lIVE1MLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBfc2V0VGFncyhfZGVmQ29sb3JzKVxufVxuXG4vKipcbiAqIEV4cG9zZSB0YWdzLCBpbmNsdWRpbmcgb3BlbiBhbmQgY2xvc2UuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5hbnNpSFRNTC50YWdzID0ge31cblxuaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYW5zaUhUTUwudGFncywgJ29wZW4nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfb3BlblRhZ3MgfVxuICB9KVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYW5zaUhUTUwudGFncywgJ2Nsb3NlJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX2Nsb3NlVGFncyB9XG4gIH0pXG59IGVsc2Uge1xuICBhbnNpSFRNTC50YWdzLm9wZW4gPSBfb3BlblRhZ3NcbiAgYW5zaUhUTUwudGFncy5jbG9zZSA9IF9jbG9zZVRhZ3Ncbn1cblxuZnVuY3Rpb24gX3NldFRhZ3MgKGNvbG9ycykge1xuICAvLyByZXNldCBhbGxcbiAgX29wZW5UYWdzWycwJ10gPSAnZm9udC13ZWlnaHQ6bm9ybWFsO29wYWNpdHk6MTtjb2xvcjojJyArIGNvbG9ycy5yZXNldFswXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFsxXVxuICAvLyBpbnZlcnNlXG4gIF9vcGVuVGFnc1snNyddID0gJ2NvbG9yOiMnICsgY29sb3JzLnJlc2V0WzFdICsgJztiYWNrZ3JvdW5kOiMnICsgY29sb3JzLnJlc2V0WzBdXG4gIC8vIGRhcmsgZ3JleVxuICBfb3BlblRhZ3NbJzkwJ10gPSAnY29sb3I6IycgKyBjb2xvcnMuZGFya2dyZXlcblxuICBmb3IgKHZhciBjb2RlIGluIF9zdHlsZXMpIHtcbiAgICB2YXIgY29sb3IgPSBfc3R5bGVzW2NvZGVdXG4gICAgdmFyIG9yaUNvbG9yID0gY29sb3JzW2NvbG9yXSB8fCAnMDAwJ1xuICAgIF9vcGVuVGFnc1tjb2RlXSA9ICdjb2xvcjojJyArIG9yaUNvbG9yXG4gICAgY29kZSA9IHBhcnNlSW50KGNvZGUpXG4gICAgX29wZW5UYWdzWyhjb2RlICsgMTApLnRvU3RyaW5nKCldID0gJ2JhY2tncm91bmQ6IycgKyBvcmlDb2xvclxuICB9XG59XG5cbmFuc2lIVE1MLnJlc2V0KClcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbnNpLWh0bWwvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gL1tcXHUwMDFiXFx1MDA5Yl1bWygpIzs/XSooPzpbMC05XXsxLDR9KD86O1swLTldezAsNH0pKik/WzAtOUEtUFJaY2YtbnFyeT0+PF0vZztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5zaS1yZWdleC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2V2ZW50cy9ldmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBYbWxFbnRpdGllczogcmVxdWlyZSgnLi9saWIveG1sLWVudGl0aWVzLmpzJyksXG4gIEh0bWw0RW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw0LWVudGl0aWVzLmpzJyksXG4gIEh0bWw1RW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw1LWVudGl0aWVzLmpzJyksXG4gIEFsbEh0bWxFbnRpdGllczogcmVxdWlyZSgnLi9saWIvaHRtbDUtZW50aXRpZXMuanMnKVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9odG1sLWVudGl0aWVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSFRNTF9BTFBIQSA9IFsnYXBvcycsICduYnNwJywgJ2lleGNsJywgJ2NlbnQnLCAncG91bmQnLCAnY3VycmVuJywgJ3llbicsICdicnZiYXInLCAnc2VjdCcsICd1bWwnLCAnY29weScsICdvcmRmJywgJ2xhcXVvJywgJ25vdCcsICdzaHknLCAncmVnJywgJ21hY3InLCAnZGVnJywgJ3BsdXNtbicsICdzdXAyJywgJ3N1cDMnLCAnYWN1dGUnLCAnbWljcm8nLCAncGFyYScsICdtaWRkb3QnLCAnY2VkaWwnLCAnc3VwMScsICdvcmRtJywgJ3JhcXVvJywgJ2ZyYWMxNCcsICdmcmFjMTInLCAnZnJhYzM0JywgJ2lxdWVzdCcsICdBZ3JhdmUnLCAnQWFjdXRlJywgJ0FjaXJjJywgJ0F0aWxkZScsICdBdW1sJywgJ0FyaW5nJywgJ0FlbGlnJywgJ0NjZWRpbCcsICdFZ3JhdmUnLCAnRWFjdXRlJywgJ0VjaXJjJywgJ0V1bWwnLCAnSWdyYXZlJywgJ0lhY3V0ZScsICdJY2lyYycsICdJdW1sJywgJ0VUSCcsICdOdGlsZGUnLCAnT2dyYXZlJywgJ09hY3V0ZScsICdPY2lyYycsICdPdGlsZGUnLCAnT3VtbCcsICd0aW1lcycsICdPc2xhc2gnLCAnVWdyYXZlJywgJ1VhY3V0ZScsICdVY2lyYycsICdVdW1sJywgJ1lhY3V0ZScsICdUSE9STicsICdzemxpZycsICdhZ3JhdmUnLCAnYWFjdXRlJywgJ2FjaXJjJywgJ2F0aWxkZScsICdhdW1sJywgJ2FyaW5nJywgJ2FlbGlnJywgJ2NjZWRpbCcsICdlZ3JhdmUnLCAnZWFjdXRlJywgJ2VjaXJjJywgJ2V1bWwnLCAnaWdyYXZlJywgJ2lhY3V0ZScsICdpY2lyYycsICdpdW1sJywgJ2V0aCcsICdudGlsZGUnLCAnb2dyYXZlJywgJ29hY3V0ZScsICdvY2lyYycsICdvdGlsZGUnLCAnb3VtbCcsICdkaXZpZGUnLCAnb3NsYXNoJywgJ3VncmF2ZScsICd1YWN1dGUnLCAndWNpcmMnLCAndXVtbCcsICd5YWN1dGUnLCAndGhvcm4nLCAneXVtbCcsICdxdW90JywgJ2FtcCcsICdsdCcsICdndCcsICdPRWxpZycsICdvZWxpZycsICdTY2Fyb24nLCAnc2Nhcm9uJywgJ1l1bWwnLCAnY2lyYycsICd0aWxkZScsICdlbnNwJywgJ2Vtc3AnLCAndGhpbnNwJywgJ3p3bmonLCAnendqJywgJ2xybScsICdybG0nLCAnbmRhc2gnLCAnbWRhc2gnLCAnbHNxdW8nLCAncnNxdW8nLCAnc2JxdW8nLCAnbGRxdW8nLCAncmRxdW8nLCAnYmRxdW8nLCAnZGFnZ2VyJywgJ0RhZ2dlcicsICdwZXJtaWwnLCAnbHNhcXVvJywgJ3JzYXF1bycsICdldXJvJywgJ2Zub2YnLCAnQWxwaGEnLCAnQmV0YScsICdHYW1tYScsICdEZWx0YScsICdFcHNpbG9uJywgJ1pldGEnLCAnRXRhJywgJ1RoZXRhJywgJ0lvdGEnLCAnS2FwcGEnLCAnTGFtYmRhJywgJ011JywgJ051JywgJ1hpJywgJ09taWNyb24nLCAnUGknLCAnUmhvJywgJ1NpZ21hJywgJ1RhdScsICdVcHNpbG9uJywgJ1BoaScsICdDaGknLCAnUHNpJywgJ09tZWdhJywgJ2FscGhhJywgJ2JldGEnLCAnZ2FtbWEnLCAnZGVsdGEnLCAnZXBzaWxvbicsICd6ZXRhJywgJ2V0YScsICd0aGV0YScsICdpb3RhJywgJ2thcHBhJywgJ2xhbWJkYScsICdtdScsICdudScsICd4aScsICdvbWljcm9uJywgJ3BpJywgJ3JobycsICdzaWdtYWYnLCAnc2lnbWEnLCAndGF1JywgJ3Vwc2lsb24nLCAncGhpJywgJ2NoaScsICdwc2knLCAnb21lZ2EnLCAndGhldGFzeW0nLCAndXBzaWgnLCAncGl2JywgJ2J1bGwnLCAnaGVsbGlwJywgJ3ByaW1lJywgJ1ByaW1lJywgJ29saW5lJywgJ2ZyYXNsJywgJ3dlaWVycCcsICdpbWFnZScsICdyZWFsJywgJ3RyYWRlJywgJ2FsZWZzeW0nLCAnbGFycicsICd1YXJyJywgJ3JhcnInLCAnZGFycicsICdoYXJyJywgJ2NyYXJyJywgJ2xBcnInLCAndUFycicsICdyQXJyJywgJ2RBcnInLCAnaEFycicsICdmb3JhbGwnLCAncGFydCcsICdleGlzdCcsICdlbXB0eScsICduYWJsYScsICdpc2luJywgJ25vdGluJywgJ25pJywgJ3Byb2QnLCAnc3VtJywgJ21pbnVzJywgJ2xvd2FzdCcsICdyYWRpYycsICdwcm9wJywgJ2luZmluJywgJ2FuZycsICdhbmQnLCAnb3InLCAnY2FwJywgJ2N1cCcsICdpbnQnLCAndGhlcmU0JywgJ3NpbScsICdjb25nJywgJ2FzeW1wJywgJ25lJywgJ2VxdWl2JywgJ2xlJywgJ2dlJywgJ3N1YicsICdzdXAnLCAnbnN1YicsICdzdWJlJywgJ3N1cGUnLCAnb3BsdXMnLCAnb3RpbWVzJywgJ3BlcnAnLCAnc2RvdCcsICdsY2VpbCcsICdyY2VpbCcsICdsZmxvb3InLCAncmZsb29yJywgJ2xhbmcnLCAncmFuZycsICdsb3onLCAnc3BhZGVzJywgJ2NsdWJzJywgJ2hlYXJ0cycsICdkaWFtcyddO1xudmFyIEhUTUxfQ09ERVMgPSBbMzksIDE2MCwgMTYxLCAxNjIsIDE2MywgMTY0LCAxNjUsIDE2NiwgMTY3LCAxNjgsIDE2OSwgMTcwLCAxNzEsIDE3MiwgMTczLCAxNzQsIDE3NSwgMTc2LCAxNzcsIDE3OCwgMTc5LCAxODAsIDE4MSwgMTgyLCAxODMsIDE4NCwgMTg1LCAxODYsIDE4NywgMTg4LCAxODksIDE5MCwgMTkxLCAxOTIsIDE5MywgMTk0LCAxOTUsIDE5NiwgMTk3LCAxOTgsIDE5OSwgMjAwLCAyMDEsIDIwMiwgMjAzLCAyMDQsIDIwNSwgMjA2LCAyMDcsIDIwOCwgMjA5LCAyMTAsIDIxMSwgMjEyLCAyMTMsIDIxNCwgMjE1LCAyMTYsIDIxNywgMjE4LCAyMTksIDIyMCwgMjIxLCAyMjIsIDIyMywgMjI0LCAyMjUsIDIyNiwgMjI3LCAyMjgsIDIyOSwgMjMwLCAyMzEsIDIzMiwgMjMzLCAyMzQsIDIzNSwgMjM2LCAyMzcsIDIzOCwgMjM5LCAyNDAsIDI0MSwgMjQyLCAyNDMsIDI0NCwgMjQ1LCAyNDYsIDI0NywgMjQ4LCAyNDksIDI1MCwgMjUxLCAyNTIsIDI1MywgMjU0LCAyNTUsIDM0LCAzOCwgNjAsIDYyLCAzMzgsIDMzOSwgMzUyLCAzNTMsIDM3NiwgNzEwLCA3MzIsIDgxOTQsIDgxOTUsIDgyMDEsIDgyMDQsIDgyMDUsIDgyMDYsIDgyMDcsIDgyMTEsIDgyMTIsIDgyMTYsIDgyMTcsIDgyMTgsIDgyMjAsIDgyMjEsIDgyMjIsIDgyMjQsIDgyMjUsIDgyNDAsIDgyNDksIDgyNTAsIDgzNjQsIDQwMiwgOTEzLCA5MTQsIDkxNSwgOTE2LCA5MTcsIDkxOCwgOTE5LCA5MjAsIDkyMSwgOTIyLCA5MjMsIDkyNCwgOTI1LCA5MjYsIDkyNywgOTI4LCA5MjksIDkzMSwgOTMyLCA5MzMsIDkzNCwgOTM1LCA5MzYsIDkzNywgOTQ1LCA5NDYsIDk0NywgOTQ4LCA5NDksIDk1MCwgOTUxLCA5NTIsIDk1MywgOTU0LCA5NTUsIDk1NiwgOTU3LCA5NTgsIDk1OSwgOTYwLCA5NjEsIDk2MiwgOTYzLCA5NjQsIDk2NSwgOTY2LCA5NjcsIDk2OCwgOTY5LCA5NzcsIDk3OCwgOTgyLCA4MjI2LCA4MjMwLCA4MjQyLCA4MjQzLCA4MjU0LCA4MjYwLCA4NDcyLCA4NDY1LCA4NDc2LCA4NDgyLCA4NTAxLCA4NTkyLCA4NTkzLCA4NTk0LCA4NTk1LCA4NTk2LCA4NjI5LCA4NjU2LCA4NjU3LCA4NjU4LCA4NjU5LCA4NjYwLCA4NzA0LCA4NzA2LCA4NzA3LCA4NzA5LCA4NzExLCA4NzEyLCA4NzEzLCA4NzE1LCA4NzE5LCA4NzIxLCA4NzIyLCA4NzI3LCA4NzMwLCA4NzMzLCA4NzM0LCA4NzM2LCA4NzQzLCA4NzQ0LCA4NzQ1LCA4NzQ2LCA4NzQ3LCA4NzU2LCA4NzY0LCA4NzczLCA4Nzc2LCA4ODAwLCA4ODAxLCA4ODA0LCA4ODA1LCA4ODM0LCA4ODM1LCA4ODM2LCA4ODM4LCA4ODM5LCA4ODUzLCA4ODU1LCA4ODY5LCA4OTAxLCA4OTY4LCA4OTY5LCA4OTcwLCA4OTcxLCA5MDAxLCA5MDAyLCA5Njc0LCA5ODI0LCA5ODI3LCA5ODI5LCA5ODMwXTtcblxudmFyIGFscGhhSW5kZXggPSB7fTtcbnZhciBudW1JbmRleCA9IHt9O1xuXG52YXIgaSA9IDA7XG52YXIgbGVuZ3RoID0gSFRNTF9BTFBIQS5sZW5ndGg7XG53aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIHZhciBhID0gSFRNTF9BTFBIQVtpXTtcbiAgICB2YXIgYyA9IEhUTUxfQ09ERVNbaV07XG4gICAgYWxwaGFJbmRleFthXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgbnVtSW5kZXhbY10gPSBhO1xuICAgIGkrKztcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSHRtbDRFbnRpdGllcygpIHt9XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYoIz9bXFx3XFxkXSspOz8vZywgZnVuY3Rpb24ocywgZW50aXR5KSB7XG4gICAgICAgIHZhciBjaHI7XG4gICAgICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBlbnRpdHkuY2hhckF0KDEpLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigyKSwgMTYpIDpcbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDEpKTtcblxuICAgICAgICAgICAgaWYgKCEoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpKSB7XG4gICAgICAgICAgICAgICAgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNociA9IGFscGhhSW5kZXhbZW50aXR5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hyIHx8IHM7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYWxwaGEgPSBudW1JbmRleFtzdHIuY2hhckNvZGVBdChpKV07XG4gICAgICAgIHJlc3VsdCArPSBhbHBoYSA/IFwiJlwiICsgYWxwaGEgKyBcIjtcIiA6IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgYWxwaGEgPSBudW1JbmRleFtjY107XG4gICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjYyA8IDMyIHx8IGNjID4gMTI2KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCImI1wiICsgY2MgKyBcIjtcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWw0RW50aXRpZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaHRtbC1lbnRpdGllcy9saWIvaHRtbDQtZW50aXRpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBBTFBIQV9JTkRFWCA9IHtcbiAgICAnJmx0JzogJzwnLFxuICAgICcmZ3QnOiAnPicsXG4gICAgJyZxdW90JzogJ1wiJyxcbiAgICAnJmFwb3MnOiAnXFwnJyxcbiAgICAnJmFtcCc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJmFwb3M7JzogJ1xcJycsXG4gICAgJyZhbXA7JzogJyYnXG59O1xuXG52YXIgQ0hBUl9JTkRFWCA9IHtcbiAgICA2MDogJ2x0JyxcbiAgICA2MjogJ2d0JyxcbiAgICAzNDogJ3F1b3QnLFxuICAgIDM5OiAnYXBvcycsXG4gICAgMzg6ICdhbXAnXG59O1xuXG52YXIgQ0hBUl9TX0lOREVYID0ge1xuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgICdcXCcnOiAnJmFwb3M7JyxcbiAgICAnJic6ICcmYW1wOydcbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFhtbEVudGl0aWVzKCkge31cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLzx8PnxcInwnfCYvZywgZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gQ0hBUl9TX0lOREVYW3NdO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mIz9bMC05YS16QS1aXSs7Py9nLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIGlmIChzLmNoYXJBdCgxKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHMuY2hhckF0KDIpLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQocy5zdWJzdHIoMyksIDE2KSA6XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQocy5zdWJzdHIoMikpO1xuXG4gICAgICAgICAgICBpZiAoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQUxQSEFfSU5ERVhbc10gfHwgcztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGFscGhhID0gQ0hBUl9JTkRFWFtjXTtcbiAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAzMiB8fCBjID4gMTI2KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5naHQgPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5naHQpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG4gfTtcblxubW9kdWxlLmV4cG9ydHMgPSBYbWxFbnRpdGllcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9odG1sLWVudGl0aWVzL2xpYi94bWwtZW50aXRpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcblxuICAgIHZhciBsb2dNZXRob2RzID0gW1xuICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgIFwid2FyblwiLFxuICAgICAgICBcImVycm9yXCJcbiAgICBdO1xuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGN1cnJlbnRMZXZlbDtcbiAgICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqXG4gICAgICogVG9wLWxldmVsIEFQSVxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICBuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3B1bnljb2RlL3B1bnljb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogc29ja2pzLWNsaWVudCB2MS4xLjQgfCBodHRwOi8vc29ja2pzLm9yZyB8IE1JVCBsaWNlbnNlICovXG4oZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5Tb2NrSlMgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB0cmFuc3BvcnRMaXN0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQtbGlzdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbWFpbicpKHRyYW5zcG9ydExpc3QpO1xuXG4vLyBUT0RPIGNhbid0IGdldCByaWQgb2YgdGhpcyB1bnRpbCBhbGwgc2VydmVycyBkb1xuaWYgKCdfc29ja2pzX29ubG9hZCcgaW4gZ2xvYmFsKSB7XG4gIHNldFRpbWVvdXQoZ2xvYmFsLl9zb2NranNfb25sb2FkLCAxKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9tYWluXCI6MTQsXCIuL3RyYW5zcG9ydC1saXN0XCI6MTZ9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gIDtcblxuZnVuY3Rpb24gQ2xvc2VFdmVudCgpIHtcbiAgRXZlbnQuY2FsbCh0aGlzKTtcbiAgdGhpcy5pbml0RXZlbnQoJ2Nsb3NlJywgZmFsc2UsIGZhbHNlKTtcbiAgdGhpcy53YXNDbGVhbiA9IGZhbHNlO1xuICB0aGlzLmNvZGUgPSAwO1xuICB0aGlzLnJlYXNvbiA9ICcnO1xufVxuXG5pbmhlcml0cyhDbG9zZUV2ZW50LCBFdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xvc2VFdmVudDtcblxufSx7XCIuL2V2ZW50XCI6NCxcImluaGVyaXRzXCI6NTd9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9ldmVudHRhcmdldCcpXG4gIDtcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xufVxuXG5pbmhlcml0cyhFdmVudEVtaXR0ZXIsIEV2ZW50VGFyZ2V0KTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0eXBlKSB7XG4gICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5vbih0eXBlLCBnKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcbiAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZXF1aXZhbGVudCBvZiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcbiAgZm9yICh2YXIgYWkgPSAxOyBhaSA8IGw7IGFpKyspIHtcbiAgICBhcmdzW2FpIC0gMV0gPSBhcmd1bWVudHNbYWldO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbn0se1wiLi9ldmVudHRhcmdldFwiOjUsXCJpbmhlcml0c1wiOjU3fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIEV2ZW50KGV2ZW50VHlwZSkge1xuICB0aGlzLnR5cGUgPSBldmVudFR5cGU7XG59XG5cbkV2ZW50LnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbihldmVudFR5cGUsIGNhbkJ1YmJsZSwgY2FuY2VsYWJsZSkge1xuICB0aGlzLnR5cGUgPSBldmVudFR5cGU7XG4gIHRoaXMuYnViYmxlcyA9IGNhbkJ1YmJsZTtcbiAgdGhpcy5jYW5jZWxhYmxlID0gY2FuY2VsYWJsZTtcbiAgdGhpcy50aW1lU3RhbXAgPSArbmV3IERhdGUoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7fTtcbkV2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge307XG5cbkV2ZW50LkNBUFRVUklOR19QSEFTRSA9IDE7XG5FdmVudC5BVF9UQVJHRVQgPSAyO1xuRXZlbnQuQlVCQkxJTkdfUEhBU0UgPSAzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyogU2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiBET00yIEV2ZW50VGFyZ2V0LlxuICogICBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1FdmVudHMvZXZlbnRzLmh0bWwjRXZlbnRzLUV2ZW50VGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xufVxuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCEoZXZlbnRUeXBlIGluIHRoaXMuX2xpc3RlbmVycykpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IFtdO1xuICB9XG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgLy8gIzRcbiAgaWYgKGFyci5pbmRleE9mKGxpc3RlbmVyKSA9PT0gLTEpIHtcbiAgICAvLyBNYWtlIGEgY29weSBzbyBhcyBub3QgdG8gaW50ZXJmZXJlIHdpdGggYSBjdXJyZW50IGRpc3BhdGNoRXZlbnQuXG4gICAgYXJyID0gYXJyLmNvbmNhdChbbGlzdGVuZXJdKTtcbiAgfVxuICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFycjtcbn07XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICB2YXIgYXJyID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gIGlmICghYXJyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpZHggPSBhcnIuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpZHggIT09IC0xKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBNYWtlIGEgY29weSBzbyBhcyBub3QgdG8gaW50ZXJmZXJlIHdpdGggYSBjdXJyZW50IGRpc3BhdGNoRXZlbnQuXG4gICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFyci5zbGljZSgwLCBpZHgpLmNvbmNhdChhcnIuc2xpY2UoaWR4ICsgMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxufTtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGV2ZW50ID0gYXJndW1lbnRzWzBdO1xuICB2YXIgdCA9IGV2ZW50LnR5cGU7XG4gIC8vIGVxdWl2YWxlbnQgb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gW2V2ZW50XSA6IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIC8vIFRPRE86IFRoaXMgZG9lc24ndCBtYXRjaCB0aGUgcmVhbCBiZWhhdmlvcjsgcGVyIHNwZWMsIG9uZm9vIGdldFxuICAvLyB0aGVpciBwbGFjZSBpbiBsaW5lIGZyb20gdGhlIC9maXJzdC8gdGltZSB0aGV5J3JlIHNldCBmcm9tXG4gIC8vIG5vbi1udWxsLiBBbHRob3VnaCBXZWJLaXQgYnVtcHMgaXQgdG8gdGhlIGVuZCBldmVyeSB0aW1lIGl0J3NcbiAgLy8gc2V0LlxuICBpZiAodGhpc1snb24nICsgdF0pIHtcbiAgICB0aGlzWydvbicgKyB0XS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuICBpZiAodCBpbiB0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAvLyBHcmFiIGEgcmVmZXJlbmNlIHRvIHRoZSBsaXN0ZW5lcnMgbGlzdC4gcmVtb3ZlRXZlbnRMaXN0ZW5lciBtYXkgYWx0ZXIgdGhlIGxpc3QuXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1t0XTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcblxufSx7fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQnKVxuICA7XG5cbmZ1bmN0aW9uIFRyYW5zcG9ydE1lc3NhZ2VFdmVudChkYXRhKSB7XG4gIEV2ZW50LmNhbGwodGhpcyk7XG4gIHRoaXMuaW5pdEV2ZW50KCdtZXNzYWdlJywgZmFsc2UsIGZhbHNlKTtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbn1cblxuaW5oZXJpdHMoVHJhbnNwb3J0TWVzc2FnZUV2ZW50LCBFdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0TWVzc2FnZUV2ZW50O1xuXG59LHtcIi4vZXZlbnRcIjo0LFwiaW5oZXJpdHNcIjo1N31dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2lmcmFtZScpXG4gIDtcblxuZnVuY3Rpb24gRmFjYWRlSlModHJhbnNwb3J0KSB7XG4gIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgdHJhbnNwb3J0Lm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgdHJhbnNwb3J0Lm9uKCdjbG9zZScsIHRoaXMuX3RyYW5zcG9ydENsb3NlLmJpbmQodGhpcykpO1xufVxuXG5GYWNhZGVKUy5wcm90b3R5cGUuX3RyYW5zcG9ydENsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIGlmcmFtZVV0aWxzLnBvc3RNZXNzYWdlKCdjJywgSlNPTjMuc3RyaW5naWZ5KFtjb2RlLCByZWFzb25dKSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl90cmFuc3BvcnRNZXNzYWdlID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ3QnLCBmcmFtZSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLl90cmFuc3BvcnQuc2VuZChkYXRhKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY2FkZUpTO1xuXG59LHtcIi4vdXRpbHMvaWZyYW1lXCI6NDcsXCJqc29uM1wiOjU4fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIEZhY2FkZUpTID0gcmVxdWlyZSgnLi9mYWNhZGUnKVxuICAsIEluZm9JZnJhbWVSZWNlaXZlciA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUtcmVjZWl2ZXInKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pZnJhbWUnKVxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aWZyYW1lLWJvb3RzdHJhcCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICB2YXIgdHJhbnNwb3J0TWFwID0ge307XG4gIGF2YWlsYWJsZVRyYW5zcG9ydHMuZm9yRWFjaChmdW5jdGlvbihhdCkge1xuICAgIGlmIChhdC5mYWNhZGVUcmFuc3BvcnQpIHtcbiAgICAgIHRyYW5zcG9ydE1hcFthdC5mYWNhZGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZV0gPSBhdC5mYWNhZGVUcmFuc3BvcnQ7XG4gICAgfVxuICB9KTtcblxuICAvLyBoYXJkLWNvZGVkIGZvciB0aGUgaW5mbyBpZnJhbWVcbiAgLy8gVE9ETyBzZWUgaWYgd2UgY2FuIG1ha2UgdGhpcyBtb3JlIGR5bmFtaWNcbiAgdHJhbnNwb3J0TWFwW0luZm9JZnJhbWVSZWNlaXZlci50cmFuc3BvcnROYW1lXSA9IEluZm9JZnJhbWVSZWNlaXZlcjtcbiAgdmFyIHBhcmVudE9yaWdpbjtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgU29ja0pTLmJvb3RzdHJhcF9pZnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuICAgIHZhciBmYWNhZGU7XG4gICAgaWZyYW1lVXRpbHMuY3VycmVudFdpbmRvd0lkID0gbG9jLmhhc2guc2xpY2UoMSk7XG4gICAgdmFyIG9uTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLnNvdXJjZSAhPT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGFyZW50T3JpZ2luID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJlbnRPcmlnaW4gPSBlLm9yaWdpbjtcbiAgICAgIH1cbiAgICAgIGlmIChlLm9yaWdpbiAhPT0gcGFyZW50T3JpZ2luKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlmcmFtZU1lc3NhZ2U7XG4gICAgICB0cnkge1xuICAgICAgICBpZnJhbWVNZXNzYWdlID0gSlNPTjMucGFyc2UoZS5kYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgZS5kYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gaWZyYW1lVXRpbHMuY3VycmVudFdpbmRvd0lkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoaWZyYW1lTWVzc2FnZS50eXBlKSB7XG4gICAgICBjYXNlICdzJzpcbiAgICAgICAgdmFyIHA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcCA9IEpTT04zLnBhcnNlKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2ZXJzaW9uID0gcFswXTtcbiAgICAgICAgdmFyIHRyYW5zcG9ydCA9IHBbMV07XG4gICAgICAgIHZhciB0cmFuc1VybCA9IHBbMl07XG4gICAgICAgIHZhciBiYXNlVXJsID0gcFszXTtcbiAgICAgICAgZGVidWcodmVyc2lvbiwgdHJhbnNwb3J0LCB0cmFuc1VybCwgYmFzZVVybCk7XG4gICAgICAgIC8vIGNoYW5nZSB0aGlzIHRvIHNlbXZlciBsb2dpY1xuICAgICAgICBpZiAodmVyc2lvbiAhPT0gU29ja0pTLnZlcnNpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGF0aWJsZSBTb2NrSlMhIE1haW4gc2l0ZSB1c2VzOicgK1xuICAgICAgICAgICAgICAgICAgICAnIFwiJyArIHZlcnNpb24gKyAnXCIsIHRoZSBpZnJhbWU6JyArXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgU29ja0pTLnZlcnNpb24gKyAnXCIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwodHJhbnNVcmwsIGxvYy5ocmVmKSB8fFxuICAgICAgICAgICAgIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwoYmFzZVVybCwgbG9jLmhyZWYpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGNvbm5lY3QgdG8gZGlmZmVyZW50IGRvbWFpbiBmcm9tIHdpdGhpbiBhbiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2lmcmFtZS4gKCcgKyBsb2MuaHJlZiArICcsICcgKyB0cmFuc1VybCArICcsICcgKyBiYXNlVXJsICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgICBmYWNhZGUgPSBuZXcgRmFjYWRlSlMobmV3IHRyYW5zcG9ydE1hcFt0cmFuc3BvcnRdKHRyYW5zVXJsLCBiYXNlVXJsKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbSc6XG4gICAgICAgIGZhY2FkZS5fc2VuZChpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2MnOlxuICAgICAgICBpZiAoZmFjYWRlKSB7XG4gICAgICAgICAgZmFjYWRlLl9jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZhY2FkZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdtZXNzYWdlJywgb25NZXNzYWdlKTtcblxuICAgIC8vIFN0YXJ0XG4gICAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ3MnKTtcbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2ZhY2FkZVwiOjcsXCIuL2luZm8taWZyYW1lLXJlY2VpdmVyXCI6MTAsXCIuL2xvY2F0aW9uXCI6MTMsXCIuL3V0aWxzL2V2ZW50XCI6NDYsXCIuL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJqc29uM1wiOjU4fV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLWFqYXgnKTtcbn1cblxuZnVuY3Rpb24gSW5mb0FqYXgodXJsLCBBamF4T2JqZWN0KSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHQwID0gK25ldyBEYXRlKCk7XG4gIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnR0VUJywgdXJsKTtcblxuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgIHZhciBpbmZvLCBydHQ7XG4gICAgaWYgKHN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICBydHQgPSAoK25ldyBEYXRlKCkpIC0gdDA7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGluZm8gPSBKU09OMy5wYXJzZSh0ZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIHRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghb2JqZWN0VXRpbHMuaXNPYmplY3QoaW5mbykpIHtcbiAgICAgICAgaW5mbyA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEluZm9BamF4LCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvQWpheC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy54by5jbG9zZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvQWpheDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vdXRpbHMvb2JqZWN0XCI6NDksXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBJbmZvQWpheCA9IHJlcXVpcmUoJy4vaW5mby1hamF4JylcbiAgO1xuXG5mdW5jdGlvbiBJbmZvUmVjZWl2ZXJJZnJhbWUodHJhbnNVcmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLmlyID0gbmV3IEluZm9BamF4KHRyYW5zVXJsLCBYSFJMb2NhbE9iamVjdCk7XG4gIHRoaXMuaXIub25jZSgnZmluaXNoJywgZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gICAgc2VsZi5pciA9IG51bGw7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgSlNPTjMuc3RyaW5naWZ5KFtpbmZvLCBydHRdKSk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhJbmZvUmVjZWl2ZXJJZnJhbWUsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9SZWNlaXZlcklmcmFtZS50cmFuc3BvcnROYW1lID0gJ2lmcmFtZS1pbmZvLXJlY2VpdmVyJztcblxuSW5mb1JlY2VpdmVySWZyYW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pcikge1xuICAgIHRoaXMuaXIuY2xvc2UoKTtcbiAgICB0aGlzLmlyID0gbnVsbDtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvUmVjZWl2ZXJJZnJhbWU7XG5cbn0se1wiLi9pbmZvLWFqYXhcIjo5LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIElmcmFtZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L2lmcmFtZScpXG4gICwgSW5mb1JlY2VpdmVySWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLWlmcmFtZScpO1xufVxuXG5mdW5jdGlvbiBJbmZvSWZyYW1lKGJhc2VVcmwsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZnIgPSBzZWxmLmlmciA9IG5ldyBJZnJhbWVUcmFuc3BvcnQoSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUsIHVybCwgYmFzZVVybCk7XG5cbiAgICBpZnIub25jZSgnbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgICAgaWYgKG1zZykge1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkID0gSlNPTjMucGFyc2UobXNnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIG1zZyk7XG4gICAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZm8gPSBkWzBdLCBydHQgPSBkWzFdO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgICB9XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSk7XG5cbiAgICBpZnIub25jZSgnY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVE9ETyB0aGlzIHNlZW1zIHRoZSBzYW1lIGFzIHRoZSAnbmVlZEJvZHknIGZyb20gdHJhbnNwb3J0c1xuICBpZiAoIWdsb2JhbC5kb2N1bWVudC5ib2R5KSB7XG4gICAgdXRpbHMuYXR0YWNoRXZlbnQoJ2xvYWQnLCBnbyk7XG4gIH0gZWxzZSB7XG4gICAgZ28oKTtcbiAgfVxufVxuXG5pbmhlcml0cyhJbmZvSWZyYW1lLCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvSWZyYW1lLmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG59O1xuXG5JbmZvSWZyYW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pZnIpIHtcbiAgICB0aGlzLmlmci5jbG9zZSgpO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMuaWZyID0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb0lmcmFtZTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9pbmZvLWlmcmFtZS1yZWNlaXZlclwiOjEwLFwiLi90cmFuc3BvcnQvaWZyYW1lXCI6MjIsXCIuL3V0aWxzL2V2ZW50XCI6NDYsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKVxuICAsIFhEUiA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94ZHInKVxuICAsIFhIUkNvcnMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgWEhSRmFrZSA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZScpXG4gICwgSW5mb0lmcmFtZSA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUnKVxuICAsIEluZm9BamF4ID0gcmVxdWlyZSgnLi9pbmZvLWFqYXgnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1yZWNlaXZlcicpO1xufVxuXG5mdW5jdGlvbiBJbmZvUmVjZWl2ZXIoYmFzZVVybCwgdXJsSW5mbykge1xuICBkZWJ1ZyhiYXNlVXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZG9YaHIoYmFzZVVybCwgdXJsSW5mbyk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhJbmZvUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbi8vIFRPRE8gdGhpcyBpcyBjdXJyZW50bHkgaWdub3JpbmcgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIHRyYW5zcG9ydHMgYW5kIHRoZSB3aGl0ZWxpc3RcblxuSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlciA9IGZ1bmN0aW9uKGJhc2VVcmwsIHVybCwgdXJsSW5mbykge1xuICAvLyBkZXRlcm1pbmUgbWV0aG9kIG9mIENPUlMgc3VwcG9ydCAoaWYgbmVlZGVkKVxuICBpZiAodXJsSW5mby5zYW1lT3JpZ2luKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkxvY2FsKTtcbiAgfVxuICBpZiAoWEhSQ29ycy5lbmFibGVkKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkNvcnMpO1xuICB9XG4gIGlmIChYRFIuZW5hYmxlZCAmJiB1cmxJbmZvLnNhbWVTY2hlbWUpIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWERSKTtcbiAgfVxuICBpZiAoSW5mb0lmcmFtZS5lbmFibGVkKCkpIHtcbiAgICByZXR1cm4gbmV3IEluZm9JZnJhbWUoYmFzZVVybCwgdXJsKTtcbiAgfVxuICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSRmFrZSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmRvWGhyID0gZnVuY3Rpb24oYmFzZVVybCwgdXJsSW5mbykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIHVybCA9IHVybFV0aWxzLmFkZFBhdGgoYmFzZVVybCwgJy9pbmZvJylcbiAgICA7XG4gIGRlYnVnKCdkb1hocicsIHVybCk7XG5cbiAgdGhpcy54byA9IEluZm9SZWNlaXZlci5fZ2V0UmVjZWl2ZXIoYmFzZVVybCwgdXJsLCB1cmxJbmZvKTtcblxuICB0aGlzLnRpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgfSwgSW5mb1JlY2VpdmVyLnRpbWVvdXQpO1xuXG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gICAgZGVidWcoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gIH0pO1xufTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKHdhc0NsZWFuKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0UmVmKTtcbiAgdGhpcy50aW1lb3V0UmVmID0gbnVsbDtcbiAgaWYgKCF3YXNDbGVhbiAmJiB0aGlzLnhvKSB7XG4gICAgdGhpcy54by5jbG9zZSgpO1xuICB9XG4gIHRoaXMueG8gPSBudWxsO1xufTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIudGltZW91dCA9IDgwMDA7XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb1JlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi9pbmZvLWFqYXhcIjo5LFwiLi9pbmZvLWlmcmFtZVwiOjExLFwiLi90cmFuc3BvcnQvc2VuZGVyL3hkclwiOjM0LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1jb3JzXCI6MzUsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWZha2VcIjozNixcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWxcIjozNyxcIi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmxvY2F0aW9uIHx8IHtcbiAgb3JpZ2luOiAnaHR0cDovL2xvY2FsaG9zdDo4MCdcbiwgcHJvdG9jb2w6ICdodHRwJ1xuLCBob3N0OiAnbG9jYWxob3N0J1xuLCBwb3J0OiA4MFxuLCBocmVmOiAnaHR0cDovL2xvY2FsaG9zdC8nXG4sIGhhc2g6ICcnXG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vc2hpbXMnKTtcblxudmFyIFVSTCA9IHJlcXVpcmUoJ3VybC1wYXJzZScpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi91dGlscy9yYW5kb20nKVxuICAsIGVzY2FwZSA9IHJlcXVpcmUoJy4vdXRpbHMvZXNjYXBlJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgdHJhbnNwb3J0ID0gcmVxdWlyZSgnLi91dGlscy90cmFuc3BvcnQnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3QnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuL3V0aWxzL2Jyb3dzZXInKVxuICAsIGxvZyA9IHJlcXVpcmUoJy4vdXRpbHMvbG9nJylcbiAgLCBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvZXZlbnQnKVxuICAsIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9ldmVudC9ldmVudHRhcmdldCcpXG4gICwgbG9jID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpXG4gICwgQ2xvc2VFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvY2xvc2UnKVxuICAsIFRyYW5zcG9ydE1lc3NhZ2VFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvdHJhbnMtbWVzc2FnZScpXG4gICwgSW5mb1JlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50Om1haW4nKTtcbn1cblxudmFyIHRyYW5zcG9ydHM7XG5cbi8vIGZvbGxvdyBjb25zdHJ1Y3RvciBzdGVwcyBkZWZpbmVkIGF0IGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnNvY2tldHMvI3RoZS13ZWJzb2NrZXQtaW50ZXJmYWNlXG5mdW5jdGlvbiBTb2NrSlModXJsLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tKUykpIHtcbiAgICByZXR1cm4gbmV3IFNvY2tKUyh1cmwsIHByb3RvY29scywgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1NvY2tKUzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50XCIpO1xuICB9XG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLkNPTk5FQ1RJTkc7XG4gIHRoaXMuZXh0ZW5zaW9ucyA9ICcnO1xuICB0aGlzLnByb3RvY29sID0gJyc7XG5cbiAgLy8gbm9uLXN0YW5kYXJkIGV4dGVuc2lvblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKG9wdGlvbnMucHJvdG9jb2xzX3doaXRlbGlzdCkge1xuICAgIGxvZy53YXJuKFwiJ3Byb3RvY29sc193aGl0ZWxpc3QnIGlzIERFUFJFQ0FURUQuIFVzZSAndHJhbnNwb3J0cycgaW5zdGVhZC5cIik7XG4gIH1cbiAgdGhpcy5fdHJhbnNwb3J0c1doaXRlbGlzdCA9IG9wdGlvbnMudHJhbnNwb3J0cztcbiAgdGhpcy5fdHJhbnNwb3J0T3B0aW9ucyA9IG9wdGlvbnMudHJhbnNwb3J0T3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc2Vzc2lvbklkID0gb3B0aW9ucy5zZXNzaW9uSWQgfHwgODtcbiAgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAnbnVtYmVyJykge1xuICAgIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmFuZG9tLnN0cmluZyhzZXNzaW9uSWQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWYgc2Vzc2lvbklkIGlzIHVzZWQgaW4gdGhlIG9wdGlvbnMsIGl0IG5lZWRzIHRvIGJlIGEgbnVtYmVyIG9yIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB0aGlzLl9zZXJ2ZXIgPSBvcHRpb25zLnNlcnZlciB8fCByYW5kb20ubnVtYmVyU3RyaW5nKDEwMDApO1xuXG4gIC8vIFN0ZXAgMSBvZiBXUyBzcGVjIC0gcGFyc2UgYW5kIHZhbGlkYXRlIHRoZSB1cmwuIElzc3VlICM4XG4gIHZhciBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybCk7XG4gIGlmICghcGFyc2VkVXJsLmhvc3QgfHwgIXBhcnNlZFVybC5wcm90b2NvbCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBVUkwgJ1wiICsgdXJsICsgXCInIGlzIGludmFsaWRcIik7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RoZSBVUkwgbXVzdCBub3QgY29udGFpbiBhIGZyYWdtZW50Jyk7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSAnaHR0cDonICYmIHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMJ3Mgc2NoZW1lIG11c3QgYmUgZWl0aGVyICdodHRwOicgb3IgJ2h0dHBzOicuICdcIiArIHBhcnNlZFVybC5wcm90b2NvbCArIFwiJyBpcyBub3QgYWxsb3dlZC5cIik7XG4gIH1cblxuICB2YXIgc2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgLy8gU3RlcCAyIC0gZG9uJ3QgYWxsb3cgc2VjdXJlIG9yaWdpbiB3aXRoIGFuIGluc2VjdXJlIHByb3RvY29sXG4gIGlmIChsb2MucHJvdG9jb2wgPT09ICdodHRwcycgJiYgIXNlY3VyZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2VjdXJpdHlFcnJvcjogQW4gaW5zZWN1cmUgU29ja0pTIGNvbm5lY3Rpb24gbWF5IG5vdCBiZSBpbml0aWF0ZWQgZnJvbSBhIHBhZ2UgbG9hZGVkIG92ZXIgSFRUUFMnKTtcbiAgfVxuXG4gIC8vIFN0ZXAgMyAtIGNoZWNrIHBvcnQgYWNjZXNzIC0gbm8gbmVlZCBoZXJlXG4gIC8vIFN0ZXAgNCAtIHBhcnNlIHByb3RvY29scyBhcmd1bWVudFxuICBpZiAoIXByb3RvY29scykge1xuICAgIHByb3RvY29scyA9IFtdO1xuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHByb3RvY29scykpIHtcbiAgICBwcm90b2NvbHMgPSBbcHJvdG9jb2xzXTtcbiAgfVxuXG4gIC8vIFN0ZXAgNSAtIGNoZWNrIHByb3RvY29scyBhcmd1bWVudFxuICB2YXIgc29ydGVkUHJvdG9jb2xzID0gcHJvdG9jb2xzLnNvcnQoKTtcbiAgc29ydGVkUHJvdG9jb2xzLmZvckVhY2goZnVuY3Rpb24ocHJvdG8sIGkpIHtcbiAgICBpZiAoIXByb3RvKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgcHJvdG9jb2xzIGVudHJ5ICdcIiArIHByb3RvICsgXCInIGlzIGludmFsaWQuXCIpO1xuICAgIH1cbiAgICBpZiAoaSA8IChzb3J0ZWRQcm90b2NvbHMubGVuZ3RoIC0gMSkgJiYgcHJvdG8gPT09IHNvcnRlZFByb3RvY29sc1tpICsgMV0pIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBwcm90b2NvbHMgZW50cnkgJ1wiICsgcHJvdG8gKyBcIicgaXMgZHVwbGljYXRlZC5cIik7XG4gICAgfVxuICB9KTtcblxuICAvLyBTdGVwIDYgLSBjb252ZXJ0IG9yaWdpblxuICB2YXIgbyA9IHVybFV0aWxzLmdldE9yaWdpbihsb2MuaHJlZik7XG4gIHRoaXMuX29yaWdpbiA9IG8gPyBvLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuXG4gIC8vIHJlbW92ZSB0aGUgdHJhaWxpbmcgc2xhc2hcbiAgcGFyc2VkVXJsLnNldCgncGF0aG5hbWUnLCBwYXJzZWRVcmwucGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCAnJykpO1xuXG4gIC8vIHN0b3JlIHRoZSBzYW5pdGl6ZWQgdXJsXG4gIHRoaXMudXJsID0gcGFyc2VkVXJsLmhyZWY7XG4gIGRlYnVnKCd1c2luZyB1cmwnLCB0aGlzLnVybCk7XG5cbiAgLy8gU3RlcCA3IC0gc3RhcnQgY29ubmVjdGlvbiBpbiBiYWNrZ3JvdW5kXG4gIC8vIG9idGFpbiBzZXJ2ZXIgaW5mb1xuICAvLyBodHRwOi8vc29ja2pzLmdpdGh1Yi5pby9zb2NranMtcHJvdG9jb2wvc29ja2pzLXByb3RvY29sLTAuMy4zLmh0bWwjc2VjdGlvbi0yNlxuICB0aGlzLl91cmxJbmZvID0ge1xuICAgIG51bGxPcmlnaW46ICFicm93c2VyLmhhc0RvbWFpbigpXG4gICwgc2FtZU9yaWdpbjogdXJsVXRpbHMuaXNPcmlnaW5FcXVhbCh0aGlzLnVybCwgbG9jLmhyZWYpXG4gICwgc2FtZVNjaGVtZTogdXJsVXRpbHMuaXNTY2hlbWVFcXVhbCh0aGlzLnVybCwgbG9jLmhyZWYpXG4gIH07XG5cbiAgdGhpcy5faXIgPSBuZXcgSW5mb1JlY2VpdmVyKHRoaXMudXJsLCB0aGlzLl91cmxJbmZvKTtcbiAgdGhpcy5faXIub25jZSgnZmluaXNoJywgdGhpcy5fcmVjZWl2ZUluZm8uYmluZCh0aGlzKSk7XG59XG5cbmluaGVyaXRzKFNvY2tKUywgRXZlbnRUYXJnZXQpO1xuXG5mdW5jdGlvbiB1c2VyU2V0Q29kZShjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSAxMDAwIHx8IChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KTtcbn1cblxuU29ja0pTLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAvLyBTdGVwIDFcbiAgaWYgKGNvZGUgJiYgIXVzZXJTZXRDb2RlKGNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkQWNjZXNzRXJyb3I6IEludmFsaWQgY29kZScpO1xuICB9XG4gIC8vIFN0ZXAgMi40IHN0YXRlcyB0aGUgbWF4IGlzIDEyMyBieXRlcywgYnV0IHdlIGFyZSBqdXN0IGNoZWNraW5nIGxlbmd0aFxuICBpZiAocmVhc29uICYmIHJlYXNvbi5sZW5ndGggPiAxMjMpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ3JlYXNvbiBhcmd1bWVudCBoYXMgYW4gaW52YWxpZCBsZW5ndGgnKTtcbiAgfVxuXG4gIC8vIFN0ZXAgMy4xXG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TSU5HIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NFRCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE8gbG9vayBhdCBkb2NzIHRvIGRldGVybWluZSBob3cgdG8gc2V0IHRoaXNcbiAgdmFyIHdhc0NsZWFuID0gdHJ1ZTtcbiAgdGhpcy5fY2xvc2UoY29kZSB8fCAxMDAwLCByZWFzb24gfHwgJ05vcm1hbCBjbG9zdXJlJywgd2FzQ2xlYW4pO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICAvLyAjMTMgLSBjb252ZXJ0IGFueXRoaW5nIG5vbi1zdHJpbmcgdG8gc3RyaW5nXG4gIC8vIFRPRE8gdGhpcyBjdXJyZW50bHkgdHVybnMgb2JqZWN0cyBpbnRvIFtvYmplY3QgT2JqZWN0XVxuICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgfVxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZFN0YXRlRXJyb3I6IFRoZSBjb25uZWN0aW9uIGhhcyBub3QgYmVlbiBlc3RhYmxpc2hlZCB5ZXQnKTtcbiAgfVxuICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBTb2NrSlMuT1BFTikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl90cmFuc3BvcnQuc2VuZChlc2NhcGUucXVvdGUoZGF0YSkpO1xufTtcblxuU29ja0pTLnZlcnNpb24gPSByZXF1aXJlKCcuL3ZlcnNpb24nKTtcblxuU29ja0pTLkNPTk5FQ1RJTkcgPSAwO1xuU29ja0pTLk9QRU4gPSAxO1xuU29ja0pTLkNMT1NJTkcgPSAyO1xuU29ja0pTLkNMT1NFRCA9IDM7XG5cblNvY2tKUy5wcm90b3R5cGUuX3JlY2VpdmVJbmZvID0gZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gIGRlYnVnKCdfcmVjZWl2ZUluZm8nLCBydHQpO1xuICB0aGlzLl9pciA9IG51bGw7XG4gIGlmICghaW5mbykge1xuICAgIHRoaXMuX2Nsb3NlKDEwMDIsICdDYW5ub3QgY29ubmVjdCB0byBzZXJ2ZXInKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBlc3RhYmxpc2ggYSByb3VuZC10cmlwIHRpbWVvdXQgKFJUTykgYmFzZWQgb24gdGhlXG4gIC8vIHJvdW5kLXRyaXAgdGltZSAoUlRUKVxuICB0aGlzLl9ydG8gPSB0aGlzLmNvdW50UlRPKHJ0dCk7XG4gIC8vIGFsbG93IHNlcnZlciB0byBvdmVycmlkZSB1cmwgdXNlZCBmb3IgdGhlIGFjdHVhbCB0cmFuc3BvcnRcbiAgdGhpcy5fdHJhbnNVcmwgPSBpbmZvLmJhc2VfdXJsID8gaW5mby5iYXNlX3VybCA6IHRoaXMudXJsO1xuICBpbmZvID0gb2JqZWN0VXRpbHMuZXh0ZW5kKGluZm8sIHRoaXMuX3VybEluZm8pO1xuICBkZWJ1ZygnaW5mbycsIGluZm8pO1xuICAvLyBkZXRlcm1pbmUgbGlzdCBvZiBkZXNpcmVkIGFuZCBzdXBwb3J0ZWQgdHJhbnNwb3J0c1xuICB2YXIgZW5hYmxlZFRyYW5zcG9ydHMgPSB0cmFuc3BvcnRzLmZpbHRlclRvRW5hYmxlZCh0aGlzLl90cmFuc3BvcnRzV2hpdGVsaXN0LCBpbmZvKTtcbiAgdGhpcy5fdHJhbnNwb3J0cyA9IGVuYWJsZWRUcmFuc3BvcnRzLm1haW47XG4gIGRlYnVnKHRoaXMuX3RyYW5zcG9ydHMubGVuZ3RoICsgJyBlbmFibGVkIHRyYW5zcG9ydHMnKTtcblxuICB0aGlzLl9jb25uZWN0KCk7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIFRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydHMuc2hpZnQoKTsgVHJhbnNwb3J0OyBUcmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnRzLnNoaWZ0KCkpIHtcbiAgICBkZWJ1ZygnYXR0ZW1wdCcsIFRyYW5zcG9ydC50cmFuc3BvcnROYW1lKTtcbiAgICBpZiAoVHJhbnNwb3J0Lm5lZWRCb2R5KSB7XG4gICAgICBpZiAoIWdsb2JhbC5kb2N1bWVudC5ib2R5IHx8XG4gICAgICAgICAgKHR5cGVvZiBnbG9iYWwuZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnY29tcGxldGUnICYmXG4gICAgICAgICAgICBnbG9iYWwuZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2ludGVyYWN0aXZlJykpIHtcbiAgICAgICAgZGVidWcoJ3dhaXRpbmcgZm9yIGJvZHknKTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0cy51bnNoaWZ0KFRyYW5zcG9ydCk7XG4gICAgICAgIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ2xvYWQnLCB0aGlzLl9jb25uZWN0LmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHRpbWVvdXQgYmFzZWQgb24gUlRPIGFuZCByb3VuZCB0cmlwcy4gRGVmYXVsdCB0byA1c1xuICAgIHZhciB0aW1lb3V0TXMgPSAodGhpcy5fcnRvICogVHJhbnNwb3J0LnJvdW5kVHJpcHMpIHx8IDUwMDA7XG4gICAgdGhpcy5fdHJhbnNwb3J0VGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl90cmFuc3BvcnRUaW1lb3V0LmJpbmQodGhpcyksIHRpbWVvdXRNcyk7XG4gICAgZGVidWcoJ3VzaW5nIHRpbWVvdXQnLCB0aW1lb3V0TXMpO1xuXG4gICAgdmFyIHRyYW5zcG9ydFVybCA9IHVybFV0aWxzLmFkZFBhdGgodGhpcy5fdHJhbnNVcmwsICcvJyArIHRoaXMuX3NlcnZlciArICcvJyArIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkKCkpO1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5fdHJhbnNwb3J0T3B0aW9uc1tUcmFuc3BvcnQudHJhbnNwb3J0TmFtZV07XG4gICAgZGVidWcoJ3RyYW5zcG9ydCB1cmwnLCB0cmFuc3BvcnRVcmwpO1xuICAgIHZhciB0cmFuc3BvcnRPYmogPSBuZXcgVHJhbnNwb3J0KHRyYW5zcG9ydFVybCwgdGhpcy5fdHJhbnNVcmwsIG9wdGlvbnMpO1xuICAgIHRyYW5zcG9ydE9iai5vbignbWVzc2FnZScsIHRoaXMuX3RyYW5zcG9ydE1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gICAgdHJhbnNwb3J0T2JqLm9uY2UoJ2Nsb3NlJywgdGhpcy5fdHJhbnNwb3J0Q2xvc2UuYmluZCh0aGlzKSk7XG4gICAgdHJhbnNwb3J0T2JqLnRyYW5zcG9ydE5hbWUgPSBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnRPYmo7XG5cbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fY2xvc2UoMjAwMCwgJ0FsbCB0cmFuc3BvcnRzIGZhaWxlZCcsIGZhbHNlKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ190cmFuc3BvcnRUaW1lb3V0Jyk7XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0Q2xvc2UoMjAwNywgJ1RyYW5zcG9ydCB0aW1lZCBvdXQnKTtcbiAgfVxufTtcblxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0TWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuICBkZWJ1ZygnX3RyYW5zcG9ydE1lc3NhZ2UnLCBtc2cpO1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIHR5cGUgPSBtc2cuc2xpY2UoMCwgMSlcbiAgICAsIGNvbnRlbnQgPSBtc2cuc2xpY2UoMSlcbiAgICAsIHBheWxvYWRcbiAgICA7XG5cbiAgLy8gZmlyc3QgY2hlY2sgZm9yIG1lc3NhZ2VzIHRoYXQgZG9uJ3QgbmVlZCBhIHBheWxvYWRcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnbyc6XG4gICAgICB0aGlzLl9vcGVuKCk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAnaCc6XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdoZWFydGJlYXQnKSk7XG4gICAgICBkZWJ1ZygnaGVhcnRiZWF0JywgdGhpcy50cmFuc3BvcnQpO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICB0cnkge1xuICAgICAgcGF5bG9hZCA9IEpTT04zLnBhcnNlKGNvbnRlbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKCdiYWQganNvbicsIGNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBkZWJ1ZygnZW1wdHkgcGF5bG9hZCcsIGNvbnRlbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2EnOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHtcbiAgICAgICAgcGF5bG9hZC5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICBkZWJ1ZygnbWVzc2FnZScsIHNlbGYudHJhbnNwb3J0LCBwKTtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQobmV3IFRyYW5zcG9ydE1lc3NhZ2VFdmVudChwKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbSc6XG4gICAgICBkZWJ1ZygnbWVzc2FnZScsIHRoaXMudHJhbnNwb3J0LCBwYXlsb2FkKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgVHJhbnNwb3J0TWVzc2FnZUV2ZW50KHBheWxvYWQpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2MnOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkgJiYgcGF5bG9hZC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdGhpcy5fY2xvc2UocGF5bG9hZFswXSwgcGF5bG9hZFsxXSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0Q2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgZGVidWcoJ190cmFuc3BvcnRDbG9zZScsIHRoaXMudHJhbnNwb3J0LCBjb2RlLCByZWFzb24pO1xuICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgaWYgKCF1c2VyU2V0Q29kZShjb2RlKSAmJiBjb2RlICE9PSAyMDAwICYmIHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICB0aGlzLl9jb25uZWN0KCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fY2xvc2UoY29kZSwgcmVhc29uKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX29wZW4gPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19vcGVuJywgdGhpcy5fdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCk7XG4gICAgICB0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuT1BFTjtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ29wZW4nKSk7XG4gICAgZGVidWcoJ2Nvbm5lY3RlZCcsIHRoaXMudHJhbnNwb3J0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGUgc2VydmVyIG1pZ2h0IGhhdmUgYmVlbiByZXN0YXJ0ZWQsIGFuZCBsb3N0IHRyYWNrIG9mIG91clxuICAgIC8vIGNvbm5lY3Rpb24uXG4gICAgdGhpcy5fY2xvc2UoMTAwNiwgJ1NlcnZlciBsb3N0IHNlc3Npb24nKTtcbiAgfVxufTtcblxuU29ja0pTLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24sIHdhc0NsZWFuKSB7XG4gIGRlYnVnKCdfY2xvc2UnLCB0aGlzLnRyYW5zcG9ydCwgY29kZSwgcmVhc29uLCB3YXNDbGVhbiwgdGhpcy5yZWFkeVN0YXRlKTtcbiAgdmFyIGZvcmNlRmFpbCA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLl9pcikge1xuICAgIGZvcmNlRmFpbCA9IHRydWU7XG4gICAgdGhpcy5faXIuY2xvc2UoKTtcbiAgICB0aGlzLl9pciA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NFRCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZFN0YXRlRXJyb3I6IFNvY2tKUyBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCcpO1xuICB9XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLkNMT1NJTkc7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLkNMT1NFRDtcblxuICAgIGlmIChmb3JjZUZhaWwpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Vycm9yJykpO1xuICAgIH1cblxuICAgIHZhciBlID0gbmV3IENsb3NlRXZlbnQoJ2Nsb3NlJyk7XG4gICAgZS53YXNDbGVhbiA9IHdhc0NsZWFuIHx8IGZhbHNlO1xuICAgIGUuY29kZSA9IGNvZGUgfHwgMTAwMDtcbiAgICBlLnJlYXNvbiA9IHJlYXNvbjtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlKTtcbiAgICB0aGlzLm9ubWVzc2FnZSA9IHRoaXMub25jbG9zZSA9IHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgZGVidWcoJ2Rpc2Nvbm5lY3RlZCcpO1xuICB9LmJpbmQodGhpcyksIDApO1xufTtcblxuLy8gU2VlOiBodHRwOi8vd3d3LmVyZy5hYmRuLmFjLnVrL35nZXJyaXQvZGNjcC9ub3Rlcy9jY2lkMi9ydG9fZXN0aW1hdG9yL1xuLy8gYW5kIFJGQyAyOTg4LlxuU29ja0pTLnByb3RvdHlwZS5jb3VudFJUTyA9IGZ1bmN0aW9uKHJ0dCkge1xuICAvLyBJbiBhIGxvY2FsIGVudmlyb25tZW50LCB3aGVuIHVzaW5nIElFOC85IGFuZCB0aGUgYGpzb25wLXBvbGxpbmdgXG4gIC8vIHRyYW5zcG9ydCB0aGUgdGltZSBuZWVkZWQgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiAodGhlIHRpbWUgdGhhdCBwYXNzXG4gIC8vIGZyb20gdGhlIG9wZW5pbmcgb2YgdGhlIHRyYW5zcG9ydCB0byB0aGUgY2FsbCBvZiBgX2Rpc3BhdGNoT3BlbmApIGlzXG4gIC8vIGFyb3VuZCAyMDBtc2VjICh0aGUgbG93ZXIgYm91bmQgdXNlZCBpbiB0aGUgYXJ0aWNsZSBhYm92ZSkgYW5kIHRoaXNcbiAgLy8gY2F1c2VzIHNwdXJpb3VzIHRpbWVvdXRzLiBGb3IgdGhpcyByZWFzb24gd2UgY2FsY3VsYXRlIGEgdmFsdWUgc2xpZ2h0bHlcbiAgLy8gbGFyZ2VyIHRoYW4gdGhhdCB1c2VkIGluIHRoZSBhcnRpY2xlLlxuICBpZiAocnR0ID4gMTAwKSB7XG4gICAgcmV0dXJuIDQgKiBydHQ7IC8vIHJ0byA+IDQwMG1zZWNcbiAgfVxuICByZXR1cm4gMzAwICsgcnR0OyAvLyAzMDBtc2VjIDwgcnRvIDw9IDQwMG1zZWNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICB0cmFuc3BvcnRzID0gdHJhbnNwb3J0KGF2YWlsYWJsZVRyYW5zcG9ydHMpO1xuICByZXF1aXJlKCcuL2lmcmFtZS1ib290c3RyYXAnKShTb2NrSlMsIGF2YWlsYWJsZVRyYW5zcG9ydHMpO1xuICByZXR1cm4gU29ja0pTO1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9ldmVudC9jbG9zZVwiOjIsXCIuL2V2ZW50L2V2ZW50XCI6NCxcIi4vZXZlbnQvZXZlbnR0YXJnZXRcIjo1LFwiLi9ldmVudC90cmFucy1tZXNzYWdlXCI6NixcIi4vaWZyYW1lLWJvb3RzdHJhcFwiOjgsXCIuL2luZm8tcmVjZWl2ZXJcIjoxMixcIi4vbG9jYXRpb25cIjoxMyxcIi4vc2hpbXNcIjoxNSxcIi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi91dGlscy9lc2NhcGVcIjo0NSxcIi4vdXRpbHMvZXZlbnRcIjo0NixcIi4vdXRpbHMvbG9nXCI6NDgsXCIuL3V0aWxzL29iamVjdFwiOjQ5LFwiLi91dGlscy9yYW5kb21cIjo1MCxcIi4vdXRpbHMvdHJhbnNwb3J0XCI6NTEsXCIuL3V0aWxzL3VybFwiOjUyLFwiLi92ZXJzaW9uXCI6NTMsXCJkZWJ1Z1wiOjU1LFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTgsXCJ1cmwtcGFyc2VcIjo2MX1dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIGVzbGludC1kaXNhYmxlICovXG4vKiBqc2NzOiBkaXNhYmxlICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIHB1bGxlZCBzcGVjaWZpYyBzaGltcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuXG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBTdHJpbmdQcm90b3R5cGUgPSBTdHJpbmcucHJvdG90eXBlO1xudmFyIGFycmF5X3NsaWNlID0gQXJyYXlQcm90b3R5cGUuc2xpY2U7XG5cbnZhciBfdG9TdHJpbmcgPSBPYmplY3RQcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG52YXIgaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xudmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxudmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4Jywge30pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7IC8qIHRoaXMgaXMgRVMzICovXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59KCkpO1xuXG4vLyBEZWZpbmUgY29uZmlndXJhYmxlLCB3cml0YWJsZSBhbmQgbm9uLWVudW1lcmFibGUgcHJvcHNcbi8vIGlmIHRoZXkgZG9uJ3QgZXhpc3QuXG52YXIgZGVmaW5lUHJvcGVydHk7XG5pZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgbWV0aG9kLCBmb3JjZUFzc2lnbikge1xuICAgICAgICBpZiAoIWZvcmNlQXNzaWduICYmIChuYW1lIGluIG9iamVjdCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbWV0aG9kXG4gICAgICAgIH0pO1xuICAgIH07XG59IGVsc2Uge1xuICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgbWV0aG9kLCBmb3JjZUFzc2lnbikge1xuICAgICAgICBpZiAoIWZvcmNlQXNzaWduICYmIChuYW1lIGluIG9iamVjdCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIG9iamVjdFtuYW1lXSA9IG1ldGhvZDtcbiAgICB9O1xufVxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqZWN0LCBtYXAsIGZvcmNlQXNzaWduKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBtYXApIHtcbiAgICAgICAgaWYgKE9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwgbmFtZSkpIHtcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIG1hcFtuYW1lXSwgZm9yY2VBc3NpZ24pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIHRvT2JqZWN0ID0gZnVuY3Rpb24gKG8pIHtcbiAgICBpZiAobyA9PSBudWxsKSB7IC8vIHRoaXMgbWF0Y2hlcyBib3RoIG51bGwgYW5kIHVuZGVmaW5lZFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FuJ3QgY29udmVydCBcIiArIG8gKyAnIHRvIG9iamVjdCcpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0KG8pO1xufTtcblxuLy9cbi8vIFV0aWxcbi8vID09PT09PVxuLy9cblxuLy8gRVM1IDkuNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS40XG4vLyBodHRwOi8vanNwZXJmLmNvbS90by1pbnRlZ2VyXG5cbmZ1bmN0aW9uIHRvSW50ZWdlcihudW0pIHtcbiAgICB2YXIgbiA9ICtudW07XG4gICAgaWYgKG4gIT09IG4pIHsgLy8gaXNOYU5cbiAgICAgICAgbiA9IDA7XG4gICAgfSBlbHNlIGlmIChuICE9PSAwICYmIG4gIT09ICgxIC8gMCkgJiYgbiAhPT0gLSgxIC8gMCkpIHtcbiAgICAgICAgbiA9IChuID4gMCB8fCAtMSkgKiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIFRvVWludDMyKHgpIHtcbiAgICByZXR1cm4geCA+Pj4gMDtcbn1cblxuLy9cbi8vIEZ1bmN0aW9uXG4vLyA9PT09PT09PVxuLy9cblxuLy8gRVMtNSAxNS4zLjQuNVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMy40LjVcblxuZnVuY3Rpb24gRW1wdHkoKSB7fVxuXG5kZWZpbmVQcm9wZXJ0aWVzKEZ1bmN0aW9uUHJvdG90eXBlLCB7XG4gICAgYmluZDogZnVuY3Rpb24gYmluZCh0aGF0KSB7IC8vIC5sZW5ndGggaXMgMVxuICAgICAgICAvLyAxLiBMZXQgVGFyZ2V0IGJlIHRoZSB0aGlzIHZhbHVlLlxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgLy8gMi4gSWYgSXNDYWxsYWJsZShUYXJnZXQpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgIGlmICghaXNGdW5jdGlvbih0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICcgKyB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuIExldCBBIGJlIGEgbmV3IChwb3NzaWJseSBlbXB0eSkgaW50ZXJuYWwgbGlzdCBvZiBhbGwgb2YgdGhlXG4gICAgICAgIC8vICAgYXJndW1lbnQgdmFsdWVzIHByb3ZpZGVkIGFmdGVyIHRoaXNBcmcgKGFyZzEsIGFyZzIgZXRjKSwgaW4gb3JkZXIuXG4gICAgICAgIC8vIFhYWCBzbGljZWRBcmdzIHdpbGwgc3RhbmQgaW4gZm9yIFwiQVwiIGlmIHVzZWRcbiAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vIGZvciBub3JtYWwgY2FsbFxuICAgICAgICAvLyA0LiBMZXQgRiBiZSBhIG5ldyBuYXRpdmUgRUNNQVNjcmlwdCBvYmplY3QuXG4gICAgICAgIC8vIDExLiBTZXQgdGhlIFtbUHJvdG90eXBlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0aGUgc3RhbmRhcmRcbiAgICAgICAgLy8gICBidWlsdC1pbiBGdW5jdGlvbiBwcm90b3R5cGUgb2JqZWN0IGFzIHNwZWNpZmllZCBpbiAxNS4zLjMuMS5cbiAgICAgICAgLy8gMTIuIFNldCB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4xLlxuICAgICAgICAvLyAxMy4gU2V0IHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMi5cbiAgICAgICAgLy8gMTQuIFNldCB0aGUgW1tIYXNJbnN0YW5jZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMy5cbiAgICAgICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjIgW1tDb25zdHJ1Y3RdXVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LFxuICAgICAgICAgICAgICAgIC8vIEYgdGhhdCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAvLyAxLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dXG4gICAgICAgICAgICAgICAgLy8gICBpbnRlcm5hbCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAyLiBJZiB0YXJnZXQgaGFzIG5vIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kLCBhXG4gICAgICAgICAgICAgICAgLy8gICBUeXBlRXJyb3IgZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIG1ldGhvZCBvZiB0YXJnZXQgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjEgW1tDYWxsXV1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsIEYsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgdmFsdWUgYW5kIGEgbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgLy8gc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAyLiBMZXQgYm91bmRUaGlzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZFRoaXNdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMy4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vICAgb2YgdGFyZ2V0IHByb3ZpZGluZyBib3VuZFRoaXMgYXMgdGhlIHRoaXMgdmFsdWUgYW5kXG4gICAgICAgICAgICAgICAgLy8gICBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgLy8gZXF1aXY6IHRhcmdldC5jYWxsKHRoaXMsIC4uLmJvdW5kQXJncywgLi4uYXJncylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gMTUuIElmIHRoZSBbW0NsYXNzXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgVGFyZ2V0IGlzIFwiRnVuY3Rpb25cIiwgdGhlblxuICAgICAgICAvLyAgICAgYS4gTGV0IEwgYmUgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBUYXJnZXQgbWludXMgdGhlIGxlbmd0aCBvZiBBLlxuICAgICAgICAvLyAgICAgYi4gU2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gZWl0aGVyIDAgb3IgTCwgd2hpY2hldmVyIGlzXG4gICAgICAgIC8vICAgICAgIGxhcmdlci5cbiAgICAgICAgLy8gMTYuIEVsc2Ugc2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gMC5cblxuICAgICAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuXG4gICAgICAgIC8vIDE3LiBTZXQgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byB0aGUgdmFsdWVzXG4gICAgICAgIC8vICAgc3BlY2lmaWVkIGluIDE1LjMuNS4xLlxuICAgICAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBYWFggQnVpbGQgYSBkeW5hbWljIGZ1bmN0aW9uIHdpdGggZGVzaXJlZCBhbW91bnQgb2YgYXJndW1lbnRzIGlzIHRoZSBvbmx5XG4gICAgICAgIC8vIHdheSB0byBzZXQgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBhIGZ1bmN0aW9uLlxuICAgICAgICAvLyBJbiBlbnZpcm9ubWVudHMgd2hlcmUgQ29udGVudCBTZWN1cml0eSBQb2xpY2llcyBlbmFibGVkIChDaHJvbWUgZXh0ZW5zaW9ucyxcbiAgICAgICAgLy8gZm9yIGV4LikgYWxsIHVzZSBvZiBldmFsIG9yIEZ1bmN0aW9uIGNvc3RydWN0b3IgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgLy8gSG93ZXZlciBpbiBhbGwgb2YgdGhlc2UgZW52aXJvbm1lbnRzIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGV4aXN0c1xuICAgICAgICAvLyBhbmQgc28gdGhpcyBjb2RlIHdpbGwgbmV2ZXIgYmUgZXhlY3V0ZWQuXG4gICAgICAgIHZhciBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBkYW5nbGluZyByZWZlcmVuY2VzLlxuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gMTguIFNldCB0aGUgW1tFeHRlbnNpYmxlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0cnVlLlxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gMTkuIExldCB0aHJvd2VyIGJlIHRoZSBbW1Rocm93VHlwZUVycm9yXV0gZnVuY3Rpb24gT2JqZWN0ICgxMy4yLjMpLlxuICAgICAgICAvLyAyMC4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgLy8gICBhcmd1bWVudHMgXCJjYWxsZXJcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLCBbW1NldF1dOlxuICAgICAgICAvLyAgIHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LCBhbmRcbiAgICAgICAgLy8gICBmYWxzZS5cbiAgICAgICAgLy8gMjEuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiYXJndW1lbnRzXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlcixcbiAgICAgICAgLy8gICBbW1NldF1dOiB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSxcbiAgICAgICAgLy8gICBhbmQgZmFsc2UuXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyBOT1RFIEZ1bmN0aW9uIG9iamVjdHMgY3JlYXRlZCB1c2luZyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBkbyBub3RcbiAgICAgICAgLy8gaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eSBvciB0aGUgW1tDb2RlXV0sIFtbRm9ybWFsUGFyYW1ldGVyc11dLCBhbmRcbiAgICAgICAgLy8gW1tTY29wZV1dIGludGVybmFsIHByb3BlcnRpZXMuXG4gICAgICAgIC8vIFhYWCBjYW4ndCBkZWxldGUgcHJvdG90eXBlIGluIHB1cmUtanMuXG5cbiAgICAgICAgLy8gMjIuIFJldHVybiBGLlxuICAgICAgICByZXR1cm4gYm91bmQ7XG4gICAgfVxufSk7XG5cbi8vXG4vLyBBcnJheVxuLy8gPT09PT1cbi8vXG5cbi8vIEVTNSAxNS40LjMuMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC4zLjJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXlcbmRlZmluZVByb3BlcnRpZXMoQXJyYXksIHsgaXNBcnJheTogaXNBcnJheSB9KTtcblxuXG52YXIgYm94ZWRTdHJpbmcgPSBPYmplY3QoJ2EnKTtcbnZhciBzcGxpdFN0cmluZyA9IGJveGVkU3RyaW5nWzBdICE9PSAnYScgfHwgISgwIGluIGJveGVkU3RyaW5nKTtcblxudmFyIHByb3Blcmx5Qm94ZXNDb250ZXh0ID0gZnVuY3Rpb24gcHJvcGVybHlCb3hlZChtZXRob2QpIHtcbiAgICAvLyBDaGVjayBub2RlIDAuNi4yMSBidWcgd2hlcmUgdGhpcmQgcGFyYW1ldGVyIGlzIG5vdCBib3hlZFxuICAgIHZhciBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gdHJ1ZTtcbiAgICB2YXIgcHJvcGVybHlCb3hlc1N0cmljdCA9IHRydWU7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgICBtZXRob2QuY2FsbCgnZm9vJywgZnVuY3Rpb24gKF8sIF9fLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdvYmplY3QnKSB7IHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSBmYWxzZTsgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtZXRob2QuY2FsbChbMV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgICAgIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0eXBlb2YgdGhpcyA9PT0gJ3N0cmluZyc7XG4gICAgICAgIH0sICd4Jyk7XG4gICAgfVxuICAgIHJldHVybiAhIW1ldGhvZCAmJiBwcm9wZXJseUJveGVzTm9uU3RyaWN0ICYmIHByb3Blcmx5Qm94ZXNTdHJpY3Q7XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmdW4gLyosIHRoaXNwKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gdGhpcy5zcGxpdCgnJykgOiBvYmplY3QsXG4gICAgICAgICAgICB0aGlzcCA9IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgIGlmICghaXNGdW5jdGlvbihmdW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7IC8vIFRPRE8gbWVzc2FnZVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgIC8vIEludm9rZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBjYWxsLCBwYXNzaW5nIGFyZ3VtZW50czpcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0LCBwcm9wZXJ0eSB2YWx1ZSwgcHJvcGVydHkga2V5LCB0aGlzQXJnIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHRcbiAgICAgICAgICAgICAgICBmdW4uY2FsbCh0aGlzcCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5mb3JFYWNoKSk7XG5cbi8vIEVTNSAxNS40LjQuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xNFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZlxudmFyIGhhc0ZpcmVmb3gySW5kZXhPZkJ1ZyA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mICYmIFswLCAxXS5pbmRleE9mKDEsIDIpICE9PSAtMTtcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNvdWdodCAvKiwgZnJvbUluZGV4ICovICkge1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gdGhpcy5zcGxpdCgnJykgOiB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaSA9IHRvSW50ZWdlcihhcmd1bWVudHNbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIG5lZ2F0aXZlIGluZGljZXNcbiAgICAgICAgaSA9IGkgPj0gMCA/IGkgOiBNYXRoLm1heCgwLCBsZW5ndGggKyBpKTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiBzZWxmW2ldID09PSBzb3VnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufSwgaGFzRmlyZWZveDJJbmRleE9mQnVnKTtcblxuLy9cbi8vIFN0cmluZ1xuLy8gPT09PT09XG4vL1xuXG4vLyBFUzUgMTUuNS40LjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS41LjQuMTRcblxuLy8gW2J1Z2ZpeCwgSUUgbHQgOSwgZmlyZWZveCA0LCBLb25xdWVyb3IsIE9wZXJhLCBvYnNjdXJlIGJyb3dzZXJzXVxuLy8gTWFueSBicm93c2VycyBkbyBub3Qgc3BsaXQgcHJvcGVybHkgd2l0aCByZWd1bGFyIGV4cHJlc3Npb25zIG9yIHRoZXlcbi8vIGRvIG5vdCBwZXJmb3JtIHRoZSBzcGxpdCBjb3JyZWN0bHkgdW5kZXIgb2JzY3VyZSBjb25kaXRpb25zLlxuLy8gU2VlIGh0dHA6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy9jcm9zcy1icm93c2VyLXNwbGl0XG4vLyBJJ3ZlIHRlc3RlZCBpbiBtYW55IGJyb3dzZXJzIGFuZCB0aGlzIHNlZW1zIHRvIGNvdmVyIHRoZSBkZXZpYW50IG9uZXM6XG4vLyAgICAnYWInLnNwbGl0KC8oPzphYikqLykgc2hvdWxkIGJlIFtcIlwiLCBcIlwiXSwgbm90IFtcIlwiXVxuLy8gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pIHNob3VsZCBiZSBbXCJcIiwgXCIuXCIsIFwiXCIsIFwiXCJdLCBub3QgW1wiXCIsIFwiXCJdXG4vLyAgICAndGVzc3QnLnNwbGl0KC8ocykqLykgc2hvdWxkIGJlIFtcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgXCJzXCIsIFwidFwiXSwgbm90XG4vLyAgICAgICBbdW5kZWZpbmVkLCBcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgLi4uXVxuLy8gICAgJycuc3BsaXQoLy4/Lykgc2hvdWxkIGJlIFtdLCBub3QgW1wiXCJdXG4vLyAgICAnLicuc3BsaXQoLygpKCkvKSBzaG91bGQgYmUgW1wiLlwiXSwgbm90IFtcIlwiLCBcIlwiLCBcIi5cIl1cblxudmFyIHN0cmluZ19zcGxpdCA9IFN0cmluZ1Byb3RvdHlwZS5zcGxpdDtcbmlmIChcbiAgICAnYWInLnNwbGl0KC8oPzphYikqLykubGVuZ3RoICE9PSAyIHx8XG4gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pLmxlbmd0aCAhPT0gNCB8fFxuICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKVsxXSA9PT0gJ3QnIHx8XG4gICAgJ3Rlc3QnLnNwbGl0KC8oPzopLywgLTEpLmxlbmd0aCAhPT0gNCB8fFxuICAgICcnLnNwbGl0KC8uPy8pLmxlbmd0aCB8fFxuICAgICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDFcbikge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb21wbGlhbnRFeGVjTnBjZyA9IC8oKT8/Ly5leGVjKCcnKVsxXSA9PT0gdm9pZCAwOyAvLyBOUENHOiBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuXG4gICAgICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgICAgICB2YXIgc3RyaW5nID0gdGhpcztcbiAgICAgICAgICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCAmJiBsaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgICAgICAgIGlmIChfdG9TdHJpbmcuY2FsbChzZXBhcmF0b3IpICE9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgICAgICAgICAgIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lICA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLmV4dGVuZGVkICAgPyAneCcgOiAnJykgKyAvLyBQcm9wb3NlZCBmb3IgRVM2XG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSAgICAgPyAneScgOiAnJyksIC8vIEZpcmVmb3ggMytcbiAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgICAgICAgIHN0cmluZyArPSAnJzsgLy8gVHlwZS1jb252ZXJ0XG4gICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yLnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICAgICAgICAgKiBJZiB1bmRlZmluZWQ6IDQyOTQ5NjcyOTUgLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgICogSWYgMCwgSW5maW5pdHksIG9yIE5hTjogMFxuICAgICAgICAgICAgICogSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IE1hdGguZmxvb3IobGltaXQpOyBpZiAobGltaXQgPiA0Mjk0OTY3Mjk1KSBsaW1pdCAtPSA0Mjk0OTY3Mjk2O1xuICAgICAgICAgICAgICogSWYgbmVnYXRpdmUgbnVtYmVyOiA0Mjk0OTY3Mjk2IC0gTWF0aC5mbG9vcihNYXRoLmFicyhsaW1pdCkpXG4gICAgICAgICAgICAgKiBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGltaXQgPSBsaW1pdCA9PT0gdm9pZCAwID9cbiAgICAgICAgICAgICAgICAtMSA+Pj4gMCA6IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgICAgICAgICAgICBUb1VpbnQzMihsaW1pdCk7XG4gICAgICAgICAgICB3aGlsZSAobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgLy8gYHNlcGFyYXRvci5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICAgICAgICAgICAgICAgICAgICAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZyAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXlQcm90b3R5cGUucHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRvci5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvci50ZXN0KCcnKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW1pdCA/IG91dHB1dC5zbGljZSgwLCBsaW1pdCkgOiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfSgpKTtcblxuLy8gW2J1Z2ZpeCwgY2hyb21lXVxuLy8gSWYgc2VwYXJhdG9yIGlzIHVuZGVmaW5lZCwgdGhlbiB0aGUgcmVzdWx0IGFycmF5IGNvbnRhaW5zIGp1c3Qgb25lIFN0cmluZyxcbi8vIHdoaWNoIGlzIHRoZSB0aGlzIHZhbHVlIChjb252ZXJ0ZWQgdG8gYSBTdHJpbmcpLiBJZiBsaW1pdCBpcyBub3QgdW5kZWZpbmVkLFxuLy8gdGhlbiB0aGUgb3V0cHV0IGFycmF5IGlzIHRydW5jYXRlZCBzbyB0aGF0IGl0IGNvbnRhaW5zIG5vIG1vcmUgdGhhbiBsaW1pdFxuLy8gZWxlbWVudHMuXG4vLyBcIjBcIi5zcGxpdCh1bmRlZmluZWQsIDApIC0+IFtdXG59IGVsc2UgaWYgKCcwJy5zcGxpdCh2b2lkIDAsIDApLmxlbmd0aCkge1xuICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwICYmIGxpbWl0ID09PSAwKSB7IHJldHVybiBbXTsgfVxuICAgICAgICByZXR1cm4gc3RyaW5nX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbn1cblxuLy8gRUNNQS0yNjIsIDNyZCBCLjIuM1xuLy8gTm90IGFuIEVDTUFTY3JpcHQgc3RhbmRhcmQsIGFsdGhvdWdoIEVDTUFTY3JpcHQgM3JkIEVkaXRpb24gaGFzIGFcbi8vIG5vbi1ub3JtYXRpdmUgc2VjdGlvbiBzdWdnZXN0aW5nIHVuaWZvcm0gc2VtYW50aWNzIGFuZCBpdCBzaG91bGQgYmVcbi8vIG5vcm1hbGl6ZWQgYWNyb3NzIGFsbCBicm93c2Vyc1xuLy8gW2J1Z2ZpeCwgSUUgbHQgOV0gSUUgPCA5IHN1YnN0cigpIHdpdGggbmVnYXRpdmUgdmFsdWUgbm90IHdvcmtpbmcgaW4gSUVcbnZhciBzdHJpbmdfc3Vic3RyID0gU3RyaW5nUHJvdG90eXBlLnN1YnN0cjtcbnZhciBoYXNOZWdhdGl2ZVN1YnN0ckJ1ZyA9ICcnLnN1YnN0ciAmJiAnMGInLnN1YnN0cigtMSkgIT09ICdiJztcbmRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgc3Vic3RyOiBmdW5jdGlvbiBzdWJzdHIoc3RhcnQsIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nX3N1YnN0ci5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHN0YXJ0IDwgMCA/ICgoc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0KSA8IDAgPyAwIDogc3RhcnQpIDogc3RhcnQsXG4gICAgICAgICAgICBsZW5ndGhcbiAgICAgICAgKTtcbiAgICB9XG59LCBoYXNOZWdhdGl2ZVN1YnN0ckJ1Zyk7XG5cbn0se31dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gIC8vIHN0cmVhbWluZyB0cmFuc3BvcnRzXG4gIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3dlYnNvY2tldCcpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hoci1zdHJlYW1pbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94ZHItc3RyZWFtaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvZXZlbnRzb3VyY2UnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC9ldmVudHNvdXJjZScpKVxuXG4gIC8vIHBvbGxpbmcgdHJhbnNwb3J0c1xuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9odG1sZmlsZScpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L2h0bWxmaWxlJykpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hoci1wb2xsaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGRyLXBvbGxpbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItcG9sbGluZycpKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9qc29ucC1wb2xsaW5nJylcbl07XG5cbn0se1wiLi90cmFuc3BvcnQvZXZlbnRzb3VyY2VcIjoyMCxcIi4vdHJhbnNwb3J0L2h0bWxmaWxlXCI6MjEsXCIuL3RyYW5zcG9ydC9qc29ucC1wb2xsaW5nXCI6MjMsXCIuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXBcIjoyNixcIi4vdHJhbnNwb3J0L3dlYnNvY2tldFwiOjM4LFwiLi90cmFuc3BvcnQveGRyLXBvbGxpbmdcIjozOSxcIi4vdHJhbnNwb3J0L3hkci1zdHJlYW1pbmdcIjo0MCxcIi4vdHJhbnNwb3J0L3hoci1wb2xsaW5nXCI6NDEsXCIuL3RyYW5zcG9ydC94aHItc3RyZWFtaW5nXCI6NDJ9XSwxNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZXZlbnQnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBYSFIgPSBnbG9iYWwuWE1MSHR0cFJlcXVlc3RcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmJyb3dzZXI6eGhyJyk7XG59XG5cbmZ1bmN0aW9uIEFic3RyYWN0WEhST2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gIGRlYnVnKG1ldGhvZCwgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cyk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhBYnN0cmFjdFhIUk9iamVjdCwgRXZlbnRFbWl0dGVyKTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIHRoaXMueGhyID0gbmV3IFhIUigpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICB9XG5cbiAgaWYgKCF0aGlzLnhocikge1xuICAgIGRlYnVnKCdubyB4aHInKTtcbiAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcsIDAsICdubyB4aHIgc3VwcG9ydCcpO1xuICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzZXZlcmFsIGJyb3dzZXJzIGNhY2hlIFBPU1RzXG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ3Q9JyArICgrbmV3IERhdGUoKSkpO1xuXG4gIC8vIEV4cGxvcmVyIHRlbmRzIHRvIGtlZXAgY29ubmVjdGlvbiBvcGVuLCBldmVuIGFmdGVyIHRoZVxuICAvLyB0YWIgZ2V0cyBjbG9zZWQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzUyODBcbiAgdGhpcy51bmxvYWRSZWYgPSB1dGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3VubG9hZCBjbGVhbnVwJyk7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgfSk7XG4gIHRyeSB7XG4gICAgdGhpcy54aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgaWYgKHRoaXMudGltZW91dCAmJiAndGltZW91dCcgaW4gdGhpcy54aHIpIHtcbiAgICAgIHRoaXMueGhyLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICB0aGlzLnhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZGVidWcoJ3hociB0aW1lb3V0Jyk7XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgICAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICAgIH07XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoJ2V4Y2VwdGlvbicsIGUpO1xuICAgIC8vIElFIHJhaXNlcyBhbiBleGNlcHRpb24gb24gd3JvbmcgcG9ydC5cbiAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoKCFvcHRzIHx8ICFvcHRzLm5vQ3JlZGVudGlhbHMpICYmIEFic3RyYWN0WEhST2JqZWN0LnN1cHBvcnRzQ09SUykge1xuICAgIGRlYnVnKCd3aXRoQ3JlZGVudGlhbHMnKTtcbiAgICAvLyBNb3ppbGxhIGRvY3Mgc2F5cyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9YTUxIdHRwUmVxdWVzdCA6XG4gICAgLy8gXCJUaGlzIG5ldmVyIGFmZmVjdHMgc2FtZS1zaXRlIHJlcXVlc3RzLlwiXG5cbiAgICB0aGlzLnhoci53aXRoQ3JlZGVudGlhbHMgPSAndHJ1ZSc7XG4gIH1cbiAgaWYgKG9wdHMgJiYgb3B0cy5oZWFkZXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9wdHMuaGVhZGVycykge1xuICAgICAgdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIG9wdHMuaGVhZGVyc1trZXldKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi54aHIpIHtcbiAgICAgIHZhciB4ID0gc2VsZi54aHI7XG4gICAgICB2YXIgdGV4dCwgc3RhdHVzO1xuICAgICAgZGVidWcoJ3JlYWR5U3RhdGUnLCB4LnJlYWR5U3RhdGUpO1xuICAgICAgc3dpdGNoICh4LnJlYWR5U3RhdGUpIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgLy8gSUUgZG9lc24ndCBsaWtlIHBlZWtpbmcgaW50byByZXNwb25zZVRleHQgb3Igc3RhdHVzXG4gICAgICAgIC8vIG9uIE1pY3Jvc29mdC5YTUxIVFRQIGFuZCByZWFkeXN0YXRlPTNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGF0dXMgPSB4LnN0YXR1cztcbiAgICAgICAgICB0ZXh0ID0geC5yZXNwb25zZVRleHQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgIC8vIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJRSBkb2VzIHJldHVybiByZWFkeXN0YXRlID09IDMgZm9yIDQwNCBhbnN3ZXJzLlxuICAgICAgICBpZiAoc3RhdHVzID09PSAyMDAgJiYgdGV4dCAmJiB0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkZWJ1ZygnY2h1bmsnKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2NodW5rJywgc3RhdHVzLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgc3RhdHVzID0geC5zdGF0dXM7XG4gICAgICAgIGRlYnVnKCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAvLyBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgICAgICAgc3RhdHVzID0gMjA0O1xuICAgICAgICB9XG4gICAgICAgIC8vIElFIHJldHVybnMgdGhpcyBmb3IgYSBiYWQgcG9ydFxuICAgICAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2FhMzgzNzcwKHY9dnMuODUpLmFzcHhcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIwMDUgfHwgc3RhdHVzID09PSAxMjAyOSkge1xuICAgICAgICAgIHN0YXR1cyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzLCB4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgc3RhdHVzLCB4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdHJ5IHtcbiAgICBzZWxmLnhoci5zZW5kKHBheWxvYWQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gIH1cbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKGFib3J0KSB7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG4gIGlmICghdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcblxuICAvLyBJRSBuZWVkcyB0aGlzIGZpZWxkIHRvIGJlIGEgZnVuY3Rpb25cbiAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7fTtcbiAgaWYgKHRoaXMueGhyLm9udGltZW91dCkge1xuICAgIHRoaXMueGhyLm9udGltZW91dCA9IG51bGw7XG4gIH1cblxuICBpZiAoYWJvcnQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICB9XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy54aHIgPSBudWxsO1xufTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKHRydWUpO1xufTtcblxuQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCA9ICEhWEhSO1xuLy8gb3ZlcnJpZGUgWE1MSHR0cFJlcXVlc3QgZm9yIElFNi83XG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbmlmICghQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCAmJiAoYXhvIGluIGdsb2JhbCkpIHtcbiAgZGVidWcoJ292ZXJyaWRpbmcgeG1saHR0cHJlcXVlc3QnKTtcbiAgWEhSID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsW2F4b10oJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICBBYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkID0gISFuZXcgWEhSKCk7XG59XG5cbnZhciBjb3JzID0gZmFsc2U7XG50cnkge1xuICBjb3JzID0gJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhIUigpO1xufSBjYXRjaCAoaWdub3JlZCkge1xuICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG59XG5cbkFic3RyYWN0WEhST2JqZWN0LnN1cHBvcnRzQ09SUyA9IGNvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RYSFJPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLkV2ZW50U291cmNlO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRHJpdmVyID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xuaWYgKERyaXZlcikge1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFdlYlNvY2tldEJyb3dzZXJEcml2ZXIodXJsKSB7XG5cdFx0cmV0dXJuIG5ldyBEcml2ZXIodXJsKTtcblx0fTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzID0gdW5kZWZpbmVkO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgRXZlbnRTb3VyY2VSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIvZXZlbnRzb3VyY2UnKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgRXZlbnRTb3VyY2VEcml2ZXIgPSByZXF1aXJlKCdldmVudHNvdXJjZScpXG4gIDtcblxuZnVuY3Rpb24gRXZlbnRTb3VyY2VUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFFdmVudFNvdXJjZVRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuXG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2V2ZW50c291cmNlJywgRXZlbnRTb3VyY2VSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKEV2ZW50U291cmNlVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5FdmVudFNvdXJjZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIUV2ZW50U291cmNlRHJpdmVyO1xufTtcblxuRXZlbnRTb3VyY2VUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdldmVudHNvdXJjZSc7XG5FdmVudFNvdXJjZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFNvdXJjZVRyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL2V2ZW50c291cmNlXCI6MjksXCIuL3NlbmRlci94aHItY29yc1wiOjM1LFwiZXZlbnRzb3VyY2VcIjoxOCxcImluaGVyaXRzXCI6NTd9XSwyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBIdG1sZmlsZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9odG1sZmlsZScpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICA7XG5cbmZ1bmN0aW9uIEh0bWxGaWxlVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLCBYSFJMb2NhbE9iamVjdCk7XG59XG5cbmluaGVyaXRzKEh0bWxGaWxlVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5IdG1sRmlsZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICByZXR1cm4gSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkICYmIGluZm8uc2FtZU9yaWdpbjtcbn07XG5cbkh0bWxGaWxlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaHRtbGZpbGUnO1xuSHRtbEZpbGVUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbEZpbGVUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci9odG1sZmlsZVwiOjMwLFwiLi9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJpbmhlcml0c1wiOjU3fV0sMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gRmV3IGNvb2wgdHJhbnNwb3J0cyBkbyB3b3JrIG9ubHkgZm9yIHNhbWUtb3JpZ2luLiBJbiBvcmRlciB0byBtYWtlXG4vLyB0aGVtIHdvcmsgY3Jvc3MtZG9tYWluIHdlIHNoYWxsIHVzZSBpZnJhbWUsIHNlcnZlZCBmcm9tIHRoZVxuLy8gcmVtb3RlIGRvbWFpbi4gTmV3IGJyb3dzZXJzIGhhdmUgY2FwYWJpbGl0aWVzIHRvIGNvbW11bmljYXRlIHdpdGhcbi8vIGNyb3NzIGRvbWFpbiBpZnJhbWUgdXNpbmcgcG9zdE1lc3NhZ2UoKS4gSW4gSUUgaXQgd2FzIGltcGxlbWVudGVkXG4vLyBmcm9tIElFIDgrLCBidXQgb2YgY291cnNlLCBJRSBnb3Qgc29tZSBkZXRhaWxzIHdyb25nOlxuLy8gICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjMTk3MDE1KHY9VlMuODUpLmFzcHhcbi8vICAgIGh0dHA6Ly9zdGV2ZXNvdWRlcnMuY29tL21pc2MvdGVzdC1wb3N0bWVzc2FnZS5waHBcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIHZlcnNpb24gPSByZXF1aXJlKCcuLi92ZXJzaW9uJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3VybCcpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9pZnJhbWUnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9ldmVudCcpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vdXRpbHMvcmFuZG9tJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnRyYW5zcG9ydDppZnJhbWUnKTtcbn1cblxuZnVuY3Rpb24gSWZyYW1lVHJhbnNwb3J0KHRyYW5zcG9ydCwgdHJhbnNVcmwsIGJhc2VVcmwpIHtcbiAgaWYgKCFJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLm9yaWdpbiA9IHVybFV0aWxzLmdldE9yaWdpbihiYXNlVXJsKTtcbiAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgdGhpcy50cmFuc1VybCA9IHRyYW5zVXJsO1xuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgdGhpcy53aW5kb3dJZCA9IHJhbmRvbS5zdHJpbmcoOCk7XG5cbiAgdmFyIGlmcmFtZVVybCA9IHVybFV0aWxzLmFkZFBhdGgoYmFzZVVybCwgJy9pZnJhbWUuaHRtbCcpICsgJyMnICsgdGhpcy53aW5kb3dJZDtcbiAgZGVidWcodHJhbnNwb3J0LCB0cmFuc1VybCwgaWZyYW1lVXJsKTtcblxuICB0aGlzLmlmcmFtZU9iaiA9IGlmcmFtZVV0aWxzLmNyZWF0ZUlmcmFtZShpZnJhbWVVcmwsIGZ1bmN0aW9uKHIpIHtcbiAgICBkZWJ1ZygnZXJyIGNhbGxiYWNrJyk7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIDEwMDYsICdVbmFibGUgdG8gbG9hZCBhbiBpZnJhbWUgKCcgKyByICsgJyknKTtcbiAgICBzZWxmLmNsb3NlKCk7XG4gIH0pO1xuXG4gIHRoaXMub25tZXNzYWdlQ2FsbGJhY2sgPSB0aGlzLl9tZXNzYWdlLmJpbmQodGhpcyk7XG4gIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ21lc3NhZ2UnLCB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrKTtcbn1cblxuaW5oZXJpdHMoSWZyYW1lVHJhbnNwb3J0LCBFdmVudEVtaXR0ZXIpO1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBpZiAodGhpcy5pZnJhbWVPYmopIHtcbiAgICBldmVudFV0aWxzLmRldGFjaEV2ZW50KCdtZXNzYWdlJywgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICB0aGlzLnBvc3RNZXNzYWdlKCdjJyk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgICB0aGlzLmlmcmFtZU9iai5jbGVhbnVwKCk7XG4gICAgdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICAgIHRoaXMub25tZXNzYWdlQ2FsbGJhY2sgPSB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gIH1cbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuX21lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gIGRlYnVnKCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgaWYgKCF1cmxVdGlscy5pc09yaWdpbkVxdWFsKGUub3JpZ2luLCB0aGlzLm9yaWdpbikpIHtcbiAgICBkZWJ1Zygnbm90IHNhbWUgb3JpZ2luJywgZS5vcmlnaW4sIHRoaXMub3JpZ2luKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaWZyYW1lTWVzc2FnZTtcbiAgdHJ5IHtcbiAgICBpZnJhbWVNZXNzYWdlID0gSlNPTjMucGFyc2UoZS5kYXRhKTtcbiAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgIGRlYnVnKCdiYWQganNvbicsIGUuZGF0YSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlmcmFtZU1lc3NhZ2Uud2luZG93SWQgIT09IHRoaXMud2luZG93SWQpIHtcbiAgICBkZWJ1ZygnbWlzbWF0Y2hlZCB3aW5kb3cgaWQnLCBpZnJhbWVNZXNzYWdlLndpbmRvd0lkLCB0aGlzLndpbmRvd0lkKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKGlmcmFtZU1lc3NhZ2UudHlwZSkge1xuICBjYXNlICdzJzpcbiAgICB0aGlzLmlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICAvLyB3aW5kb3cgZ2xvYmFsIGRlcGVuZGVuY3lcbiAgICB0aGlzLnBvc3RNZXNzYWdlKCdzJywgSlNPTjMuc3RyaW5naWZ5KFtcbiAgICAgIHZlcnNpb25cbiAgICAsIHRoaXMudHJhbnNwb3J0XG4gICAgLCB0aGlzLnRyYW5zVXJsXG4gICAgLCB0aGlzLmJhc2VVcmxcbiAgICBdKSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3QnOlxuICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2MnOlxuICAgIHZhciBjZGF0YTtcbiAgICB0cnkge1xuICAgICAgY2RhdGEgPSBKU09OMy5wYXJzZShpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBjZGF0YVswXSwgY2RhdGFbMV0pO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgICBicmVhaztcbiAgfVxufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgZGVidWcoJ3Bvc3RNZXNzYWdlJywgdHlwZSwgZGF0YSk7XG4gIHRoaXMuaWZyYW1lT2JqLnBvc3QoSlNPTjMuc3RyaW5naWZ5KHtcbiAgICB3aW5kb3dJZDogdGhpcy53aW5kb3dJZFxuICAsIHR5cGU6IHR5cGVcbiAgLCBkYXRhOiBkYXRhIHx8ICcnXG4gIH0pLCB0aGlzLm9yaWdpbik7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGRlYnVnKCdzZW5kJywgbWVzc2FnZSk7XG4gIHRoaXMucG9zdE1lc3NhZ2UoJ20nLCBtZXNzYWdlKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lJztcbklmcmFtZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBJZnJhbWVUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuLi91dGlscy9ldmVudFwiOjQ2LFwiLi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuLi91dGlscy9yYW5kb21cIjo1MCxcIi4uL3V0aWxzL3VybFwiOjUyLFwiLi4vdmVyc2lvblwiOjUzLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OH1dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIHNpbXBsZXN0IGFuZCBtb3N0IHJvYnVzdCB0cmFuc3BvcnQsIHVzaW5nIHRoZSB3ZWxsLWtub3cgY3Jvc3Ncbi8vIGRvbWFpbiBoYWNrIC0gSlNPTlAuIFRoaXMgdHJhbnNwb3J0IGlzIHF1aXRlIGluZWZmaWNpZW50IC0gb25lXG4vLyBtZXNzYWdlIGNvdWxkIHVzZSB1cCB0byBvbmUgaHR0cCByZXF1ZXN0LiBCdXQgYXQgbGVhc3QgaXQgd29ya3MgYWxtb3N0XG4vLyBldmVyeXdoZXJlLlxuLy8gS25vd24gbGltaXRhdGlvbnM6XG4vLyAgIG8geW91IHdpbGwgZ2V0IGEgc3Bpbm5pbmcgY3Vyc29yXG4vLyAgIG8gZm9yIEtvbnF1ZXJvciBhIGR1bWIgdGltZXIgaXMgbmVlZGVkIHRvIGRldGVjdCBlcnJvcnNcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFNlbmRlclJlY2VpdmVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyLXJlY2VpdmVyJylcbiAgLCBKc29ucFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9qc29ucCcpXG4gICwganNvbnBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlci9qc29ucCcpXG4gIDtcblxuZnVuY3Rpb24gSnNvblBUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFKc29uUFRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBTZW5kZXJSZWNlaXZlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2pzb25wJywganNvbnBTZW5kZXIsIEpzb25wUmVjZWl2ZXIpO1xufVxuXG5pbmhlcml0cyhKc29uUFRyYW5zcG9ydCwgU2VuZGVyUmVjZWl2ZXIpO1xuXG5Kc29uUFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIWdsb2JhbC5kb2N1bWVudDtcbn07XG5cbkpzb25QVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnanNvbnAtcG9sbGluZyc7XG5Kc29uUFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMTtcbkpzb25QVHJhbnNwb3J0Lm5lZWRCb2R5ID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29uUFRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9saWIvc2VuZGVyLXJlY2VpdmVyXCI6MjgsXCIuL3JlY2VpdmVyL2pzb25wXCI6MzEsXCIuL3NlbmRlci9qc29ucFwiOjMzLFwiaW5oZXJpdHNcIjo1N31dLDI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgU2VuZGVyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3NlbmRlci1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDphamF4LWJhc2VkJyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFqYXhTZW5kZXIoQWpheE9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24odXJsLCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIGRlYnVnKCdjcmVhdGUgYWpheCBzZW5kZXInLCB1cmwsIHBheWxvYWQpO1xuICAgIHZhciBvcHQgPSB7fTtcbiAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHQuaGVhZGVycyA9IHsnQ29udGVudC10eXBlJzogJ3RleHQvcGxhaW4nfTtcbiAgICB9XG4gICAgdmFyIGFqYXhVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHVybCwgJy94aHJfc2VuZCcpO1xuICAgIHZhciB4byA9IG5ldyBBamF4T2JqZWN0KCdQT1NUJywgYWpheFVybCwgcGF5bG9hZCwgb3B0KTtcbiAgICB4by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMpO1xuICAgICAgeG8gPSBudWxsO1xuXG4gICAgICBpZiAoc3RhdHVzICE9PSAyMDAgJiYgc3RhdHVzICE9PSAyMDQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignaHR0cCBzdGF0dXMgJyArIHN0YXR1cykpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnYWJvcnQnKTtcbiAgICAgIHhvLmNsb3NlKCk7XG4gICAgICB4byA9IG51bGw7XG5cbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Fib3J0ZWQnKTtcbiAgICAgIGVyci5jb2RlID0gMTAwMDtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gQWpheEJhc2VkVHJhbnNwb3J0KHRyYW5zVXJsLCB1cmxTdWZmaXgsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XG4gIFNlbmRlclJlY2VpdmVyLmNhbGwodGhpcywgdHJhbnNVcmwsIHVybFN1ZmZpeCwgY3JlYXRlQWpheFNlbmRlcihBamF4T2JqZWN0KSwgUmVjZWl2ZXIsIEFqYXhPYmplY3QpO1xufVxuXG5pbmhlcml0cyhBamF4QmFzZWRUcmFuc3BvcnQsIFNlbmRlclJlY2VpdmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBamF4QmFzZWRUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuLi8uLi91dGlscy91cmxcIjo1MixcIi4vc2VuZGVyLXJlY2VpdmVyXCI6MjgsXCJkZWJ1Z1wiOjU1LFwiaW5oZXJpdHNcIjo1N31dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmJ1ZmZlcmVkLXNlbmRlcicpO1xufVxuXG5mdW5jdGlvbiBCdWZmZXJlZFNlbmRlcih1cmwsIHNlbmRlcikge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuc2VuZGVyID0gc2VuZGVyO1xuICB0aGlzLnVybCA9IHVybDtcbn1cblxuaW5oZXJpdHMoQnVmZmVyZWRTZW5kZXIsIEV2ZW50RW1pdHRlcik7XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICBkZWJ1Zygnc2VuZCcsIG1lc3NhZ2UpO1xuICB0aGlzLnNlbmRCdWZmZXIucHVzaChtZXNzYWdlKTtcbiAgaWYgKCF0aGlzLnNlbmRTdG9wKSB7XG4gICAgdGhpcy5zZW5kU2NoZWR1bGUoKTtcbiAgfVxufTtcblxuLy8gRm9yIHBvbGxpbmcgdHJhbnNwb3J0cyBpbiBhIHNpdHVhdGlvbiB3aGVuIGluIHRoZSBtZXNzYWdlIGNhbGxiYWNrLFxuLy8gbmV3IG1lc3NhZ2UgaXMgYmVpbmcgc2VuZC4gSWYgdGhlIHNlbmRpbmcgY29ubmVjdGlvbiB3YXMgc3RhcnRlZFxuLy8gYmVmb3JlIHJlY2VpdmluZyBvbmUsIGl0IGlzIHBvc3NpYmxlIHRvIHNhdHVyYXRlIHRoZSBuZXR3b3JrIGFuZFxuLy8gdGltZW91dCBkdWUgdG8gdGhlIGxhY2sgb2YgcmVjZWl2aW5nIHNvY2tldC4gVG8gYXZvaWQgdGhhdCB3ZSBkZWxheVxuLy8gc2VuZGluZyBtZXNzYWdlcyBieSBzb21lIHNtYWxsIHRpbWUsIGluIG9yZGVyIHRvIGxldCByZWNlaXZpbmdcbi8vIGNvbm5lY3Rpb24gYmUgc3RhcnRlZCBiZWZvcmVoYW5kLiBUaGlzIGlzIG9ubHkgYSBoYWxmbWVhc3VyZSBhbmRcbi8vIGRvZXMgbm90IGZpeCB0aGUgYmlnIHByb2JsZW0sIGJ1dCBpdCBkb2VzIG1ha2UgdGhlIHRlc3RzIGdvIG1vcmVcbi8vIHN0YWJsZSBvbiBzbG93IG5ldHdvcmtzLlxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRTY2hlZHVsZVdhaXQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ3NlbmRTY2hlZHVsZVdhaXQnKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHJlZjtcbiAgdGhpcy5zZW5kU3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdzZW5kU3RvcCcpO1xuICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgfTtcbiAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcbiAgICBzZWxmLnNlbmRTY2hlZHVsZSgpO1xuICB9LCAyNSk7XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZFNjaGVkdWxlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdzZW5kU2NoZWR1bGUnLCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgcGF5bG9hZCA9ICdbJyArIHRoaXMuc2VuZEJ1ZmZlci5qb2luKCcsJykgKyAnXSc7XG4gICAgdGhpcy5zZW5kU3RvcCA9IHRoaXMuc2VuZGVyKHRoaXMudXJsLCBwYXlsb2FkLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZXJyLmNvZGUgfHwgMTAwNiwgJ1NlbmRpbmcgZXJyb3I6ICcgKyBlcnIpO1xuICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNlbmRTY2hlZHVsZVdhaXQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgfVxufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIGlmICh0aGlzLnNlbmRTdG9wKSB7XG4gICAgdGhpcy5zZW5kU3RvcCgpO1xuICAgIHRoaXMuc2VuZFN0b3AgPSBudWxsO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcmVkU2VuZGVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSWZyYW1lVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vaWZyYW1lJylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpXG4gIDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0cmFuc3BvcnQpIHtcblxuICBmdW5jdGlvbiBJZnJhbWVXcmFwVHJhbnNwb3J0KHRyYW5zVXJsLCBiYXNlVXJsKSB7XG4gICAgSWZyYW1lVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUsIHRyYW5zVXJsLCBiYXNlVXJsKTtcbiAgfVxuXG4gIGluaGVyaXRzKElmcmFtZVdyYXBUcmFuc3BvcnQsIElmcmFtZVRyYW5zcG9ydCk7XG5cbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24odXJsLCBpbmZvKSB7XG4gICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaWZyYW1lSW5mbyA9IG9iamVjdFV0aWxzLmV4dGVuZCh7fSwgaW5mbyk7XG4gICAgaWZyYW1lSW5mby5zYW1lT3JpZ2luID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJhbnNwb3J0LmVuYWJsZWQoaWZyYW1lSW5mbykgJiYgSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKTtcbiAgfTtcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lLScgKyB0cmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5uZWVkQm9keSA9IHRydWU7XG4gIElmcmFtZVdyYXBUcmFuc3BvcnQucm91bmRUcmlwcyA9IElmcmFtZVRyYW5zcG9ydC5yb3VuZFRyaXBzICsgdHJhbnNwb3J0LnJvdW5kVHJpcHMgLSAxOyAvLyBodG1sLCBqYXZhc2NyaXB0ICgyKSArIHRyYW5zcG9ydCAtIG5vIENPUlMgKDEpXG5cbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5mYWNhZGVUcmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgcmV0dXJuIElmcmFtZVdyYXBUcmFuc3BvcnQ7XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9vYmplY3RcIjo0OSxcIi4uL2lmcmFtZVwiOjIyLFwiaW5oZXJpdHNcIjo1N31dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnBvbGxpbmcnKTtcbn1cblxuZnVuY3Rpb24gUG9sbGluZyhSZWNlaXZlciwgcmVjZWl2ZVVybCwgQWpheE9iamVjdCkge1xuICBkZWJ1ZyhyZWNlaXZlVXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHRoaXMuUmVjZWl2ZXIgPSBSZWNlaXZlcjtcbiAgdGhpcy5yZWNlaXZlVXJsID0gcmVjZWl2ZVVybDtcbiAgdGhpcy5BamF4T2JqZWN0ID0gQWpheE9iamVjdDtcbiAgdGhpcy5fc2NoZWR1bGVSZWNlaXZlcigpO1xufVxuXG5pbmhlcml0cyhQb2xsaW5nLCBFdmVudEVtaXR0ZXIpO1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5fc2NoZWR1bGVSZWNlaXZlciA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3NjaGVkdWxlUmVjZWl2ZXInKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcG9sbCA9IHRoaXMucG9sbCA9IG5ldyB0aGlzLlJlY2VpdmVyKHRoaXMucmVjZWl2ZVVybCwgdGhpcy5BamF4T2JqZWN0KTtcblxuICBwb2xsLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gIH0pO1xuXG4gIHBvbGwub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICBkZWJ1ZygnY2xvc2UnLCBjb2RlLCByZWFzb24sIHNlbGYucG9sbElzQ2xvc2luZyk7XG4gICAgc2VsZi5wb2xsID0gcG9sbCA9IG51bGw7XG5cbiAgICBpZiAoIXNlbGYucG9sbElzQ2xvc2luZykge1xuICAgICAgaWYgKHJlYXNvbiA9PT0gJ25ldHdvcmsnKSB7XG4gICAgICAgIHNlbGYuX3NjaGVkdWxlUmVjZWl2ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBjb2RlIHx8IDEwMDYsIHJlYXNvbik7XG4gICAgICAgIHNlbGYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cblBvbGxpbmcucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLnBvbGxJc0Nsb3NpbmcgPSB0cnVlO1xuICBpZiAodGhpcy5wb2xsKSB7XG4gICAgdGhpcy5wb2xsLmFib3J0KCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgQnVmZmVyZWRTZW5kZXIgPSByZXF1aXJlKCcuL2J1ZmZlcmVkLXNlbmRlcicpXG4gICwgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXItcmVjZWl2ZXInKTtcbn1cblxuZnVuY3Rpb24gU2VuZGVyUmVjZWl2ZXIodHJhbnNVcmwsIHVybFN1ZmZpeCwgc2VuZGVyRnVuYywgUmVjZWl2ZXIsIEFqYXhPYmplY3QpIHtcbiAgdmFyIHBvbGxVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHRyYW5zVXJsLCB1cmxTdWZmaXgpO1xuICBkZWJ1Zyhwb2xsVXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBCdWZmZXJlZFNlbmRlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCBzZW5kZXJGdW5jKTtcblxuICB0aGlzLnBvbGwgPSBuZXcgUG9sbGluZyhSZWNlaXZlciwgcG9sbFVybCwgQWpheE9iamVjdCk7XG4gIHRoaXMucG9sbC5vbignbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgIGRlYnVnKCdwb2xsIG1lc3NhZ2UnLCBtc2cpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gIH0pO1xuICB0aGlzLnBvbGwub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICBkZWJ1ZygncG9sbCBjbG9zZScsIGNvZGUsIHJlYXNvbik7XG4gICAgc2VsZi5wb2xsID0gbnVsbDtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgY29kZSwgcmVhc29uKTtcbiAgICBzZWxmLmNsb3NlKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhTZW5kZXJSZWNlaXZlciwgQnVmZmVyZWRTZW5kZXIpO1xuXG5TZW5kZXJSZWNlaXZlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLmNsb3NlLmNhbGwodGhpcyk7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBpZiAodGhpcy5wb2xsKSB7XG4gICAgdGhpcy5wb2xsLmFib3J0KCk7XG4gICAgdGhpcy5wb2xsID0gbnVsbDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZW5kZXJSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiLi9idWZmZXJlZC1zZW5kZXJcIjoyNSxcIi4vcG9sbGluZ1wiOjI3LFwiZGVidWdcIjo1NSxcImluaGVyaXRzXCI6NTd9XSwyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgRXZlbnRTb3VyY2VEcml2ZXIgPSByZXF1aXJlKCdldmVudHNvdXJjZScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpldmVudHNvdXJjZScpO1xufVxuXG5mdW5jdGlvbiBFdmVudFNvdXJjZVJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBlcyA9IHRoaXMuZXMgPSBuZXcgRXZlbnRTb3VyY2VEcml2ZXIodXJsKTtcbiAgZXMub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkZWNvZGVVUkkoZS5kYXRhKSk7XG4gIH07XG4gIGVzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Vycm9yJywgZXMucmVhZHlTdGF0ZSwgZSk7XG4gICAgLy8gRVMgb24gcmVjb25uZWN0aW9uIGhhcyByZWFkeVN0YXRlID0gMCBvciAxLlxuICAgIC8vIG9uIG5ldHdvcmsgZXJyb3IgaXQncyBDTE9TRUQgPSAyXG4gICAgdmFyIHJlYXNvbiA9IChlcy5yZWFkeVN0YXRlICE9PSAyID8gJ25ldHdvcmsnIDogJ3Blcm1hbmVudCcpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICBzZWxmLl9jbG9zZShyZWFzb24pO1xuICB9O1xufVxuXG5pbmhlcml0cyhFdmVudFNvdXJjZVJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLl9jbG9zZSgndXNlcicpO1xufTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcbiAgdmFyIGVzID0gdGhpcy5lcztcbiAgaWYgKGVzKSB7XG4gICAgZXMub25tZXNzYWdlID0gZXMub25lcnJvciA9IG51bGw7XG4gICAgZXMuY2xvc2UoKTtcbiAgICB0aGlzLmVzID0gbnVsbDtcbiAgfVxufTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gIGRlYnVnKCdjbG9zZScsIHJlYXNvbik7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgLy8gU2FmYXJpIGFuZCBjaHJvbWUgPCAxNSBjcmFzaCBpZiB3ZSBjbG9zZSB3aW5kb3cgYmVmb3JlXG4gIC8vIHdhaXRpbmcgZm9yIEVTIGNsZWFudXAuIFNlZTpcbiAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTg5MTU1XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfSwgMjAwKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRTb3VyY2VSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiZXZlbnRzb3VyY2VcIjoxOCxcImluaGVyaXRzXCI6NTd9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvaWZyYW1lJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmh0bWxmaWxlJyk7XG59XG5cbmZ1bmN0aW9uIEh0bWxmaWxlUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmcmFtZVV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UoKTtcblxuICB0aGlzLmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg2KTtcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAnYz0nICsgZGVjb2RlVVJJQ29tcG9uZW50KGlmcmFtZVV0aWxzLldQcmVmaXggKyAnLicgKyB0aGlzLmlkKSk7XG5cbiAgZGVidWcoJ3VzaW5nIGh0bWxmaWxlJywgSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQpO1xuICB2YXIgY29uc3RydWN0RnVuYyA9IEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID9cbiAgICAgIGlmcmFtZVV0aWxzLmNyZWF0ZUh0bWxmaWxlIDogaWZyYW1lVXRpbHMuY3JlYXRlSWZyYW1lO1xuXG4gIGdsb2JhbFtpZnJhbWVVdGlscy5XUHJlZml4XVt0aGlzLmlkXSA9IHtcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnc3RhcnQnKTtcbiAgICAgIHNlbGYuaWZyYW1lT2JqLmxvYWRlZCgpO1xuICAgIH1cbiAgLCBtZXNzYWdlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBkZWJ1ZygnbWVzc2FnZScsIGRhdGEpO1xuICAgICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG4gICAgfVxuICAsIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ3N0b3AnKTtcbiAgICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICAgIHNlbGYuX2Nsb3NlKCduZXR3b3JrJyk7XG4gICAgfVxuICB9O1xuICB0aGlzLmlmcmFtZU9iaiA9IGNvbnN0cnVjdEZ1bmModXJsLCBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygnY2FsbGJhY2snKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgc2VsZi5fY2xvc2UoJ3Blcm1hbmVudCcpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSHRtbGZpbGVSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5fY2xvc2UoJ3VzZXInKTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBpZiAodGhpcy5pZnJhbWVPYmopIHtcbiAgICB0aGlzLmlmcmFtZU9iai5jbGVhbnVwKCk7XG4gICAgdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICB9XG4gIGRlbGV0ZSBnbG9iYWxbaWZyYW1lVXRpbHMuV1ByZWZpeF1bdGhpcy5pZF07XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgZGVidWcoJ19jbG9zZScsIHJlYXNvbik7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgPSBmYWxzZTtcblxuLy8gb2JmdXNjYXRlIHRvIGF2b2lkIGZpcmV3YWxsc1xudmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG5pZiAoYXhvIGluIGdsb2JhbCkge1xuICB0cnkge1xuICAgIEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID0gISFuZXcgZ2xvYmFsW2F4b10oJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gIH1cbn1cblxuSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkID0gSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgfHwgaWZyYW1lVXRpbHMuaWZyYW1lRW5hYmxlZDtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sZmlsZVJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvaWZyYW1lJylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9icm93c2VyJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpqc29ucCcpO1xufVxuXG5mdW5jdGlvbiBKc29ucFJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UoKTtcblxuICB0aGlzLmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg2KTtcbiAgdmFyIHVybFdpdGhJZCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ2M9JyArIGVuY29kZVVSSUNvbXBvbmVudCh1dGlscy5XUHJlZml4ICsgJy4nICsgdGhpcy5pZCkpO1xuXG4gIGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXSA9IHRoaXMuX2NhbGxiYWNrLmJpbmQodGhpcyk7XG4gIHRoaXMuX2NyZWF0ZVNjcmlwdCh1cmxXaXRoSWQpO1xuXG4gIC8vIEZhbGxiYWNrIG1vc3RseSBmb3IgS29ucXVlcm9yIC0gc3R1cGlkIHRpbWVyLCAzNSBzZWNvbmRzIHNoYWxsIGJlIHBsZW50eS5cbiAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKHRpbWVvdXQpJykpO1xuICB9LCBKc29ucFJlY2VpdmVyLnRpbWVvdXQpO1xufVxuXG5pbmhlcml0cyhKc29ucFJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgaWYgKGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXSkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0pTT05QIHVzZXIgYWJvcnRlZCByZWFkJyk7XG4gICAgZXJyLmNvZGUgPSAxMDAwO1xuICAgIHRoaXMuX2Fib3J0KGVycik7XG4gIH1cbn07XG5cbkpzb25wUmVjZWl2ZXIudGltZW91dCA9IDM1MDAwO1xuSnNvbnBSZWNlaXZlci5zY3JpcHRFcnJvclRpbWVvdXQgPSAxMDAwO1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY2FsbGJhY2sgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGRlYnVnKCdfY2FsbGJhY2snLCBkYXRhKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuXG4gIGlmICh0aGlzLmFib3J0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGRhdGEpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIGRhdGEpO1xuICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xuICB9XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCAnbmV0d29yaycpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2Fib3J0ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGRlYnVnKCdfYWJvcnQnLCBlcnIpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuYWJvcnRpbmcgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgZXJyLmNvZGUsIGVyci5tZXNzYWdlKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICBpZiAodGhpcy5zY3JpcHQyKSB7XG4gICAgdGhpcy5zY3JpcHQyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQyKTtcbiAgICB0aGlzLnNjcmlwdDIgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdDtcbiAgICAvLyBVbmZvcnR1bmF0ZWx5LCB5b3UgY2FuJ3QgcmVhbGx5IGFib3J0IHNjcmlwdCBsb2FkaW5nIG9mXG4gICAgLy8gdGhlIHNjcmlwdC5cbiAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBzY3JpcHQub25lcnJvciA9XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25jbGljayA9IG51bGw7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG4gIGRlbGV0ZSBnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF07XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fc2NyaXB0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19zY3JpcHRFcnJvcicpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLmVycm9yVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmVycm9yVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGlmICghc2VsZi5sb2FkZWRPa2F5KSB7XG4gICAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25lcnJvciknKSk7XG4gICAgfVxuICB9LCBKc29ucFJlY2VpdmVyLnNjcmlwdEVycm9yVGltZW91dCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY3JlYXRlU2NyaXB0ID0gZnVuY3Rpb24odXJsKSB7XG4gIGRlYnVnKCdfY3JlYXRlU2NyaXB0JywgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHZhciBzY3JpcHQyOyAgLy8gT3BlcmEgc3luY2hyb25vdXMgbG9hZCB0cmljay5cblxuICBzY3JpcHQuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDgpO1xuICBzY3JpcHQuc3JjID0gdXJsO1xuICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICBzY3JpcHQuY2hhcnNldCA9ICdVVEYtOCc7XG4gIHNjcmlwdC5vbmVycm9yID0gdGhpcy5fc2NyaXB0RXJyb3IuYmluZCh0aGlzKTtcbiAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmxvYWQnKTtcbiAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25sb2FkKScpKTtcbiAgfTtcblxuICAvLyBJRTkgZmlyZXMgJ2Vycm9yJyBldmVudCBhZnRlciBvbnJlYWR5c3RhdGVjaGFuZ2Ugb3IgYmVmb3JlLCBpbiByYW5kb20gb3JkZXIuXG4gIC8vIFVzZSBsb2FkZWRPa2F5IHRvIGRldGVybWluZSBpZiBhY3R1YWxseSBlcnJvcmVkXG4gIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25yZWFkeXN0YXRlY2hhbmdlJywgc2NyaXB0LnJlYWR5U3RhdGUpO1xuICAgIGlmICgvbG9hZGVkfGNsb3NlZC8udGVzdChzY3JpcHQucmVhZHlTdGF0ZSkpIHtcbiAgICAgIGlmIChzY3JpcHQgJiYgc2NyaXB0Lmh0bWxGb3IgJiYgc2NyaXB0Lm9uY2xpY2spIHtcbiAgICAgICAgc2VsZi5sb2FkZWRPa2F5ID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBJbiBJRSwgYWN0dWFsbHkgZXhlY3V0ZSB0aGUgc2NyaXB0LlxuICAgICAgICAgIHNjcmlwdC5vbmNsaWNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ucmVhZHlzdGF0ZWNoYW5nZSknKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBJRTogZXZlbnQvaHRtbEZvci9vbmNsaWNrIHRyaWNrLlxuICAvLyBPbmUgY2FuJ3QgcmVseSBvbiBwcm9wZXIgb3JkZXIgZm9yIG9ucmVhZHlzdGF0ZWNoYW5nZS4gSW4gb3JkZXIgdG9cbiAgLy8gbWFrZSBzdXJlLCBzZXQgYSAnaHRtbEZvcicgYW5kICdldmVudCcgcHJvcGVydGllcywgc28gdGhhdFxuICAvLyBzY3JpcHQgY29kZSB3aWxsIGJlIGluc3RhbGxlZCBhcyAnb25jbGljaycgaGFuZGxlciBmb3IgdGhlXG4gIC8vIHNjcmlwdCBvYmplY3QuIExhdGVyLCBvbnJlYWR5c3RhdGVjaGFuZ2UsIG1hbnVhbGx5IGV4ZWN1dGUgdGhpc1xuICAvLyBjb2RlLiBGRiBhbmQgQ2hyb21lIGRvZXNuJ3Qgd29yayB3aXRoICdldmVudCcgYW5kICdodG1sRm9yJ1xuICAvLyBzZXQuIEZvciByZWZlcmVuY2Ugc2VlOlxuICAvLyAgIGh0dHA6Ly9qYXVib3VyZy5uZXQvMjAxMC8wNy9sb2FkaW5nLXNjcmlwdC1hcy1vbmNsaWNrLWhhbmRsZXItb2YuaHRtbFxuICAvLyBBbHNvLCByZWFkIG9uIHRoYXQgYWJvdXQgc2NyaXB0IG9yZGVyaW5nOlxuICAvLyAgIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9EeW5hbWljX1NjcmlwdF9FeGVjdXRpb25fT3JkZXJcbiAgaWYgKHR5cGVvZiBzY3JpcHQuYXN5bmMgPT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5kb2N1bWVudC5hdHRhY2hFdmVudCkge1xuICAgIC8vIEFjY29yZGluZyB0byBtb3ppbGxhIGRvY3MsIGluIHJlY2VudCBicm93c2VycyBzY3JpcHQuYXN5bmMgZGVmYXVsdHNcbiAgICAvLyB0byAndHJ1ZScsIHNvIHdlIG1heSB1c2UgaXQgdG8gZGV0ZWN0IGEgZ29vZCBicm93c2VyOlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0hUTUwvRWxlbWVudC9zY3JpcHRcbiAgICBpZiAoIWJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgICAvLyBOYWl2ZWx5IGFzc3VtZSB3ZSdyZSBpbiBJRVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2NyaXB0Lmh0bWxGb3IgPSBzY3JpcHQuaWQ7XG4gICAgICAgIHNjcmlwdC5ldmVudCA9ICdvbmNsaWNrJztcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3BlcmEsIHNlY29uZCBzeW5jIHNjcmlwdCBoYWNrXG4gICAgICBzY3JpcHQyID0gdGhpcy5zY3JpcHQyID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0Mi50ZXh0ID0gXCJ0cnl7dmFyIGEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnXCIgKyBzY3JpcHQuaWQgKyBcIicpOyBpZihhKWEub25lcnJvcigpO31jYXRjaCh4KXt9O1wiO1xuICAgICAgc2NyaXB0LmFzeW5jID0gc2NyaXB0Mi5hc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGhlYWQgPSBnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQpO1xuICBpZiAoc2NyaXB0Mikge1xuICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdDIsIGhlYWQuZmlyc3RDaGlsZCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSnNvbnBSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi4vLi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuLi8uLi91dGlscy9yYW5kb21cIjo1MCxcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6eGhyJyk7XG59XG5cbmZ1bmN0aW9uIFhoclJlY2VpdmVyKHVybCwgQWpheE9iamVjdCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuYnVmZmVyUG9zaXRpb24gPSAwO1xuXG4gIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIHVybCwgbnVsbCk7XG4gIHRoaXMueG8ub24oJ2NodW5rJywgdGhpcy5fY2h1bmtIYW5kbGVyLmJpbmQodGhpcykpO1xuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMsIHRleHQpO1xuICAgIHNlbGYuX2NodW5rSGFuZGxlcihzdGF0dXMsIHRleHQpO1xuICAgIHNlbGYueG8gPSBudWxsO1xuICAgIHZhciByZWFzb24gPSBzdGF0dXMgPT09IDIwMCA/ICduZXR3b3JrJyA6ICdwZXJtYW5lbnQnO1xuICAgIGRlYnVnKCdjbG9zZScsIHJlYXNvbik7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoWGhyUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5fY2h1bmtIYW5kbGVyID0gZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gIGRlYnVnKCdfY2h1bmtIYW5kbGVyJywgc3RhdHVzKTtcbiAgaWYgKHN0YXR1cyAhPT0gMjAwIHx8ICF0ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaWR4ID0gLTE7IDsgdGhpcy5idWZmZXJQb3NpdGlvbiArPSBpZHggKyAxKSB7XG4gICAgdmFyIGJ1ZiA9IHRleHQuc2xpY2UodGhpcy5idWZmZXJQb3NpdGlvbik7XG4gICAgaWR4ID0gYnVmLmluZGV4T2YoJ1xcbicpO1xuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIG1zZyA9IGJ1Zi5zbGljZSgwLCBpZHgpO1xuICAgIGlmIChtc2cpIHtcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gICAgfVxuICB9XG59O1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIGlmICh0aGlzLnhvKSB7XG4gICAgdGhpcy54by5jbG9zZSgpO1xuICAgIGRlYnVnKCdjbG9zZScpO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCAndXNlcicpO1xuICAgIHRoaXMueG8gPSBudWxsO1xuICB9XG4gIHRoaXMuX2NsZWFudXAoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyOmpzb25wJyk7XG59XG5cbnZhciBmb3JtLCBhcmVhO1xuXG5mdW5jdGlvbiBjcmVhdGVJZnJhbWUoaWQpIHtcbiAgZGVidWcoJ2NyZWF0ZUlmcmFtZScsIGlkKTtcbiAgdHJ5IHtcbiAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICByZXR1cm4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxpZnJhbWUgbmFtZT1cIicgKyBpZCArICdcIj4nKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWZyYW1lLm5hbWUgPSBpZDtcbiAgICByZXR1cm4gaWZyYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZvcm0oKSB7XG4gIGRlYnVnKCdjcmVhdGVGb3JtJyk7XG4gIGZvcm0gPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICBmb3JtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgZm9ybS5lbmN0eXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gIGZvcm0uYWNjZXB0Q2hhcnNldCA9ICdVVEYtOCc7XG5cbiAgYXJlYSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICBhcmVhLm5hbWUgPSAnZCc7XG4gIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG5cbiAgZ2xvYmFsLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXJsLCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICBkZWJ1Zyh1cmwsIHBheWxvYWQpO1xuICBpZiAoIWZvcm0pIHtcbiAgICBjcmVhdGVGb3JtKCk7XG4gIH1cbiAgdmFyIGlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg4KTtcbiAgZm9ybS50YXJnZXQgPSBpZDtcbiAgZm9ybS5hY3Rpb24gPSB1cmxVdGlscy5hZGRRdWVyeSh1cmxVdGlscy5hZGRQYXRoKHVybCwgJy9qc29ucF9zZW5kJyksICdpPScgKyBpZCk7XG5cbiAgdmFyIGlmcmFtZSA9IGNyZWF0ZUlmcmFtZShpZCk7XG4gIGlmcmFtZS5pZCA9IGlkO1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXG4gIHRyeSB7XG4gICAgYXJlYS52YWx1ZSA9IHBheWxvYWQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBzZXJpb3VzbHkgYnJva2VuIGJyb3dzZXJzIGdldCBoZXJlXG4gIH1cbiAgZm9ybS5zdWJtaXQoKTtcblxuICB2YXIgY29tcGxldGVkID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgZGVidWcoJ2NvbXBsZXRlZCcsIGlkLCBlcnIpO1xuICAgIGlmICghaWZyYW1lLm9uZXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGlmcmFtZS5vbmVycm9yID0gaWZyYW1lLm9ubG9hZCA9IG51bGw7XG4gICAgLy8gT3BlcmEgbWluaSBkb2Vzbid0IGxpa2UgaWYgd2UgR0MgaWZyYW1lXG4gICAgLy8gaW1tZWRpYXRlbHksIHRodXMgdGhpcyB0aW1lb3V0LlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnY2xlYW5pbmcgdXAnLCBpZCk7XG4gICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgaWZyYW1lID0gbnVsbDtcbiAgICB9LCA1MDApO1xuICAgIGFyZWEudmFsdWUgPSAnJztcbiAgICAvLyBJdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZWN0IGlmIHRoZSBpZnJhbWUgc3VjY2VlZGVkIG9yXG4gICAgLy8gZmFpbGVkIHRvIHN1Ym1pdCBvdXIgZm9ybS5cbiAgICBjYWxsYmFjayhlcnIpO1xuICB9O1xuICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmVycm9yJywgaWQpO1xuICAgIGNvbXBsZXRlZCgpO1xuICB9O1xuICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ubG9hZCcsIGlkKTtcbiAgICBjb21wbGV0ZWQoKTtcbiAgfTtcbiAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1Zygnb25yZWFkeXN0YXRlY2hhbmdlJywgaWQsIGlmcmFtZS5yZWFkeVN0YXRlLCBlKTtcbiAgICBpZiAoaWZyYW1lLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdhYm9ydGVkJywgaWQpO1xuICAgIGNvbXBsZXRlZChuZXcgRXJyb3IoJ0Fib3J0ZWQnKSk7XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9yYW5kb21cIjo1MCxcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NX1dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2V2ZW50JylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3NlcicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyOnhkcicpO1xufVxuXG4vLyBSZWZlcmVuY2VzOlxuLy8gICBodHRwOi8vYWpheGlhbi5jb20vYXJjaGl2ZXMvMTAwLWxpbmUtYWpheC13cmFwcGVyXG4vLyAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzI4ODA2MCh2PVZTLjg1KS5hc3B4XG5cbmZ1bmN0aW9uIFhEUk9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCkge1xuICBkZWJ1ZyhtZXRob2QsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhYRFJPYmplY3QsIEV2ZW50RW1pdHRlcik7XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBheWxvYWQpIHtcbiAgZGVidWcoJ19zdGFydCcpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB4ZHIgPSBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCk7XG4gIC8vIElFIGNhY2hlcyBldmVuIFBPU1RzXG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ3Q9JyArICgrbmV3IERhdGUoKSkpO1xuXG4gIHhkci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29uZXJyb3InKTtcbiAgICBzZWxmLl9lcnJvcigpO1xuICB9O1xuICB4ZHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29udGltZW91dCcpO1xuICAgIHNlbGYuX2Vycm9yKCk7XG4gIH07XG4gIHhkci5vbnByb2dyZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3Byb2dyZXNzJywgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgc2VsZi5lbWl0KCdjaHVuaycsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gIH07XG4gIHhkci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygnbG9hZCcpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgfTtcbiAgdGhpcy54ZHIgPSB4ZHI7XG4gIHRoaXMudW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgfSk7XG4gIHRyeSB7XG4gICAgLy8gRmFpbHMgd2l0aCBBY2Nlc3NEZW5pZWQgaWYgcG9ydCBudW1iZXIgaXMgYm9ndXNcbiAgICB0aGlzLnhkci5vcGVuKG1ldGhvZCwgdXJsKTtcbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICB0aGlzLnhkci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgIH1cbiAgICB0aGlzLnhkci5zZW5kKHBheWxvYWQpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgdGhpcy5fZXJyb3IoKTtcbiAgfVxufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKGFib3J0KSB7XG4gIGRlYnVnKCdjbGVhbnVwJywgYWJvcnQpO1xuICBpZiAoIXRoaXMueGRyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGV2ZW50VXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcblxuICB0aGlzLnhkci5vbnRpbWVvdXQgPSB0aGlzLnhkci5vbmVycm9yID0gdGhpcy54ZHIub25wcm9ncmVzcyA9IHRoaXMueGRyLm9ubG9hZCA9IG51bGw7XG4gIGlmIChhYm9ydCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhkci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gIH1cbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLnhkciA9IG51bGw7XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKHRydWUpO1xufTtcblxuLy8gSUUgOC85IGlmIHRoZSByZXF1ZXN0IHRhcmdldCB1c2VzIHRoZSBzYW1lIHNjaGVtZSAtICM3OVxuWERST2JqZWN0LmVuYWJsZWQgPSAhIShnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgYnJvd3Nlci5oYXNEb21haW4oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gWERST2JqZWN0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9icm93c2VyXCI6NDQsXCIuLi8uLi91dGlscy9ldmVudFwiOjQ2LFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBYaHJEcml2ZXIgPSByZXF1aXJlKCcuLi9kcml2ZXIveGhyJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJDb3JzT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gIFhockRyaXZlci5jYWxsKHRoaXMsIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKTtcbn1cblxuaW5oZXJpdHMoWEhSQ29yc09iamVjdCwgWGhyRHJpdmVyKTtcblxuWEhSQ29yc09iamVjdC5lbmFibGVkID0gWGhyRHJpdmVyLmVuYWJsZWQgJiYgWGhyRHJpdmVyLnN1cHBvcnRzQ09SUztcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJDb3JzT2JqZWN0O1xuXG59LHtcIi4uL2RyaXZlci94aHJcIjoxNyxcImluaGVyaXRzXCI6NTd9XSwzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJGYWtlKC8qIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzICovKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdGhpcy50byA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsICd7fScpO1xuICB9LCBYSFJGYWtlLnRpbWVvdXQpO1xufVxuXG5pbmhlcml0cyhYSFJGYWtlLCBFdmVudEVtaXR0ZXIpO1xuXG5YSFJGYWtlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhclRpbWVvdXQodGhpcy50byk7XG59O1xuXG5YSFJGYWtlLnRpbWVvdXQgPSAyMDAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkZha2U7XG5cbn0se1wiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBYaHJEcml2ZXIgPSByZXF1aXJlKCcuLi9kcml2ZXIveGhyJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJMb2NhbE9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCAvKiwgb3B0cyAqLykge1xuICBYaHJEcml2ZXIuY2FsbCh0aGlzLCBtZXRob2QsIHVybCwgcGF5bG9hZCwge1xuICAgIG5vQ3JlZGVudGlhbHM6IHRydWVcbiAgfSk7XG59XG5cbmluaGVyaXRzKFhIUkxvY2FsT2JqZWN0LCBYaHJEcml2ZXIpO1xuXG5YSFJMb2NhbE9iamVjdC5lbmFibGVkID0gWGhyRHJpdmVyLmVuYWJsZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSTG9jYWxPYmplY3Q7XG5cbn0se1wiLi4vZHJpdmVyL3hoclwiOjE3LFwiaW5oZXJpdHNcIjo1N31dLDM4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2V2ZW50JylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3VybCcpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgV2Vic29ja2V0RHJpdmVyID0gcmVxdWlyZSgnLi9kcml2ZXIvd2Vic29ja2V0JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OndlYnNvY2tldCcpO1xufVxuXG5mdW5jdGlvbiBXZWJTb2NrZXRUcmFuc3BvcnQodHJhbnNVcmwsIGlnbm9yZSwgb3B0aW9ucykge1xuICBpZiAoIVdlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICBkZWJ1ZygnY29uc3RydWN0b3InLCB0cmFuc1VybCk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0cmFuc1VybCwgJy93ZWJzb2NrZXQnKTtcbiAgaWYgKHVybC5zbGljZSgwLCA1KSA9PT0gJ2h0dHBzJykge1xuICAgIHVybCA9ICd3c3MnICsgdXJsLnNsaWNlKDUpO1xuICB9IGVsc2Uge1xuICAgIHVybCA9ICd3cycgKyB1cmwuc2xpY2UoNCk7XG4gIH1cbiAgdGhpcy51cmwgPSB1cmw7XG5cbiAgdGhpcy53cyA9IG5ldyBXZWJzb2NrZXREcml2ZXIodGhpcy51cmwsIFtdLCBvcHRpb25zKTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UgZXZlbnQnLCBlLmRhdGEpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGUuZGF0YSk7XG4gIH07XG4gIC8vIEZpcmVmb3ggaGFzIGFuIGludGVyZXN0aW5nIGJ1Zy4gSWYgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBpc1xuICAvLyBjcmVhdGVkIGFmdGVyIG9udW5sb2FkLCBpdCBzdGF5cyBhbGl2ZSBldmVuIHdoZW4gdXNlclxuICAvLyBuYXZpZ2F0ZXMgYXdheSBmcm9tIHRoZSBwYWdlLiBJbiBzdWNoIHNpdHVhdGlvbiBsZXQncyBsaWUgLVxuICAvLyBsZXQncyBub3Qgb3BlbiB0aGUgd3MgY29ubmVjdGlvbiBhdCBhbGwuIFNlZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NvY2tqcy9zb2NranMtY2xpZW50L2lzc3Vlcy8yOFxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTYwODVcbiAgdGhpcy51bmxvYWRSZWYgPSB1dGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3VubG9hZCcpO1xuICAgIHNlbGYud3MuY2xvc2UoKTtcbiAgfSk7XG4gIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnY2xvc2UgZXZlbnQnLCBlLmNvZGUsIGUucmVhc29uKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZS5jb2RlLCBlLnJlYXNvbik7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Vycm9yIGV2ZW50JywgZSk7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIDEwMDYsICdXZWJTb2NrZXQgY29ubmVjdGlvbiBicm9rZW4nKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH07XG59XG5cbmluaGVyaXRzKFdlYlNvY2tldFRyYW5zcG9ydCwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgbXNnID0gJ1snICsgZGF0YSArICddJztcbiAgZGVidWcoJ3NlbmQnLCBtc2cpO1xuICB0aGlzLndzLnNlbmQobXNnKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHZhciB3cyA9IHRoaXMud3M7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgaWYgKHdzKSB7XG4gICAgd3MuY2xvc2UoKTtcbiAgfVxufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdmFyIHdzID0gdGhpcy53cztcbiAgaWYgKHdzKSB7XG4gICAgd3Mub25tZXNzYWdlID0gd3Mub25jbG9zZSA9IHdzLm9uZXJyb3IgPSBudWxsO1xuICB9XG4gIHV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy53cyA9IG51bGw7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnZW5hYmxlZCcpO1xuICByZXR1cm4gISFXZWJzb2NrZXREcml2ZXI7XG59O1xuV2ViU29ja2V0VHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnd2Vic29ja2V0JztcblxuLy8gSW4gdGhlb3J5LCB3cyBzaG91bGQgcmVxdWlyZSAxIHJvdW5kIHRyaXAuIEJ1dCBpbiBjaHJvbWUsIHRoaXMgaXNcbi8vIG5vdCB2ZXJ5IHN0YWJsZSBvdmVyIFNTTC4gTW9zdCBsaWtlbHkgYSB3cyBjb25uZWN0aW9uIHJlcXVpcmVzIGFcbi8vIHNlcGFyYXRlIFNTTCBjb25uZWN0aW9uLCBpbiB3aGljaCBjYXNlIDIgcm91bmQgdHJpcHMgYXJlIGFuXG4vLyBhYnNvbHV0ZSBtaW51bXVtLlxuV2ViU29ja2V0VHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi91dGlscy91cmxcIjo1MixcIi4vZHJpdmVyL3dlYnNvY2tldFwiOjE5LFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGRyU3RyZWFtaW5nVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi94ZHItc3RyZWFtaW5nJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYRFJPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94ZHInKVxuICA7XG5cbmZ1bmN0aW9uIFhkclBvbGxpbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYRFJPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocicsIFhoclJlY2VpdmVyLCBYRFJPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYZHJQb2xsaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YZHJQb2xsaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBYZHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZDtcblhkclBvbGxpbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4ZHItcG9sbGluZyc7XG5YZHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYZHJQb2xsaW5nVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94ZHJcIjozNCxcIi4veGRyLXN0cmVhbWluZ1wiOjQwLFwiaW5oZXJpdHNcIjo1N31dLDQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhEUk9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hkcicpXG4gIDtcblxuLy8gQWNjb3JkaW5nIHRvOlxuLy8gICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2NDE1MDcvZGV0ZWN0LWJyb3dzZXItc3VwcG9ydC1mb3ItY3Jvc3MtZG9tYWluLXhtbGh0dHByZXF1ZXN0c1xuLy8gICBodHRwOi8vaGFja3MubW96aWxsYS5vcmcvMjAwOS8wNy9jcm9zcy1zaXRlLXhtbGh0dHByZXF1ZXN0LXdpdGgtY29ycy9cblxuZnVuY3Rpb24gWGRyU3RyZWFtaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XG59XG5cbmluaGVyaXRzKFhkclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLmNvb2tpZV9uZWVkZWQgfHwgaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBYRFJPYmplY3QuZW5hYmxlZCAmJiBpbmZvLnNhbWVTY2hlbWU7XG59O1xuXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4ZHItc3RyZWFtaW5nJztcblhkclN0cmVhbWluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94ZHJcIjozNCxcImluaGVyaXRzXCI6NTd9XSw0MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgO1xuXG5mdW5jdGlvbiBYaHJQb2xsaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiAhWEhSQ29yc09iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYaHJQb2xsaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YaHJQb2xsaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiBpbmZvLnNhbWVPcmlnaW4pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gWEhSQ29yc09iamVjdC5lbmFibGVkO1xufTtcblxuWGhyUG9sbGluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hoci1wb2xsaW5nJztcblhoclBvbGxpbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclBvbGxpbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hoci1jb3JzXCI6MzUsXCIuL3NlbmRlci94aHItbG9jYWxcIjozNyxcImluaGVyaXRzXCI6NTd9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbHMvYnJvd3NlcicpXG4gIDtcblxuZnVuY3Rpb24gWGhyU3RyZWFtaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiAhWEhSQ29yc09iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyX3N0cmVhbWluZycsIFhoclJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGhyU3RyZWFtaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBPcGVyYSBkb2Vzbid0IHN1cHBvcnQgeGhyLXN0cmVhbWluZyAjNjBcbiAgLy8gQnV0IGl0IG1pZ2h0IGJlIGFibGUgdG8gIzkyXG4gIGlmIChicm93c2VyLmlzT3BlcmEoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBYSFJDb3JzT2JqZWN0LmVuYWJsZWQ7XG59O1xuXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItc3RyZWFtaW5nJztcblhoclN0cmVhbWluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbi8vIFNhZmFyaSBnZXRzIGNvbmZ1c2VkIHdoZW4gYSBzdHJlYW1pbmcgYWpheCByZXF1ZXN0IGlzIHN0YXJ0ZWRcbi8vIGJlZm9yZSBvbmxvYWQuIFRoaXMgY2F1c2VzIHRoZSBsb2FkIGluZGljYXRvciB0byBzcGluIGluZGVmaW5ldGVseS5cbi8vIE9ubHkgcmVxdWlyZSBib2R5IHdoZW4gdXNlZCBpbiBhIGJyb3dzZXJcblhoclN0cmVhbWluZ1RyYW5zcG9ydC5uZWVkQm9keSA9ICEhZ2xvYmFsLmRvY3VtZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclN0cmVhbWluZ1RyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hoci1jb3JzXCI6MzUsXCIuL3NlbmRlci94aHItbG9jYWxcIjozNyxcImluaGVyaXRzXCI6NTd9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbmlmIChnbG9iYWwuY3J5cHRvICYmIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIG1vZHVsZS5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBnbG9iYWwuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBieXRlc1tpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1Nik7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbiAgfTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzT3BlcmE6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmXG4gICAgICAvb3BlcmEvaS50ZXN0KGdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4sIGlzS29ucXVlcm9yOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ2xvYmFsLm5hdmlnYXRvciAmJlxuICAgICAgL2tvbnF1ZXJvci9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLy8gIzE4NyB3cmFwIGRvY3VtZW50LmRvbWFpbiBpbiB0cnkvY2F0Y2ggYmVjYXVzZSBvZiBXUDggZnJvbSBmaWxlOi8vL1xuLCBoYXNEb21haW46IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBub24tYnJvd3NlciBjbGllbnQgYWx3YXlzIGhhcyBhIGRvbWFpblxuICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuICEhZ2xvYmFsLmRvY3VtZW50LmRvbWFpbjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpO1xuXG4vLyBTb21lIGV4dHJhIGNoYXJhY3RlcnMgdGhhdCBDaHJvbWUgZ2V0cyB3cm9uZywgYW5kIHN1YnN0aXR1dGVzIHdpdGhcbi8vIHNvbWV0aGluZyBlbHNlIG9uIHRoZSB3aXJlLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbnZhciBleHRyYUVzY2FwYWJsZSA9IC9bXFx4MDAtXFx4MWZcXHVkODAwLVxcdWRmZmZcXHVmZmZlXFx1ZmZmZlxcdTAzMDAtXFx1MDMzM1xcdTAzM2QtXFx1MDM0NlxcdTAzNGEtXFx1MDM0Y1xcdTAzNTAtXFx1MDM1MlxcdTAzNTctXFx1MDM1OFxcdTAzNWMtXFx1MDM2MlxcdTAzNzRcXHUwMzdlXFx1MDM4N1xcdTA1OTEtXFx1MDVhZlxcdTA1YzRcXHUwNjEwLVxcdTA2MTdcXHUwNjUzLVxcdTA2NTRcXHUwNjU3LVxcdTA2NWJcXHUwNjVkLVxcdTA2NWVcXHUwNmRmLVxcdTA2ZTJcXHUwNmViLVxcdTA2ZWNcXHUwNzMwXFx1MDczMi1cXHUwNzMzXFx1MDczNS1cXHUwNzM2XFx1MDczYVxcdTA3M2RcXHUwNzNmLVxcdTA3NDFcXHUwNzQzXFx1MDc0NVxcdTA3NDdcXHUwN2ViLVxcdTA3ZjFcXHUwOTUxXFx1MDk1OC1cXHUwOTVmXFx1MDlkYy1cXHUwOWRkXFx1MDlkZlxcdTBhMzNcXHUwYTM2XFx1MGE1OS1cXHUwYTViXFx1MGE1ZVxcdTBiNWMtXFx1MGI1ZFxcdTBlMzgtXFx1MGUzOVxcdTBmNDNcXHUwZjRkXFx1MGY1MlxcdTBmNTdcXHUwZjVjXFx1MGY2OVxcdTBmNzItXFx1MGY3NlxcdTBmNzhcXHUwZjgwLVxcdTBmODNcXHUwZjkzXFx1MGY5ZFxcdTBmYTJcXHUwZmE3XFx1MGZhY1xcdTBmYjlcXHUxOTM5LVxcdTE5M2FcXHUxYTE3XFx1MWI2YlxcdTFjZGEtXFx1MWNkYlxcdTFkYzAtXFx1MWRjZlxcdTFkZmNcXHUxZGZlXFx1MWY3MVxcdTFmNzNcXHUxZjc1XFx1MWY3N1xcdTFmNzlcXHUxZjdiXFx1MWY3ZFxcdTFmYmJcXHUxZmJlXFx1MWZjOVxcdTFmY2JcXHUxZmQzXFx1MWZkYlxcdTFmZTNcXHUxZmViXFx1MWZlZS1cXHUxZmVmXFx1MWZmOVxcdTFmZmJcXHUxZmZkXFx1MjAwMC1cXHUyMDAxXFx1MjBkMC1cXHUyMGQxXFx1MjBkNC1cXHUyMGQ3XFx1MjBlNy1cXHUyMGU5XFx1MjEyNlxcdTIxMmEtXFx1MjEyYlxcdTIzMjktXFx1MjMyYVxcdTJhZGNcXHUzMDJiLVxcdTMwMmNcXHVhYWIyLVxcdWFhYjNcXHVmOTAwLVxcdWZhMGRcXHVmYTEwXFx1ZmExMlxcdWZhMTUtXFx1ZmExZVxcdWZhMjBcXHVmYTIyXFx1ZmEyNS1cXHVmYTI2XFx1ZmEyYS1cXHVmYTJkXFx1ZmEzMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIxZFxcdWZiMWZcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MC1cXHVmYjQxXFx1ZmI0My1cXHVmYjQ0XFx1ZmI0Ni1cXHVmYjRlXFx1ZmZmMC1cXHVmZmZmXS9nXG4gICwgZXh0cmFMb29rdXA7XG5cbi8vIFRoaXMgbWF5IGJlIHF1aXRlIHNsb3csIHNvIGxldCdzIGRlbGF5IHVudGlsIHVzZXIgYWN0dWFsbHkgdXNlcyBiYWRcbi8vIGNoYXJhY3RlcnMuXG52YXIgdW5yb2xsTG9va3VwID0gZnVuY3Rpb24oZXNjYXBhYmxlKSB7XG4gIHZhciBpO1xuICB2YXIgdW5yb2xsZWQgPSB7fTtcbiAgdmFyIGMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IDY1NTM2OyBpKyspIHtcbiAgICBjLnB1c2goIFN0cmluZy5mcm9tQ2hhckNvZGUoaSkgKTtcbiAgfVxuICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgYy5qb2luKCcnKS5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgIHVucm9sbGVkWyBhIF0gPSAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICByZXR1cm4gJyc7XG4gIH0pO1xuICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgcmV0dXJuIHVucm9sbGVkO1xufTtcblxuLy8gUXVvdGUgc3RyaW5nLCBhbHNvIHRha2luZyBjYXJlIG9mIHVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IGJyb3dzZXJzXG4vLyBvZnRlbiBicmVhay4gRXNwZWNpYWxseSwgdGFrZSBjYXJlIG9mIHVuaWNvZGUgc3Vycm9nYXRlczpcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFwcGluZ19vZl9Vbmljb2RlX2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHF1b3RlOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgcXVvdGVkID0gSlNPTjMuc3RyaW5naWZ5KHN0cmluZyk7XG5cbiAgICAvLyBJbiBtb3N0IGNhc2VzIHRoaXMgc2hvdWxkIGJlIHZlcnkgZmFzdCBhbmQgZ29vZCBlbm91Z2guXG4gICAgZXh0cmFFc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICBpZiAoIWV4dHJhRXNjYXBhYmxlLnRlc3QocXVvdGVkKSkge1xuICAgICAgcmV0dXJuIHF1b3RlZDtcbiAgICB9XG5cbiAgICBpZiAoIWV4dHJhTG9va3VwKSB7XG4gICAgICBleHRyYUxvb2t1cCA9IHVucm9sbExvb2t1cChleHRyYUVzY2FwYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1b3RlZC5yZXBsYWNlKGV4dHJhRXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gZXh0cmFMb29rdXBbYV07XG4gICAgfSk7XG4gIH1cbn07XG5cbn0se1wianNvbjNcIjo1OH1dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4vcmFuZG9tJyk7XG5cbnZhciBvblVubG9hZCA9IHt9XG4gICwgYWZ0ZXJVbmxvYWQgPSBmYWxzZVxuICAgIC8vIGRldGVjdCBnb29nbGUgY2hyb21lIHBhY2thZ2VkIGFwcHMgYmVjYXVzZSB0aGV5IGRvbid0IGFsbG93IHRoZSAndW5sb2FkJyBldmVudFxuICAsIGlzQ2hyb21lUGFja2FnZWRBcHAgPSBnbG9iYWwuY2hyb21lICYmIGdsb2JhbC5jaHJvbWUuYXBwICYmIGdsb2JhbC5jaHJvbWUuYXBwLnJ1bnRpbWVcbiAgO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXR0YWNoRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICAgIC8vIElFIHF1aXJrcy5cbiAgICAgIC8vIEFjY29yZGluZyB0bzogaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxuICAgICAgLy8gdGhlIG1lc3NhZ2UgZ2V0cyBkZWxpdmVyZWQgb25seSB0byAnZG9jdW1lbnQnLCBub3QgJ3dpbmRvdycuXG4gICAgICBnbG9iYWwuZG9jdW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAvLyBJIGdldCAnd2luZG93JyBmb3IgaWU4LlxuICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4sIGRldGFjaEV2ZW50OiBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZ2xvYmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmRldGFjaEV2ZW50KSB7XG4gICAgICBnbG9iYWwuZG9jdW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICBnbG9iYWwuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiwgdW5sb2FkQWRkOiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIGlmIChpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcmVmID0gcmFuZG9tLnN0cmluZyg4KTtcbiAgICBvblVubG9hZFtyZWZdID0gbGlzdGVuZXI7XG4gICAgaWYgKGFmdGVyVW5sb2FkKSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMudHJpZ2dlclVubG9hZENhbGxiYWNrcywgMCk7XG4gICAgfVxuICAgIHJldHVybiByZWY7XG4gIH1cblxuLCB1bmxvYWREZWw6IGZ1bmN0aW9uKHJlZikge1xuICAgIGlmIChyZWYgaW4gb25VbmxvYWQpIHtcbiAgICAgIGRlbGV0ZSBvblVubG9hZFtyZWZdO1xuICAgIH1cbiAgfVxuXG4sIHRyaWdnZXJVbmxvYWRDYWxsYmFja3M6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHJlZiBpbiBvblVubG9hZCkge1xuICAgICAgb25VbmxvYWRbcmVmXSgpO1xuICAgICAgZGVsZXRlIG9uVW5sb2FkW3JlZl07XG4gICAgfVxuICB9XG59O1xuXG52YXIgdW5sb2FkVHJpZ2dlcmVkID0gZnVuY3Rpb24oKSB7XG4gIGlmIChhZnRlclVubG9hZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhZnRlclVubG9hZCA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzLnRyaWdnZXJVbmxvYWRDYWxsYmFja3MoKTtcbn07XG5cbi8vICd1bmxvYWQnIGFsb25lIGlzIG5vdCByZWxpYWJsZSBpbiBvcGVyYSB3aXRoaW4gYW4gaWZyYW1lLCBidXQgd2Vcbi8vIGNhbid0IHVzZSBgYmVmb3JldW5sb2FkYCBhcyBJRSBmaXJlcyBpdCBvbiBqYXZhc2NyaXB0OiBsaW5rcy5cbmlmICghaXNDaHJvbWVQYWNrYWdlZEFwcCkge1xuICBtb2R1bGUuZXhwb3J0cy5hdHRhY2hFdmVudCgndW5sb2FkJywgdW5sb2FkVHJpZ2dlcmVkKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9yYW5kb21cIjo1MH1dLDQ3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vZXZlbnQnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Jyb3dzZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6aWZyYW1lJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXUHJlZml4OiAnX2pwJ1xuLCBjdXJyZW50V2luZG93SWQ6IG51bGxcblxuLCBwb2xsdXRlR2xvYmFsTmFtZXNwYWNlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIShtb2R1bGUuZXhwb3J0cy5XUHJlZml4IGluIGdsb2JhbCkpIHtcbiAgICAgIGdsb2JhbFttb2R1bGUuZXhwb3J0cy5XUHJlZml4XSA9IHt9O1xuICAgIH1cbiAgfVxuXG4sIHBvc3RNZXNzYWdlOiBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gICAgaWYgKGdsb2JhbC5wYXJlbnQgIT09IGdsb2JhbCkge1xuICAgICAgZ2xvYmFsLnBhcmVudC5wb3N0TWVzc2FnZShKU09OMy5zdHJpbmdpZnkoe1xuICAgICAgICB3aW5kb3dJZDogbW9kdWxlLmV4cG9ydHMuY3VycmVudFdpbmRvd0lkXG4gICAgICAsIHR5cGU6IHR5cGVcbiAgICAgICwgZGF0YTogZGF0YSB8fCAnJ1xuICAgICAgfSksICcqJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdDYW5ub3QgcG9zdE1lc3NhZ2UsIG5vIHBhcmVudCB3aW5kb3cuJywgdHlwZSwgZGF0YSk7XG4gICAgfVxuICB9XG5cbiwgY3JlYXRlSWZyYW1lOiBmdW5jdGlvbihpZnJhbWVVcmwsIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgaWZyYW1lID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIHZhciB0cmVmLCB1bmxvYWRSZWY7XG4gICAgdmFyIHVuYXR0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygndW5hdHRhY2gnKTtcbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIC8vIEV4cGxvcmVyIGhhZCBwcm9ibGVtcyB3aXRoIHRoYXQuXG4gICAgICB0cnkge1xuICAgICAgICBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgICAgaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgIHVuYXR0YWNoKCk7XG4gICAgICAgIC8vIFRoaXMgdGltZW91dCBtYWtlcyBjaHJvbWUgZmlyZSBvbmJlZm9yZXVubG9hZCBldmVudFxuICAgICAgICAvLyB3aXRoaW4gaWZyYW1lLiBXaXRob3V0IHRoZSB0aW1lb3V0IGl0IGdvZXMgc3RyYWlnaHQgdG9cbiAgICAgICAgLy8gb251bmxvYWQuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWZyYW1lID0gbnVsbDtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGV2ZW50VXRpbHMudW5sb2FkRGVsKHVubG9hZFJlZik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgZGVidWcoJ29uZXJyb3InLCBlcnIpO1xuICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGVycm9yQ2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwb3N0ID0gZnVuY3Rpb24obXNnLCBvcmlnaW4pIHtcbiAgICAgIGRlYnVnKCdwb3N0JywgbXNnLCBvcmlnaW4pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1zZywgb3JpZ2luKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmcmFtZS5zcmMgPSBpZnJhbWVVcmw7XG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcignb25lcnJvcicpO1xuICAgIH07XG4gICAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ29ubG9hZCcpO1xuICAgICAgLy8gYG9ubG9hZGAgaXMgdHJpZ2dlcmVkIGJlZm9yZSBzY3JpcHRzIG9uIHRoZSBpZnJhbWUgYXJlXG4gICAgICAvLyBleGVjdXRlZC4gR2l2ZSBpdCBmZXcgc2Vjb25kcyB0byBhY3R1YWxseSBsb2FkIHN0dWZmLlxuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9uZXJyb3IoJ29ubG9hZCB0aW1lb3V0Jyk7XG4gICAgICB9LCAyMDAwKTtcbiAgICB9O1xuICAgIGdsb2JhbC5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCd0aW1lb3V0Jyk7XG4gICAgfSwgMTUwMDApO1xuICAgIHVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGNsZWFudXApO1xuICAgIHJldHVybiB7XG4gICAgICBwb3N0OiBwb3N0XG4gICAgLCBjbGVhbnVwOiBjbGVhbnVwXG4gICAgLCBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgfTtcbiAgfVxuXG4vKiBlc2xpbnQgbm8tdW5kZWY6IFwib2ZmXCIsIG5ldy1jYXA6IFwib2ZmXCIgKi9cbiwgY3JlYXRlSHRtbGZpbGU6IGZ1bmN0aW9uKGlmcmFtZVVybCwgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuICAgIHZhciBkb2MgPSBuZXcgZ2xvYmFsW2F4b10oJ2h0bWxmaWxlJyk7XG4gICAgdmFyIHRyZWYsIHVubG9hZFJlZjtcbiAgICB2YXIgaWZyYW1lO1xuICAgIHZhciB1bmF0dGFjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgZXZlbnRVdGlscy51bmxvYWREZWwodW5sb2FkUmVmKTtcbiAgICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgaWZyYW1lID0gZG9jID0gbnVsbDtcbiAgICAgICAgQ29sbGVjdEdhcmJhZ2UoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24ocikge1xuICAgICAgZGVidWcoJ29uZXJyb3InLCByKTtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBlcnJvckNhbGxiYWNrKHIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZG9jLm9wZW4oKTtcbiAgICBkb2Mud3JpdGUoJzxodG1sPjxzJyArICdjcmlwdD4nICtcbiAgICAgICAgICAgICAgJ2RvY3VtZW50LmRvbWFpbj1cIicgKyBnbG9iYWwuZG9jdW1lbnQuZG9tYWluICsgJ1wiOycgK1xuICAgICAgICAgICAgICAnPC9zJyArICdjcmlwdD48L2h0bWw+Jyk7XG4gICAgZG9jLmNsb3NlKCk7XG4gICAgZG9jLnBhcmVudFdpbmRvd1ttb2R1bGUuZXhwb3J0cy5XUHJlZml4XSA9IGdsb2JhbFttb2R1bGUuZXhwb3J0cy5XUHJlZml4XTtcbiAgICB2YXIgYyA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChjKTtcbiAgICBpZnJhbWUgPSBkb2MuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgYy5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIGlmcmFtZS5zcmMgPSBpZnJhbWVVcmw7XG4gICAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ29uZXJyb3InKTtcbiAgICB9O1xuICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcigndGltZW91dCcpO1xuICAgIH0sIDE1MDAwKTtcbiAgICB1bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChjbGVhbnVwKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zdDogcG9zdFxuICAgICwgY2xlYW51cDogY2xlYW51cFxuICAgICwgbG9hZGVkOiB1bmF0dGFjaFxuICAgIH07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmlmcmFtZUVuYWJsZWQgPSBmYWxzZTtcbmlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgLy8gcG9zdE1lc3NhZ2UgbWlzYmVoYXZlcyBpbiBrb25xdWVyb3IgNC42LjUgLSB0aGUgbWVzc2FnZXMgYXJlIGRlbGl2ZXJlZCB3aXRoXG4gIC8vIGh1Z2UgZGVsYXksIG9yIG5vdCBhdCBhbGwuXG4gIG1vZHVsZS5leHBvcnRzLmlmcmFtZUVuYWJsZWQgPSAodHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgIHR5cGVvZiBnbG9iYWwucG9zdE1lc3NhZ2UgPT09ICdvYmplY3QnKSAmJiAoIWJyb3dzZXIuaXNLb25xdWVyb3IoKSk7XG59XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vYnJvd3NlclwiOjQ0LFwiLi9ldmVudFwiOjQ2LFwiZGVidWdcIjo1NSxcImpzb24zXCI6NTh9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBsb2dPYmplY3QgPSB7fTtcblsnbG9nJywgJ2RlYnVnJywgJ3dhcm4nXS5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICB2YXIgbGV2ZWxFeGlzdHM7XG5cbiAgdHJ5IHtcbiAgICBsZXZlbEV4aXN0cyA9IGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlW2xldmVsXSAmJiBnbG9iYWwuY29uc29sZVtsZXZlbF0uYXBwbHk7XG4gIH0gY2F0Y2goZSkge1xuICAgIC8vIGRvIG5vdGhpbmdcbiAgfVxuXG4gIGxvZ09iamVjdFtsZXZlbF0gPSBsZXZlbEV4aXN0cyA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdLmFwcGx5KGdsb2JhbC5jb25zb2xlLCBhcmd1bWVudHMpO1xuICB9IDogKGxldmVsID09PSAnbG9nJyA/IGZ1bmN0aW9uICgpIHt9IDogbG9nT2JqZWN0LmxvZyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2dPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc09iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICB9XG5cbiwgZXh0ZW5kOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIXRoaXMuaXNPYmplY3Qob2JqKSkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgdmFyIHNvdXJjZSwgcHJvcDtcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBwcm9wKSkge1xuICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG59O1xuXG59LHt9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBjcnlwdG86dHJ1ZSAqL1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG4vLyBUaGlzIHN0cmluZyBoYXMgbGVuZ3RoIDMyLCBhIHBvd2VyIG9mIDIsIHNvIHRoZSBtb2R1bHVzIGRvZXNuJ3QgaW50cm9kdWNlIGFcbi8vIGJpYXMuXG52YXIgX3JhbmRvbVN0cmluZ0NoYXJzID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Jztcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdHJpbmc6IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBtYXggPSBfcmFuZG9tU3RyaW5nQ2hhcnMubGVuZ3RoO1xuICAgIHZhciBieXRlcyA9IGNyeXB0by5yYW5kb21CeXRlcyhsZW5ndGgpO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXQucHVzaChfcmFuZG9tU3RyaW5nQ2hhcnMuc3Vic3RyKGJ5dGVzW2ldICUgbWF4LCAxKSk7XG4gICAgfVxuICAgIHJldHVybiByZXQuam9pbignJyk7XG4gIH1cblxuLCBudW1iZXI6IGZ1bmN0aW9uKG1heCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXgpO1xuICB9XG5cbiwgbnVtYmVyU3RyaW5nOiBmdW5jdGlvbihtYXgpIHtcbiAgICB2YXIgdCA9ICgnJyArIChtYXggLSAxKSkubGVuZ3RoO1xuICAgIHZhciBwID0gbmV3IEFycmF5KHQgKyAxKS5qb2luKCcwJyk7XG4gICAgcmV0dXJuIChwICsgdGhpcy5udW1iZXIobWF4KSkuc2xpY2UoLXQpO1xuICB9XG59O1xuXG59LHtcImNyeXB0b1wiOjQzfV0sNTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczp0cmFuc3BvcnQnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHJldHVybiB7XG4gICAgZmlsdGVyVG9FbmFibGVkOiBmdW5jdGlvbih0cmFuc3BvcnRzV2hpdGVsaXN0LCBpbmZvKSB7XG4gICAgICB2YXIgdHJhbnNwb3J0cyA9IHtcbiAgICAgICAgbWFpbjogW11cbiAgICAgICwgZmFjYWRlOiBbXVxuICAgICAgfTtcbiAgICAgIGlmICghdHJhbnNwb3J0c1doaXRlbGlzdCkge1xuICAgICAgICB0cmFuc3BvcnRzV2hpdGVsaXN0ID0gW107XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0cmFuc3BvcnRzV2hpdGVsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cmFuc3BvcnRzV2hpdGVsaXN0ID0gW3RyYW5zcG9ydHNXaGl0ZWxpc3RdO1xuICAgICAgfVxuXG4gICAgICBhdmFpbGFibGVUcmFuc3BvcnRzLmZvckVhY2goZnVuY3Rpb24odHJhbnMpIHtcbiAgICAgICAgaWYgKCF0cmFucykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFucy50cmFuc3BvcnROYW1lID09PSAnd2Vic29ja2V0JyAmJiBpbmZvLndlYnNvY2tldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBkZWJ1ZygnZGlzYWJsZWQgZnJvbSBzZXJ2ZXInLCAnd2Vic29ja2V0Jyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zcG9ydHNXaGl0ZWxpc3QubGVuZ3RoICYmXG4gICAgICAgICAgICB0cmFuc3BvcnRzV2hpdGVsaXN0LmluZGV4T2YodHJhbnMudHJhbnNwb3J0TmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgZGVidWcoJ25vdCBpbiB3aGl0ZWxpc3QnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnMuZW5hYmxlZChpbmZvKSkge1xuICAgICAgICAgIGRlYnVnKCdlbmFibGVkJywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgICAgdHJhbnNwb3J0cy5tYWluLnB1c2godHJhbnMpO1xuICAgICAgICAgIGlmICh0cmFucy5mYWNhZGVUcmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydHMuZmFjYWRlLnB1c2godHJhbnMuZmFjYWRlVHJhbnNwb3J0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ2Rpc2FibGVkJywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRyYW5zcG9ydHM7XG4gICAgfVxuICB9O1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTV9XSw1MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVVJMID0gcmVxdWlyZSgndXJsLXBhcnNlJyk7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6dXJsJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRPcmlnaW46IGZ1bmN0aW9uKHVybCkge1xuICAgIGlmICghdXJsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcCA9IG5ldyBVUkwodXJsKTtcbiAgICBpZiAocC5wcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHBvcnQgPSBwLnBvcnQ7XG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gKHAucHJvdG9jb2wgPT09ICdodHRwczonKSA/ICc0NDMnIDogJzgwJztcbiAgICB9XG5cbiAgICByZXR1cm4gcC5wcm90b2NvbCArICcvLycgKyBwLmhvc3RuYW1lICsgJzonICsgcG9ydDtcbiAgfVxuXG4sIGlzT3JpZ2luRXF1YWw6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5nZXRPcmlnaW4oYSkgPT09IHRoaXMuZ2V0T3JpZ2luKGIpO1xuICAgIGRlYnVnKCdzYW1lJywgYSwgYiwgcmVzKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiwgaXNTY2hlbWVFcXVhbDogZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiAoYS5zcGxpdCgnOicpWzBdID09PSBiLnNwbGl0KCc6JylbMF0pO1xuICB9XG5cbiwgYWRkUGF0aDogZnVuY3Rpb24gKHVybCwgcGF0aCkge1xuICAgIHZhciBxcyA9IHVybC5zcGxpdCgnPycpO1xuICAgIHJldHVybiBxc1swXSArIHBhdGggKyAocXNbMV0gPyAnPycgKyBxc1sxXSA6ICcnKTtcbiAgfVxuXG4sIGFkZFF1ZXJ5OiBmdW5jdGlvbiAodXJsLCBxKSB7XG4gICAgcmV0dXJuIHVybCArICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICgnPycgKyBxKSA6ICgnJicgKyBxKSk7XG4gIH1cbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwidXJsLXBhcnNlXCI6NjF9XSw1MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9ICcxLjEuNCc7XG5cbn0se31dLDU0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDBcbnZhciBtID0gcyAqIDYwXG52YXIgaCA9IG0gKiA2MFxudmFyIGQgPSBoICogMjRcbnZhciB5ID0gZCAqIDM2NS4yNVxuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsXG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID9cblx0XHRcdGZtdExvbmcodmFsKSA6XG5cdFx0XHRmbXRTaG9ydCh2YWwpXG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgKyBKU09OLnN0cmluZ2lmeSh2YWwpKVxufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cilcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDAwMCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoc3RyKVxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKVxuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeVxuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGRcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGhcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG1cbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHNcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnXG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnXG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nXG4gIH1cbiAgaWYgKG1zID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnXG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJ1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJ1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lXG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJ1xufVxuXG59LHt9XSw1NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi9kZWJ1Z1wiOjU2fV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWdbJ2RlZmF1bHQnXSA9IGNyZWF0ZURlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIC8vIGRpc2FibGVkP1xuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuICAgIGV4cG9ydHMuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG4gICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cblxuICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgZGVidWcudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5pbml0KSB7XG4gICAgZXhwb3J0cy5pbml0KGRlYnVnKTtcbiAgfVxuXG4gIHJldHVybiBkZWJ1Zztcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICBleHBvcnRzLm5hbWVzID0gW107XG4gIGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cblxufSx7XCJtc1wiOjU0fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cbn0se31dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICBcIm9iamVjdFwiOiB0cnVlXG4gIH07XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXG4gIC8vIGFuZCB0aGUgYHdpbmRvd2Agb2JqZWN0IGluIGJyb3dzZXJzLiBSaGlubyBleHBvcnRzIGEgYGdsb2JhbGAgZnVuY3Rpb25cbiAgLy8gaW5zdGVhZC5cbiAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcbiAgICAgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiB0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsO1xuXG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcInNlbGZcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xuICAgIGNvbnRleHQgfHwgKGNvbnRleHQgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG4gICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcbiAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcbiAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuICAgIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG4gICAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG4gICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAgIC8vIHN1cHBvcnRlZC5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG4gICAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG4gICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIixcbiAgICAgICAgICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCIsXG4gICAgICAgICAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cbiAgICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBpc1Byb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgICAzNDogJ1xcXFxcIicsXG4gICAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgICAgMTA6IFwiXFxcXG5cIixcbiAgICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG4gICAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG4gICAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xuICAgICAgICAgIHZhciBzeW1ib2xzID0gdXNlQ2hhckluZGV4ICYmIChjaGFySW5kZXhCdWdneSA/IHZhbHVlLnNwbGl0KFwiXCIpIDogdmFsdWUpO1xuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVzZUNoYXJJbmRleCA/IHN5bWJvbHNbaW5kZXhdIDogdmFsdWUuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcbiAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcbiAgICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXG4gICAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxuICAgICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cbiAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cbiAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXG4gICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04uc3RyaW5naWZ5YC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuICAgICAgICAgIGlmIChvYmplY3RUeXBlc1t0eXBlb2YgZmlsdGVyXSAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgICAgNDc6IFwiL1wiLFxuICAgICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgICAxMTA6IFwiXFxuXCIsXG4gICAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3IHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMiB8fCBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG4gICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG4gICAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHNbXCJydW5JbkNvbnRleHRcIl0gPSBydW5JbkNvbnRleHQ7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cblxuICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgcnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICAgIHZhciBuYXRpdmVKU09OID0gcm9vdC5KU09OLFxuICAgICAgICBwcmV2aW91c0pTT04gPSByb290W1wiSlNPTjNcIl0sXG4gICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcblxuICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcIkpTT04zXCJdID0ge1xuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxuICAgICAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXG4gICAgICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcbiAgICAgICAgICBpc1Jlc3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcbiAgICAgICAgICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTjM7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcm9vdC5KU09OID0ge1xuICAgICAgXCJwYXJzZVwiOiBKU09OMy5wYXJzZSxcbiAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxuICAgIH07XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDU5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogU2ltcGxlIHF1ZXJ5IHN0cmluZyBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBwYXJzZWQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnkpIHtcbiAgdmFyIHBhcnNlciA9IC8oW149PyZdKyk9PyhbXiZdKikvZ1xuICAgICwgcmVzdWx0ID0ge31cbiAgICAsIHBhcnQ7XG5cbiAgLy9cbiAgLy8gTGl0dGxlIG5pZnR5IHBhcnNpbmcgaGFjaywgbGV2ZXJhZ2UgdGhlIGZhY3QgdGhhdCBSZWdFeHAuZXhlYyBpbmNyZW1lbnRzXG4gIC8vIHRoZSBsYXN0SW5kZXggcHJvcGVydHkgc28gd2UgY2FuIGNvbnRpbnVlIGV4ZWN1dGluZyB0aGlzIGxvb3AgdW50aWwgd2UndmVcbiAgLy8gcGFyc2VkIGFsbCByZXN1bHRzLlxuICAvL1xuICBmb3IgKDtcbiAgICBwYXJ0ID0gcGFyc2VyLmV4ZWMocXVlcnkpO1xuICAgIHJlc3VsdFtkZWNvZGVVUklDb21wb25lbnQocGFydFsxXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRbMl0pXG4gICk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBxdWVyeSBzdHJpbmcgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBPcHRpb25hbCBwcmVmaXguXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdpZnkob2JqLCBwcmVmaXgpIHtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIHZhciBwYWlycyA9IFtdO1xuXG4gIC8vXG4gIC8vIE9wdGlvbmFsbHkgcHJlZml4IHdpdGggYSAnPycgaWYgbmVlZGVkXG4gIC8vXG4gIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByZWZpeCkgcHJlZml4ID0gJz8nO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsnPScrIGVuY29kZVVSSUNvbXBvbmVudChvYmpba2V5XSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWlycy5sZW5ndGggPyBwcmVmaXggKyBwYWlycy5qb2luKCcmJykgOiAnJztcbn1cblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmV4cG9ydHMuc3RyaW5naWZ5ID0gcXVlcnlzdHJpbmdpZnk7XG5leHBvcnRzLnBhcnNlID0gcXVlcnlzdHJpbmc7XG5cbn0se31dLDYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSdyZSByZXF1aXJlZCB0byBhZGQgYSBwb3J0IG51bWJlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZGVmYXVsdC1wb3J0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHBvcnQgUG9ydCBudW1iZXIgd2UgbmVlZCB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJcyBpdCBhIGRlZmF1bHQgcG9ydCBmb3IgdGhlIGdpdmVuIHByb3RvY29sXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlZChwb3J0LCBwcm90b2NvbCkge1xuICBwcm90b2NvbCA9IHByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gIHBvcnQgPSArcG9ydDtcblxuICBpZiAoIXBvcnQpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgY2FzZSAnaHR0cCc6XG4gICAgY2FzZSAnd3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA4MDtcblxuICAgIGNhc2UgJ2h0dHBzJzpcbiAgICBjYXNlICd3c3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA0NDM7XG5cbiAgICBjYXNlICdmdHAnOlxuICAgIHJldHVybiBwb3J0ICE9PSAyMTtcblxuICAgIGNhc2UgJ2dvcGhlcic6XG4gICAgcmV0dXJuIHBvcnQgIT09IDcwO1xuXG4gICAgY2FzZSAnZmlsZSc6XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHBvcnQgIT09IDA7XG59O1xuXG59LHt9XSw2MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKVxuICAsIGxvbGNhdGlvbiA9IHJlcXVpcmUoJy4vbG9sY2F0aW9uJylcbiAgLCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5naWZ5JylcbiAgLCBwcm90b2NvbHJlID0gL14oW2Etel1bYS16MC05ListXSo6KT8oXFwvXFwvKT8oW1xcU1xcc10qKS9pO1xuXG4vKipcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2UgcnVsZXMgZm9yIHRoZSBVUkwgcGFyc2VyLCBpdCBpbmZvcm1zIHRoZSBwYXJzZXJcbiAqIGFib3V0OlxuICpcbiAqIDAuIFRoZSBjaGFyIGl0IE5lZWRzIHRvIHBhcnNlLCBpZiBpdCdzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBkb25lIHVzaW5nXG4gKiAgICBpbmRleE9mLCBSZWdFeHAgdXNpbmcgZXhlYyBhbmQgTmFOIG1lYW5zIHNldCBhcyBjdXJyZW50IHZhbHVlLlxuICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXG4gKiAyLiBJbmRpY2F0aW9uIGlmIGl0J3MgYmFja3dhcmRzIG9yIGZvcndhcmQgcGFyc2luZywgd2hlbiBzZXQgYXMgbnVtYmVyIGl0J3NcbiAqICAgIHRoZSB2YWx1ZSBvZiBleHRyYSBjaGFycyB0aGF0IHNob3VsZCBiZSBzcGxpdCBvZmYuXG4gKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXG4gKiA0LiBgdG9Mb3dlckNhc2VgIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKi9cbnZhciBydWxlcyA9IFtcbiAgWycjJywgJ2hhc2gnXSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnPycsICdxdWVyeSddLCAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJy8nLCAncGF0aG5hbWUnXSwgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWydAJywgJ2F1dGgnLCAxXSwgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGZyb250LlxuICBbTmFOLCAnaG9zdCcsIHVuZGVmaW5lZCwgMSwgMV0sICAgICAgIC8vIFNldCBsZWZ0IG92ZXIgdmFsdWUuXG4gIFsvOihcXGQrKSQvLCAncG9ydCcsIHVuZGVmaW5lZCwgMV0sICAgIC8vIFJlZ0V4cCB0aGUgYmFjay5cbiAgW05hTiwgJ2hvc3RuYW1lJywgdW5kZWZpbmVkLCAxLCAxXSAgICAvLyBTZXQgbGVmdCBvdmVyLlxuXTtcblxuLyoqXG4gKiBAdHlwZWRlZiBQcm90b2NvbEV4dHJhY3RcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIG1hdGNoZWQgaW4gdGhlIFVSTCwgaW4gbG93ZXJjYXNlLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBzbGFzaGVzIGB0cnVlYCBpZiBwcm90b2NvbCBpcyBmb2xsb3dlZCBieSBcIi8vXCIsIGVsc2UgYGZhbHNlYC5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZXN0IFJlc3Qgb2YgdGhlIFVSTCB0aGF0IGlzIG5vdCBwYXJ0IG9mIHRoZSBwcm90b2NvbC5cbiAqL1xuXG4vKipcbiAqIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gZnJvbSBhIFVSTCB3aXRoL3dpdGhvdXQgZG91YmxlIHNsYXNoIChcIi8vXCIpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIGV4dHJhY3QgZnJvbS5cbiAqIEByZXR1cm4ge1Byb3RvY29sRXh0cmFjdH0gRXh0cmFjdGVkIGluZm9ybWF0aW9uLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbChhZGRyZXNzKSB7XG4gIHZhciBtYXRjaCA9IHByb3RvY29scmUuZXhlYyhhZGRyZXNzKTtcblxuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBtYXRjaFsxXSA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiAnJyxcbiAgICBzbGFzaGVzOiAhIW1hdGNoWzJdLFxuICAgIHJlc3Q6IG1hdGNoWzNdXG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlbGF0aXZlIFVSTCBwYXRobmFtZSBhZ2FpbnN0IGEgYmFzZSBVUkwgcGF0aG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlIFBhdGhuYW1lIG9mIHRoZSByZWxhdGl2ZSBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZSBQYXRobmFtZSBvZiB0aGUgYmFzZSBVUkwuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlc29sdmVkIHBhdGhuYW1lLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUocmVsYXRpdmUsIGJhc2UpIHtcbiAgdmFyIHBhdGggPSAoYmFzZSB8fCAnLycpLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmNvbmNhdChyZWxhdGl2ZS5zcGxpdCgnLycpKVxuICAgICwgaSA9IHBhdGgubGVuZ3RoXG4gICAgLCBsYXN0ID0gcGF0aFtpIC0gMV1cbiAgICAsIHVuc2hpZnQgPSBmYWxzZVxuICAgICwgdXAgPSAwO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocGF0aFtpXSA9PT0gJy4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhdGhbaV0gPT09ICcuLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBpZiAoaSA9PT0gMCkgdW5zaGlmdCA9IHRydWU7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuc2hpZnQpIHBhdGgudW5zaGlmdCgnJyk7XG4gIGlmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgcGF0aC5wdXNoKCcnKTtcblxuICByZXR1cm4gcGF0aC5qb2luKCcvJyk7XG59XG5cbi8qKlxuICogVGhlIGFjdHVhbCBVUkwgaW5zdGFuY2UuIEluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIG9iamVjdCB3ZSd2ZSBvcHRlZC1pbiB0b1xuICogY3JlYXRlIGFuIGFjdHVhbCBjb25zdHJ1Y3RvciBhcyBpdCdzIG11Y2ggbW9yZSBtZW1vcnkgZWZmaWNpZW50IGFuZFxuICogZmFzdGVyIGFuZCBpdCBwbGVhc2VzIG15IE9DRC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2NhdGlvbiBMb2NhdGlvbiBkZWZhdWx0cyBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHBhcnNlciBQYXJzZXIgZm9yIHRoZSBxdWVyeSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBVUkwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVVJMKSkge1xuICAgIHJldHVybiBuZXcgVVJMKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHJlbGF0aXZlLCBleHRyYWN0ZWQsIHBhcnNlLCBpbnN0cnVjdGlvbiwgaW5kZXgsIGtleVxuICAgICwgaW5zdHJ1Y3Rpb25zID0gcnVsZXMuc2xpY2UoKVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NhdGlvblxuICAgICwgdXJsID0gdGhpc1xuICAgICwgaSA9IDA7XG5cbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnRzIGFsbG93cyB0aGlzIG1vZHVsZSB0d28gaGF2ZSBjb21wYXRpYmlsaXR5IHdpdGhcbiAgLy8gMiBkaWZmZXJlbnQgQVBJOlxuICAvL1xuICAvLyAxLiBOb2RlLmpzJ3MgYHVybC5wYXJzZWAgYXBpIHdoaWNoIGFjY2VwdHMgYSBVUkwsIGJvb2xlYW4gYXMgYXJndW1lbnRzXG4gIC8vICAgIHdoZXJlIHRoZSBib29sZWFuIGluZGljYXRlcyB0aGF0IHRoZSBxdWVyeSBzdHJpbmcgc2hvdWxkIGFsc28gYmUgcGFyc2VkLlxuICAvL1xuICAvLyAyLiBUaGUgYFVSTGAgaW50ZXJmYWNlIG9mIHRoZSBicm93c2VyIHdoaWNoIGFjY2VwdHMgYSBVUkwsIG9iamVjdCBhc1xuICAvLyAgICBhcmd1bWVudHMuIFRoZSBzdXBwbGllZCBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQgdmFsdWVzIC8gZmFsbC1iYWNrXG4gIC8vICAgIGZvciByZWxhdGl2ZSBwYXRocy5cbiAgLy9cbiAgaWYgKCdvYmplY3QnICE9PSB0eXBlICYmICdzdHJpbmcnICE9PSB0eXBlKSB7XG4gICAgcGFyc2VyID0gbG9jYXRpb247XG4gICAgbG9jYXRpb24gPSBudWxsO1xuICB9XG5cbiAgaWYgKHBhcnNlciAmJiAnZnVuY3Rpb24nICE9PSB0eXBlb2YgcGFyc2VyKSBwYXJzZXIgPSBxcy5wYXJzZTtcblxuICBsb2NhdGlvbiA9IGxvbGNhdGlvbihsb2NhdGlvbik7XG5cbiAgLy9cbiAgLy8gRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBiZWZvcmUgcnVubmluZyB0aGUgaW5zdHJ1Y3Rpb25zLlxuICAvL1xuICBleHRyYWN0ZWQgPSBleHRyYWN0UHJvdG9jb2woYWRkcmVzcyB8fCAnJyk7XG4gIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XG4gIHVybC5zbGFzaGVzID0gZXh0cmFjdGVkLnNsYXNoZXMgfHwgcmVsYXRpdmUgJiYgbG9jYXRpb24uc2xhc2hlcztcbiAgdXJsLnByb3RvY29sID0gZXh0cmFjdGVkLnByb3RvY29sIHx8IGxvY2F0aW9uLnByb3RvY29sIHx8ICcnO1xuICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XG5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgYXV0aG9yaXR5IGNvbXBvbmVudCBpcyBhYnNlbnQgdGhlIFVSTCBzdGFydHMgd2l0aCBhIHBhdGhcbiAgLy8gY29tcG9uZW50LlxuICAvL1xuICBpZiAoIWV4dHJhY3RlZC5zbGFzaGVzKSBpbnN0cnVjdGlvbnNbMl0gPSBbLyguKikvLCAncGF0aG5hbWUnXTtcblxuICBmb3IgKDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2ldO1xuICAgIHBhcnNlID0gaW5zdHJ1Y3Rpb25bMF07XG4gICAga2V5ID0gaW5zdHJ1Y3Rpb25bMV07XG5cbiAgICBpZiAocGFyc2UgIT09IHBhcnNlKSB7XG4gICAgICB1cmxba2V5XSA9IGFkZHJlc3M7XG4gICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBhcnNlKSB7XG4gICAgICBpZiAofihpbmRleCA9IGFkZHJlc3MuaW5kZXhPZihwYXJzZSkpKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGluc3RydWN0aW9uWzJdKSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZShpbmRleCArIGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGluZGV4ID0gcGFyc2UuZXhlYyhhZGRyZXNzKSkpIHtcbiAgICAgIHVybFtrZXldID0gaW5kZXhbMV07XG4gICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleC5pbmRleCk7XG4gICAgfVxuXG4gICAgdXJsW2tleV0gPSB1cmxba2V5XSB8fCAoXG4gICAgICByZWxhdGl2ZSAmJiBpbnN0cnVjdGlvblszXSA/IGxvY2F0aW9uW2tleV0gfHwgJycgOiAnJ1xuICAgICk7XG5cbiAgICAvL1xuICAgIC8vIEhvc3RuYW1lLCBob3N0IGFuZCBwcm90b2NvbCBzaG91bGQgYmUgbG93ZXJjYXNlZCBzbyB0aGV5IGNhbiBiZSB1c2VkIHRvXG4gICAgLy8gY3JlYXRlIGEgcHJvcGVyIGBvcmlnaW5gLlxuICAgIC8vXG4gICAgaWYgKGluc3RydWN0aW9uWzRdKSB1cmxba2V5XSA9IHVybFtrZXldLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICAvL1xuICAvLyBBbHNvIHBhcnNlIHRoZSBzdXBwbGllZCBxdWVyeSBzdHJpbmcgaW4gdG8gYW4gb2JqZWN0LiBJZiB3ZSdyZSBzdXBwbGllZFxuICAvLyB3aXRoIGEgY3VzdG9tIHBhcnNlciBhcyBmdW5jdGlvbiB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJ1aWxkLWluXG4gIC8vIHBhcnNlci5cbiAgLy9cbiAgaWYgKHBhcnNlcikgdXJsLnF1ZXJ5ID0gcGFyc2VyKHVybC5xdWVyeSk7XG5cbiAgLy9cbiAgLy8gSWYgdGhlIFVSTCBpcyByZWxhdGl2ZSwgcmVzb2x2ZSB0aGUgcGF0aG5hbWUgYWdhaW5zdCB0aGUgYmFzZSBVUkwuXG4gIC8vXG4gIGlmIChcbiAgICAgIHJlbGF0aXZlXG4gICAgJiYgbG9jYXRpb24uc2xhc2hlc1xuICAgICYmIHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJ1xuICAgICYmICh1cmwucGF0aG5hbWUgIT09ICcnIHx8IGxvY2F0aW9uLnBhdGhuYW1lICE9PSAnJylcbiAgKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gcmVzb2x2ZSh1cmwucGF0aG5hbWUsIGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIHNob3VsZCBub3QgYWRkIHBvcnQgbnVtYmVycyBpZiB0aGV5IGFyZSBhbHJlYWR5IHRoZSBkZWZhdWx0IHBvcnQgbnVtYmVyXG4gIC8vIGZvciBhIGdpdmVuIHByb3RvY29sLiBBcyB0aGUgaG9zdCBhbHNvIGNvbnRhaW5zIHRoZSBwb3J0IG51bWJlciB3ZSdyZSBnb2luZ1xuICAvLyBvdmVycmlkZSBpdCB3aXRoIHRoZSBob3N0bmFtZSB3aGljaCBjb250YWlucyBubyBwb3J0IG51bWJlci5cbiAgLy9cbiAgaWYgKCFyZXF1aXJlZCh1cmwucG9ydCwgdXJsLnByb3RvY29sKSkge1xuICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIHVybC5wb3J0ID0gJyc7XG4gIH1cblxuICAvL1xuICAvLyBQYXJzZSBkb3duIHRoZSBgYXV0aGAgZm9yIHRoZSB1c2VybmFtZSBhbmQgcGFzc3dvcmQuXG4gIC8vXG4gIHVybC51c2VybmFtZSA9IHVybC5wYXNzd29yZCA9ICcnO1xuICBpZiAodXJsLmF1dGgpIHtcbiAgICBpbnN0cnVjdGlvbiA9IHVybC5hdXRoLnNwbGl0KCc6Jyk7XG4gICAgdXJsLnVzZXJuYW1lID0gaW5zdHJ1Y3Rpb25bMF0gfHwgJyc7XG4gICAgdXJsLnBhc3N3b3JkID0gaW5zdHJ1Y3Rpb25bMV0gfHwgJyc7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIC8vXG4gIC8vIFRoZSBocmVmIGlzIGp1c3QgdGhlIGNvbXBpbGVkIHJlc3VsdC5cbiAgLy9cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY2hhbmdpbmcgcHJvcGVydGllcyBpbiB0aGUgVVJMIGluc3RhbmNlIHRvXG4gKiBpbnN1cmUgdGhhdCB0aGV5IGFsbCBwcm9wYWdhdGUgY29ycmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJ0ICAgICAgICAgIFByb3BlcnR5IHdlIG5lZWQgdG8gYWRqdXN0LlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgICAgICAgICAgVGhlIG5ld2x5IGFzc2lnbmVkIHZhbHVlLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBmbiAgV2hlbiBzZXR0aW5nIHRoZSBxdWVyeSwgaXQgd2lsbCBiZSB0aGUgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgdG8gcGFyc2UgdGhlIHF1ZXJ5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiBzZXR0aW5nIHRoZSBwcm90b2NvbCwgZG91YmxlIHNsYXNoIHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgZnJvbSB0aGUgZmluYWwgdXJsIGlmIGl0IGlzIHRydWUuXG4gKiBAcmV0dXJucyB7VVJMfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKC86XFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWUuam9pbignOicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgdXJsLnByb3RvY29sID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRobmFtZSc6XG4gICAgICB1cmwucGF0aG5hbWUgPSB2YWx1ZS5sZW5ndGggJiYgdmFsdWUuY2hhckF0KDApICE9PSAnLycgPyAnLycgKyB2YWx1ZSA6IHZhbHVlO1xuXG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zID0gcnVsZXNbaV07XG5cbiAgICBpZiAoaW5zWzRdKSB1cmxbaW5zWzFdXSA9IHVybFtpbnNbMV1dLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG5cbiAgcmV0dXJuIHVybDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZ2lmeSBPcHRpb25hbCBxdWVyeSBzdHJpbmdpZnkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZ5KSB7XG4gIGlmICghc3RyaW5naWZ5IHx8ICdmdW5jdGlvbicgIT09IHR5cGVvZiBzdHJpbmdpZnkpIHN0cmluZ2lmeSA9IHFzLnN0cmluZ2lmeTtcblxuICB2YXIgcXVlcnlcbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIHByb3RvY29sID0gdXJsLnByb3RvY29sO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5jaGFyQXQocHJvdG9jb2wubGVuZ3RoIC0gMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIHZhciByZXN1bHQgPSBwcm90b2NvbCArICh1cmwuc2xhc2hlcyA/ICcvLycgOiAnJyk7XG5cbiAgaWYgKHVybC51c2VybmFtZSkge1xuICAgIHJlc3VsdCArPSB1cmwudXNlcm5hbWU7XG4gICAgaWYgKHVybC5wYXNzd29yZCkgcmVzdWx0ICs9ICc6JysgdXJsLnBhc3N3b3JkO1xuICAgIHJlc3VsdCArPSAnQCc7XG4gIH1cblxuICByZXN1bHQgKz0gdXJsLmhvc3QgKyB1cmwucGF0aG5hbWU7XG5cbiAgcXVlcnkgPSAnb2JqZWN0JyA9PT0gdHlwZW9mIHVybC5xdWVyeSA/IHN0cmluZ2lmeSh1cmwucXVlcnkpIDogdXJsLnF1ZXJ5O1xuICBpZiAocXVlcnkpIHJlc3VsdCArPSAnPycgIT09IHF1ZXJ5LmNoYXJBdCgwKSA/ICc/JysgcXVlcnkgOiBxdWVyeTtcblxuICBpZiAodXJsLmhhc2gpIHJlc3VsdCArPSB1cmwuaGFzaDtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5VUkwucHJvdG90eXBlID0geyBzZXQ6IHNldCwgdG9TdHJpbmc6IHRvU3RyaW5nIH07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIFVSTCBwYXJzZXIgYW5kIHNvbWUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgYmUgdXNlZnVsIGZvclxuLy8gb3RoZXJzIG9yIHRlc3RpbmcuXG4vL1xuVVJMLmV4dHJhY3RQcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbDtcblVSTC5sb2NhdGlvbiA9IGxvbGNhdGlvbjtcblVSTC5xcyA9IHFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVSTDtcblxufSx7XCIuL2xvbGNhdGlvblwiOjYyLFwicXVlcnlzdHJpbmdpZnlcIjo1OSxcInJlcXVpcmVzLXBvcnRcIjo2MH1dLDYyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHNsYXNoZXMgPSAvXltBLVphLXpdW0EtWmEtejAtOSstLl0qOlxcL1xcLy87XG5cbi8qKlxuICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgbm90IGJlIGNvcGllZCBvciBpbmhlcml0ZWQgZnJvbS4gVGhpcyBpcyBvbmx5IG5lZWRlZFxuICogZm9yIGFsbCBub24gYmxvYiBVUkwncyBhcyBhIGJsb2IgVVJMIGRvZXMgbm90IGluY2x1ZGUgYSBoYXNoLCBvbmx5IHRoZVxuICogb3JpZ2luLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgaWdub3JlID0geyBoYXNoOiAxLCBxdWVyeTogMSB9XG4gICwgVVJMO1xuXG4vKipcbiAqIFRoZSBsb2NhdGlvbiBvYmplY3QgZGlmZmVycyB3aGVuIHlvdXIgY29kZSBpcyBsb2FkZWQgdGhyb3VnaCBhIG5vcm1hbCBwYWdlLFxuICogV29ya2VyIG9yIHRocm91Z2ggYSB3b3JrZXIgdXNpbmcgYSBibG9iLiBBbmQgd2l0aCB0aGUgYmxvYmJsZSBiZWdpbnMgdGhlXG4gKiB0cm91YmxlIGFzIHRoZSBsb2NhdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIHRoZSBVUkwgb2YgdGhlIGJsb2IsIG5vdCB0aGVcbiAqIGxvY2F0aW9uIG9mIHRoZSBwYWdlIHdoZXJlIG91ciBjb2RlIGlzIGxvYWRlZCBpbi4gVGhlIGFjdHVhbCBvcmlnaW4gaXNcbiAqIGVuY29kZWQgaW4gdGhlIGBwYXRobmFtZWAgc28gd2UgY2FuIHRoYW5rZnVsbHkgZ2VuZXJhdGUgYSBnb29kIFwiZGVmYXVsdFwiXG4gKiBsb2NhdGlvbiBmcm9tIGl0IHNvIHdlIGNhbiBnZW5lcmF0ZSBwcm9wZXIgcmVsYXRpdmUgVVJMJ3MgYWdhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2MgT3B0aW9uYWwgZGVmYXVsdCBsb2NhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2xjYXRpb24gb2JqZWN0LlxuICogQGFwaSBwdWJsaWNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsb2xjYXRpb24obG9jKSB7XG4gIGxvYyA9IGxvYyB8fCBnbG9iYWwubG9jYXRpb24gfHwge307XG4gIFVSTCA9IFVSTCB8fCByZXF1aXJlKCcuLycpO1xuXG4gIHZhciBmaW5hbGRlc3RpbmF0aW9uID0ge31cbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jXG4gICAgLCBrZXk7XG5cbiAgaWYgKCdibG9iOicgPT09IGxvYy5wcm90b2NvbCkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVVJMKHVuZXNjYXBlKGxvYy5wYXRobmFtZSksIHt9KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZSkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVVJMKGxvYywge30pO1xuICAgIGZvciAoa2V5IGluIGlnbm9yZSkgZGVsZXRlIGZpbmFsZGVzdGluYXRpb25ba2V5XTtcbiAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZSkge1xuICAgIGZvciAoa2V5IGluIGxvYykge1xuICAgICAgaWYgKGtleSBpbiBpZ25vcmUpIGNvbnRpbnVlO1xuICAgICAgZmluYWxkZXN0aW5hdGlvbltrZXldID0gbG9jW2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPSBzbGFzaGVzLnRlc3QobG9jLmhyZWYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5hbGRlc3RpbmF0aW9uO1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9cIjo2MX1dfSx7fSxbMV0pKDEpXG59KTtcblxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb2NranMuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc29ja2pzLWNsaWVudC9kaXN0L3NvY2tqcy5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuc2lSZWdleCA9IHJlcXVpcmUoJ2Fuc2ktcmVnZXgnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gc3RyLnJlcGxhY2UoYW5zaVJlZ2V4LCAnJykgOiBzdHI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N0cmlwLWFuc2kvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3VybC91cmwuanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi91cmwvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgZXJyb3Igb3ZlcmxheSBpcyBpbnNwaXJlZCAoYW5kIG1vc3RseSBjb3BpZWQpIGZyb20gQ3JlYXRlIFJlYWN0IEFwcCAoaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29raW5jdWJhdG9yL2NyZWF0ZS1yZWFjdC1hcHApXG4vLyBUaGV5LCBpbiB0dXJuLCBnb3QgaW5zcGlyZWQgYnkgd2VicGFjay1ob3QtbWlkZGxld2FyZSAoaHR0cHM6Ly9naXRodWIuY29tL2dsZW5qYW1pbi93ZWJwYWNrLWhvdC1taWRkbGV3YXJlKS5cblxudmFyIGFuc2lIVE1MID0gcmVxdWlyZSgnYW5zaS1odG1sJyk7XG52YXIgRW50aXRpZXMgPSByZXF1aXJlKCdodG1sLWVudGl0aWVzJykuQWxsSHRtbEVudGl0aWVzO1xuXG52YXIgZW50aXRpZXMgPSBuZXcgRW50aXRpZXMoKTtcblxudmFyIGNvbG9ycyA9IHtcbiAgcmVzZXQ6IFsndHJhbnNwYXJlbnQnLCAndHJhbnNwYXJlbnQnXSxcbiAgYmxhY2s6ICcxODE4MTgnLFxuICByZWQ6ICdFMzYwNDknLFxuICBncmVlbjogJ0IzQ0I3NCcsXG4gIHllbGxvdzogJ0ZGRDA4MCcsXG4gIGJsdWU6ICc3Q0FGQzInLFxuICBtYWdlbnRhOiAnN0ZBQ0NBJyxcbiAgY3lhbjogJ0MzQzJFRicsXG4gIGxpZ2h0Z3JleTogJ0VCRTdFMycsXG4gIGRhcmtncmV5OiAnNkQ3ODkxJ1xufTtcbmFuc2lIVE1MLnNldENvbG9ycyhjb2xvcnMpO1xuXG5mdW5jdGlvbiBjcmVhdGVPdmVybGF5SWZyYW1lKG9uSWZyYW1lTG9hZCkge1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gIGlmcmFtZS5pZCA9ICd3ZWJwYWNrLWRldi1zZXJ2ZXItY2xpZW50LW92ZXJsYXknO1xuICBpZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcbiAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgaWZyYW1lLnN0eWxlLmxlZnQgPSAwO1xuICBpZnJhbWUuc3R5bGUudG9wID0gMDtcbiAgaWZyYW1lLnN0eWxlLnJpZ2h0ID0gMDtcbiAgaWZyYW1lLnN0eWxlLmJvdHRvbSA9IDA7XG4gIGlmcmFtZS5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gIGlmcmFtZS5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICBpZnJhbWUuc3R5bGUuYm9yZGVyID0gJ25vbmUnO1xuICBpZnJhbWUuc3R5bGUuekluZGV4ID0gOTk5OTk5OTk5OTtcbiAgaWZyYW1lLm9ubG9hZCA9IG9uSWZyYW1lTG9hZDtcbiAgcmV0dXJuIGlmcmFtZTtcbn1cblxuZnVuY3Rpb24gYWRkT3ZlcmxheURpdlRvKGlmcmFtZSkge1xuICB2YXIgZGl2ID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlkID0gJ3dlYnBhY2stZGV2LXNlcnZlci1jbGllbnQtb3ZlcmxheS1kaXYnO1xuICBkaXYuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICBkaXYuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICBkaXYuc3R5bGUubGVmdCA9IDA7XG4gIGRpdi5zdHlsZS50b3AgPSAwO1xuICBkaXYuc3R5bGUucmlnaHQgPSAwO1xuICBkaXYuc3R5bGUuYm90dG9tID0gMDtcbiAgZGl2LnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgZGl2LnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLCAwLCAwLCAwLjg1KSc7XG4gIGRpdi5zdHlsZS5jb2xvciA9ICcjRThFOEU4JztcbiAgZGl2LnN0eWxlLmZvbnRGYW1pbHkgPSAnTWVubG8sIENvbnNvbGFzLCBtb25vc3BhY2UnO1xuICBkaXYuc3R5bGUuZm9udFNpemUgPSAnbGFyZ2UnO1xuICBkaXYuc3R5bGUucGFkZGluZyA9ICcycmVtJztcbiAgZGl2LnN0eWxlLmxpbmVIZWlnaHQgPSAnMS4yJztcbiAgZGl2LnN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnO1xuICBkaXYuc3R5bGUub3ZlcmZsb3cgPSAnYXV0byc7XG4gIGlmcmFtZS5jb250ZW50RG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICByZXR1cm4gZGl2O1xufVxuXG52YXIgb3ZlcmxheUlmcmFtZSA9IG51bGw7XG52YXIgb3ZlcmxheURpdiA9IG51bGw7XG52YXIgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gbnVsbDtcblxuZnVuY3Rpb24gZW5zdXJlT3ZlcmxheURpdkV4aXN0cyhvbk92ZXJsYXlEaXZSZWFkeSkge1xuICBpZiAob3ZlcmxheURpdikge1xuICAgIC8vIEV2ZXJ5dGhpbmcgaXMgcmVhZHksIGNhbGwgdGhlIGNhbGxiYWNrIHJpZ2h0IGF3YXkuXG4gICAgb25PdmVybGF5RGl2UmVhZHkob3ZlcmxheURpdik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ3JlYXRpbmcgYW4gaWZyYW1lIG1heSBiZSBhc3luY2hyb25vdXMgc28gd2UnbGwgc2NoZWR1bGUgdGhlIGNhbGxiYWNrLlxuICAvLyBJbiBjYXNlIG9mIG11bHRpcGxlIGNhbGxzLCBsYXN0IGNhbGxiYWNrIHdpbnMuXG4gIGxhc3RPbk92ZXJsYXlEaXZSZWFkeSA9IG9uT3ZlcmxheURpdlJlYWR5O1xuXG4gIGlmIChvdmVybGF5SWZyYW1lKSB7XG4gICAgLy8gV2UncmUgYWxyZWFkeSBjcmVhdGluZyBpdC5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDcmVhdGUgaWZyYW1lIGFuZCwgd2hlbiBpdCBpcyByZWFkeSwgYSBkaXYgaW5zaWRlIGl0LlxuICBvdmVybGF5SWZyYW1lID0gY3JlYXRlT3ZlcmxheUlmcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgb3ZlcmxheURpdiA9IGFkZE92ZXJsYXlEaXZUbyhvdmVybGF5SWZyYW1lKTtcbiAgICAvLyBOb3cgd2UgY2FuIHRhbGshXG4gICAgbGFzdE9uT3ZlcmxheURpdlJlYWR5KG92ZXJsYXlEaXYpO1xuICB9KTtcblxuICAvLyBaYWxnbyBhbGVydDogb25JZnJhbWVMb2FkKCkgd2lsbCBiZSBjYWxsZWQgZWl0aGVyIHN5bmNocm9ub3VzbHlcbiAgLy8gb3IgYXN5bmNocm9ub3VzbHkgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyLlxuICAvLyBXZSBkZWxheSBhZGRpbmcgaXQgc28gYG92ZXJsYXlJZnJhbWVgIGlzIHNldCB3aGVuIGBvbklmcmFtZUxvYWRgIGZpcmVzLlxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG92ZXJsYXlJZnJhbWUpO1xufVxuXG5mdW5jdGlvbiBzaG93TWVzc2FnZU92ZXJsYXkobWVzc2FnZSkge1xuICBlbnN1cmVPdmVybGF5RGl2RXhpc3RzKGZ1bmN0aW9uIChkaXYpIHtcbiAgICAvLyBNYWtlIGl0IGxvb2sgc2ltaWxhciB0byBvdXIgdGVybWluYWwuXG4gICAgZGl2LmlubmVySFRNTCA9ICc8c3BhbiBzdHlsZT1cImNvbG9yOiAjJyArIGNvbG9ycy5yZWQgKyAnXCI+RmFpbGVkIHRvIGNvbXBpbGUuPC9zcGFuPjxicj48YnI+JyArIGFuc2lIVE1MKGVudGl0aWVzLmVuY29kZShtZXNzYWdlKSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95RXJyb3JPdmVybGF5KCkge1xuICBpZiAoIW92ZXJsYXlEaXYpIHtcbiAgICAvLyBJdCBpcyBub3QgdGhlcmUgaW4gdGhlIGZpcnN0IHBsYWNlLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENsZWFuIHVwIGFuZCByZXNldCBpbnRlcm5hbCBzdGF0ZS5cbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdmVybGF5SWZyYW1lKTtcbiAgb3ZlcmxheURpdiA9IG51bGw7XG4gIG92ZXJsYXlJZnJhbWUgPSBudWxsO1xuICBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBudWxsO1xufVxuXG4vLyBTdWNjZXNzZnVsIGNvbXBpbGF0aW9uLlxuZXhwb3J0cy5jbGVhciA9IGZ1bmN0aW9uIGhhbmRsZVN1Y2Nlc3MoKSB7XG4gIGRlc3Ryb3lFcnJvck92ZXJsYXkoKTtcbn07XG5cbi8vIENvbXBpbGF0aW9uIHdpdGggZXJyb3JzIChlLmcuIHN5bnRheCBlcnJvciBvciBtaXNzaW5nIG1vZHVsZXMpLlxuZXhwb3J0cy5zaG93TWVzc2FnZSA9IGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UobWVzc2FnZXMpIHtcbiAgc2hvd01lc3NhZ2VPdmVybGF5KG1lc3NhZ2VzWzBdKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L292ZXJsYXkuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNvY2tKUyA9IHJlcXVpcmUoJ3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMnKTtcblxudmFyIHJldHJpZXMgPSAwO1xudmFyIHNvY2sgPSBudWxsO1xuXG52YXIgc29ja2V0ID0gZnVuY3Rpb24gaW5pdFNvY2tldCh1cmwsIGhhbmRsZXJzKSB7XG4gIHNvY2sgPSBuZXcgU29ja0pTKHVybCk7XG5cbiAgc29jay5vbm9wZW4gPSBmdW5jdGlvbiBvbm9wZW4oKSB7XG4gICAgcmV0cmllcyA9IDA7XG4gIH07XG5cbiAgc29jay5vbmNsb3NlID0gZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAocmV0cmllcyA9PT0gMCkge1xuICAgICAgaGFuZGxlcnMuY2xvc2UoKTtcbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gcmVjb25uZWN0LlxuICAgIHNvY2sgPSBudWxsO1xuXG4gICAgLy8gQWZ0ZXIgMTAgcmV0cmllcyBzdG9wIHRyeWluZywgdG8gcHJldmVudCBsb2dzcGFtLlxuICAgIGlmIChyZXRyaWVzIDw9IDEwKSB7XG4gICAgICAvLyBFeHBvbmVudGlhbGx5IGluY3JlYXNlIHRpbWVvdXQgdG8gcmVjb25uZWN0LlxuICAgICAgLy8gUmVzcGVjdGZ1bGx5IGNvcGllZCBmcm9tIHRoZSBwYWNrYWdlIGBnb3RgLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9ycywgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG4gICAgICB2YXIgcmV0cnlJbk1zID0gMTAwMCAqIE1hdGgucG93KDIsIHJldHJpZXMpICsgTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgIHJldHJpZXMgKz0gMTtcblxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNvY2tldCh1cmwsIGhhbmRsZXJzKTtcbiAgICAgIH0sIHJldHJ5SW5Ncyk7XG4gICAgfVxuICB9O1xuXG4gIHNvY2sub25tZXNzYWdlID0gZnVuY3Rpb24gb25tZXNzYWdlKGUpIHtcbiAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCBhbGwgZGF0YSBzZW50IHZpYSB0aGUgd2Vic29ja2V0IGlzIEpTT04uXG4gICAgdmFyIG1zZyA9IEpTT04ucGFyc2UoZS5kYXRhKTtcbiAgICBpZiAoaGFuZGxlcnNbbXNnLnR5cGVdKSB7XG4gICAgICBoYW5kbGVyc1ttc2cudHlwZV0obXNnLmRhdGEpO1xuICAgIH1cbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc29ja2V0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9zb2NrZXQuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudHNcIik7XHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvaG90L2VtaXR0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbnZhciBTZW5zb3JTYW1wbGUgPSByZXF1aXJlKCcuL3NlbnNvci1zYW1wbGUuanMnKTtcbnZhciBNYXRoVXRpbCA9IHJlcXVpcmUoJy4uL21hdGgtdXRpbC5qcycpO1xudmFyIFV0aWwgPSByZXF1aXJlKCcuLi91dGlsLmpzJyk7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgYSBzaW1wbGUgY29tcGxlbWVudGFyeSBmaWx0ZXIsIHdoaWNoIGZ1c2VzIGd5cm9zY29wZSBhbmRcbiAqIGFjY2VsZXJvbWV0ZXIgZGF0YSBmcm9tIHRoZSAnZGV2aWNlbW90aW9uJyBldmVudC5cbiAqXG4gKiBBY2NlbGVyb21ldGVyIGRhdGEgaXMgdmVyeSBub2lzeSwgYnV0IHN0YWJsZSBvdmVyIHRoZSBsb25nIHRlcm0uXG4gKiBHeXJvc2NvcGUgZGF0YSBpcyBzbW9vdGgsIGJ1dCB0ZW5kcyB0byBkcmlmdCBvdmVyIHRoZSBsb25nIHRlcm0uXG4gKlxuICogVGhpcyBmdXNpb24gaXMgcmVsYXRpdmVseSBzaW1wbGU6XG4gKiAxLiBHZXQgb3JpZW50YXRpb24gZXN0aW1hdGVzIGZyb20gYWNjZWxlcm9tZXRlciBieSBhcHBseWluZyBhIGxvdy1wYXNzIGZpbHRlclxuICogICAgb24gdGhhdCBkYXRhLlxuICogMi4gR2V0IG9yaWVudGF0aW9uIGVzdGltYXRlcyBmcm9tIGd5cm9zY29wZSBieSBpbnRlZ3JhdGluZyBvdmVyIHRpbWUuXG4gKiAzLiBDb21iaW5lIHRoZSB0d28gZXN0aW1hdGVzLCB3ZWlnaGluZyAoMSkgaW4gdGhlIGxvbmcgdGVybSwgYnV0ICgyKSBmb3IgdGhlXG4gKiAgICBzaG9ydCB0ZXJtLlxuICovXG5mdW5jdGlvbiBDb21wbGVtZW50YXJ5RmlsdGVyKGtGaWx0ZXIpIHtcbiAgdGhpcy5rRmlsdGVyID0ga0ZpbHRlcjtcblxuICAvLyBSYXcgc2Vuc29yIG1lYXN1cmVtZW50cy5cbiAgdGhpcy5jdXJyZW50QWNjZWxNZWFzdXJlbWVudCA9IG5ldyBTZW5zb3JTYW1wbGUoKTtcbiAgdGhpcy5jdXJyZW50R3lyb01lYXN1cmVtZW50ID0gbmV3IFNlbnNvclNhbXBsZSgpO1xuICB0aGlzLnByZXZpb3VzR3lyb01lYXN1cmVtZW50ID0gbmV3IFNlbnNvclNhbXBsZSgpO1xuXG4gIC8vIFNldCBkZWZhdWx0IGxvb2sgZGlyZWN0aW9uIHRvIGJlIGluIHRoZSBjb3JyZWN0IGRpcmVjdGlvbi5cbiAgaWYgKFV0aWwuaXNJT1MoKSkge1xuICAgIHRoaXMuZmlsdGVyUSA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKC0xLCAwLCAwLCAxKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZpbHRlclEgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigxLCAwLCAwLCAxKTtcbiAgfVxuICB0aGlzLnByZXZpb3VzRmlsdGVyUSA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG4gIHRoaXMucHJldmlvdXNGaWx0ZXJRLmNvcHkodGhpcy5maWx0ZXJRKTtcblxuICAvLyBPcmllbnRhdGlvbiBiYXNlZCBvbiB0aGUgYWNjZWxlcm9tZXRlci5cbiAgdGhpcy5hY2NlbFEgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuICAvLyBXaGV0aGVyIG9yIG5vdCB0aGUgb3JpZW50YXRpb24gaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gIHRoaXMuaXNPcmllbnRhdGlvbkluaXRpYWxpemVkID0gZmFsc2U7XG4gIC8vIFJ1bm5pbmcgZXN0aW1hdGUgb2YgZ3Jhdml0eSBiYXNlZCBvbiB0aGUgY3VycmVudCBvcmllbnRhdGlvbi5cbiAgdGhpcy5lc3RpbWF0ZWRHcmF2aXR5ID0gbmV3IE1hdGhVdGlsLlZlY3RvcjMoKTtcbiAgLy8gTWVhc3VyZWQgZ3Jhdml0eSBiYXNlZCBvbiBhY2NlbGVyb21ldGVyLlxuICB0aGlzLm1lYXN1cmVkR3Jhdml0eSA9IG5ldyBNYXRoVXRpbC5WZWN0b3IzKCk7XG5cbiAgLy8gRGVidWcgb25seSBxdWF0ZXJuaW9uIG9mIGd5cm8tYmFzZWQgb3JpZW50YXRpb24uXG4gIHRoaXMuZ3lyb0ludGVncmFsUSA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG59XG5cbkNvbXBsZW1lbnRhcnlGaWx0ZXIucHJvdG90eXBlLmFkZEFjY2VsTWVhc3VyZW1lbnQgPSBmdW5jdGlvbih2ZWN0b3IsIHRpbWVzdGFtcFMpIHtcbiAgdGhpcy5jdXJyZW50QWNjZWxNZWFzdXJlbWVudC5zZXQodmVjdG9yLCB0aW1lc3RhbXBTKTtcbn07XG5cbkNvbXBsZW1lbnRhcnlGaWx0ZXIucHJvdG90eXBlLmFkZEd5cm9NZWFzdXJlbWVudCA9IGZ1bmN0aW9uKHZlY3RvciwgdGltZXN0YW1wUykge1xuICB0aGlzLmN1cnJlbnRHeXJvTWVhc3VyZW1lbnQuc2V0KHZlY3RvciwgdGltZXN0YW1wUyk7XG5cbiAgdmFyIGRlbHRhVCA9IHRpbWVzdGFtcFMgLSB0aGlzLnByZXZpb3VzR3lyb01lYXN1cmVtZW50LnRpbWVzdGFtcFM7XG4gIGlmIChVdGlsLmlzVGltZXN0YW1wRGVsdGFWYWxpZChkZWx0YVQpKSB7XG4gICAgdGhpcy5ydW5fKCk7XG4gIH1cblxuICB0aGlzLnByZXZpb3VzR3lyb01lYXN1cmVtZW50LmNvcHkodGhpcy5jdXJyZW50R3lyb01lYXN1cmVtZW50KTtcbn07XG5cbkNvbXBsZW1lbnRhcnlGaWx0ZXIucHJvdG90eXBlLnJ1bl8gPSBmdW5jdGlvbigpIHtcblxuICBpZiAoIXRoaXMuaXNPcmllbnRhdGlvbkluaXRpYWxpemVkKSB7XG4gICAgdGhpcy5hY2NlbFEgPSB0aGlzLmFjY2VsVG9RdWF0ZXJuaW9uXyh0aGlzLmN1cnJlbnRBY2NlbE1lYXN1cmVtZW50LnNhbXBsZSk7XG4gICAgdGhpcy5wcmV2aW91c0ZpbHRlclEuY29weSh0aGlzLmFjY2VsUSk7XG4gICAgdGhpcy5pc09yaWVudGF0aW9uSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkZWx0YVQgPSB0aGlzLmN1cnJlbnRHeXJvTWVhc3VyZW1lbnQudGltZXN0YW1wUyAtXG4gICAgICB0aGlzLnByZXZpb3VzR3lyb01lYXN1cmVtZW50LnRpbWVzdGFtcFM7XG5cbiAgLy8gQ29udmVydCBneXJvIHJvdGF0aW9uIHZlY3RvciB0byBhIHF1YXRlcm5pb24gZGVsdGEuXG4gIHZhciBneXJvRGVsdGFRID0gdGhpcy5neXJvVG9RdWF0ZXJuaW9uRGVsdGFfKHRoaXMuY3VycmVudEd5cm9NZWFzdXJlbWVudC5zYW1wbGUsIGRlbHRhVCk7XG4gIHRoaXMuZ3lyb0ludGVncmFsUS5tdWx0aXBseShneXJvRGVsdGFRKTtcblxuICAvLyBmaWx0ZXJfMSA9IEsgKiAoZmlsdGVyXzAgKyBneXJvICogZFQpICsgKDEgLSBLKSAqIGFjY2VsLlxuICB0aGlzLmZpbHRlclEuY29weSh0aGlzLnByZXZpb3VzRmlsdGVyUSk7XG4gIHRoaXMuZmlsdGVyUS5tdWx0aXBseShneXJvRGVsdGFRKTtcblxuICAvLyBDYWxjdWxhdGUgdGhlIGRlbHRhIGJldHdlZW4gdGhlIGN1cnJlbnQgZXN0aW1hdGVkIGdyYXZpdHkgYW5kIHRoZSByZWFsXG4gIC8vIGdyYXZpdHkgdmVjdG9yIGZyb20gYWNjZWxlcm9tZXRlci5cbiAgdmFyIGludkZpbHRlclEgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuICBpbnZGaWx0ZXJRLmNvcHkodGhpcy5maWx0ZXJRKTtcbiAgaW52RmlsdGVyUS5pbnZlcnNlKCk7XG5cbiAgdGhpcy5lc3RpbWF0ZWRHcmF2aXR5LnNldCgwLCAwLCAtMSk7XG4gIHRoaXMuZXN0aW1hdGVkR3Jhdml0eS5hcHBseVF1YXRlcm5pb24oaW52RmlsdGVyUSk7XG4gIHRoaXMuZXN0aW1hdGVkR3Jhdml0eS5ub3JtYWxpemUoKTtcblxuICB0aGlzLm1lYXN1cmVkR3Jhdml0eS5jb3B5KHRoaXMuY3VycmVudEFjY2VsTWVhc3VyZW1lbnQuc2FtcGxlKTtcbiAgdGhpcy5tZWFzdXJlZEdyYXZpdHkubm9ybWFsaXplKCk7XG5cbiAgLy8gQ29tcGFyZSBlc3RpbWF0ZWQgZ3Jhdml0eSB3aXRoIG1lYXN1cmVkIGdyYXZpdHksIGdldCB0aGUgZGVsdGEgcXVhdGVybmlvblxuICAvLyBiZXR3ZWVuIHRoZSB0d28uXG4gIHZhciBkZWx0YVEgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuICBkZWx0YVEuc2V0RnJvbVVuaXRWZWN0b3JzKHRoaXMuZXN0aW1hdGVkR3Jhdml0eSwgdGhpcy5tZWFzdXJlZEdyYXZpdHkpO1xuICBkZWx0YVEuaW52ZXJzZSgpO1xuXG4gIGlmIChVdGlsLmlzRGVidWcoKSkge1xuICAgIGNvbnNvbGUubG9nKCdEZWx0YTogJWQgZGVnLCBHX2VzdDogKCVzLCAlcywgJXMpLCBHX21lYXM6ICglcywgJXMsICVzKScsXG4gICAgICAgICAgICAgICAgTWF0aFV0aWwucmFkVG9EZWcgKiBVdGlsLmdldFF1YXRlcm5pb25BbmdsZShkZWx0YVEpLFxuICAgICAgICAgICAgICAgICh0aGlzLmVzdGltYXRlZEdyYXZpdHkueCkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgICAodGhpcy5lc3RpbWF0ZWRHcmF2aXR5LnkpLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgICAgKHRoaXMuZXN0aW1hdGVkR3Jhdml0eS56KS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICAgICh0aGlzLm1lYXN1cmVkR3Jhdml0eS54KS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICAgICh0aGlzLm1lYXN1cmVkR3Jhdml0eS55KS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICAgICh0aGlzLm1lYXN1cmVkR3Jhdml0eS56KS50b0ZpeGVkKDEpKTtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSB0aGUgU0xFUlAgdGFyZ2V0OiBjdXJyZW50IG9yaWVudGF0aW9uIHBsdXMgdGhlIG1lYXN1cmVkLWVzdGltYXRlZFxuICAvLyBxdWF0ZXJuaW9uIGRlbHRhLlxuICB2YXIgdGFyZ2V0USA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG4gIHRhcmdldFEuY29weSh0aGlzLmZpbHRlclEpO1xuICB0YXJnZXRRLm11bHRpcGx5KGRlbHRhUSk7XG5cbiAgLy8gU0xFUlAgZmFjdG9yOiAwIGlzIHB1cmUgZ3lybywgMSBpcyBwdXJlIGFjY2VsLlxuICB0aGlzLmZpbHRlclEuc2xlcnAodGFyZ2V0USwgMSAtIHRoaXMua0ZpbHRlcik7XG5cbiAgdGhpcy5wcmV2aW91c0ZpbHRlclEuY29weSh0aGlzLmZpbHRlclEpO1xufTtcblxuQ29tcGxlbWVudGFyeUZpbHRlci5wcm90b3R5cGUuZ2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZmlsdGVyUTtcbn07XG5cbkNvbXBsZW1lbnRhcnlGaWx0ZXIucHJvdG90eXBlLmFjY2VsVG9RdWF0ZXJuaW9uXyA9IGZ1bmN0aW9uKGFjY2VsKSB7XG4gIHZhciBub3JtQWNjZWwgPSBuZXcgTWF0aFV0aWwuVmVjdG9yMygpO1xuICBub3JtQWNjZWwuY29weShhY2NlbCk7XG4gIG5vcm1BY2NlbC5ub3JtYWxpemUoKTtcbiAgdmFyIHF1YXQgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuICBxdWF0LnNldEZyb21Vbml0VmVjdG9ycyhuZXcgTWF0aFV0aWwuVmVjdG9yMygwLCAwLCAtMSksIG5vcm1BY2NlbCk7XG4gIHF1YXQuaW52ZXJzZSgpO1xuICByZXR1cm4gcXVhdDtcbn07XG5cbkNvbXBsZW1lbnRhcnlGaWx0ZXIucHJvdG90eXBlLmd5cm9Ub1F1YXRlcm5pb25EZWx0YV8gPSBmdW5jdGlvbihneXJvLCBkdCkge1xuICAvLyBFeHRyYWN0IGF4aXMgYW5kIGFuZ2xlIGZyb20gdGhlIGd5cm9zY29wZSBkYXRhLlxuICB2YXIgcXVhdCA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG4gIHZhciBheGlzID0gbmV3IE1hdGhVdGlsLlZlY3RvcjMoKTtcbiAgYXhpcy5jb3B5KGd5cm8pO1xuICBheGlzLm5vcm1hbGl6ZSgpO1xuICBxdWF0LnNldEZyb21BeGlzQW5nbGUoYXhpcywgZ3lyby5sZW5ndGgoKSAqIGR0KTtcbiAgcmV0dXJuIHF1YXQ7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcGxlbWVudGFyeUZpbHRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi93ZWJ2ci1wb2x5ZmlsbC9zcmMvc2Vuc29yLWZ1c2lvbi9jb21wbGVtZW50YXJ5LWZpbHRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBNYXRoVXRpbCA9IHJlcXVpcmUoJy4uL21hdGgtdXRpbCcpO1xudmFyIFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbi8qKlxuICogR2l2ZW4gYW4gb3JpZW50YXRpb24gYW5kIHRoZSBneXJvc2NvcGUgZGF0YSwgcHJlZGljdHMgdGhlIGZ1dHVyZSBvcmllbnRhdGlvblxuICogb2YgdGhlIGhlYWQuIFRoaXMgbWFrZXMgcmVuZGVyaW5nIGFwcGVhciBmYXN0ZXIuXG4gKlxuICogQWxzbyBzZWU6IGh0dHA6Ly9tc2wuY3MudWl1Yy5lZHUvfmxhdmFsbGUvcGFwZXJzL0xhdlllckthdEFudDE0LnBkZlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmVkaWN0aW9uVGltZVMgdGltZSBmcm9tIGhlYWQgbW92ZW1lbnQgdG8gdGhlIGFwcGVhcmFuY2Ugb2ZcbiAqIHRoZSBjb3JyZXNwb25kaW5nIGltYWdlLlxuICovXG5mdW5jdGlvbiBQb3NlUHJlZGljdG9yKHByZWRpY3Rpb25UaW1lUykge1xuICB0aGlzLnByZWRpY3Rpb25UaW1lUyA9IHByZWRpY3Rpb25UaW1lUztcblxuICAvLyBUaGUgcXVhdGVybmlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgdGhpcy5wcmV2aW91c1EgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuICAvLyBQcmV2aW91cyB0aW1lIGEgcHJlZGljdGlvbiBvY2N1cnJlZC5cbiAgdGhpcy5wcmV2aW91c1RpbWVzdGFtcFMgPSBudWxsO1xuXG4gIC8vIFRoZSBkZWx0YSBxdWF0ZXJuaW9uIHRoYXQgYWRqdXN0cyB0aGUgY3VycmVudCBwb3NlLlxuICB0aGlzLmRlbHRhUSA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG4gIC8vIFRoZSBvdXRwdXQgcXVhdGVybmlvbi5cbiAgdGhpcy5vdXRRID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcbn1cblxuUG9zZVByZWRpY3Rvci5wcm90b3R5cGUuZ2V0UHJlZGljdGlvbiA9IGZ1bmN0aW9uKGN1cnJlbnRRLCBneXJvLCB0aW1lc3RhbXBTKSB7XG4gIGlmICghdGhpcy5wcmV2aW91c1RpbWVzdGFtcFMpIHtcbiAgICB0aGlzLnByZXZpb3VzUS5jb3B5KGN1cnJlbnRRKTtcbiAgICB0aGlzLnByZXZpb3VzVGltZXN0YW1wUyA9IHRpbWVzdGFtcFM7XG4gICAgcmV0dXJuIGN1cnJlbnRRO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGF4aXMgYW5kIGFuZ2xlIGJhc2VkIG9uIGd5cm9zY29wZSByb3RhdGlvbiByYXRlIGRhdGEuXG4gIHZhciBheGlzID0gbmV3IE1hdGhVdGlsLlZlY3RvcjMoKTtcbiAgYXhpcy5jb3B5KGd5cm8pO1xuICBheGlzLm5vcm1hbGl6ZSgpO1xuXG4gIHZhciBhbmd1bGFyU3BlZWQgPSBneXJvLmxlbmd0aCgpO1xuXG4gIC8vIElmIHdlJ3JlIHJvdGF0aW5nIHNsb3dseSwgZG9uJ3QgZG8gcHJlZGljdGlvbi5cbiAgaWYgKGFuZ3VsYXJTcGVlZCA8IE1hdGhVdGlsLmRlZ1RvUmFkICogMjApIHtcbiAgICBpZiAoVXRpbC5pc0RlYnVnKCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdNb3Zpbmcgc2xvd2x5LCBhdCAlcyBkZWcvczogbm8gcHJlZGljdGlvbicsXG4gICAgICAgICAgICAgICAgICAoTWF0aFV0aWwucmFkVG9EZWcgKiBhbmd1bGFyU3BlZWQpLnRvRml4ZWQoMSkpO1xuICAgIH1cbiAgICB0aGlzLm91dFEuY29weShjdXJyZW50USk7XG4gICAgdGhpcy5wcmV2aW91c1EuY29weShjdXJyZW50USk7XG4gICAgcmV0dXJuIHRoaXMub3V0UTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgcHJlZGljdGVkIGFuZ2xlIGJhc2VkIG9uIHRoZSB0aW1lIGRlbHRhIGFuZCBsYXRlbmN5LlxuICB2YXIgZGVsdGFUID0gdGltZXN0YW1wUyAtIHRoaXMucHJldmlvdXNUaW1lc3RhbXBTO1xuICB2YXIgcHJlZGljdEFuZ2xlID0gYW5ndWxhclNwZWVkICogdGhpcy5wcmVkaWN0aW9uVGltZVM7XG5cbiAgdGhpcy5kZWx0YVEuc2V0RnJvbUF4aXNBbmdsZShheGlzLCBwcmVkaWN0QW5nbGUpO1xuICB0aGlzLm91dFEuY29weSh0aGlzLnByZXZpb3VzUSk7XG4gIHRoaXMub3V0US5tdWx0aXBseSh0aGlzLmRlbHRhUSk7XG5cbiAgdGhpcy5wcmV2aW91c1EuY29weShjdXJyZW50USk7XG4gIHRoaXMucHJldmlvdXNUaW1lc3RhbXBTID0gdGltZXN0YW1wUztcblxuICByZXR1cm4gdGhpcy5vdXRRO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvc2VQcmVkaWN0b3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vd2VidnItcG9seWZpbGwvc3JjL3NlbnNvci1mdXNpb24vcG9zZS1wcmVkaWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIFNlbnNvclNhbXBsZShzYW1wbGUsIHRpbWVzdGFtcFMpIHtcbiAgdGhpcy5zZXQoc2FtcGxlLCB0aW1lc3RhbXBTKTtcbn07XG5cblNlbnNvclNhbXBsZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oc2FtcGxlLCB0aW1lc3RhbXBTKSB7XG4gIHRoaXMuc2FtcGxlID0gc2FtcGxlO1xuICB0aGlzLnRpbWVzdGFtcFMgPSB0aW1lc3RhbXBTO1xufTtcblxuU2Vuc29yU2FtcGxlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oc2Vuc29yU2FtcGxlKSB7XG4gIHRoaXMuc2V0KHNlbnNvclNhbXBsZS5zYW1wbGUsIHNlbnNvclNhbXBsZS50aW1lc3RhbXBTKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2Vuc29yU2FtcGxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3dlYnZyLXBvbHlmaWxsL3NyYy9zZW5zb3ItZnVzaW9uL3NlbnNvci1zYW1wbGUuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIHdlYnBhY2tFbXB0eUNvbnRleHQocmVxKSB7XG5cdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIicuXCIpO1xufVxud2VicGFja0VtcHR5Q29udGV4dC5rZXlzID0gZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfTtcbndlYnBhY2tFbXB0eUNvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tFbXB0eUNvbnRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tFbXB0eUNvbnRleHQ7XG53ZWJwYWNrRW1wdHlDb250ZXh0LmlkID0gNjg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2hvdCBub25yZWN1cnNpdmUgXlxcLlxcL2xvZyRcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=