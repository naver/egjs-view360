(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("@egjs/component"), require("@egjs/axes"));
	else if(typeof define === 'function' && define.amd)
		define("view360", ["@egjs/component", "@egjs/axes"], factory);
	else if(typeof exports === 'object')
		exports["view360"] = factory(require("@egjs/component"), require("@egjs/axes"));
	else
		root["eg"] = root["eg"] || {}, root["eg"]["view360"] = factory(root["eg"]["Component"], root["eg"]["Axes"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__28__, __WEBPACK_EXTERNAL_MODULE__31__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 39);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__resourceQuery) {
/* global __resourceQuery WorkerGlobalScope self */

/* eslint prefer-destructuring: off */

var querystring = __webpack_require__(2);

var url = __webpack_require__(5);

var stripAnsi = __webpack_require__(10);

var log = __webpack_require__(12).getLogger('webpack-dev-server');

var socket = __webpack_require__(13);

var overlay = __webpack_require__(15);

function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute('src');
  } // Fall back to getting all scripts in the document.


  var scriptElements = document.scripts || [];
  var currentScript = scriptElements[scriptElements.length - 1];

  if (currentScript) {
    return currentScript.getAttribute('src');
  } // Fail as there was no script to use.


  throw new Error('[WDS] Failed to get current script source.');
}

var urlParts;
var hotReload = true;

if (typeof window !== 'undefined') {
  var qs = window.location.search.toLowerCase();
  hotReload = qs.indexOf('hotreload=false') === -1;
}

if (true) {
  // If this bundle is inlined, use the resource query to get the correct url.
  urlParts = url.parse(__resourceQuery.substr(1));
} else { var scriptHost; }

if (!urlParts.port || urlParts.port === '0') {
  urlParts.port = self.location.port;
}

var _hot = false;
var initial = true;
var currentHash = '';
var useWarningOverlay = false;
var useErrorOverlay = false;
var useProgress = false;
var INFO = 'info';
var WARNING = 'warning';
var ERROR = 'error';
var NONE = 'none'; // Set the default log level

log.setDefaultLevel(INFO); // Send messages to the outside, so plugins can consume it.

function sendMsg(type, data) {
  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: "webpack".concat(type),
      data: data
    }, '*');
  }
}

var onSocketMsg = {
  hot: function hot() {
    _hot = true;
    log.info('[WDS] Hot Module Replacement enabled.');
  },
  invalid: function invalid() {
    log.info('[WDS] App updated. Recompiling...'); // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.

    if (useWarningOverlay || useErrorOverlay) {
      overlay.clear();
    }

    sendMsg('Invalid');
  },
  hash: function hash(_hash) {
    currentHash = _hash;
  },
  'still-ok': function stillOk() {
    log.info('[WDS] Nothing changed.');

    if (useWarningOverlay || useErrorOverlay) {
      overlay.clear();
    }

    sendMsg('StillOk');
  },
  'log-level': function logLevel(level) {
    var hotCtx = __webpack_require__(21);

    if (hotCtx.keys().indexOf('./log') !== -1) {
      hotCtx('./log').setLogLevel(level);
    }

    switch (level) {
      case INFO:
      case ERROR:
        log.setLevel(level);
        break;

      case WARNING:
        // loglevel's warning name is different from webpack's
        log.setLevel('warn');
        break;

      case NONE:
        log.disableAll();
        break;

      default:
        log.error("[WDS] Unknown clientLogLevel '".concat(level, "'"));
    }
  },
  overlay: function overlay(value) {
    if (typeof document !== 'undefined') {
      if (typeof value === 'boolean') {
        useWarningOverlay = false;
        useErrorOverlay = value;
      } else if (value) {
        useWarningOverlay = value.warnings;
        useErrorOverlay = value.errors;
      }
    }
  },
  progress: function progress(_progress) {
    if (typeof document !== 'undefined') {
      useProgress = _progress;
    }
  },
  'progress-update': function progressUpdate(data) {
    if (useProgress) {
      log.info("[WDS] ".concat(data.percent, "% - ").concat(data.msg, "."));
    }

    sendMsg('Progress', data);
  },
  ok: function ok() {
    sendMsg('Ok');

    if (useWarningOverlay || useErrorOverlay) {
      overlay.clear();
    }

    if (initial) {
      return initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp();
  },
  'content-changed': function contentChanged() {
    log.info('[WDS] Content base changed. Reloading...');
    self.location.reload();
  },
  warnings: function warnings(_warnings) {
    log.warn('[WDS] Warnings while compiling.');

    var strippedWarnings = _warnings.map(function (warning) {
      return stripAnsi(warning);
    });

    sendMsg('Warnings', strippedWarnings);

    for (var i = 0; i < strippedWarnings.length; i++) {
      log.warn(strippedWarnings[i]);
    }

    if (useWarningOverlay) {
      overlay.showMessage(_warnings);
    }

    if (initial) {
      return initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp();
  },
  errors: function errors(_errors) {
    log.error('[WDS] Errors while compiling. Reload prevented.');

    var strippedErrors = _errors.map(function (error) {
      return stripAnsi(error);
    });

    sendMsg('Errors', strippedErrors);

    for (var i = 0; i < strippedErrors.length; i++) {
      log.error(strippedErrors[i]);
    }

    if (useErrorOverlay) {
      overlay.showMessage(_errors);
    }

    initial = false;
  },
  error: function error(_error) {
    log.error(_error);
  },
  close: function close() {
    log.error('[WDS] Disconnected!');
    sendMsg('Close');
  }
};
var hostname = urlParts.hostname;
var protocol = urlParts.protocol;
var port = urlParts.port; // check ipv4 and ipv6 `all hostname`

if (hostname === '0.0.0.0' || hostname === '::') {
  // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384
  // eslint-disable-next-line no-bitwise
  if (self.location.hostname && !!~self.location.protocol.indexOf('http')) {
    hostname = self.location.hostname;
    port = self.location.port;
  }
} // `hostname` can be empty when the script path is relative. In that case, specifying
// a protocol would result in an invalid URL.
// When https is used in the app, secure websockets are always necessary
// because the browser doesn't accept non-secure websockets.


if (hostname && (self.location.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {
  protocol = self.location.protocol;
}

var socketUrl = url.format({
  protocol: protocol,
  auth: urlParts.auth,
  hostname: hostname,
  port: port,
  // If sockPath is provided it'll be passed in via the __resourceQuery as a
  // query param so it has to be parsed out of the querystring in order for the
  // client to open the socket to the correct location.
  pathname: urlParts.path == null || urlParts.path === '/' ? '/sockjs-node' : querystring.parse(urlParts.path).sockPath || urlParts.path
});
socket(socketUrl, onSocketMsg);
var isUnloading = false;
self.addEventListener('beforeunload', function () {
  isUnloading = true;
});

function reloadApp() {
  if (isUnloading || !hotReload) {
    return;
  }

  if (_hot) {
    log.info('[WDS] App hot update...'); // eslint-disable-next-line global-require

    var hotEmitter = __webpack_require__(23);

    hotEmitter.emit('webpackHotUpdate', currentHash);

    if (typeof self !== 'undefined' && self.window) {
      // broadcast update to window
      self.postMessage("webpackHotUpdate".concat(currentHash), '*');
    }
  } else {
    var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)

    var intervalId = self.setInterval(function () {
      if (rootWindow.location.protocol !== 'about:') {
        // reload immediately if protocol is valid
        applyReload(rootWindow, intervalId);
      } else {
        rootWindow = rootWindow.parent;

        if (rootWindow.parent === rootWindow) {
          // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
          applyReload(rootWindow, intervalId);
        }
      }
    });
  }

  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    log.info('[WDS] App updated. Reloading...');
    rootWindow.location.reload();
  }
}
/* WEBPACK VAR INJECTION */}.call(this, "?http://0.0.0.0"))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(3);
exports.encode = exports.stringify = __webpack_require__(4);


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(6);
var util = __webpack_require__(9);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(2);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(7)(module), __webpack_require__(8)))

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 8 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ansiRegex = __webpack_require__(11)();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SockJS = __webpack_require__(14);

var retries = 0;
var sock = null;

var socket = function initSocket(url, handlers) {
  sock = new SockJS(url);

  sock.onopen = function onopen() {
    retries = 0;
  };

  sock.onclose = function onclose() {
    if (retries === 0) {
      handlers.close();
    } // Try to reconnect.


    sock = null; // After 10 retries stop trying, to prevent logspam.

    if (retries <= 10) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-mixed-operators, no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;
      setTimeout(function () {
        socket(url, handlers);
      }, retryInMs);
    }
  };

  sock.onmessage = function onmessage(e) {
    // This assumes that all data sent via the websocket is JSON.
    var msg = JSON.parse(e.data);

    if (handlers[msg.type]) {
      handlers[msg.type](msg.data);
    }
  };
};

module.exports = socket;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/* sockjs-client v1.3.0 | http://sockjs.org | MIT license */
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
'use strict';

var transportList = require('./transport-list');

module.exports = require('./main')(transportList);

// TODO can't get rid of this until all servers do
if ('_sockjs_onload' in global) {
  setTimeout(global._sockjs_onload, 1);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./main":14,"./transport-list":16}],2:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function CloseEvent() {
  Event.call(this);
  this.initEvent('close', false, false);
  this.wasClean = false;
  this.code = 0;
  this.reason = '';
}

inherits(CloseEvent, Event);

module.exports = CloseEvent;

},{"./event":4,"inherits":57}],3:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventTarget = require('./eventtarget')
  ;

function EventEmitter() {
  EventTarget.call(this);
}

inherits(EventEmitter, EventTarget);

EventEmitter.prototype.removeAllListeners = function(type) {
  if (type) {
    delete this._listeners[type];
  } else {
    this._listeners = {};
  }
};

EventEmitter.prototype.once = function(type, listener) {
  var self = this
    , fired = false;

  function g() {
    self.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  this.on(type, g);
};

EventEmitter.prototype.emit = function() {
  var type = arguments[0];
  var listeners = this._listeners[type];
  if (!listeners) {
    return;
  }
  // equivalent of Array.prototype.slice.call(arguments, 1);
  var l = arguments.length;
  var args = new Array(l - 1);
  for (var ai = 1; ai < l; ai++) {
    args[ai - 1] = arguments[ai];
  }
  for (var i = 0; i < listeners.length; i++) {
    listeners[i].apply(this, args);
  }
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

module.exports.EventEmitter = EventEmitter;

},{"./eventtarget":5,"inherits":57}],4:[function(require,module,exports){
'use strict';

function Event(eventType) {
  this.type = eventType;
}

Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
  this.type = eventType;
  this.bubbles = canBubble;
  this.cancelable = cancelable;
  this.timeStamp = +new Date();
  return this;
};

Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault = function() {};

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

module.exports = Event;

},{}],5:[function(require,module,exports){
'use strict';

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

function EventTarget() {
  this._listeners = {};
}

EventTarget.prototype.addEventListener = function(eventType, listener) {
  if (!(eventType in this._listeners)) {
    this._listeners[eventType] = [];
  }
  var arr = this._listeners[eventType];
  // #4
  if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
    arr = arr.concat([listener]);
  }
  this._listeners[eventType] = arr;
};

EventTarget.prototype.removeEventListener = function(eventType, listener) {
  var arr = this._listeners[eventType];
  if (!arr) {
    return;
  }
  var idx = arr.indexOf(listener);
  if (idx !== -1) {
    if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
    } else {
      delete this._listeners[eventType];
    }
    return;
  }
};

EventTarget.prototype.dispatchEvent = function() {
  var event = arguments[0];
  var t = event.type;
  // equivalent of Array.prototype.slice.call(arguments, 0);
  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
  if (this['on' + t]) {
    this['on' + t].apply(this, args);
  }
  if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
    var listeners = this._listeners[t];
    for (var i = 0; i < listeners.length; i++) {
      listeners[i].apply(this, args);
    }
  }
};

module.exports = EventTarget;

},{}],6:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function TransportMessageEvent(data) {
  Event.call(this);
  this.initEvent('message', false, false);
  this.data = data;
}

inherits(TransportMessageEvent, Event);

module.exports = TransportMessageEvent;

},{"./event":4,"inherits":57}],7:[function(require,module,exports){
'use strict';

var JSON3 = require('json3')
  , iframeUtils = require('./utils/iframe')
  ;

function FacadeJS(transport) {
  this._transport = transport;
  transport.on('message', this._transportMessage.bind(this));
  transport.on('close', this._transportClose.bind(this));
}

FacadeJS.prototype._transportClose = function(code, reason) {
  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
};
FacadeJS.prototype._transportMessage = function(frame) {
  iframeUtils.postMessage('t', frame);
};
FacadeJS.prototype._send = function(data) {
  this._transport.send(data);
};
FacadeJS.prototype._close = function() {
  this._transport.close();
  this._transport.removeAllListeners();
};

module.exports = FacadeJS;

},{"./utils/iframe":47,"json3":58}],8:[function(require,module,exports){
(function (process){
'use strict';

var urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , JSON3 = require('json3')
  , FacadeJS = require('./facade')
  , InfoIframeReceiver = require('./info-iframe-receiver')
  , iframeUtils = require('./utils/iframe')
  , loc = require('./location')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:iframe-bootstrap');
}

module.exports = function(SockJS, availableTransports) {
  var transportMap = {};
  availableTransports.forEach(function(at) {
    if (at.facadeTransport) {
      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
    }
  });

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
  var parentOrigin;

  /* eslint-disable camelcase */
  SockJS.bootstrap_iframe = function() {
    /* eslint-enable camelcase */
    var facade;
    iframeUtils.currentWindowId = loc.hash.slice(1);
    var onMessage = function(e) {
      if (e.source !== parent) {
        return;
      }
      if (typeof parentOrigin === 'undefined') {
        parentOrigin = e.origin;
      }
      if (e.origin !== parentOrigin) {
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = JSON3.parse(e.data);
      } catch (ignored) {
        debug('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
        return;
      }
      switch (iframeMessage.type) {
      case 's':
        var p;
        try {
          p = JSON3.parse(iframeMessage.data);
        } catch (ignored) {
          debug('bad json', iframeMessage.data);
          break;
        }
        var version = p[0];
        var transport = p[1];
        var transUrl = p[2];
        var baseUrl = p[3];
        debug(version, transport, transUrl, baseUrl);
        // change this to semver logic
        if (version !== SockJS.version) {
          throw new Error('Incompatible SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".');
        }

        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
          throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
        }
        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
        break;
      case 'm':
        facade._send(iframeMessage.data);
        break;
      case 'c':
        if (facade) {
          facade._close();
        }
        facade = null;
        break;
      }
    };

    eventUtils.attachEvent('message', onMessage);

    // Start
    iframeUtils.postMessage('s');
  };
};

}).call(this,{ env: {} })

},{"./facade":7,"./info-iframe-receiver":10,"./location":13,"./utils/event":46,"./utils/iframe":47,"./utils/url":52,"debug":55,"json3":58}],9:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , objectUtils = require('./utils/object')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-ajax');
}

function InfoAjax(url, AjaxObject) {
  EventEmitter.call(this);

  var self = this;
  var t0 = +new Date();
  this.xo = new AjaxObject('GET', url);

  this.xo.once('finish', function(status, text) {
    var info, rtt;
    if (status === 200) {
      rtt = (+new Date()) - t0;
      if (text) {
        try {
          info = JSON3.parse(text);
        } catch (e) {
          debug('bad json', text);
        }
      }

      if (!objectUtils.isObject(info)) {
        info = {};
      }
    }
    self.emit('finish', info, rtt);
    self.removeAllListeners();
  });
}

inherits(InfoAjax, EventEmitter);

InfoAjax.prototype.close = function() {
  this.removeAllListeners();
  this.xo.close();
};

module.exports = InfoAjax;

}).call(this,{ env: {} })

},{"./utils/object":49,"debug":55,"events":3,"inherits":57,"json3":58}],10:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , JSON3 = require('json3')
  , XHRLocalObject = require('./transport/sender/xhr-local')
  , InfoAjax = require('./info-ajax')
  ;

function InfoReceiverIframe(transUrl) {
  var self = this;
  EventEmitter.call(this);

  this.ir = new InfoAjax(transUrl, XHRLocalObject);
  this.ir.once('finish', function(info, rtt) {
    self.ir = null;
    self.emit('message', JSON3.stringify([info, rtt]));
  });
}

inherits(InfoReceiverIframe, EventEmitter);

InfoReceiverIframe.transportName = 'iframe-info-receiver';

InfoReceiverIframe.prototype.close = function() {
  if (this.ir) {
    this.ir.close();
    this.ir = null;
  }
  this.removeAllListeners();
};

module.exports = InfoReceiverIframe;

},{"./info-ajax":9,"./transport/sender/xhr-local":37,"events":3,"inherits":57,"json3":58}],11:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , utils = require('./utils/event')
  , IframeTransport = require('./transport/iframe')
  , InfoReceiverIframe = require('./info-iframe-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-iframe');
}

function InfoIframe(baseUrl, url) {
  var self = this;
  EventEmitter.call(this);

  var go = function() {
    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

    ifr.once('message', function(msg) {
      if (msg) {
        var d;
        try {
          d = JSON3.parse(msg);
        } catch (e) {
          debug('bad json', msg);
          self.emit('finish');
          self.close();
          return;
        }

        var info = d[0], rtt = d[1];
        self.emit('finish', info, rtt);
      }
      self.close();
    });

    ifr.once('close', function() {
      self.emit('finish');
      self.close();
    });
  };

  // TODO this seems the same as the 'needBody' from transports
  if (!global.document.body) {
    utils.attachEvent('load', go);
  } else {
    go();
  }
}

inherits(InfoIframe, EventEmitter);

InfoIframe.enabled = function() {
  return IframeTransport.enabled();
};

InfoIframe.prototype.close = function() {
  if (this.ifr) {
    this.ifr.close();
  }
  this.removeAllListeners();
  this.ifr = null;
};

module.exports = InfoIframe;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./info-iframe-receiver":10,"./transport/iframe":22,"./utils/event":46,"debug":55,"events":3,"inherits":57,"json3":58}],12:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , urlUtils = require('./utils/url')
  , XDR = require('./transport/sender/xdr')
  , XHRCors = require('./transport/sender/xhr-cors')
  , XHRLocal = require('./transport/sender/xhr-local')
  , XHRFake = require('./transport/sender/xhr-fake')
  , InfoIframe = require('./info-iframe')
  , InfoAjax = require('./info-ajax')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-receiver');
}

function InfoReceiver(baseUrl, urlInfo) {
  debug(baseUrl);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self.doXhr(baseUrl, urlInfo);
  }, 0);
}

inherits(InfoReceiver, EventEmitter);

// TODO this is currently ignoring the list of available transports and the whitelist

InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
  if (urlInfo.sameOrigin) {
    return new InfoAjax(url, XHRLocal);
  }
  if (XHRCors.enabled) {
    return new InfoAjax(url, XHRCors);
  }
  if (XDR.enabled && urlInfo.sameScheme) {
    return new InfoAjax(url, XDR);
  }
  if (InfoIframe.enabled()) {
    return new InfoIframe(baseUrl, url);
  }
  return new InfoAjax(url, XHRFake);
};

InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
  var self = this
    , url = urlUtils.addPath(baseUrl, '/info')
    ;
  debug('doXhr', url);

  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

  this.timeoutRef = setTimeout(function() {
    debug('timeout');
    self._cleanup(false);
    self.emit('finish');
  }, InfoReceiver.timeout);

  this.xo.once('finish', function(info, rtt) {
    debug('finish', info, rtt);
    self._cleanup(true);
    self.emit('finish', info, rtt);
  });
};

InfoReceiver.prototype._cleanup = function(wasClean) {
  debug('_cleanup');
  clearTimeout(this.timeoutRef);
  this.timeoutRef = null;
  if (!wasClean && this.xo) {
    this.xo.close();
  }
  this.xo = null;
};

InfoReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  this._cleanup(false);
};

InfoReceiver.timeout = 8000;

module.exports = InfoReceiver;

}).call(this,{ env: {} })

},{"./info-ajax":9,"./info-iframe":11,"./transport/sender/xdr":34,"./transport/sender/xhr-cors":35,"./transport/sender/xhr-fake":36,"./transport/sender/xhr-local":37,"./utils/url":52,"debug":55,"events":3,"inherits":57}],13:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.location || {
  origin: 'http://localhost:80'
, protocol: 'http:'
, host: 'localhost'
, port: 80
, href: 'http://localhost/'
, hash: ''
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (process,global){
'use strict';

require('./shims');

var URL = require('url-parse')
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , random = require('./utils/random')
  , escape = require('./utils/escape')
  , urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , transport = require('./utils/transport')
  , objectUtils = require('./utils/object')
  , browser = require('./utils/browser')
  , log = require('./utils/log')
  , Event = require('./event/event')
  , EventTarget = require('./event/eventtarget')
  , loc = require('./location')
  , CloseEvent = require('./event/close')
  , TransportMessageEvent = require('./event/trans-message')
  , InfoReceiver = require('./info-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:main');
}

var transports;

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
function SockJS(url, protocols, options) {
  if (!(this instanceof SockJS)) {
    return new SockJS(url, protocols, options);
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
  }
  EventTarget.call(this);

  this.readyState = SockJS.CONNECTING;
  this.extensions = '';
  this.protocol = '';

  // non-standard extension
  options = options || {};
  if (options.protocols_whitelist) {
    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
  }
  this._transportsWhitelist = options.transports;
  this._transportOptions = options.transportOptions || {};

  var sessionId = options.sessionId || 8;
  if (typeof sessionId === 'function') {
    this._generateSessionId = sessionId;
  } else if (typeof sessionId === 'number') {
    this._generateSessionId = function() {
      return random.string(sessionId);
    };
  } else {
    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
  }

  this._server = options.server || random.numberString(1000);

  // Step 1 of WS spec - parse and validate the url. Issue #8
  var parsedUrl = new URL(url);
  if (!parsedUrl.host || !parsedUrl.protocol) {
    throw new SyntaxError("The URL '" + url + "' is invalid");
  } else if (parsedUrl.hash) {
    throw new SyntaxError('The URL must not contain a fragment');
  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
  }

  var secure = parsedUrl.protocol === 'https:';
  // Step 2 - don't allow secure origin with an insecure protocol
  if (loc.protocol === 'https:' && !secure) {
    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
  }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
  if (!protocols) {
    protocols = [];
  } else if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  // Step 5 - check protocols argument
  var sortedProtocols = protocols.sort();
  sortedProtocols.forEach(function(proto, i) {
    if (!proto) {
      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
    }
    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
    }
  });

  // Step 6 - convert origin
  var o = urlUtils.getOrigin(loc.href);
  this._origin = o ? o.toLowerCase() : null;

  // remove the trailing slash
  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

  // store the sanitized url
  this.url = parsedUrl.href;
  debug('using url', this.url);

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
  this._urlInfo = {
    nullOrigin: !browser.hasDomain()
  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
  };

  this._ir = new InfoReceiver(this.url, this._urlInfo);
  this._ir.once('finish', this._receiveInfo.bind(this));
}

inherits(SockJS, EventTarget);

function userSetCode(code) {
  return code === 1000 || (code >= 3000 && code <= 4999);
}

SockJS.prototype.close = function(code, reason) {
  // Step 1
  if (code && !userSetCode(code)) {
    throw new Error('InvalidAccessError: Invalid code');
  }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
  if (reason && reason.length > 123) {
    throw new SyntaxError('reason argument has an invalid length');
  }

  // Step 3.1
  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
    return;
  }

  // TODO look at docs to determine how to set this
  var wasClean = true;
  this._close(code || 1000, reason || 'Normal closure', wasClean);
};

SockJS.prototype.send = function(data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
  if (typeof data !== 'string') {
    data = '' + data;
  }
  if (this.readyState === SockJS.CONNECTING) {
    throw new Error('InvalidStateError: The connection has not been established yet');
  }
  if (this.readyState !== SockJS.OPEN) {
    return;
  }
  this._transport.send(escape.quote(data));
};

SockJS.version = require('./version');

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._receiveInfo = function(info, rtt) {
  debug('_receiveInfo', rtt);
  this._ir = null;
  if (!info) {
    this._close(1002, 'Cannot connect to server');
    return;
  }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
  this._rto = this.countRTO(rtt);
  // allow server to override url used for the actual transport
  this._transUrl = info.base_url ? info.base_url : this.url;
  info = objectUtils.extend(info, this._urlInfo);
  debug('info', info);
  // determine list of desired and supported transports
  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
  this._transports = enabledTransports.main;
  debug(this._transports.length + ' enabled transports');

  this._connect();
};

SockJS.prototype._connect = function() {
  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
    debug('attempt', Transport.transportName);
    if (Transport.needBody) {
      if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
        debug('waiting for body');
        this._transports.unshift(Transport);
        eventUtils.attachEvent('load', this._connect.bind(this));
        return;
      }
    }

    // calculate timeout based on RTO and round trips. Default to 5s
    var timeoutMs = (this._rto * Transport.roundTrips) || 5000;
    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
    debug('using timeout', timeoutMs);

    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
    var options = this._transportOptions[Transport.transportName];
    debug('transport url', transportUrl);
    var transportObj = new Transport(transportUrl, this._transUrl, options);
    transportObj.on('message', this._transportMessage.bind(this));
    transportObj.once('close', this._transportClose.bind(this));
    transportObj.transportName = Transport.transportName;
    this._transport = transportObj;

    return;
  }
  this._close(2000, 'All transports failed', false);
};

SockJS.prototype._transportTimeout = function() {
  debug('_transportTimeout');
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transport) {
      this._transport.close();
    }

    this._transportClose(2007, 'Transport timed out');
  }
};

SockJS.prototype._transportMessage = function(msg) {
  debug('_transportMessage', msg);
  var self = this
    , type = msg.slice(0, 1)
    , content = msg.slice(1)
    , payload
    ;

  // first check for messages that don't need a payload
  switch (type) {
    case 'o':
      this._open();
      return;
    case 'h':
      this.dispatchEvent(new Event('heartbeat'));
      debug('heartbeat', this.transport);
      return;
  }

  if (content) {
    try {
      payload = JSON3.parse(content);
    } catch (e) {
      debug('bad json', content);
    }
  }

  if (typeof payload === 'undefined') {
    debug('empty payload', content);
    return;
  }

  switch (type) {
    case 'a':
      if (Array.isArray(payload)) {
        payload.forEach(function(p) {
          debug('message', self.transport, p);
          self.dispatchEvent(new TransportMessageEvent(p));
        });
      }
      break;
    case 'm':
      debug('message', this.transport, payload);
      this.dispatchEvent(new TransportMessageEvent(payload));
      break;
    case 'c':
      if (Array.isArray(payload) && payload.length === 2) {
        this._close(payload[0], payload[1], true);
      }
      break;
  }
};

SockJS.prototype._transportClose = function(code, reason) {
  debug('_transportClose', this.transport, code, reason);
  if (this._transport) {
    this._transport.removeAllListeners();
    this._transport = null;
    this.transport = null;
  }

  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
    this._connect();
    return;
  }

  this._close(code, reason);
};

SockJS.prototype._open = function() {
  debug('_open', this._transport.transportName, this.readyState);
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transportTimeoutId) {
      clearTimeout(this._transportTimeoutId);
      this._transportTimeoutId = null;
    }
    this.readyState = SockJS.OPEN;
    this.transport = this._transport.transportName;
    this.dispatchEvent(new Event('open'));
    debug('connected', this.transport);
  } else {
    // The server might have been restarted, and lost track of our
    // connection.
    this._close(1006, 'Server lost session');
  }
};

SockJS.prototype._close = function(code, reason, wasClean) {
  debug('_close', this.transport, code, reason, wasClean, this.readyState);
  var forceFail = false;

  if (this._ir) {
    forceFail = true;
    this._ir.close();
    this._ir = null;
  }
  if (this._transport) {
    this._transport.close();
    this._transport = null;
    this.transport = null;
  }

  if (this.readyState === SockJS.CLOSED) {
    throw new Error('InvalidStateError: SockJS has already been closed');
  }

  this.readyState = SockJS.CLOSING;
  setTimeout(function() {
    this.readyState = SockJS.CLOSED;

    if (forceFail) {
      this.dispatchEvent(new Event('error'));
    }

    var e = new CloseEvent('close');
    e.wasClean = wasClean || false;
    e.code = code || 1000;
    e.reason = reason;

    this.dispatchEvent(e);
    this.onmessage = this.onclose = this.onerror = null;
    debug('disconnected');
  }.bind(this), 0);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
SockJS.prototype.countRTO = function(rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
  if (rtt > 100) {
    return 4 * rtt; // rto > 400msec
  }
  return 300 + rtt; // 300msec < rto <= 400msec
};

module.exports = function(availableTransports) {
  transports = transport(availableTransports);
  require('./iframe-bootstrap')(SockJS, availableTransports);
  return SockJS;
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./event/close":2,"./event/event":4,"./event/eventtarget":5,"./event/trans-message":6,"./iframe-bootstrap":8,"./info-receiver":12,"./location":13,"./shims":15,"./utils/browser":44,"./utils/escape":45,"./utils/event":46,"./utils/log":48,"./utils/object":49,"./utils/random":50,"./utils/transport":51,"./utils/url":52,"./version":53,"debug":55,"inherits":57,"json3":58,"url-parse":61}],15:[function(require,module,exports){
/* eslint-disable */
/* jscs: disable */
'use strict';

// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);

},{}],16:[function(require,module,exports){
'use strict';

module.exports = [
  // streaming transports
  require('./transport/websocket')
, require('./transport/xhr-streaming')
, require('./transport/xdr-streaming')
, require('./transport/eventsource')
, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))

  // polling transports
, require('./transport/htmlfile')
, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))
, require('./transport/xhr-polling')
, require('./transport/xdr-polling')
, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))
, require('./transport/jsonp-polling')
];

},{"./transport/eventsource":20,"./transport/htmlfile":21,"./transport/jsonp-polling":23,"./transport/lib/iframe-wrap":26,"./transport/websocket":38,"./transport/xdr-polling":39,"./transport/xdr-streaming":40,"./transport/xhr-polling":41,"./transport/xhr-streaming":42}],17:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('../../utils/event')
  , urlUtils = require('../../utils/url')
  , XHR = global.XMLHttpRequest
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:browser:xhr');
}

function AbstractXHRObject(method, url, payload, opts) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function () {
    self._start(method, url, payload, opts);
  }, 0);
}

inherits(AbstractXHRObject, EventEmitter);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
  var self = this;

  try {
    this.xhr = new XHR();
  } catch (x) {
    // intentionally empty
  }

  if (!this.xhr) {
    debug('no xhr');
    this.emit('finish', 0, 'no xhr support');
    this._cleanup();
    return;
  }

  // several browsers cache POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload cleanup');
    self._cleanup(true);
  });
  try {
    this.xhr.open(method, url, true);
    if (this.timeout && 'timeout' in this.xhr) {
      this.xhr.timeout = this.timeout;
      this.xhr.ontimeout = function() {
        debug('xhr timeout');
        self.emit('finish', 0, '');
        self._cleanup(false);
      };
    }
  } catch (e) {
    debug('exception', e);
    // IE raises an exception on wrong port.
    this.emit('finish', 0, '');
    this._cleanup(false);
    return;
  }

  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
    debug('withCredentials');
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

    this.xhr.withCredentials = true;
  }
  if (opts && opts.headers) {
    for (var key in opts.headers) {
      this.xhr.setRequestHeader(key, opts.headers[key]);
    }
  }

  this.xhr.onreadystatechange = function() {
    if (self.xhr) {
      var x = self.xhr;
      var text, status;
      debug('readyState', x.readyState);
      switch (x.readyState) {
      case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
        try {
          status = x.status;
          text = x.responseText;
        } catch (e) {
          // intentionally empty
        }
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }

        // IE does return readystate == 3 for 404 answers.
        if (status === 200 && text && text.length > 0) {
          debug('chunk');
          self.emit('chunk', status, text);
        }
        break;
      case 4:
        status = x.status;
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
        if (status === 12005 || status === 12029) {
          status = 0;
        }

        debug('finish', status, x.responseText);
        self.emit('finish', status, x.responseText);
        self._cleanup(false);
        break;
      }
    }
  };

  try {
    self.xhr.send(payload);
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
};

AbstractXHRObject.prototype._cleanup = function(abort) {
  debug('cleanup');
  if (!this.xhr) {
    return;
  }
  this.removeAllListeners();
  utils.unloadDel(this.unloadRef);

  // IE needs this field to be a function
  this.xhr.onreadystatechange = function() {};
  if (this.xhr.ontimeout) {
    this.xhr.ontimeout = null;
  }

  if (abort) {
    try {
      this.xhr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

AbstractXHRObject.enabled = !!XHR;
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (!AbstractXHRObject.enabled && (axo in global)) {
  debug('overriding xmlhttprequest');
  XHR = function() {
    try {
      return new global[axo]('Microsoft.XMLHTTP');
    } catch (e) {
      return null;
    }
  };
  AbstractXHRObject.enabled = !!new XHR();
}

var cors = false;
try {
  cors = 'withCredentials' in new XHR();
} catch (ignored) {
  // intentionally empty
}

AbstractXHRObject.supportsCORS = cors;

module.exports = AbstractXHRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],18:[function(require,module,exports){
(function (global){
module.exports = global.EventSource;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
(function (global){
'use strict';

var Driver = global.WebSocket || global.MozWebSocket;
if (Driver) {
	module.exports = function WebSocketBrowserDriver(url) {
		return new Driver(url);
	};
} else {
	module.exports = undefined;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , EventSourceReceiver = require('./receiver/eventsource')
  , XHRCorsObject = require('./sender/xhr-cors')
  , EventSourceDriver = require('eventsource')
  ;

function EventSourceTransport(transUrl) {
  if (!EventSourceTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
}

inherits(EventSourceTransport, AjaxBasedTransport);

EventSourceTransport.enabled = function() {
  return !!EventSourceDriver;
};

EventSourceTransport.transportName = 'eventsource';
EventSourceTransport.roundTrips = 2;

module.exports = EventSourceTransport;

},{"./lib/ajax-based":24,"./receiver/eventsource":29,"./sender/xhr-cors":35,"eventsource":18,"inherits":57}],21:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , HtmlfileReceiver = require('./receiver/htmlfile')
  , XHRLocalObject = require('./sender/xhr-local')
  , AjaxBasedTransport = require('./lib/ajax-based')
  ;

function HtmlFileTransport(transUrl) {
  if (!HtmlfileReceiver.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
}

inherits(HtmlFileTransport, AjaxBasedTransport);

HtmlFileTransport.enabled = function(info) {
  return HtmlfileReceiver.enabled && info.sameOrigin;
};

HtmlFileTransport.transportName = 'htmlfile';
HtmlFileTransport.roundTrips = 2;

module.exports = HtmlFileTransport;

},{"./lib/ajax-based":24,"./receiver/htmlfile":30,"./sender/xhr-local":37,"inherits":57}],22:[function(require,module,exports){
(function (process){
'use strict';

// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var inherits = require('inherits')
  , JSON3 = require('json3')
  , EventEmitter = require('events').EventEmitter
  , version = require('../version')
  , urlUtils = require('../utils/url')
  , iframeUtils = require('../utils/iframe')
  , eventUtils = require('../utils/event')
  , random = require('../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:transport:iframe');
}

function IframeTransport(transport, transUrl, baseUrl) {
  if (!IframeTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  EventEmitter.call(this);

  var self = this;
  this.origin = urlUtils.getOrigin(baseUrl);
  this.baseUrl = baseUrl;
  this.transUrl = transUrl;
  this.transport = transport;
  this.windowId = random.string(8);

  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
  debug(transport, transUrl, iframeUrl);

  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
    debug('err callback');
    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
    self.close();
  });

  this.onmessageCallback = this._message.bind(this);
  eventUtils.attachEvent('message', this.onmessageCallback);
}

inherits(IframeTransport, EventEmitter);

IframeTransport.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.iframeObj) {
    eventUtils.detachEvent('message', this.onmessageCallback);
    try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
      this.postMessage('c');
    } catch (x) {
      // intentionally empty
    }
    this.iframeObj.cleanup();
    this.iframeObj = null;
    this.onmessageCallback = this.iframeObj = null;
  }
};

IframeTransport.prototype._message = function(e) {
  debug('message', e.data);
  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
    debug('not same origin', e.origin, this.origin);
    return;
  }

  var iframeMessage;
  try {
    iframeMessage = JSON3.parse(e.data);
  } catch (ignored) {
    debug('bad json', e.data);
    return;
  }

  if (iframeMessage.windowId !== this.windowId) {
    debug('mismatched window id', iframeMessage.windowId, this.windowId);
    return;
  }

  switch (iframeMessage.type) {
  case 's':
    this.iframeObj.loaded();
    // window global dependency
    this.postMessage('s', JSON3.stringify([
      version
    , this.transport
    , this.transUrl
    , this.baseUrl
    ]));
    break;
  case 't':
    this.emit('message', iframeMessage.data);
    break;
  case 'c':
    var cdata;
    try {
      cdata = JSON3.parse(iframeMessage.data);
    } catch (ignored) {
      debug('bad json', iframeMessage.data);
      return;
    }
    this.emit('close', cdata[0], cdata[1]);
    this.close();
    break;
  }
};

IframeTransport.prototype.postMessage = function(type, data) {
  debug('postMessage', type, data);
  this.iframeObj.post(JSON3.stringify({
    windowId: this.windowId
  , type: type
  , data: data || ''
  }), this.origin);
};

IframeTransport.prototype.send = function(message) {
  debug('send', message);
  this.postMessage('m', message);
};

IframeTransport.enabled = function() {
  return iframeUtils.iframeEnabled;
};

IframeTransport.transportName = 'iframe';
IframeTransport.roundTrips = 2;

module.exports = IframeTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/iframe":47,"../utils/random":50,"../utils/url":52,"../version":53,"debug":55,"events":3,"inherits":57,"json3":58}],23:[function(require,module,exports){
(function (global){
'use strict';

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = require('inherits')
  , SenderReceiver = require('./lib/sender-receiver')
  , JsonpReceiver = require('./receiver/jsonp')
  , jsonpSender = require('./sender/jsonp')
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/sender-receiver":28,"./receiver/jsonp":31,"./sender/jsonp":33,"inherits":57}],24:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , SenderReceiver = require('./sender-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:ajax-based');
}

function createAjaxSender(AjaxObject) {
  return function(url, payload, callback) {
    debug('create ajax sender', url, payload);
    var opt = {};
    if (typeof payload === 'string') {
      opt.headers = {'Content-type': 'text/plain'};
    }
    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
    xo.once('finish', function(status) {
      debug('finish', status);
      xo = null;

      if (status !== 200 && status !== 204) {
        return callback(new Error('http status ' + status));
      }
      callback();
    });
    return function() {
      debug('abort');
      xo.close();
      xo = null;

      var err = new Error('Aborted');
      err.code = 1000;
      callback(err);
    };
  };
}

function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
}

inherits(AjaxBasedTransport, SenderReceiver);

module.exports = AjaxBasedTransport;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./sender-receiver":28,"debug":55,"inherits":57}],25:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self.close();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.close = function() {
  debug('close');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],26:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , IframeTransport = require('../iframe')
  , objectUtils = require('../../utils/object')
  ;

module.exports = function(transport) {

  function IframeWrapTransport(transUrl, baseUrl) {
    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
  }

  inherits(IframeWrapTransport, IframeTransport);

  IframeWrapTransport.enabled = function(url, info) {
    if (!global.document) {
      return false;
    }

    var iframeInfo = objectUtils.extend({}, info);
    iframeInfo.sameOrigin = true;
    return transport.enabled(iframeInfo) && IframeTransport.enabled();
  };

  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
  IframeWrapTransport.needBody = true;
  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

  IframeWrapTransport.facadeTransport = transport;

  return IframeWrapTransport;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/object":49,"../iframe":22,"inherits":57}],27:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],28:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , BufferedSender = require('./buffered-sender')
  , Polling = require('./polling')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender-receiver');
}

function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
  debug(pollUrl);
  var self = this;
  BufferedSender.call(this, transUrl, senderFunc);

  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
  this.poll.on('message', function(msg) {
    debug('poll message', msg);
    self.emit('message', msg);
  });
  this.poll.once('close', function(code, reason) {
    debug('poll close', code, reason);
    self.poll = null;
    self.emit('close', code, reason);
    self.close();
  });
}

inherits(SenderReceiver, BufferedSender);

SenderReceiver.prototype.close = function() {
  BufferedSender.prototype.close.call(this);
  debug('close');
  this.removeAllListeners();
  if (this.poll) {
    this.poll.abort();
    this.poll = null;
  }
};

module.exports = SenderReceiver;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./buffered-sender":25,"./polling":27,"debug":55,"inherits":57}],29:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , EventSourceDriver = require('eventsource')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"eventsource":18,"inherits":57}],30:[function(require,module,exports){
(function (process,global){
'use strict';

var inherits = require('inherits')
  , iframeUtils = require('../../utils/iframe')
  , urlUtils = require('../../utils/url')
  , EventEmitter = require('events').EventEmitter
  , random = require('../../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {
    // intentionally empty
  }
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],31:[function(require,module,exports){
(function (process,global){
'use strict';

var utils = require('../../utils/iframe')
  , random = require('../../utils/random')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {
          // intentionally empty
        }
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {
        // intentionally empty
      }
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],32:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:xhr');
}

function XhrReceiver(url, AjaxObject) {
  debug(url);
  EventEmitter.call(this);
  var self = this;

  this.bufferPosition = 0;

  this.xo = new AjaxObject('POST', url, null);
  this.xo.on('chunk', this._chunkHandler.bind(this));
  this.xo.once('finish', function(status, text) {
    debug('finish', status, text);
    self._chunkHandler(status, text);
    self.xo = null;
    var reason = status === 200 ? 'network' : 'permanent';
    debug('close', reason);
    self.emit('close', null, reason);
    self._cleanup();
  });
}

inherits(XhrReceiver, EventEmitter);

XhrReceiver.prototype._chunkHandler = function(status, text) {
  debug('_chunkHandler', status);
  if (status !== 200 || !text) {
    return;
  }

  for (var idx = -1; ; this.bufferPosition += idx + 1) {
    var buf = text.slice(this.bufferPosition);
    idx = buf.indexOf('\n');
    if (idx === -1) {
      break;
    }
    var msg = buf.slice(0, idx);
    if (msg) {
      debug('message', msg);
      this.emit('message', msg);
    }
  }
};

XhrReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

XhrReceiver.prototype.abort = function() {
  debug('abort');
  if (this.xo) {
    this.xo.close();
    debug('close');
    this.emit('close', null, 'user');
    this.xo = null;
  }
  this._cleanup();
};

module.exports = XhrReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],33:[function(require,module,exports){
(function (process,global){
'use strict';

var random = require('../../utils/random')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/random":50,"../../utils/url":52,"debug":55}],34:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , eventUtils = require('../../utils/event')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:xdr');
}

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

function XDRObject(method, url, payload) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self._start(method, url, payload);
  }, 0);
}

inherits(XDRObject, EventEmitter);

XDRObject.prototype._start = function(method, url, payload) {
  debug('_start');
  var self = this;
  var xdr = new global.XDomainRequest();
  // IE caches even POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  xdr.onerror = function() {
    debug('onerror');
    self._error();
  };
  xdr.ontimeout = function() {
    debug('ontimeout');
    self._error();
  };
  xdr.onprogress = function() {
    debug('progress', xdr.responseText);
    self.emit('chunk', 200, xdr.responseText);
  };
  xdr.onload = function() {
    debug('load');
    self.emit('finish', 200, xdr.responseText);
    self._cleanup(false);
  };
  this.xdr = xdr;
  this.unloadRef = eventUtils.unloadAdd(function() {
    self._cleanup(true);
  });
  try {
    // Fails with AccessDenied if port number is bogus
    this.xdr.open(method, url);
    if (this.timeout) {
      this.xdr.timeout = this.timeout;
    }
    this.xdr.send(payload);
  } catch (x) {
    this._error();
  }
};

XDRObject.prototype._error = function() {
  this.emit('finish', 0, '');
  this._cleanup(false);
};

XDRObject.prototype._cleanup = function(abort) {
  debug('cleanup', abort);
  if (!this.xdr) {
    return;
  }
  this.removeAllListeners();
  eventUtils.unloadDel(this.unloadRef);

  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
  if (abort) {
    try {
      this.xdr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xdr = null;
};

XDRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

// IE 8/9 if the request target uses the same scheme - #79
XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

module.exports = XDRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],35:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRCorsObject(method, url, payload, opts) {
  XhrDriver.call(this, method, url, payload, opts);
}

inherits(XHRCorsObject, XhrDriver);

XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

module.exports = XHRCorsObject;

},{"../driver/xhr":17,"inherits":57}],36:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;

},{"events":3,"inherits":57}],37:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRLocalObject(method, url, payload /*, opts */) {
  XhrDriver.call(this, method, url, payload, {
    noCredentials: true
  });
}

inherits(XHRLocalObject, XhrDriver);

XHRLocalObject.enabled = XhrDriver.enabled;

module.exports = XHRLocalObject;

},{"../driver/xhr":17,"inherits":57}],38:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('../utils/event')
  , urlUtils = require('../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , WebsocketDriver = require('./driver/websocket')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:websocket');
}

function WebSocketTransport(transUrl, ignore, options) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url, [], options);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  var ws = this.ws;
  this._cleanup();
  if (ws) {
    ws.close();
  }
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/url":52,"./driver/websocket":19,"debug":55,"events":3,"inherits":57}],39:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XdrStreamingTransport = require('./xdr-streaming')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"./xdr-streaming":40,"inherits":57}],40:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

function XdrStreamingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
}

inherits(XdrStreamingTransport, AjaxBasedTransport);

XdrStreamingTransport.enabled = function(info) {
  if (info.cookie_needed || info.nullOrigin) {
    return false;
  }
  return XDRObject.enabled && info.sameScheme;
};

XdrStreamingTransport.transportName = 'xdr-streaming';
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrStreamingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"inherits":57}],41:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  ;

function XhrPollingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
}

inherits(XhrPollingTransport, AjaxBasedTransport);

XhrPollingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }

  if (XHRLocalObject.enabled && info.sameOrigin) {
    return true;
  }
  return XHRCorsObject.enabled;
};

XhrPollingTransport.transportName = 'xhr-polling';
XhrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XhrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],42:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  , browser = require('../utils/browser')
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../utils/browser":44,"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],43:[function(require,module,exports){
(function (global){
'use strict';

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],44:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  isOpera: function() {
    return global.navigator &&
      /opera/i.test(global.navigator.userAgent);
  }

, isKonqueror: function() {
    return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent);
  }

  // #187 wrap document.domain in try/catch because of WP8 from file:///
, hasDomain: function () {
    // non-browser client always has a domain
    if (!global.document) {
      return true;
    }

    try {
      return !!global.document.domain;
    } catch (e) {
      return false;
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],45:[function(require,module,exports){
'use strict';

var JSON3 = require('json3');

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
// eslint-disable-next-line no-control-regex
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON3.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};

},{"json3":58}],46:[function(require,module,exports){
(function (global){
'use strict';

var random = require('./random');

var onUnload = {}
  , afterUnload = false
    // detect google chrome packaged apps because they don't allow the 'unload' event
  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
  ;

module.exports = {
  attachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.addEventListener(event, listener, false);
    } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
      global.document.attachEvent('on' + event, listener);
      // I get 'window' for ie8.
      global.attachEvent('on' + event, listener);
    }
  }

, detachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.removeEventListener(event, listener, false);
    } else if (global.document && global.detachEvent) {
      global.document.detachEvent('on' + event, listener);
      global.detachEvent('on' + event, listener);
    }
  }

, unloadAdd: function(listener) {
    if (isChromePackagedApp) {
      return null;
    }

    var ref = random.string(8);
    onUnload[ref] = listener;
    if (afterUnload) {
      setTimeout(this.triggerUnloadCallbacks, 0);
    }
    return ref;
  }

, unloadDel: function(ref) {
    if (ref in onUnload) {
      delete onUnload[ref];
    }
  }

, triggerUnloadCallbacks: function() {
    for (var ref in onUnload) {
      onUnload[ref]();
      delete onUnload[ref];
    }
  }
};

var unloadTriggered = function() {
  if (afterUnload) {
    return;
  }
  afterUnload = true;
  module.exports.triggerUnloadCallbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
if (!isChromePackagedApp) {
  module.exports.attachEvent('unload', unloadTriggered);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./random":50}],47:[function(require,module,exports){
(function (process,global){
'use strict';

var eventUtils = require('./event')
  , JSON3 = require('json3')
  , browser = require('./browser')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:iframe');
}

module.exports = {
  WPrefix: '_jp'
, currentWindowId: null

, polluteGlobalNamespace: function() {
    if (!(module.exports.WPrefix in global)) {
      global[module.exports.WPrefix] = {};
    }
  }

, postMessage: function(type, data) {
    if (global.parent !== global) {
      global.parent.postMessage(JSON3.stringify({
        windowId: module.exports.currentWindowId
      , type: type
      , data: data || ''
      }), '*');
    } else {
      debug('Cannot postMessage, no parent window.', type, data);
    }
  }

, createIframe: function(iframeUrl, errorCallback) {
    var iframe = global.document.createElement('iframe');
    var tref, unloadRef;
    var unattach = function() {
      debug('unattach');
      clearTimeout(tref);
      // Explorer had problems with that.
      try {
        iframe.onload = null;
      } catch (x) {
        // intentionally empty
      }
      iframe.onerror = null;
    };
    var cleanup = function() {
      debug('cleanup');
      if (iframe) {
        unattach();
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
        setTimeout(function() {
          if (iframe) {
            iframe.parentNode.removeChild(iframe);
          }
          iframe = null;
        }, 0);
        eventUtils.unloadDel(unloadRef);
      }
    };
    var onerror = function(err) {
      debug('onerror', err);
      if (iframe) {
        cleanup();
        errorCallback(err);
      }
    };
    var post = function(msg, origin) {
      debug('post', msg, origin);
      setTimeout(function() {
        try {
          // When the iframe is not loaded, IE raises an exception
          // on 'contentWindow'.
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage(msg, origin);
          }
        } catch (x) {
          // intentionally empty
        }
      }, 0);
    };

    iframe.src = iframeUrl;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function() {
      onerror('onerror');
    };
    iframe.onload = function() {
      debug('onload');
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
      clearTimeout(tref);
      tref = setTimeout(function() {
        onerror('onload timeout');
      }, 2000);
    };
    global.document.body.appendChild(iframe);
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }

/* eslint no-undef: "off", new-cap: "off" */
, createHtmlfile: function(iframeUrl, errorCallback) {
    var axo = ['Active'].concat('Object').join('X');
    var doc = new global[axo]('htmlfile');
    var tref, unloadRef;
    var iframe;
    var unattach = function() {
      clearTimeout(tref);
      iframe.onerror = null;
    };
    var cleanup = function() {
      if (doc) {
        unattach();
        eventUtils.unloadDel(unloadRef);
        iframe.parentNode.removeChild(iframe);
        iframe = doc = null;
        CollectGarbage();
      }
    };
    var onerror = function(r) {
      debug('onerror', r);
      if (doc) {
        cleanup();
        errorCallback(r);
      }
    };
    var post = function(msg, origin) {
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {
        // intentionally empty
      }
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframeUrl;
    iframe.onerror = function() {
      onerror('onerror');
    };
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }
};

module.exports.iframeEnabled = false;
if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror());
}

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./browser":44,"./event":46,"debug":55,"json3":58}],48:[function(require,module,exports){
(function (global){
'use strict';

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists;

  try {
    levelExists = global.console && global.console[level] && global.console[level].apply;
  } catch(e) {
    // do nothing
  }

  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
'use strict';

module.exports = {
  isObject: function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

, extend: function(obj) {
    if (!this.isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  }
};

},{}],50:[function(require,module,exports){
'use strict';

/* global crypto:true */
var crypto = require('crypto');

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
module.exports = {
  string: function(length) {
    var max = _randomStringChars.length;
    var bytes = crypto.randomBytes(length);
    var ret = [];
    for (var i = 0; i < length; i++) {
      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
    }
    return ret.join('');
  }

, number: function(max) {
    return Math.floor(Math.random() * max);
  }

, numberString: function(max) {
    var t = ('' + (max - 1)).length;
    var p = new Array(t + 1).join('0');
    return (p + this.number(max)).slice(-t);
  }
};

},{"crypto":43}],51:[function(require,module,exports){
(function (process){
'use strict';

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

}).call(this,{ env: {} })

},{"debug":55}],52:[function(require,module,exports){
(function (process){
'use strict';

var URL = require('url-parse');

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:url');
}

module.exports = {
  getOrigin: function(url) {
    if (!url) {
      return null;
    }

    var p = new URL(url);
    if (p.protocol === 'file:') {
      return null;
    }

    var port = p.port;
    if (!port) {
      port = (p.protocol === 'https:') ? '443' : '80';
    }

    return p.protocol + '//' + p.hostname + ':' + port;
  }

, isOriginEqual: function(a, b) {
    var res = this.getOrigin(a) === this.getOrigin(b);
    debug('same', a, b, res);
    return res;
  }

, isSchemeEqual: function(a, b) {
    return (a.split(':')[0] === b.split(':')[0]);
  }

, addPath: function (url, path) {
    var qs = url.split('?');
    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
  }

, addQuery: function (url, q) {
    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
  }
};

}).call(this,{ env: {} })

},{"debug":55,"url-parse":61}],53:[function(require,module,exports){
module.exports = '1.3.0';

},{}],54:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],55:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};


}).call(this,{ env: {} })

},{"./common":56}],56:[function(require,module,exports){
"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;


},{"ms":54}],57:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],58:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String} The decoded string.
 * @api private
 */
function decode(input) {
  return decodeURIComponent(input.replace(/\+/g, ' '));
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    if (key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],60:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],61:[function(require,module,exports){
(function (global){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var location = global && global.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} location Location defaults for relative paths.
 * @param {Boolean|Function} parser Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.qs = qs;

module.exports = Url;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":59,"requires-port":60}]},{},[1])(1)
});


//# sourceMappingURL=sockjs.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(8)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).

var ansiHTML = __webpack_require__(16);

var Entities = __webpack_require__(17).AllHtmlEntities;

var entities = new Entities();
var colors = {
  reset: ['transparent', 'transparent'],
  black: '181818',
  red: 'E36049',
  green: 'B3CB74',
  yellow: 'FFD080',
  blue: '7CAFC2',
  magenta: '7FACCA',
  cyan: 'C3C2EF',
  lightgrey: 'EBE7E3',
  darkgrey: '6D7891'
};
ansiHTML.setColors(colors);

function createOverlayIframe(onIframeLoad) {
  var iframe = document.createElement('iframe');
  iframe.id = 'webpack-dev-server-client-overlay';
  iframe.src = 'about:blank';
  iframe.style.position = 'fixed';
  iframe.style.left = 0;
  iframe.style.top = 0;
  iframe.style.right = 0;
  iframe.style.bottom = 0;
  iframe.style.width = '100vw';
  iframe.style.height = '100vh';
  iframe.style.border = 'none';
  iframe.style.zIndex = 9999999999;
  iframe.onload = onIframeLoad;
  return iframe;
}

function addOverlayDivTo(iframe) {
  var div = iframe.contentDocument.createElement('div');
  div.id = 'webpack-dev-server-client-overlay-div';
  div.style.position = 'fixed';
  div.style.boxSizing = 'border-box';
  div.style.left = 0;
  div.style.top = 0;
  div.style.right = 0;
  div.style.bottom = 0;
  div.style.width = '100vw';
  div.style.height = '100vh';
  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
  div.style.color = '#E8E8E8';
  div.style.fontFamily = 'Menlo, Consolas, monospace';
  div.style.fontSize = 'large';
  div.style.padding = '2rem';
  div.style.lineHeight = '1.2';
  div.style.whiteSpace = 'pre-wrap';
  div.style.overflow = 'auto';
  iframe.contentDocument.body.appendChild(div);
  return div;
}

var overlayIframe = null;
var overlayDiv = null;
var lastOnOverlayDivReady = null;

function ensureOverlayDivExists(onOverlayDivReady) {
  if (overlayDiv) {
    // Everything is ready, call the callback right away.
    onOverlayDivReady(overlayDiv);
    return;
  } // Creating an iframe may be asynchronous so we'll schedule the callback.
  // In case of multiple calls, last callback wins.


  lastOnOverlayDivReady = onOverlayDivReady;

  if (overlayIframe) {
    // We're already creating it.
    return;
  } // Create iframe and, when it is ready, a div inside it.


  overlayIframe = createOverlayIframe(function () {
    overlayDiv = addOverlayDivTo(overlayIframe); // Now we can talk!

    lastOnOverlayDivReady(overlayDiv);
  }); // Zalgo alert: onIframeLoad() will be called either synchronously
  // or asynchronously depending on the browser.
  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.

  document.body.appendChild(overlayIframe);
}

function showMessageOverlay(message) {
  ensureOverlayDivExists(function (div) {
    // Make it look similar to our terminal.
    div.innerHTML = "<span style=\"color: #".concat(colors.red, "\">Failed to compile.</span><br><br>").concat(ansiHTML(entities.encode(message)));
  });
}

function destroyErrorOverlay() {
  if (!overlayDiv) {
    // It is not there in the first place.
    return;
  } // Clean up and reset internal state.


  document.body.removeChild(overlayIframe);
  overlayDiv = null;
  overlayIframe = null;
  lastOnOverlayDivReady = null;
} // Successful compilation.


exports.clear = function handleSuccess() {
  destroyErrorOverlay();
}; // Compilation with errors (e.g. syntax error or missing modules).


exports.showMessage = function handleMessage(messages) {
  showMessageOverlay(messages[0]);
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
}
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
}
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
}
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
}

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text
  }

  // Cache opened sequence.
  var ansiCodes = []
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
    var ot = _openTags[seq]
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop()
        return '</span>'
      }
      // Open tag.
      ansiCodes.push(seq)
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
    }

    var ct = _closeTags[seq]
    if (ct) {
      // Pop sequence
      ansiCodes.pop()
      return ct
    }
    return ''
  })

  // Make sure tags are closed.
  var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

  return ret
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.')
  }

  var _finalColors = {}
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null
    if (!hex) {
      _finalColors[key] = _defColors[key]
      continue
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex]
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string'
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
      }
      var defHexColor = _defColors[key]
      if (!hex[0]) {
        hex[0] = defHexColor[0]
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]]
        hex.push(defHexColor[1])
      }

      hex = hex.slice(0, 2)
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
    }
    _finalColors[key] = hex
  }
  _setTags(_finalColors)
}

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors)
}

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {}

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () { return _openTags }
  })
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () { return _closeTags }
  })
} else {
  ansiHTML.tags.open = _openTags
  ansiHTML.tags.close = _closeTags
}

function _setTags (colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey

  for (var code in _styles) {
    var color = _styles[code]
    var oriColor = colors[color] || '000'
    _openTags[code] = 'color:#' + oriColor
    code = parseInt(code)
    _openTags[(code + 10).toString()] = 'background:#' + oriColor
  }
}

ansiHTML.reset()


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  XmlEntities: __webpack_require__(18),
  Html4Entities: __webpack_require__(19),
  Html5Entities: __webpack_require__(20),
  AllHtmlEntities: __webpack_require__(20)
};


/***/ }),
/* 18 */
/***/ (function(module, exports) {

var ALPHA_INDEX = {
    '&lt': '<',
    '&gt': '>',
    '&quot': '"',
    '&apos': '\'',
    '&amp': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': '\'',
    '&amp;': '&'
};

var CHAR_INDEX = {
    60: 'lt',
    62: 'gt',
    34: 'quot',
    39: 'apos',
    38: 'amp'
};

var CHAR_S_INDEX = {
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;',
    '&': '&amp;'
};

/**
 * @constructor
 */
function XmlEntities() {}

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/<|>|"|'|&/g, function(s) {
        return CHAR_S_INDEX[s];
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encode = function(str) {
    return new XmlEntities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {
        if (s.charAt(1) === '#') {
            var code = s.charAt(2).toLowerCase() === 'x' ?
                parseInt(s.substr(3), 16) :
                parseInt(s.substr(2));

            if (isNaN(code) || code < -32768 || code > 65535) {
                return '';
            }
            return String.fromCharCode(code);
        }
        return ALPHA_INDEX[s] || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.decode = function(str) {
    return new XmlEntities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var alpha = CHAR_INDEX[c];
        if (alpha) {
            result += "&" + alpha + ";";
            i++;
            continue;
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonUTF = function(str) {
    return new XmlEntities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLenght = str.length;
    var result = '';
    var i = 0;
    while (i < strLenght) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonASCII = function(str) {
    return new XmlEntities().encodeNonASCII(str);
 };

module.exports = XmlEntities;


/***/ }),
/* 19 */
/***/ (function(module, exports) {

var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];

var alphaIndex = {};
var numIndex = {};

var i = 0;
var length = HTML_ALPHA.length;
while (i < length) {
    var a = HTML_ALPHA[i];
    var c = HTML_CODES[i];
    alphaIndex[a] = String.fromCharCode(c);
    numIndex[c] = a;
    i++;
}

/**
 * @constructor
 */
function Html4Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1).toLowerCase() === 'x' ?
                parseInt(entity.substr(2), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.decode = function(str) {
    return new Html4Entities().decode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var alpha = numIndex[str.charCodeAt(i)];
        result += alpha ? "&" + alpha + ";" : str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encode = function(str) {
    return new Html4Entities().encode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var cc = str.charCodeAt(i);
        var alpha = numIndex[cc];
        if (alpha) {
            result += "&" + alpha + ";";
        } else if (cc < 32 || cc > 126) {
            result += "&#" + cc + ";";
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonUTF = function(str) {
    return new Html4Entities().encodeNonUTF(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonASCII = function(str) {
    return new Html4Entities().encodeNonASCII(str);
};

module.exports = Html4Entities;


/***/ }),
/* 20 */
/***/ (function(module, exports) {

var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];

var alphaIndex = {};
var charIndex = {};

createIndexes(alphaIndex, charIndex);

/**
 * @constructor
 */
function Html5Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1) === 'x' ?
                parseInt(entity.substr(2).toLowerCase(), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.decode = function(str) {
    return new Html5Entities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var charInfo = charIndex[str.charCodeAt(i)];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        result += str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encode = function(str) {
    return new Html5Entities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var charInfo = charIndex[c];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonUTF = function(str) {
    return new Html5Entities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonASCII = function(str) {
    return new Html5Entities().encodeNonASCII(str);
 };

/**
 * @param {Object} alphaIndex Passed by reference.
 * @param {Object} charIndex Passed by reference.
 */
function createIndexes(alphaIndex, charIndex) {
    var i = ENTITIES.length;
    var _results = [];
    while (i--) {
        var e = ENTITIES[i];
        var alpha = e[0];
        var chars = e[1];
        var chr = chars[0];
        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo;
        if (addChar) {
            charInfo = charIndex[chr] = charIndex[chr] || {};
        }
        if (chars[1]) {
            var chr2 = chars[1];
            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
            _results.push(addChar && (charInfo[chr2] = alpha));
        } else {
            alphaIndex[alpha] = String.fromCharCode(chr);
            _results.push(addChar && (charInfo[''] = alpha));
        }
    }
}

module.exports = Html5Entities;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./log": 22
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) { // check for number or string
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return id;
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 21;

/***/ }),
/* 22 */
/***/ (function(module, exports) {

var logLevel = "info";

function dummy() {}

function shouldLog(level) {
	var shouldLog =
		(logLevel === "info" && level === "info") ||
		(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning") ||
		(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error");
	return shouldLog;
}

function logGroup(logFn) {
	return function(level, msg) {
		if (shouldLog(level)) {
			logFn(msg);
		}
	};
}

module.exports = function(level, msg) {
	if (shouldLog(level)) {
		if (level === "info") {
			console.log(msg);
		} else if (level === "warning") {
			console.warn(msg);
		} else if (level === "error") {
			console.error(msg);
		}
	}
};

/* eslint-disable node/no-unsupported-features/node-builtins */
var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
/* eslint-enable node/no-unsupported-features/node-builtins */

module.exports.group = logGroup(group);

module.exports.groupCollapsed = logGroup(groupCollapsed);

module.exports.groupEnd = logGroup(groupEnd);

module.exports.setLogLevel = function(level) {
	logLevel = level;
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var EventEmitter = __webpack_require__(24);
module.exports = new EventEmitter();


/***/ }),
/* 24 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 25 */,
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.5+7f2b526d
 */

(function (global, factory) {
	 true ? module.exports = factory() :
	undefined;
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && "function" === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var TRY_CATCH_ERROR = { error: null };

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    TRY_CATCH_ERROR.error = error;
    return TRY_CATCH_ERROR;
  }
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === TRY_CATCH_ERROR) {
      reject(promise, TRY_CATCH_ERROR.error);
      TRY_CATCH_ERROR.error = null;
    } else if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = void 0,
      failed = void 0;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value.error = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (failed) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = getThen(entry);

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        handleMaybeThenable(promise, entry, _then);
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    if (isFunction(callback)) {
      return promise.then(function (value) {
        return constructor.resolve(callback()).then(function () {
          return value;
        });
      }, function (reason) {
        return constructor.resolve(callback()).then(function () {
          throw reason;
        });
      });
    }

    return promise.then(callback, callback);
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));



//# sourceMappingURL=es6-promise.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(27), __webpack_require__(8)))

/***/ }),
/* 27 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__28__;

/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32Array", function() { return Float32Array; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getComputedStyle", function() { return getComputedStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "userAgent", function() { return userAgent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRANSFORM", function() { return TRANSFORM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SUPPORT_TOUCH", function() { return SUPPORT_TOUCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SUPPORT_DEVICEMOTION", function() { return SUPPORT_DEVICEMOTION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SUPPORT_WILLCHANGE", function() { return SUPPORT_WILLCHANGE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DeviceMotionEvent", function() { return DeviceMotionEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "devicePixelRatio", function() { return devicePixelRatio; });
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/**
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */

_browser__WEBPACK_IMPORTED_MODULE_0__["window"].Float32Array = typeof _browser__WEBPACK_IMPORTED_MODULE_0__["window"].Float32Array !== "undefined" ? _browser__WEBPACK_IMPORTED_MODULE_0__["window"].Float32Array : _browser__WEBPACK_IMPORTED_MODULE_0__["window"].Array;
var Float32Array = _browser__WEBPACK_IMPORTED_MODULE_0__["window"].Float32Array;
var getComputedStyle = _browser__WEBPACK_IMPORTED_MODULE_0__["window"].getComputedStyle;
var userAgent = _browser__WEBPACK_IMPORTED_MODULE_0__["window"].navigator.userAgent;
var SUPPORT_TOUCH = "ontouchstart" in _browser__WEBPACK_IMPORTED_MODULE_0__["window"];
var SUPPORT_DEVICEMOTION = "ondevicemotion" in _browser__WEBPACK_IMPORTED_MODULE_0__["window"];
var DeviceMotionEvent = _browser__WEBPACK_IMPORTED_MODULE_0__["window"].DeviceMotionEvent;
var devicePixelRatio = _browser__WEBPACK_IMPORTED_MODULE_0__["window"].devicePixelRatio;

var TRANSFORM = function () {
  var docStyle = _browser__WEBPACK_IMPORTED_MODULE_0__["document"].documentElement.style;
  var target = ["transform", "webkitTransform", "msTransform", "mozTransform"];

  for (var i = 0, len = target.length; i < len; i++) {
    if (target[i] in docStyle) {
      return target[i];
    }
  }

  return "";
}(); // check for will-change support


var SUPPORT_WILLCHANGE = _browser__WEBPACK_IMPORTED_MODULE_0__["window"].CSS && _browser__WEBPACK_IMPORTED_MODULE_0__["window"].CSS.supports && _browser__WEBPACK_IMPORTED_MODULE_0__["window"].CSS.supports("will-change", "transform");


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return win; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return doc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IS_SAFARI_ON_DESKTOP", function() { return IS_SAFARI_ON_DESKTOP; });
/**
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */

/* eslint-disable no-new-func, no-nested-ternary */
var win = typeof window !== "undefined" && window.Math === Math ? window : typeof self !== "undefined" && self.Math === Math ? self : Function("return this")();
/* eslint-enable no-new-func, no-nested-ternary */

var doc = win.document;
var userAgent = win.navigator.userAgent;
var IS_SAFARI_ON_DESKTOP = userAgent.indexOf("Safari") !== -1 && userAgent.indexOf("Chrome") === -1 && userAgent.indexOf("Mac OS X") !== -1;


/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__31__;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MathUtil = __webpack_require__(33);
var Util = __webpack_require__(34);

/**
 * Given an orientation and the gyroscope data, predicts the future orientation
 * of the head. This makes rendering appear faster.
 *
 * Also see: http://msl.cs.uiuc.edu/~lavalle/papers/LavYerKatAnt14.pdf
 *
 * @param {Number} predictionTimeS time from head movement to the appearance of
 * the corresponding image.
 */
function PosePredictor(predictionTimeS) {
  this.predictionTimeS = predictionTimeS;

  // The quaternion corresponding to the previous state.
  this.previousQ = new MathUtil.Quaternion();
  // Previous time a prediction occurred.
  this.previousTimestampS = null;

  // The delta quaternion that adjusts the current pose.
  this.deltaQ = new MathUtil.Quaternion();
  // The output quaternion.
  this.outQ = new MathUtil.Quaternion();
}

PosePredictor.prototype.getPrediction = function(currentQ, gyro, timestampS) {
  if (!this.previousTimestampS) {
    this.previousQ.copy(currentQ);
    this.previousTimestampS = timestampS;
    return currentQ;
  }

  // Calculate axis and angle based on gyroscope rotation rate data.
  var axis = new MathUtil.Vector3();
  axis.copy(gyro);
  axis.normalize();

  var angularSpeed = gyro.length();

  // If we're rotating slowly, don't do prediction.
  if (angularSpeed < MathUtil.degToRad * 20) {
    if (Util.isDebug()) {
      console.log('Moving slowly, at %s deg/s: no prediction',
                  (MathUtil.radToDeg * angularSpeed).toFixed(1));
    }
    this.outQ.copy(currentQ);
    this.previousQ.copy(currentQ);
    return this.outQ;
  }

  // Get the predicted angle based on the time delta and latency.
  var deltaT = timestampS - this.previousTimestampS;
  var predictAngle = angularSpeed * this.predictionTimeS;

  this.deltaQ.setFromAxisAngle(axis, predictAngle);
  this.outQ.copy(this.previousQ);
  this.outQ.multiply(this.deltaQ);

  this.previousQ.copy(currentQ);
  this.previousTimestampS = timestampS;

  return this.outQ;
};


module.exports = PosePredictor;


/***/ }),
/* 33 */
/***/ (function(module, exports) {

/*
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var MathUtil = window.MathUtil || {};

MathUtil.degToRad = Math.PI / 180;
MathUtil.radToDeg = 180 / Math.PI;

// Some minimal math functionality borrowed from THREE.Math and stripped down
// for the purposes of this library.


MathUtil.Vector2 = function ( x, y ) {
  this.x = x || 0;
  this.y = y || 0;
};

MathUtil.Vector2.prototype = {
  constructor: MathUtil.Vector2,

  set: function ( x, y ) {
    this.x = x;
    this.y = y;

    return this;
  },

  copy: function ( v ) {
    this.x = v.x;
    this.y = v.y;

    return this;
  },

  subVectors: function ( a, b ) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;

    return this;
  },
};

MathUtil.Vector3 = function ( x, y, z ) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
};

MathUtil.Vector3.prototype = {
  constructor: MathUtil.Vector3,

  set: function ( x, y, z ) {
    this.x = x;
    this.y = y;
    this.z = z;

    return this;
  },

  copy: function ( v ) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;

    return this;
  },

  length: function () {
    return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
  },

  normalize: function () {
    var scalar = this.length();

    if ( scalar !== 0 ) {
      var invScalar = 1 / scalar;

      this.multiplyScalar(invScalar);
    } else {
      this.x = 0;
      this.y = 0;
      this.z = 0;
    }

    return this;
  },

  multiplyScalar: function ( scalar ) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
  },

  applyQuaternion: function ( q ) {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;

    // calculate quat * vector
    var ix =  qw * x + qy * z - qz * y;
    var iy =  qw * y + qz * x - qx * z;
    var iz =  qw * z + qx * y - qy * x;
    var iw = - qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
    this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
    this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

    return this;
  },

  dot: function ( v ) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  },

  crossVectors: function ( a, b ) {
    var ax = a.x, ay = a.y, az = a.z;
    var bx = b.x, by = b.y, bz = b.z;

    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;

    return this;
  },
};

MathUtil.Quaternion = function ( x, y, z, w ) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = ( w !== undefined ) ? w : 1;
};

MathUtil.Quaternion.prototype = {
  constructor: MathUtil.Quaternion,

  set: function ( x, y, z, w ) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;

    return this;
  },

  copy: function ( quaternion ) {
    this.x = quaternion.x;
    this.y = quaternion.y;
    this.z = quaternion.z;
    this.w = quaternion.w;

    return this;
  },

  setFromEulerXYZ: function( x, y, z ) {
    var c1 = Math.cos( x / 2 );
    var c2 = Math.cos( y / 2 );
    var c3 = Math.cos( z / 2 );
    var s1 = Math.sin( x / 2 );
    var s2 = Math.sin( y / 2 );
    var s3 = Math.sin( z / 2 );

    this.x = s1 * c2 * c3 + c1 * s2 * s3;
    this.y = c1 * s2 * c3 - s1 * c2 * s3;
    this.z = c1 * c2 * s3 + s1 * s2 * c3;
    this.w = c1 * c2 * c3 - s1 * s2 * s3;

    return this;
  },

  setFromEulerYXZ: function( x, y, z ) {
    var c1 = Math.cos( x / 2 );
    var c2 = Math.cos( y / 2 );
    var c3 = Math.cos( z / 2 );
    var s1 = Math.sin( x / 2 );
    var s2 = Math.sin( y / 2 );
    var s3 = Math.sin( z / 2 );

    this.x = s1 * c2 * c3 + c1 * s2 * s3;
    this.y = c1 * s2 * c3 - s1 * c2 * s3;
    this.z = c1 * c2 * s3 - s1 * s2 * c3;
    this.w = c1 * c2 * c3 + s1 * s2 * s3;

    return this;
  },

  setFromAxisAngle: function ( axis, angle ) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
    // assumes axis is normalized

    var halfAngle = angle / 2, s = Math.sin( halfAngle );

    this.x = axis.x * s;
    this.y = axis.y * s;
    this.z = axis.z * s;
    this.w = Math.cos( halfAngle );

    return this;
  },

  multiply: function ( q ) {
    return this.multiplyQuaternions( this, q );
  },

  multiplyQuaternions: function ( a, b ) {
    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

    var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
    var qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;

    this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    return this;
  },

  inverse: function () {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;

    this.normalize();

    return this;
  },

  normalize: function () {
    var l = Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

    if ( l === 0 ) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;
    } else {
      l = 1 / l;

      this.x = this.x * l;
      this.y = this.y * l;
      this.z = this.z * l;
      this.w = this.w * l;
    }

    return this;
  },

  slerp: function ( qb, t ) {
    if ( t === 0 ) return this;
    if ( t === 1 ) return this.copy( qb );

    var x = this.x, y = this.y, z = this.z, w = this.w;

    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;

    if ( cosHalfTheta < 0 ) {
      this.w = - qb.w;
      this.x = - qb.x;
      this.y = - qb.y;
      this.z = - qb.z;

      cosHalfTheta = - cosHalfTheta;
    } else {
      this.copy( qb );
    }

    if ( cosHalfTheta >= 1.0 ) {
      this.w = w;
      this.x = x;
      this.y = y;
      this.z = z;

      return this;
    }

    var halfTheta = Math.acos( cosHalfTheta );
    var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

    if ( Math.abs( sinHalfTheta ) < 0.001 ) {
      this.w = 0.5 * ( w + this.w );
      this.x = 0.5 * ( x + this.x );
      this.y = 0.5 * ( y + this.y );
      this.z = 0.5 * ( z + this.z );

      return this;
    }

    var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
    ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

    this.w = ( w * ratioA + this.w * ratioB );
    this.x = ( x * ratioA + this.x * ratioB );
    this.y = ( y * ratioA + this.y * ratioB );
    this.z = ( z * ratioA + this.z * ratioB );

    return this;
  },

  setFromUnitVectors: function () {
    // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
    // assumes direction vectors vFrom and vTo are normalized

    var v1, r;
    var EPS = 0.000001;

    return function ( vFrom, vTo ) {
      if ( v1 === undefined ) v1 = new MathUtil.Vector3();

      r = vFrom.dot( vTo ) + 1;

      if ( r < EPS ) {
        r = 0;

        if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
          v1.set( - vFrom.y, vFrom.x, 0 );
        } else {
          v1.set( 0, - vFrom.z, vFrom.y );
        }
      } else {
        v1.crossVectors( vFrom, vTo );
      }

      this.x = v1.x;
      this.y = v1.y;
      this.z = v1.z;
      this.w = r;

      this.normalize();

      return this;
    }
  }(),
};

module.exports = MathUtil;


/***/ }),
/* 34 */
/***/ (function(module, exports) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Util = window.Util || {};

Util.MIN_TIMESTEP = 0.001;
Util.MAX_TIMESTEP = 1;

Util.base64 = function(mimeType, base64) {
  return 'data:' + mimeType + ';base64,' + base64;
};

Util.clamp = function(value, min, max) {
  return Math.min(Math.max(min, value), max);
};

Util.lerp = function(a, b, t) {
  return a + ((b - a) * t);
};

/**
 * Light polyfill for `Promise.race`. Returns
 * a promise that resolves when the first promise
 * provided resolves.
 *
 * @param {Array<Promise>} promises
 */
Util.race = function(promises) {
  if (Promise.race) {
    return Promise.race(promises);
  }

  return new Promise(function (resolve, reject) {
    for (var i = 0; i < promises.length; i++) {
      promises[i].then(resolve, reject);
    }
  });
};

Util.isIOS = (function() {
  var isIOS = /iPad|iPhone|iPod/.test(navigator.platform);
  return function() {
    return isIOS;
  };
})();

Util.isWebViewAndroid = (function() {
  var isWebViewAndroid = navigator.userAgent.indexOf('Version') !== -1 &&
      navigator.userAgent.indexOf('Android') !== -1 &&
      navigator.userAgent.indexOf('Chrome') !== -1;
  return function() {
    return isWebViewAndroid;
  };
})();

Util.isSafari = (function() {
  var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  return function() {
    return isSafari;
  };
})();

Util.isFirefoxAndroid = (function() {
  var isFirefoxAndroid = navigator.userAgent.indexOf('Firefox') !== -1 &&
      navigator.userAgent.indexOf('Android') !== -1;
  return function() {
    return isFirefoxAndroid;
  };
})();

Util.isR7 = (function() {
  var isR7 = navigator.userAgent.indexOf('R7 Build') !== -1;
  return function() {
    return isR7;
  };
})();

Util.isLandscapeMode = function() {
  var rtn = (window.orientation == 90 || window.orientation == -90);
  return Util.isR7() ? !rtn : rtn;
};

// Helper method to validate the time steps of sensor timestamps.
Util.isTimestampDeltaValid = function(timestampDeltaS) {
  if (isNaN(timestampDeltaS)) {
    return false;
  }
  if (timestampDeltaS <= Util.MIN_TIMESTEP) {
    return false;
  }
  if (timestampDeltaS > Util.MAX_TIMESTEP) {
    return false;
  }
  return true;
};

Util.getScreenWidth = function() {
  return Math.max(window.screen.width, window.screen.height) *
      window.devicePixelRatio;
};

Util.getScreenHeight = function() {
  return Math.min(window.screen.width, window.screen.height) *
      window.devicePixelRatio;
};

Util.requestFullscreen = function(element) {
  if (Util.isWebViewAndroid()) {
      return false;
  }
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element.webkitRequestFullscreen) {
    element.webkitRequestFullscreen();
  } else if (element.mozRequestFullScreen) {
    element.mozRequestFullScreen();
  } else if (element.msRequestFullscreen) {
    element.msRequestFullscreen();
  } else {
    return false;
  }

  return true;
};

Util.exitFullscreen = function() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen();
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen();
  } else {
    return false;
  }

  return true;
};

Util.getFullscreenElement = function() {
  return document.fullscreenElement ||
      document.webkitFullscreenElement ||
      document.mozFullScreenElement ||
      document.msFullscreenElement;
};

Util.linkProgram = function(gl, vertexSource, fragmentSource, attribLocationMap) {
  // No error checking for brevity.
  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertexShader, vertexSource);
  gl.compileShader(vertexShader);

  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragmentShader, fragmentSource);
  gl.compileShader(fragmentShader);

  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);

  for (var attribName in attribLocationMap)
    gl.bindAttribLocation(program, attribLocationMap[attribName], attribName);

  gl.linkProgram(program);

  gl.deleteShader(vertexShader);
  gl.deleteShader(fragmentShader);

  return program;
};

Util.getProgramUniforms = function(gl, program) {
  var uniforms = {};
  var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  var uniformName = '';
  for (var i = 0; i < uniformCount; i++) {
    var uniformInfo = gl.getActiveUniform(program, i);
    uniformName = uniformInfo.name.replace('[0]', '');
    uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
  }
  return uniforms;
};

Util.orthoMatrix = function (out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right),
      bt = 1 / (bottom - top),
      nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
};

Util.copyArray = function (source, dest) {
  for (var i = 0, n = source.length; i < n; i++) {
    dest[i] = source[i];
  }
};

Util.isMobile = function() {
  var check = false;
  (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true})(navigator.userAgent||navigator.vendor||window.opera);
  return check;
};

Util.extend = function(dest, src) {
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      dest[key] = src[key];
    }
  }

  return dest;
}

Util.safariCssSizeWorkaround = function(canvas) {
  // TODO(smus): Remove this workaround when Safari for iOS is fixed.
  // iOS only workaround (for https://bugs.webkit.org/show_bug.cgi?id=152556).
  //
  // "To the last I grapple with thee;
  //  from hell's heart I stab at thee;
  //  for hate's sake I spit my last breath at thee."
  // -- Moby Dick, by Herman Melville
  if (Util.isIOS()) {
    var width = canvas.style.width;
    var height = canvas.style.height;
    canvas.style.width = (parseInt(width) + 1) + 'px';
    canvas.style.height = (parseInt(height)) + 'px';
    setTimeout(function() {
      canvas.style.width = width;
      canvas.style.height = height;
    }, 100);
  }

  // Debug only.
  window.Util = Util;
  window.canvas = canvas;
};

Util.isDebug = function() {
  return Util.getQueryParameter('debug');
};

Util.getQueryParameter = function(name) {
  var name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
  var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
      results = regex.exec(location.search);
  return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
};

Util.frameDataFromPose = (function() {
  var piOver180 = Math.PI / 180.0;
  var rad45 = Math.PI * 0.25;

  // Borrowed from glMatrix.
  function mat4_perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov ? (fov.upDegrees * piOver180) : rad45),
    downTan = Math.tan(fov ? (fov.downDegrees * piOver180) : rad45),
    leftTan = Math.tan(fov ? (fov.leftDegrees * piOver180) : rad45),
    rightTan = Math.tan(fov ? (fov.rightDegrees * piOver180) : rad45),
    xScale = 2.0 / (leftTan + rightTan),
    yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
  }

  function mat4_fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
  };

  function mat4_translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
      a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
      a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

      out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
      out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
      out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
  };

  function mat4_invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
  };

  var defaultOrientation = new Float32Array([0, 0, 0, 1]);
  var defaultPosition = new Float32Array([0, 0, 0]);

  function updateEyeMatrices(projection, view, pose, parameters, vrDisplay) {
    mat4_perspectiveFromFieldOfView(projection, parameters ? parameters.fieldOfView : null, vrDisplay.depthNear, vrDisplay.depthFar);

    var orientation = pose.orientation || defaultOrientation;
    var position = pose.position || defaultPosition;

    mat4_fromRotationTranslation(view, orientation, position);
    if (parameters)
      mat4_translate(view, view, parameters.offset);
    mat4_invert(view, view);
  }

  return function(frameData, pose, vrDisplay) {
    if (!frameData || !pose)
      return false;

    frameData.pose = pose;
    frameData.timestamp = pose.timestamp;

    updateEyeMatrices(
        frameData.leftProjectionMatrix, frameData.leftViewMatrix,
        pose, vrDisplay.getEyeParameters("left"), vrDisplay);
    updateEyeMatrices(
        frameData.rightProjectionMatrix, frameData.rightViewMatrix,
        pose, vrDisplay.getEyeParameters("right"), vrDisplay);

    return true;
  };
})();

Util.isInsideCrossDomainIFrame = function() {
  var isFramed = (window.self !== window.top);
  var refDomain = Util.getDomainFromUrl(document.referrer);
  var thisDomain = Util.getDomainFromUrl(window.location.href);

  return isFramed && (refDomain !== thisDomain);
};

// From http://stackoverflow.com/a/23945027.
Util.getDomainFromUrl = function(url) {
  var domain;
  // Find & remove protocol (http, ftp, etc.) and get domain.
  if (url.indexOf("://") > -1) {
    domain = url.split('/')[2];
  }
  else {
    domain = url.split('/')[0];
  }

  //find & remove port number
  domain = domain.split(':')[0];

  return domain;
}

module.exports = Util;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var SensorSample = __webpack_require__(36);
var MathUtil = __webpack_require__(33);
var Util = __webpack_require__(34);

/**
 * An implementation of a simple complementary filter, which fuses gyroscope and
 * accelerometer data from the 'devicemotion' event.
 *
 * Accelerometer data is very noisy, but stable over the long term.
 * Gyroscope data is smooth, but tends to drift over the long term.
 *
 * This fusion is relatively simple:
 * 1. Get orientation estimates from accelerometer by applying a low-pass filter
 *    on that data.
 * 2. Get orientation estimates from gyroscope by integrating over time.
 * 3. Combine the two estimates, weighing (1) in the long term, but (2) for the
 *    short term.
 */
function ComplementaryFilter(kFilter) {
  this.kFilter = kFilter;

  // Raw sensor measurements.
  this.currentAccelMeasurement = new SensorSample();
  this.currentGyroMeasurement = new SensorSample();
  this.previousGyroMeasurement = new SensorSample();

  // Set default look direction to be in the correct direction.
  if (Util.isIOS()) {
    this.filterQ = new MathUtil.Quaternion(-1, 0, 0, 1);
  } else {
    this.filterQ = new MathUtil.Quaternion(1, 0, 0, 1);
  }
  this.previousFilterQ = new MathUtil.Quaternion();
  this.previousFilterQ.copy(this.filterQ);

  // Orientation based on the accelerometer.
  this.accelQ = new MathUtil.Quaternion();
  // Whether or not the orientation has been initialized.
  this.isOrientationInitialized = false;
  // Running estimate of gravity based on the current orientation.
  this.estimatedGravity = new MathUtil.Vector3();
  // Measured gravity based on accelerometer.
  this.measuredGravity = new MathUtil.Vector3();

  // Debug only quaternion of gyro-based orientation.
  this.gyroIntegralQ = new MathUtil.Quaternion();
}

ComplementaryFilter.prototype.addAccelMeasurement = function(vector, timestampS) {
  this.currentAccelMeasurement.set(vector, timestampS);
};

ComplementaryFilter.prototype.addGyroMeasurement = function(vector, timestampS) {
  this.currentGyroMeasurement.set(vector, timestampS);

  var deltaT = timestampS - this.previousGyroMeasurement.timestampS;
  if (Util.isTimestampDeltaValid(deltaT)) {
    this.run_();
  }

  this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
};

ComplementaryFilter.prototype.run_ = function() {

  if (!this.isOrientationInitialized) {
    this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
    this.previousFilterQ.copy(this.accelQ);
    this.isOrientationInitialized = true;
    return;
  }

  var deltaT = this.currentGyroMeasurement.timestampS -
      this.previousGyroMeasurement.timestampS;

  // Convert gyro rotation vector to a quaternion delta.
  var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
  this.gyroIntegralQ.multiply(gyroDeltaQ);

  // filter_1 = K * (filter_0 + gyro * dT) + (1 - K) * accel.
  this.filterQ.copy(this.previousFilterQ);
  this.filterQ.multiply(gyroDeltaQ);

  // Calculate the delta between the current estimated gravity and the real
  // gravity vector from accelerometer.
  var invFilterQ = new MathUtil.Quaternion();
  invFilterQ.copy(this.filterQ);
  invFilterQ.inverse();

  this.estimatedGravity.set(0, 0, -1);
  this.estimatedGravity.applyQuaternion(invFilterQ);
  this.estimatedGravity.normalize();

  this.measuredGravity.copy(this.currentAccelMeasurement.sample);
  this.measuredGravity.normalize();

  // Compare estimated gravity with measured gravity, get the delta quaternion
  // between the two.
  var deltaQ = new MathUtil.Quaternion();
  deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
  deltaQ.inverse();

  if (Util.isDebug()) {
    console.log('Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)',
                MathUtil.radToDeg * Util.getQuaternionAngle(deltaQ),
                (this.estimatedGravity.x).toFixed(1),
                (this.estimatedGravity.y).toFixed(1),
                (this.estimatedGravity.z).toFixed(1),
                (this.measuredGravity.x).toFixed(1),
                (this.measuredGravity.y).toFixed(1),
                (this.measuredGravity.z).toFixed(1));
  }

  // Calculate the SLERP target: current orientation plus the measured-estimated
  // quaternion delta.
  var targetQ = new MathUtil.Quaternion();
  targetQ.copy(this.filterQ);
  targetQ.multiply(deltaQ);

  // SLERP factor: 0 is pure gyro, 1 is pure accel.
  this.filterQ.slerp(targetQ, 1 - this.kFilter);

  this.previousFilterQ.copy(this.filterQ);
};

ComplementaryFilter.prototype.getOrientation = function() {
  return this.filterQ;
};

ComplementaryFilter.prototype.accelToQuaternion_ = function(accel) {
  var normAccel = new MathUtil.Vector3();
  normAccel.copy(accel);
  normAccel.normalize();
  var quat = new MathUtil.Quaternion();
  quat.setFromUnitVectors(new MathUtil.Vector3(0, 0, -1), normAccel);
  quat.inverse();
  return quat;
};

ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function(gyro, dt) {
  // Extract axis and angle from the gyroscope data.
  var quat = new MathUtil.Quaternion();
  var axis = new MathUtil.Vector3();
  axis.copy(gyro);
  axis.normalize();
  quat.setFromAxisAngle(axis, gyro.length() * dt);
  return quat;
};


module.exports = ComplementaryFilter;


/***/ }),
/* 36 */
/***/ (function(module, exports) {

function SensorSample(sample, timestampS) {
  this.set(sample, timestampS);
};

SensorSample.prototype.set = function(sample, timestampS) {
  this.sample = sample;
  this.timestampS = timestampS;
};

SensorSample.prototype.copy = function(sensorSample) {
  this.set(sensorSample.sample, sensorSample.timestampS);
};

module.exports = SensorSample;


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
var VERSION = "3.2.1-snapshot";


/***/ }),
/* 38 */,
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(1);
module.exports = __webpack_require__(40);


/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _PanoViewer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PanoViewer", function() { return _PanoViewer__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _version__WEBPACK_IMPORTED_MODULE_1__["VERSION"]; });





/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/es6-promise/dist/es6-promise.js
var es6_promise = __webpack_require__(26);
var es6_promise_default = /*#__PURE__*/__webpack_require__.n(es6_promise);

// EXTERNAL MODULE: external {"commonjs":"@egjs/component","commonjs2":"@egjs/component","amd":"@egjs/component","root":["eg","Component"]}
var component_root_eg_Component_ = __webpack_require__(28);
var component_root_eg_Component_default = /*#__PURE__*/__webpack_require__.n(component_root_eg_Component_);

// EXTERNAL MODULE: ./src/utils/browserFeature.js
var browserFeature = __webpack_require__(29);

// EXTERNAL MODULE: external {"commonjs":"@egjs/axes","commonjs2":"@egjs/axes","amd":"@egjs/axes","root":["eg","Axes"]}
var axes_root_eg_Axes_ = __webpack_require__(31);
var axes_root_eg_Axes_default = /*#__PURE__*/__webpack_require__.n(axes_root_eg_Axes_);

// CONCATENATED MODULE: ./src/YawPitchControl/utils.js
function toAxis(source, offset) {
  return offset.reduce(function (acc, v, i) {
    if (source[i]) {
      acc[source[i]] = v;
    }

    return acc;
  }, {});
}
// EXTERNAL MODULE: ./node_modules/webvr-polyfill/src/sensor-fusion/pose-predictor.js
var pose_predictor = __webpack_require__(32);
var pose_predictor_default = /*#__PURE__*/__webpack_require__.n(pose_predictor);

// EXTERNAL MODULE: ./node_modules/webvr-polyfill/src/math-util.js
var math_util = __webpack_require__(33);
var math_util_default = /*#__PURE__*/__webpack_require__.n(math_util);

// EXTERNAL MODULE: ./node_modules/webvr-polyfill/src/util.js
var util = __webpack_require__(34);
var util_default = /*#__PURE__*/__webpack_require__.n(util);

// EXTERNAL MODULE: ./src/utils/browser.js
var browser = __webpack_require__(30);

// CONCATENATED MODULE: ./src/utils/mathUtil/common.js
/**
 * Original Code
 * https://github.com/toji/gl-matrix/blob/v2.3.2/src/gl-matrix/common.js
 * Common utilities
 * modified by egjs
 */
var glMatrix = {};
glMatrix.ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var degree = Math.PI / 180;

glMatrix.toRadian = function (a) {
  return a * degree;
};

glMatrix.toDegree = function (a) {
  return a / degree;
}; // glMatrix.EPSILON = 0.000001;


glMatrix.EPSILON = 0.0001;
/* harmony default export */ var common = (glMatrix);
// CONCATENATED MODULE: ./src/utils/mathUtil/vec3.js
/**
 * Original Code
 * https://github.com/toji/gl-matrix/blob/v2.3.2/src/gl-matrix/vec3.js
 * 3 Dimensional Vector Util
 * modified by egjs
 */

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */

var vec3 = {};
/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

vec3.create = function () {
  var out = new common.ARRAY_TYPE(3);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
};
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */


vec3.fromValues = function (x, y, z) {
  var out = new common.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
};

vec3.set = function (out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
};

vec3.copy = function (out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
};
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */


vec3.scale = function (out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
};
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


vec3.subtract = function (out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
};
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */


vec3.length = function (a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
};
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */


vec3.normalize = function (out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }

  return out;
};
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */


vec3.dot = function (a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


vec3.cross = function (out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
};
/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */


vec3.transformQuat = function (out, a, q) {
  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations
  var x = a[0],
      y = a[1],
      z = a[2],
      qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      // calculate quat * vec
  ix = qw * x + qy * z - qz * y,
      iy = qw * y + qz * x - qx * z,
      iz = qw * z + qx * y - qy * x,
      iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out;
};
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */


vec3.rotateZ = function (out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
};

/* harmony default export */ var mathUtil_vec3 = (vec3);
// CONCATENATED MODULE: ./src/utils/mathUtil/vec2.js
/**
 * Original Code
 * https://github.com/toji/gl-matrix/blob/v2.3.2/src/gl-matrix/vec2.js
 * 2 Dimensional Vector Util
 * modified by egjs
 */

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */

var vec2 = {};

vec2.copy = function (out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
};

/* harmony default export */ var mathUtil_vec2 = (vec2);
// CONCATENATED MODULE: ./src/utils/mathUtil/quat.js
/**
 * Original Code
 * https://github.com/toji/gl-matrix/blob/v2.3.2/src/gl-matrix/quat.js
 * Quaternion util
 * modified by egjs
 */

/**
 * @class Quaternion
 * @name quat
 */

var quat = {};
/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

quat.create = function () {
  var out = new common.ARRAY_TYPE(4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
};
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */


quat.clone = function (a) {
  var out = new common.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
};
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */


quat.fromValues = function (x, y, z, w) {
  var out = new common.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
};

;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */

quat.copy = function (out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
};
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/


quat.setAxisAngle = function (out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
};
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */


quat.multiply = function (out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3],
      bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
};
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


quat.rotateX = function (out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3],
      bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
};
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


quat.rotateY = function (out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3],
      by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
};
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */


quat.conjugate = function (out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
};
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */


quat.normalize = function (out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
  }

  return out;
};
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


quat.equals = function (a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= common.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= common.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= common.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= common.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
};
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


quat.exactEquals = function (a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/* harmony default export */ var mathUtil_quat = (quat);
// CONCATENATED MODULE: ./src/utils/mathUtil/mat4.js
/**
 * Original Code
 * https://github.com/toji/gl-matrix/blob/v2.3.2/src/gl-matrix/mat4.js
 * 4x4 Matrix util
 * modified by egjs
 */

/**
 * @class 4x4 Matrix
 * @name mat4
 */

var mat4 = {};
/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

mat4.create = function () {
  var out = new common.ARRAY_TYPE(16);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
};
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */


mat4.identity = function (out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
};
/**
 * Rotates a matrix by the given angle around the X axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


mat4.rotateX = function (out, a, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad),
      a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7],
      a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
};
/**
 * Rotates a matrix by the given angle around the Y axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


mat4.rotateY = function (out, a, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad),
      a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3],
      a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
};
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */


mat4.fromQuat = function (out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,
      xx = x * x2,
      yx = y * x2,
      yy = y * y2,
      zx = z * x2,
      zy = z * y2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
};
/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


mat4.perspective = function (out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf = 1 / (near - far);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = 2 * far * near * nf;
  out[15] = 0;
  return out;
};

/* harmony default export */ var mathUtil_mat4 = (mat4);
// CONCATENATED MODULE: ./src/utils/math-util.js
/**
 * Original Code
 * https://github.com/toji/gl-matrix/blob/v2.3.2/src/gl-matrix.js
 * Math Util
 * modified by egjs
 */

/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.2
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// Some minimal math functionality borrowed from gl-Matrix and stripped down
// for the purposes of this library.






function quatToVec3(quaternion) {
  var baseV = mathUtil_vec3.fromValues(0, 0, 1);
  mathUtil_vec3.transformQuat(baseV, baseV, quaternion);
  return baseV;
}

var math_util_util = {};

math_util_util.isPowerOfTwo = function (n) {
  return n && (n & n - 1) === 0;
};

math_util_util.extractPitchFromQuat = function (quaternion) {
  var baseV = quatToVec3(quaternion);
  return -1 * Math.atan2(baseV[1], Math.sqrt(Math.pow(baseV[0], 2) + Math.pow(baseV[2], 2)));
}; // implement reference
// the general equation of a plane : http://www.gisdeveloper.co.kr/entry/-
// calculating angle between two vectors : http://darkpgmr.tistory.com/121


var ROTATE_CONSTANT = {
  PITCH_DELTA: 1,
  YAW_DELTA_BY_ROLL: 2,
  YAW_DELTA_BY_YAW: 3
};
ROTATE_CONSTANT[ROTATE_CONSTANT.PITCH_DELTA] = {
  targetAxis: [0, 1, 0],
  meshPoint: [0, 0, 1]
};
ROTATE_CONSTANT[ROTATE_CONSTANT.YAW_DELTA_BY_ROLL] = {
  targetAxis: [0, 1, 0],
  meshPoint: [1, 0, 0]
};
ROTATE_CONSTANT[ROTATE_CONSTANT.YAW_DELTA_BY_YAW] = {
  targetAxis: [1, 0, 0],
  meshPoint: [0, 0, 1]
};

function getRotationDelta(prevQ, curQ, rotateKind) {
  var targetAxis = mathUtil_vec3.fromValues(ROTATE_CONSTANT[rotateKind].targetAxis[0], ROTATE_CONSTANT[rotateKind].targetAxis[1], ROTATE_CONSTANT[rotateKind].targetAxis[2]);
  var meshPoint = ROTATE_CONSTANT[rotateKind].meshPoint;
  var prevQuaternion = mathUtil_quat.clone(prevQ);
  var curQuaternion = mathUtil_quat.clone(curQ);
  mathUtil_quat.normalize(prevQuaternion, prevQuaternion);
  mathUtil_quat.normalize(curQuaternion, curQuaternion);
  var prevPoint = mathUtil_vec3.fromValues(0, 0, 1);
  var curPoint = mathUtil_vec3.fromValues(0, 0, 1);
  mathUtil_vec3.transformQuat(prevPoint, prevPoint, prevQuaternion);
  mathUtil_vec3.transformQuat(curPoint, curPoint, curQuaternion);
  mathUtil_vec3.transformQuat(targetAxis, targetAxis, curQuaternion);
  var rotateDistance = mathUtil_vec3.dot(targetAxis, mathUtil_vec3.cross(mathUtil_vec3.create(), prevPoint, curPoint));
  var rotateDirection = rotateDistance > 0 ? 1 : -1; // when counter clock wise, use vec3.fromValues(0,1,0)
  // when clock wise, use vec3.fromValues(0,-1,0)
  // const meshPoint1 = vec3.fromValues(0, 0, 0);

  var meshPoint2 = mathUtil_vec3.fromValues(meshPoint[0], meshPoint[1], meshPoint[2]);
  var meshPoint3;

  if (rotateKind !== ROTATE_CONSTANT.YAW_DELTA_BY_YAW) {
    meshPoint3 = mathUtil_vec3.fromValues(0, rotateDirection, 0);
  } else {
    meshPoint3 = mathUtil_vec3.fromValues(rotateDirection, 0, 0);
  }

  mathUtil_vec3.transformQuat(meshPoint2, meshPoint2, curQuaternion);
  mathUtil_vec3.transformQuat(meshPoint3, meshPoint3, curQuaternion);
  var vecU = meshPoint2;
  var vecV = meshPoint3;
  var vecN = mathUtil_vec3.create();
  mathUtil_vec3.cross(vecN, vecU, vecV);
  mathUtil_vec3.normalize(vecN, vecN);
  var coefficientA = vecN[0];
  var coefficientB = vecN[1];
  var coefficientC = vecN[2]; //	const coefficientD = -1 * vec3.dot(vecN, meshPoint1);
  // a point on the plane

  curPoint = mathUtil_vec3.fromValues(meshPoint[0], meshPoint[1], meshPoint[2]);
  mathUtil_vec3.transformQuat(curPoint, curPoint, curQuaternion); // a point should project on the plane

  prevPoint = mathUtil_vec3.fromValues(meshPoint[0], meshPoint[1], meshPoint[2]);
  mathUtil_vec3.transformQuat(prevPoint, prevPoint, prevQuaternion); // distance between prevPoint and the plane

  var distance = Math.abs(prevPoint[0] * coefficientA + prevPoint[1] * coefficientB + prevPoint[2] * coefficientC);
  var projectedPrevPoint = mathUtil_vec3.create();
  mathUtil_vec3.subtract(projectedPrevPoint, prevPoint, mathUtil_vec3.scale(mathUtil_vec3.create(), vecN, distance));
  var trigonometricRatio = (projectedPrevPoint[0] * curPoint[0] + projectedPrevPoint[1] * curPoint[1] + projectedPrevPoint[2] * curPoint[2]) / (mathUtil_vec3.length(projectedPrevPoint) * mathUtil_vec3.length(curPoint)); // defensive block

  trigonometricRatio > 1 && (trigonometricRatio = 1);
  var theta = Math.acos(trigonometricRatio);
  var crossVec = mathUtil_vec3.cross(mathUtil_vec3.create(), curPoint, projectedPrevPoint);
  distance = coefficientA * crossVec[0] + coefficientB * crossVec[1] + coefficientC * crossVec[2];
  var thetaDirection;

  if (rotateKind !== ROTATE_CONSTANT.YAW_DELTA_BY_YAW) {
    thetaDirection = distance > 0 ? 1 : -1;
  } else {
    thetaDirection = distance < 0 ? 1 : -1;
  }

  var deltaRadian = theta * thetaDirection * rotateDirection;
  return common.toDegree(deltaRadian);
}

math_util_util.getRotationDelta = getRotationDelta;

// CONCATENATED MODULE: ./src/YawPitchControl/consts.js

/**
 * Returns a number value indiciating the version of Chrome being used,
 * or otherwise `null` if not on Chrome.
 *
 * Ref: https://github.com/immersive-web/cardboard-vr-display/pull/19
 */

/**
 * In Chrome m65, `devicemotion` events are broken but subsequently fixed
 * in 65.0.3325.148. Since many browsers use Chromium, ensure that
 * we scope this detection by branch and build numbers to provide
 * a proper fallback.
 * https://github.com/immersive-web/webvr-polyfill/issues/307
 */

var version = -1; // It should not be null because it will be compared with number

var branch = null;
var build = null;
var match = /Chrome\/([0-9]+)\.(?:[0-9]*)\.([0-9]*)\.([0-9]*)/i.exec(browserFeature["userAgent"]);

if (match) {
  version = parseInt(match[1], 10);
  branch = match[2];
  build = match[3];
}

var CHROME_VERSION = version;
var IS_CHROME_WITHOUT_DEVICE_MOTION = version === 65 && branch === "3325" && parseInt(build, 10) < 148;
var IS_ANDROID = /Android/i.test(browserFeature["userAgent"]);
var CONTROL_MODE_VR = 1;
var CONTROL_MODE_YAWPITCH = 2;
var TOUCH_DIRECTION_NONE = 1;
var TOUCH_DIRECTION_YAW = 2;
var TOUCH_DIRECTION_PITCH = 4;
var TOUCH_DIRECTION_ALL = TOUCH_DIRECTION_YAW | TOUCH_DIRECTION_PITCH;
/* Const for MovableCoord */

var MC_DECELERATION = 0.0014;
var MC_MAXIMUM_DURATION = 1000;
var MC_BIND_SCALE = [0.20, 0.20];
var MIN_FIELD_OF_VIEW = 20;
var MAX_FIELD_OF_VIEW = 110;
var PAN_SCALE = 320; // const DELTA_THRESHOLD = 0.015;
// const DELTA_THRESHOLD = 0.09; // Note4
// const DELTA_THRESHOLD = 0.0825;
// const DELTA_THRESHOLD = 0.075;
// const DELTA_THRESHOLD = 0.06;
// const DELTA_THRESHOLD = 0.045;

var DELTA_THRESHOLD = 0.0375; // Note2

var YAW_RANGE_HALF = 180;
var PITCH_RANGE_HALF = 90;
var CIRCULAR_PITCH_RANGE_HALF = 180;
var PINCH_EVENTS = "pinchstart pinchmove pinchend";
var KEYMAP = {
  LEFT_ARROW: 37,
  A: 65,
  UP_ARROW: 38,
  W: 87,
  RIGHT_ARROW: 39,
  D: 68,
  DOWN_ARROW: 40,
  S: 83
};
var GYRO_MODE = {
  NONE: "none",
  YAWPITCH: "yawPitch",
  VR: "VR"
};

// CONCATENATED MODULE: ./src/YawPitchControl/input/DeviceMotion.js
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }





var STILLNESS_THRESHOLD = 200; // millisecond

var DeviceMotion_DeviceMotion =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(DeviceMotion, _Component);

  function DeviceMotion() {
    var _this;

    _this = _Component.call(this) || this;
    _this._onDeviceMotion = _this._onDeviceMotion.bind(_assertThisInitialized(_this));
    _this._onDeviceOrientation = _this._onDeviceOrientation.bind(_assertThisInitialized(_this));
    _this._onChromeWithoutDeviceMotion = _this._onChromeWithoutDeviceMotion.bind(_assertThisInitialized(_this));
    _this.isWithoutDeviceMotion = IS_CHROME_WITHOUT_DEVICE_MOTION;
    _this.isAndroid = IS_ANDROID;
    _this.stillGyroVec = mathUtil_vec3.create();
    _this.rawGyroVec = mathUtil_vec3.create();
    _this.adjustedGyroVec = mathUtil_vec3.create();
    _this._timer = null;
    _this.lastDevicemotionTimestamp = 0;
    _this._isEnabled = false;

    _this.enable();

    return _this;
  }

  var _proto = DeviceMotion.prototype;

  _proto._onChromeWithoutDeviceMotion = function _onChromeWithoutDeviceMotion(e) {
    var alpha = e.alpha,
        beta = e.beta,
        gamma = e.gamma; // There is deviceorientation event trigged with empty values
    // on Headless Chrome.

    if (alpha === null) {
      return;
    } // convert to radian


    alpha = (alpha || 0) * Math.PI / 180;
    beta = (beta || 0) * Math.PI / 180;
    gamma = (gamma || 0) * Math.PI / 180;
    this.trigger("devicemotion", {
      inputEvent: {
        deviceorientation: {
          alpha: alpha,
          beta: beta,
          gamma: -gamma
        }
      }
    });
  };

  _proto._onDeviceOrientation = function _onDeviceOrientation() {
    var _this2 = this;

    this._timer && clearTimeout(this._timer);
    this._timer = setTimeout(function () {
      if (new Date().getTime() - _this2.lastDevicemotionTimestamp < STILLNESS_THRESHOLD) {
        mathUtil_vec3.copy(_this2.stillGyroVec, _this2.rawGyroVec);
      }
    }, STILLNESS_THRESHOLD);
  };

  _proto._onDeviceMotion = function _onDeviceMotion(e) {
    // desktop chrome triggers devicemotion event with empthy sensor values.
    // Those events should ignored.
    var isGyroSensorAvailable = !(e.rotationRate.alpha == null);
    var isGravitySensorAvailable = !(e.accelerationIncludingGravity.x == null);

    if (e.interval === 0 || !(isGyroSensorAvailable && isGravitySensorAvailable)) {
      return;
    }

    var devicemotionEvent = _extends({}, e);

    devicemotionEvent.interval = e.interval;
    devicemotionEvent.timeStamp = e.timeStamp;
    devicemotionEvent.type = e.type;
    devicemotionEvent.rotationRate = {
      alpha: e.rotationRate.alpha,
      beta: e.rotationRate.beta,
      gamma: e.rotationRate.gamma
    };
    devicemotionEvent.accelerationIncludingGravity = {
      x: e.accelerationIncludingGravity.x,
      y: e.accelerationIncludingGravity.y,
      z: e.accelerationIncludingGravity.z
    };
    devicemotionEvent.acceleration = {
      x: e.acceleration.x,
      y: e.acceleration.y,
      z: e.acceleration.z
    };

    if (this.isAndroid) {
      mathUtil_vec3.set(this.rawGyroVec, e.rotationRate.alpha || 0, e.rotationRate.beta || 0, e.rotationRate.gamma || 0);
      mathUtil_vec3.subtract(this.adjustedGyroVec, this.rawGyroVec, this.stillGyroVec);
      this.lastDevicemotionTimestamp = new Date().getTime();
      devicemotionEvent.adjustedRotationRate = {
        alpha: this.adjustedGyroVec[0],
        beta: this.adjustedGyroVec[1],
        gamma: this.adjustedGyroVec[2]
      };
    }

    this.trigger("devicemotion", {
      inputEvent: devicemotionEvent
    });
  };

  _proto.enable = function enable() {
    if (this.isAndroid) {
      browser["window"].addEventListener("deviceorientation", this._onDeviceOrientation);
    }

    if (this.isWithoutDeviceMotion) {
      browser["window"].addEventListener("deviceorientation", this._onChromeWithoutDeviceMotion);
    } else {
      browser["window"].addEventListener("devicemotion", this._onDeviceMotion);
    }

    this._isEnabled = true;
  };

  _proto.disable = function disable() {
    browser["window"].removeEventListener("deviceorientation", this._onDeviceOrientation);
    browser["window"].removeEventListener("deviceorientation", this._onChromeWithoutDeviceMotion);
    browser["window"].removeEventListener("devicemotion", this._onDeviceMotion);
    this._isEnabled = false;
  };

  return DeviceMotion;
}(component_root_eg_Component_default.a);


// EXTERNAL MODULE: ./node_modules/webvr-polyfill/src/sensor-fusion/complementary-filter.js
var complementary_filter = __webpack_require__(35);
var complementary_filter_default = /*#__PURE__*/__webpack_require__.n(complementary_filter);

// CONCATENATED MODULE: ./src/YawPitchControl/input/ComplementaryFilter.js



complementary_filter_default.a.prototype.run_ = function () {
  if (!this.isOrientationInitialized) {
    this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
    this.previousFilterQ.copy(this.accelQ);
    this.isOrientationInitialized = true;
    return;
  }

  var deltaT = this.currentGyroMeasurement.timestampS - this.previousGyroMeasurement.timestampS; // Convert gyro rotation vector to a quaternion delta.

  var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
  this.gyroIntegralQ.multiply(gyroDeltaQ); // filter_1 = K * (filter_0 + gyro * dT) + (1 - K) * accel.

  this.filterQ.copy(this.previousFilterQ);
  this.filterQ.multiply(gyroDeltaQ); // Calculate the delta between the current estimated gravity and the real
  // gravity vector from accelerometer.

  var invFilterQ = new math_util_default.a.Quaternion();
  invFilterQ.copy(this.filterQ);
  invFilterQ.inverse();
  this.estimatedGravity.set(0, 0, -1);
  this.estimatedGravity.applyQuaternion(invFilterQ);
  this.estimatedGravity.normalize();
  this.measuredGravity.copy(this.currentAccelMeasurement.sample);
  this.measuredGravity.normalize(); // Compare estimated gravity with measured gravity, get the delta quaternion
  // between the two.

  var deltaQ = new math_util_default.a.Quaternion();
  deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
  deltaQ.inverse(); // Calculate the SLERP target: current orientation plus the measured-estimated
  // quaternion delta.

  var targetQ = new math_util_default.a.Quaternion();
  targetQ.copy(this.filterQ);
  targetQ.multiply(deltaQ); // SLERP factor: 0 is pure gyro, 1 is pure accel.

  this.filterQ.slerp(targetQ, 1 - this.kFilter);
  this.previousFilterQ.copy(this.filterQ);

  if (!this.isFilterQuaternionInitialized) {
    this.isFilterQuaternionInitialized = true;
  }
};

complementary_filter_default.a.prototype.getOrientation = function () {
  if (this.isFilterQuaternionInitialized) {
    return this.filterQ;
  } else {
    return null;
  }
};

/* harmony default export */ var ComplementaryFilter = (complementary_filter_default.a);
// CONCATENATED MODULE: ./src/YawPitchControl/input/FusionPoseSensor.js
function FusionPoseSensor_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function FusionPoseSensor_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }










var K_FILTER = 0.98;
var PREDICTION_TIME_S = 0.040;

var FusionPoseSensor_FusionPoseSensor =
/*#__PURE__*/
function (_Component) {
  FusionPoseSensor_inheritsLoose(FusionPoseSensor, _Component);

  function FusionPoseSensor() {
    var _this;

    _this = _Component.call(this) || this;
    _this.deviceMotion = new DeviceMotion_DeviceMotion();
    _this.accelerometer = new math_util_default.a.Vector3();
    _this.gyroscope = new math_util_default.a.Vector3();
    _this._onDeviceMotionChange = _this._onDeviceMotionChange.bind(FusionPoseSensor_assertThisInitialized(_this));
    _this._onScreenOrientationChange = _this._onScreenOrientationChange.bind(FusionPoseSensor_assertThisInitialized(_this));
    _this.filter = new ComplementaryFilter(K_FILTER);
    _this.posePredictor = new pose_predictor_default.a(PREDICTION_TIME_S);
    _this.filterToWorldQ = new math_util_default.a.Quaternion();
    _this.isFirefoxAndroid = util_default.a.isFirefoxAndroid();
    _this.isIOS = util_default.a.isIOS(); // Ref https://github.com/immersive-web/cardboard-vr-display/issues/18

    _this.isChromeUsingDegrees = CHROME_VERSION >= 66;
    _this._isEnabled = false; // Set the filter to world transform, depending on OS.

    if (_this.isIOS) {
      _this.filterToWorldQ.setFromAxisAngle(new math_util_default.a.Vector3(1, 0, 0), Math.PI / 2);
    } else {
      _this.filterToWorldQ.setFromAxisAngle(new math_util_default.a.Vector3(1, 0, 0), -Math.PI / 2);
    }

    _this.inverseWorldToScreenQ = new math_util_default.a.Quaternion();
    _this.worldToScreenQ = new math_util_default.a.Quaternion();
    _this.originalPoseAdjustQ = new math_util_default.a.Quaternion();

    _this.originalPoseAdjustQ.setFromAxisAngle(new math_util_default.a.Vector3(0, 0, 1), -browser["window"].orientation * Math.PI / 180);

    _this._setScreenTransform(); // Adjust this filter for being in landscape mode.


    if (util_default.a.isLandscapeMode()) {
      _this.filterToWorldQ.multiply(_this.inverseWorldToScreenQ);
    } // Keep track of a reset transform for resetSensor.


    _this.resetQ = new math_util_default.a.Quaternion();

    _this.deviceMotion.on("devicemotion", _this._onDeviceMotionChange);

    _this.enable();

    return _this;
  }

  var _proto = FusionPoseSensor.prototype;

  _proto.enable = function enable() {
    if (this.isEnabled()) {
      return;
    }

    this.deviceMotion.enable();
    this._isEnabled = true;
    browser["window"].addEventListener("orientationchange", this._onScreenOrientationChange);
  };

  _proto.disable = function disable() {
    if (!this.isEnabled()) {
      return;
    }

    this.deviceMotion.disable();
    this._isEnabled = false;
    browser["window"].removeEventListener("orientationchange", this._onScreenOrientationChange);
  };

  _proto.isEnabled = function isEnabled() {
    return this._isEnabled;
  };

  _proto.destroy = function destroy() {
    this.disable();
    this.deviceMotion = null;
  };

  _proto._triggerChange = function _triggerChange() {
    var orientation = this.getOrientation(); // if orientation is not prepared. don't trigger change event

    if (!orientation) {
      return;
    }

    if (!this._prevOrientation) {
      this._prevOrientation = orientation;
      return;
    }

    if (mathUtil_quat.equals(this._prevOrientation, orientation)) {
      return;
    }

    this.trigger("change", {
      quaternion: orientation
    });
  };

  _proto.getOrientation = function getOrientation() {
    var orientation; // Hack around using deviceorientation instead of devicemotion

    if (this.deviceMotion.isWithoutDeviceMotion && this._deviceOrientationQ) {
      this.deviceOrientationFixQ = this.deviceOrientationFixQ || function () {
        var y = new math_util_default.a.Quaternion().setFromAxisAngle(new math_util_default.a.Vector3(0, 1, 0), -this._alpha);
        return y;
      }.bind(this)();

      orientation = this._deviceOrientationQ;
      var out = new math_util_default.a.Quaternion();
      out.copy(orientation);
      out.multiply(this.filterToWorldQ);
      out.multiply(this.resetQ);
      out.multiply(this.worldToScreenQ);
      out.multiplyQuaternions(this.deviceOrientationFixQ, out); // return quaternion as glmatrix quaternion object

      var out_ = mathUtil_quat.fromValues(out.x, out.y, out.z, out.w);
      return mathUtil_quat.normalize(out_, out_);
    } else {
      // Convert from filter space to the the same system used by the
      // deviceorientation event.
      orientation = this.filter.getOrientation();

      if (!orientation) {
        return null;
      }

      var _out = this._convertFusionToPredicted(orientation); // return quaternion as glmatrix quaternion object


      var _out_ = mathUtil_quat.fromValues(_out.x, _out.y, _out.z, _out.w);

      return mathUtil_quat.normalize(_out_, _out_);
    }
  };

  _proto._convertFusionToPredicted = function _convertFusionToPredicted(orientation) {
    // Predict orientation.
    this.predictedQ = this.posePredictor.getPrediction(orientation, this.gyroscope, this.previousTimestampS); // Convert to THREE coordinate system: -Z forward, Y up, X right.

    var out = new math_util_default.a.Quaternion();
    out.copy(this.filterToWorldQ);
    out.multiply(this.resetQ);
    out.multiply(this.predictedQ);
    out.multiply(this.worldToScreenQ);
    return out;
  };

  _proto._onDeviceMotionChange = function _onDeviceMotionChange(_ref) {
    var inputEvent = _ref.inputEvent;
    var deviceorientation = inputEvent.deviceorientation;
    var deviceMotion = inputEvent;
    var accGravity = deviceMotion.accelerationIncludingGravity;
    var rotRate = deviceMotion.adjustedRotationRate || deviceMotion.rotationRate;
    var timestampS = deviceMotion.timeStamp / 1000;

    if (deviceorientation) {
      if (!this._alpha) {
        this._alpha = deviceorientation.alpha;
      }

      this._deviceOrientationQ = this._deviceOrientationQ || new math_util_default.a.Quaternion();

      this._deviceOrientationQ.setFromEulerYXZ(deviceorientation.beta, deviceorientation.alpha, deviceorientation.gamma);

      this._triggerChange();
    } else {
      // Firefox Android timeStamp returns one thousandth of a millisecond.
      if (this.isFirefoxAndroid) {
        timestampS /= 1000;
      }

      this.accelerometer.set(-accGravity.x, -accGravity.y, -accGravity.z);
      this.gyroscope.set(rotRate.alpha, rotRate.beta, rotRate.gamma); // Browsers on iOS, Firefox/Android, and Chrome m66/Android `rotationRate`
      // is reported in degrees, so we first convert to radians.

      if (this.isIOS || this.isFirefoxAndroid || this.isChromeUsingDegrees) {
        this.gyroscope.multiplyScalar(Math.PI / 180);
      }

      this.filter.addAccelMeasurement(this.accelerometer, timestampS);
      this.filter.addGyroMeasurement(this.gyroscope, timestampS);

      this._triggerChange();

      this.previousTimestampS = timestampS;
    }
  };

  _proto._onScreenOrientationChange = function _onScreenOrientationChange(screenOrientation) {
    this._setScreenTransform(browser["window"].orientation);
  };

  _proto._setScreenTransform = function _setScreenTransform() {
    this.worldToScreenQ.set(0, 0, 0, 1);

    switch (browser["window"].orientation) {
      case 0:
        break;

      case 90:
        this.worldToScreenQ.setFromAxisAngle(new math_util_default.a.Vector3(0, 0, 1), 90 / -180 * Math.PI);
        break;

      case -90:
        this.worldToScreenQ.setFromAxisAngle(new math_util_default.a.Vector3(0, 0, 1), -90 / -180 * Math.PI);
        break;

      case 180:
        this.worldToScreenQ.setFromAxisAngle(new math_util_default.a.Vector3(0, 0, 1), 180 / -180 * Math.PI);
        break;

      default:
        break;
    }

    this.inverseWorldToScreenQ.copy(this.worldToScreenQ);
    this.inverseWorldToScreenQ.inverse();
  };

  return FusionPoseSensor;
}(component_root_eg_Component_default.a);


// CONCATENATED MODULE: ./src/YawPitchControl/input/TiltMotionInput.js
function TiltMotionInput_extends() { TiltMotionInput_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return TiltMotionInput_extends.apply(this, arguments); }

function TiltMotionInput_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function TiltMotionInput_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }






function getDeltaYaw(prvQ, curQ) {
  var yawDeltaByYaw = math_util_util.getRotationDelta(prvQ, curQ, ROTATE_CONSTANT.YAW_DELTA_BY_YAW);
  var yawDeltaByRoll = math_util_util.getRotationDelta(prvQ, curQ, ROTATE_CONSTANT.YAW_DELTA_BY_ROLL) * Math.sin(math_util_util.extractPitchFromQuat(curQ));
  return yawDeltaByRoll + yawDeltaByYaw;
}

function getDeltaPitch(prvQ, curQ) {
  var pitchDelta = math_util_util.getRotationDelta(prvQ, curQ, ROTATE_CONSTANT.PITCH_DELTA);
  return pitchDelta;
}

var TiltMotionInput_TiltMotionInput =
/*#__PURE__*/
function (_Component) {
  TiltMotionInput_inheritsLoose(TiltMotionInput, _Component);

  function TiltMotionInput(el, options) {
    var _this;

    _this = _Component.call(this) || this;
    _this.element = el;
    _this._prevQuaternion = null;
    _this._quaternion = null;
    _this.fusionPoseSensor = null;
    _this.options = TiltMotionInput_extends({
      scale: 1,
      threshold: 0
    }, options);
    _this._onPoseChange = _this._onPoseChange.bind(TiltMotionInput_assertThisInitialized(_this));
    return _this;
  }

  var _proto = TiltMotionInput.prototype;

  _proto.mapAxes = function mapAxes(axes) {
    this.axes = axes;
  };

  _proto.connect = function connect(observer) {
    if (this.observer) {
      return this;
    }

    this.observer = observer;
    this.fusionPoseSensor = new FusionPoseSensor_FusionPoseSensor();
    this.fusionPoseSensor.enable();

    this._attachEvent();

    return this;
  };

  _proto.disconnect = function disconnect() {
    if (!this.observer) {
      return this;
    }

    this._dettachEvent();

    this.fusionPoseSensor.disable();
    this.fusionPoseSensor.destroy();
    this.fusionPoseSensor = null;
    this.observer = null;
    return this;
  };

  _proto.destroy = function destroy() {
    this.disconnect();
    this.element = null;
    this.options = null;
    this.axes = null;
    this._prevQuaternion = null;
    this._quaternion = null;
  };

  _proto._onPoseChange = function _onPoseChange(event) {
    if (!this._prevQuaternion) {
      this._prevQuaternion = mathUtil_quat.clone(event.quaternion);
      this._quaternion = mathUtil_quat.clone(event.quaternion);
      return;
    }

    mathUtil_quat.copy(this._prevQuaternion, this._quaternion);
    mathUtil_quat.copy(this._quaternion, event.quaternion);
    this.observer.change(this, event, toAxis(this.axes, [getDeltaYaw(this._prevQuaternion, this._quaternion), getDeltaPitch(this._prevQuaternion, this._quaternion)]));
  };

  _proto._attachEvent = function _attachEvent() {
    this.fusionPoseSensor.on("change", this._onPoseChange);
  };

  _proto._dettachEvent = function _dettachEvent() {
    this.fusionPoseSensor.off("change", this._onPoseChange);
  };

  return TiltMotionInput;
}(component_root_eg_Component_default.a);


// CONCATENATED MODULE: ./src/YawPitchControl/ScreenRotationAngle.js

 // Singleton

var screenRotationAngleInst = null;
var refCount = 0;

var ScreenRotationAngle_ScreenRotationAngle =
/*#__PURE__*/
function () {
  function ScreenRotationAngle() {
    refCount++;

    if (screenRotationAngleInst) {
      return screenRotationAngleInst;
    }
    /* eslint-disable */


    screenRotationAngleInst = this;
    /* eslint-enable */

    this._onDeviceOrientation = this._onDeviceOrientation.bind(this);
    this._onOrientationChange = this._onOrientationChange.bind(this);
    this._spinR = 0;
    this._screenOrientationAngle = 0;
    browser["window"].addEventListener("deviceorientation", this._onDeviceOrientation);
    browser["window"].addEventListener("orientationchange", this._onOrientationChange);
  }

  var _proto = ScreenRotationAngle.prototype;

  _proto._onDeviceOrientation = function _onDeviceOrientation(e) {
    if (e.beta === null || e.gamma === null) {
      // (Chrome) deviceorientation is fired with invalid information {alpha=null, beta=null, ...} despite of not dispatching it. We skip it.
      return;
    } // Radian


    var betaR = common.toRadian(e.beta);
    var gammaR = common.toRadian(e.gamma);
    /* spinR range = [-180, 180], left side: 0 ~ -180(deg), right side: 0 ~ 180(deg) */

    this._spinR = Math.atan2(Math.cos(betaR) * Math.sin(gammaR), Math.sin(betaR));
  };

  _proto._onOrientationChange = function _onOrientationChange(e) {
    if (browser["window"].screen && browser["window"].screen.orientation && browser["window"].screen.orientation.angle !== undefined) {
      this._screenOrientationAngle = screen.orientation.angle;
    } else if (browser["window"].orientation !== undefined) {
      /* iOS */
      this._screenOrientationAngle = browser["window"].orientation >= 0 ? browser["window"].orientation : 360 + browser["window"].orientation;
    }
  };

  _proto.getRadian = function getRadian() {
    // Join with screen orientation
    // this._testVal = this._spinR + ", " + this._screenOrientationAngle + ", " + window.orientation;
    return this._spinR + common.toRadian(this._screenOrientationAngle);
  };

  _proto.unref = function unref() {
    if (--refCount > 0) {
      return;
    }

    browser["window"].removeEventListener("deviceorientation", this._onDeviceOrientation);
    browser["window"].removeEventListener("orientationchange", this._onOrientationChange);
    this._spinR = 0;
    this._screenOrientationAngle = 0;
    /* eslint-disable */

    screenRotationAngleInst = null;
    /* eslint-enable */

    refCount = 0;
  };

  return ScreenRotationAngle;
}();


// CONCATENATED MODULE: ./src/YawPitchControl/input/RotationPanInput.js
function RotationPanInput_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }



/**
 * RotationPanInput is extension of PanInput to compensate coordinates by screen rotation angle.
 *
 * The reason for using this function is that in VR mode,
 * the roll angle is adjusted in the direction opposite to the screen rotation angle.
 *
 * Therefore, the angle that the user touches and moves does not match the angle at which the actual object should move.
 * @extends PanInput
 */

var RotationPanInput_RotationPanInput =
/*#__PURE__*/
function (_PanInput) {
  RotationPanInput_inheritsLoose(RotationPanInput, _PanInput);

  /**
   * Constructor
   *
   * @private
   * @param {HTMLElement} el target element
   * @param {Object} [options] The option object
   * @param {Boolean} [options.useRotation]  Whether to use rotation(or VR)
   */
  function RotationPanInput(el, options) {
    var _this;

    _this = _PanInput.call(this, el, options) || this;
    _this._useRotation = false;
    _this._screenRotationAngle = null;

    _this.setUseRotation(!!(options && options.useRotation));

    _this._userDirection = axes_root_eg_Axes_default.a.DIRECTION_ALL;
    return _this;
  }

  var _proto = RotationPanInput.prototype;

  _proto.setUseRotation = function setUseRotation(useRotation) {
    this._useRotation = useRotation;

    if (this._screenRotationAngle) {
      this._screenRotationAngle.unref();

      this._screenRotationAngle = null;
    }

    if (this._useRotation) {
      this._screenRotationAngle = new ScreenRotationAngle_ScreenRotationAngle();
    }
  };

  _proto.connect = function connect(observer) {
    // User intetened direction
    this._userDirection = this._direction; // In VR Mode, Use ALL direction if direction is not none
    // Because horizontal and vertical is changed dynamically by screen rotation.
    // this._direction is used to initialize hammerjs

    if (this._useRotation && this._direction & axes_root_eg_Axes_default.a.DIRECTION_ALL) {
      this._direction = axes_root_eg_Axes_default.a.DIRECTION_ALL;
    }

    _PanInput.prototype.connect.call(this, observer);
  };

  _proto.getOffset = function getOffset(properties, useDirection) {
    if (this._useRotation === false) {
      return _PanInput.prototype.getOffset.call(this, properties, useDirection);
    }

    var offset = _PanInput.prototype.getOffset.call(this, properties, [true, true]);

    var newOffset = [0, 0];

    var theta = this._screenRotationAngle.getRadian();

    var cosTheta = Math.cos(theta);
    var sinTheta = Math.sin(theta);
    newOffset[0] = offset[0] * cosTheta - offset[1] * sinTheta;
    newOffset[1] = offset[1] * cosTheta + offset[0] * sinTheta; // Use only user allowed direction.

    if (!(this._userDirection & axes_root_eg_Axes_default.a.DIRECTION_HORIZONTAL)) {
      newOffset[0] = 0;
    } else if (!(this._userDirection & axes_root_eg_Axes_default.a.DIRECTION_VERTICAL)) {
      newOffset[1] = 0;
    }

    return newOffset;
  };

  _proto.destroy = function destroy() {
    if (this._useRotation) {
      this._screenRotationAngle && this._screenRotationAngle.unref();
    }

    _PanInput.prototype.destroy.call(this);
  };

  return RotationPanInput;
}(axes_root_eg_Axes_["PanInput"]);
/**
 * Override getDirectionByAngle to return DIRECTION_ALL
 * Ref: https://github.com/naver/egjs-axes/issues/99
 *
 * But we obey axes's rule. If axes's rule is problem, let's apply following code.
 */
// PanInput.getDirectionByAngle = function (angle, thresholdAngle) {
// 	return DIRECTION_ALL;
// };



// CONCATENATED MODULE: ./src/YawPitchControl/DeviceQuaternion.js
function DeviceQuaternion_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }





var ORIGIN_VECTOR = mathUtil_vec3.fromValues(0, 0, 0);
var X_AXIS_VECTOR = mathUtil_vec3.fromValues(1, 0, 0);
var Y_AXIS_VECTOR = mathUtil_vec3.fromValues(0, 1, 0);

var DeviceQuaternion_DeviceQuaternion =
/*#__PURE__*/
function (_Component) {
  DeviceQuaternion_inheritsLoose(DeviceQuaternion, _Component);

  function DeviceQuaternion() {
    var _this;

    _this = _Component.call(this) || this;
    _this._screenRotationAngle = new ScreenRotationAngle_ScreenRotationAngle();
    _this._fusionPoseSensor = new FusionPoseSensor_FusionPoseSensor();
    _this._quaternion = mathUtil_quat.create();

    _this._fusionPoseSensor.enable();

    _this._fusionPoseSensor.on("change", function (e) {
      _this._quaternion = e.quaternion;

      _this.trigger("change", {
        isTrusted: true
      });
    });

    return _this;
  }

  var _proto = DeviceQuaternion.prototype;

  _proto.getCombinedQuaternion = function getCombinedQuaternion(yaw, pitch) {
    var deviceR = this._screenRotationAngle.getRadian(); // rotate x-axis around z-axis about screen rotation angle.


    var pitchAxis = mathUtil_vec3.rotateZ(mathUtil_vec3.create(), X_AXIS_VECTOR, ORIGIN_VECTOR, deviceR);
    var yawQ = mathUtil_quat.setAxisAngle(mathUtil_quat.create(), Y_AXIS_VECTOR, common.toRadian(-yaw)); // rotate quaternion around new x-axis about pitch angle.

    var pitchQ = mathUtil_quat.setAxisAngle(mathUtil_quat.create(), pitchAxis, common.toRadian(-pitch));
    var conj = mathUtil_quat.conjugate(mathUtil_quat.create(), this._quaternion); // Multiply pitch quaternion -> device quaternion -> yaw quaternion

    var outQ = mathUtil_quat.multiply(mathUtil_quat.create(), pitchQ, conj);
    mathUtil_quat.multiply(outQ, outQ, yawQ);
    return outQ;
  };

  _proto.destroy = function destroy() {
    // detach all event handler
    this.off();

    if (this._fusionPoseSensor) {
      this._fusionPoseSensor.off();

      this._fusionPoseSensor.destroy();

      this._fusionPoseSensor = null;
    }

    if (this._screenRotationAngle) {
      this._screenRotationAngle.unref();

      this._screenRotationAngle = null;
    }
  };

  return DeviceQuaternion;
}(component_root_eg_Component_default.a);


// EXTERNAL MODULE: ./src/version.js
var src_version = __webpack_require__(37);

// CONCATENATED MODULE: ./src/YawPitchControl/YawPitchControl.js
function YawPitchControl_extends() { YawPitchControl_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return YawPitchControl_extends.apply(this, arguments); }

function YawPitchControl_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }










var DEFAULT_YAW_RANGE = [-YAW_RANGE_HALF, YAW_RANGE_HALF];
var DEFAULT_PITCH_RANGE = [-PITCH_RANGE_HALF, PITCH_RANGE_HALF];
var CIRCULAR_PITCH_RANGE = [-CIRCULAR_PITCH_RANGE_HALF, CIRCULAR_PITCH_RANGE_HALF];
/**
 * A module used to provide coordinate based on yaw/pitch orientation. This module receives user touch action, keyboard, mouse and device orientation(if it exists) as input, then combines them and converts it to yaw/pitch coordinates.
 *
 * @alias eg.YawPitchControl
 * @extends eg.Component
 *
 * @support {"ie": "10+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.3+ (except 3.x)"}
 */

var YawPitchControl_YawPitchControl =
/*#__PURE__*/
function () {
  var YawPitchControl =
  /*#__PURE__*/
  function (_Component) {
    YawPitchControl_inheritsLoose(YawPitchControl, _Component);

    // Expose DeviceOrientationControls sub module for test purpose

    /**
     * @param {Object} options The option object of the eg.YawPitch module
     * @param {Element}[options.element=null] element A base element for the eg.YawPitch module
     * @param {Number} [options.yaw=0] initial yaw (degree)
     * @param {Number} [options.pitch=0] initial pitch (degree)
     * @param {Number} [options.fov=65] initial field of view (degree)
     * @param {Boolean} [optiosn.showPolePoint=true] Indicates whether pole is shown
     * @param {Boolean} [options.useZoom=true] Indicates whether zoom is available
     * @param {Boolean} [options.useKeyboard=true] Indicates whether keyboard is enabled
     * @param {String} [config.gyroMode=yawPitch] Enables control through device motion.
     * @param {Number} [options.touchDirection=TOUCH_DIRECTION_ALL] Direction of the touch movement (TOUCH_DIRECTION_ALL: all,  TOUCH_DIRECTION_YAW: horizontal, TOUCH_DIRECTION_PITCH: vertical, TOUCH_DIRECTION_NONE: no move)
     * @param {Array} [options.yawRange=[-180, 180] Range of visible yaw
     * @param {Array} [options.pitchRange=[-90, 90] Range of visible pitch
     * @param {Array} [options.fovRange=[30, 110] Range of FOV
     * @param {Number} [options.aspectRatio=1] Aspect Ratio
     */
    function YawPitchControl(options) {
      var _this;

      _this = _Component.call(this) || this;

      var opt = YawPitchControl_extends({
        element: null,
        yaw: 0,
        pitch: 0,
        fov: 65,
        showPolePoint: false,
        useZoom: true,
        useKeyboard: true,
        gyroMode: GYRO_MODE.YAWPITCH,
        touchDirection: TOUCH_DIRECTION_ALL,
        yawRange: DEFAULT_YAW_RANGE,
        pitchRange: DEFAULT_PITCH_RANGE,
        fovRange: [30, 110],
        aspectRatio: 1
        /* TODO: Need Mandatory? */

      }, options);

      _this._element = opt.element;
      _this._initialFov = opt.fov;
      _this._enabled = false;
      _this._isAnimating = false;
      _this._deviceQuaternion = null;

      _this._initAxes(opt);

      _this.option(opt);

      return _this;
    }

    var _proto = YawPitchControl.prototype;

    _proto._initAxes = function _initAxes(opt) {
      var _this2 = this;

      var yRange = this._updateYawRange(opt.yawRange, opt.fov, opt.aspectRatio);

      var pRange = this._updatePitchRange(opt.pitchRange, opt.fov, opt.showPolePoint);

      var useRotation = opt.gyroMode === GYRO_MODE.VR;
      this.axesPanInput = new RotationPanInput_RotationPanInput(this._element, {
        useRotation: useRotation
      });
      this.axesWheelInput = new axes_root_eg_Axes_["WheelInput"](this._element, {
        scale: -4
      });
      this.axesTiltMotionInput = null;
      this.axesPinchInput = browserFeature["SUPPORT_TOUCH"] ? new axes_root_eg_Axes_["PinchInput"](this._element, {
        scale: -1
      }) : null;
      this.axesMoveKeyInput = new axes_root_eg_Axes_["MoveKeyInput"](this._element, {
        scale: [-6, 6]
      });
      this.axes = new axes_root_eg_Axes_default.a({
        yaw: {
          range: yRange,
          circular: YawPitchControl.isCircular(yRange),
          bounce: [0, 0]
        },
        pitch: {
          range: pRange,
          circular: YawPitchControl.isCircular(pRange),
          bounce: [0, 0]
        },
        fov: {
          range: opt.fovRange,
          circular: [false, false],
          bounce: [0, 0]
        }
      }, {
        deceleration: MC_DECELERATION,
        maximumDuration: MC_MAXIMUM_DURATION
      }, {
        yaw: opt.yaw,
        pitch: opt.pitch,
        fov: opt.fov
      }).on({
        hold: function hold(evt) {
          // Restore maximumDuration not to be spin too mush.
          _this2.axes.options.maximumDuration = MC_MAXIMUM_DURATION;

          _this2.trigger("hold", {
            isTrusted: evt.isTrusted
          });
        },
        change: function change(evt) {
          if (evt.delta.fov !== 0) {
            _this2._updateControlScale(evt);

            _this2.updatePanScale();
          }

          _this2._triggerChange(evt);
        },
        release: function release(evt) {
          _this2._triggerChange(evt);
        },
        animationStart: function animationStart(evt) {},
        animationEnd: function animationEnd(evt) {
          _this2.trigger("animationEnd", {
            isTrusted: evt.isTrusted
          });
        }
      });
    }
    /**
     * Update Pan Scale
     *
     * Scale(Sensitivity) values of panning is related with fov and height.
     * If at least one of them is changed, this function need to be called.
     * @param {*} param
     */
    ;

    _proto.updatePanScale = function updatePanScale(param) {
      if (param === void 0) {
        param = {};
      }

      var fov = this.axes.get().fov;
      var areaHeight = param.height || parseInt(Object(browserFeature["getComputedStyle"])(this._element).height, 10);
      var scale = MC_BIND_SCALE[0] * fov / this._initialFov * PAN_SCALE / areaHeight;
      this.axesPanInput.options.scale = [scale, scale];
      this.axes.options.deceleration = MC_DECELERATION * fov / MAX_FIELD_OF_VIEW;
      return this;
    }
    /*
     * Override component's option method
     * to call method for updating values which is affected by option change.
     *
     * @param {*} args
     */
    ;

    _proto.option = function option() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var argLen = args.length; // Getter

      if (argLen === 0) {
        return this._getOptions();
      } else if (argLen === 1 && typeof args[0] === "string") {
        return this._getOptions(args[0]);
      } // Setter


      var beforeOptions = YawPitchControl_extends({}, this.options);

      var newOptions = {};
      var changedKeyList = []; // TODO: if value is not changed, then do not push on changedKeyList.

      if (argLen === 1) {
        changedKeyList = Object.keys(args[0]);
        newOptions = YawPitchControl_extends({}, args[0]);
      } else if (argLen >= 2) {
        changedKeyList.push(args[0]);
        newOptions[args[0]] = args[1];
      }

      this._setOptions(this._getValidatedOptions(newOptions));

      this._applyOptions(changedKeyList, beforeOptions);

      return this;
    };

    _proto._getValidatedOptions = function _getValidatedOptions(newOptions) {
      if (newOptions.yawRange) {
        newOptions.yawRange = this._getValidYawRange(newOptions.yawRange, newOptions.fov, newOptions.aspectRatio);
      }

      if (newOptions.pitchRange) {
        newOptions.pitchRange = this._getValidPitchRange(newOptions.pitchRange, newOptions.fov);
      }

      return newOptions;
    };

    _proto._getOptions = function _getOptions(key) {
      var value;

      if (typeof key === "string") {
        value = this.options[key];
      } else if (arguments.length === 0) {
        value = this.options;
      }

      return value;
    };

    _proto._setOptions = function _setOptions(options) {
      for (var key in options) {
        this.options[key] = options[key];
      }
    };

    _proto._applyOptions = function _applyOptions(keys, prevOptions) {
      // If one of below is changed, call updateControlScale()
      if (keys.some(function (key) {
        return key === "showPolePoint" || key === "fov" || key === "aspectRatio" || key === "yawRange" || key === "pitchRange";
      })) {
        this._updateControlScale(); // If fov is changed, update pan scale


        if (keys.indexOf("fov") >= 0) {
          this.updatePanScale();
        }
      }

      if (keys.some(function (key) {
        return key === "fovRange";
      })) {
        /**
         * Temporary Fix Code
         * Changed float number as toFixed(5) format for temporary.
         *
         * TODO: it should not use toFixed(5) after axes.js is fixed.
         */
        var fovRange = this.options.fovRange.map(function (v) {
          return +v.toFixed(5);
        });
        var prevFov = this.axes.get().fov;
        var nextFov = this.axes.get().fov;
        mathUtil_vec2.copy(this.axes.axis.fov.range, fovRange);

        if (nextFov < fovRange[0]) {
          nextFov = fovRange[0];
        } else if (prevFov > fovRange[1]) {
          nextFov = fovRange[1];
        }

        if (prevFov !== nextFov) {
          this.axes.setTo({
            fov: nextFov
          }, 0);

          this._updateControlScale();

          this.updatePanScale();
        }
      }

      if (keys.some(function (key) {
        return key === "gyroMode";
      }) && browserFeature["SUPPORT_DEVICEMOTION"]) {
        var isVR = this.options.gyroMode === GYRO_MODE.VR;
        var isYawPitch = this.options.gyroMode === GYRO_MODE.YAWPITCH; // Disconnect first

        if (this.axesTiltMotionInput) {
          this.axes.disconnect(this.axesTiltMotionInput);
          this.axesTiltMotionInput.destroy();
          this.axesTiltMotionInput = null;
        }

        if (this._deviceQuaternion) {
          this._deviceQuaternion.destroy();

          this._deviceQuaternion = null;
        }

        if (isVR) {
          this._initDeviceQuaternion();
        } else if (isYawPitch) {
          this.axesTiltMotionInput = new TiltMotionInput_TiltMotionInput(this._element);
          this.axes.connect(["yaw", "pitch"], this.axesTiltMotionInput);
        }

        this.axesPanInput.setUseRotation(isVR);
      }

      if (keys.some(function (key) {
        return key === "useKeyboard";
      })) {
        var useKeyboard = this.options.useKeyboard;

        if (useKeyboard) {
          this.axes.connect(["yaw", "pitch"], this.axesMoveKeyInput);
        } else {
          this.axes.disconnect(this.axesMoveKeyInput);
        }
      }

      if (keys.some(function (key) {
        return key === "useZoom";
      })) {
        var useZoom = this.options.useZoom; // Disconnect first

        this.axes.disconnect(this.axesWheelInput);

        if (useZoom) {
          this.axes.connect(["fov"], this.axesWheelInput);
        }
      }

      this._togglePinchInputByOption(this.options.touchDirection, this.options.useZoom);

      if (keys.some(function (key) {
        return key === "touchDirection";
      })) {
        this._enabled && this._enableTouch(this.options.touchDirection);
      }
    };

    _proto._togglePinchInputByOption = function _togglePinchInputByOption(touchDirection, useZoom) {
      if (this.axesPinchInput) {
        // disconnect first
        this.axes.disconnect(this.axesPinchInput); // If the touchDirection option is not ALL, pinchInput should be disconnected to make use of a native scroll.

        if (useZoom && touchDirection === TOUCH_DIRECTION_ALL && // TODO: Get rid of using private property of axes instance.
        this.axes._inputs.indexOf(this.axesPinchInput) === -1) {
          this.axes.connect(["fov"], this.axesPinchInput);
        }
      }
    };

    _proto._enableTouch = function _enableTouch(direction) {
      // Disconnect first
      this.axesPanInput && this.axes.disconnect(this.axesPanInput);
      var yawEnabled = direction & TOUCH_DIRECTION_YAW ? "yaw" : null;
      var pitchEnabled = direction & TOUCH_DIRECTION_PITCH ? "pitch" : null;
      this.axes.connect([yawEnabled, pitchEnabled], this.axesPanInput);
    };

    _proto._initDeviceQuaternion = function _initDeviceQuaternion() {
      var _this3 = this;

      this._deviceQuaternion = new DeviceQuaternion_DeviceQuaternion();

      this._deviceQuaternion.on("change", function (e) {
        _this3._triggerChange(e);
      });
    };

    _proto._getValidYawRange = function _getValidYawRange(newYawRange, newFov, newAspectRatio) {
      var ratio = YawPitchControl.adjustAspectRatio(newAspectRatio || this.options.aspectRatio || 1);
      var fov = newFov || this.axes.get().fov;
      var horizontalFov = fov * ratio;
      var isValid = newYawRange[1] - newYawRange[0] >= horizontalFov;

      if (isValid) {
        return newYawRange;
      } else {
        return this.options.yawRange || DEFAULT_YAW_RANGE;
      }
    };

    _proto._getValidPitchRange = function _getValidPitchRange(newPitchRange, newFov) {
      var fov = newFov || this.axes.get().fov;
      var isValid = newPitchRange[1] - newPitchRange[0] >= fov;

      if (isValid) {
        return newPitchRange;
      } else {
        return this.options.pitchRange || DEFAULT_PITCH_RANGE;
      }
    };

    YawPitchControl.isCircular = function isCircular(range) {
      return range[1] - range[0] < 360 ? [false, false] : [true, true];
    }
    /**
     * Update yaw/pitch min/max by 5 factor
     *
     * 1. showPolePoint
     * 2. fov
     * 3. yawRange
     * 4. pitchRange
     * 5. aspectRatio
     *
     * If one of above is changed, call this function
     */
    ;

    _proto._updateControlScale = function _updateControlScale(changeEvt) {
      var opt = this.options;
      var fov = this.axes.get().fov;

      var pRange = this._updatePitchRange(opt.pitchRange, fov, opt.showPolePoint);

      var yRange = this._updateYawRange(opt.yawRange, fov, opt.aspectRatio); // TODO: If not changed!?


      var pos = this.axes.get();
      var y = pos.yaw;
      var p = pos.pitch;
      mathUtil_vec2.copy(this.axes.axis.yaw.range, yRange);
      mathUtil_vec2.copy(this.axes.axis.pitch.range, pRange);
      this.axes.axis.yaw.circular = YawPitchControl.isCircular(yRange);
      this.axes.axis.pitch.circular = YawPitchControl.isCircular(pRange);
      /**
       * update yaw/pitch by it's range.
       */

      if (y < yRange[0]) {
        y = yRange[0];
      } else if (y > yRange[1]) {
        y = yRange[1];
      }

      if (p < pRange[0]) {
        p = pRange[0];
      } else if (p > pRange[1]) {
        p = pRange[1];
      }

      if (changeEvt) {
        changeEvt.set({
          yaw: y,
          pitch: p
        });
      }

      this.axes.setTo({
        yaw: y,
        pitch: p
      }, 0);
      return this;
    };

    _proto._updatePitchRange = function _updatePitchRange(pitchRange, fov, showPolePoint) {
      if (this.options.gyroMode === GYRO_MODE.VR) {
        // Circular pitch on VR
        return CIRCULAR_PITCH_RANGE;
      }

      var verticalAngle = pitchRange[1] - pitchRange[0];
      var halfFov = fov / 2;
      var isPanorama = verticalAngle < 180;

      if (showPolePoint && !isPanorama) {
        // Use full pinch range
        return pitchRange.map(function (v) {
          return +v.toFixed(5);
        });
      } // Round value as movableCood do.


      return [pitchRange[0] + halfFov, pitchRange[1] - halfFov].map(function (v) {
        return +v.toFixed(5);
      });
    };

    _proto._updateYawRange = function _updateYawRange(yawRange, fov, aspectRatio) {
      if (this.options.gyroMode === GYRO_MODE.VR) {
        return DEFAULT_YAW_RANGE;
      }

      var horizontalAngle = yawRange[1] - yawRange[0];
      /**
       * Full 360 Mode
       */

      if (horizontalAngle >= 360) {
        // Don't limit yaw range on Full 360 mode.
        return yawRange.map(function (v) {
          return +v.toFixed(5);
        });
      }
      /**
       * Panorama mode
       */


      var MAGIC_NUMBER = 1;
      var ratio = YawPitchControl.adjustAspectRatio(aspectRatio);
      var halfHorizontalFov = fov / 2 * ratio; // TODO: Magic Number Fix!

      if (horizontalAngle > 290) {
        MAGIC_NUMBER = 0.794; // horizontalAngle = 286;
      } else if (horizontalAngle > 125) {
        MAGIC_NUMBER = 0.98; // horizontalAngle *= 0.98;
      } // Round value as movableCood do.


      return [yawRange[0] * MAGIC_NUMBER + halfHorizontalFov, yawRange[1] * MAGIC_NUMBER - halfHorizontalFov].map(function (v) {
        return +v.toFixed(5);
      });
    };

    _proto._triggerChange = function _triggerChange(evt) {
      var pos = this.axes.get();
      var opt = this.options;
      var event = {
        targetElement: opt.element,
        isTrusted: evt.isTrusted
      };
      event.yaw = pos.yaw;
      event.pitch = pos.pitch;
      event.fov = pos.fov;

      if (opt.gyroMode === GYRO_MODE.VR && this._deviceQuaternion) {
        event.quaternion = this._deviceQuaternion.getCombinedQuaternion(pos.yaw, pos.pitch);
      }

      this.trigger("change", event);
    } // TODO: makes constant to be logic
    ;

    YawPitchControl.adjustAspectRatio = function adjustAspectRatio(input) {
      var inputRange = [0.520, 0.540, 0.563, 0.570, 0.584, 0.590, 0.609, 0.670, 0.702, 0.720, 0.760, 0.780, 0.820, 0.920, 0.970, 1.00, 1.07, 1.14, 1.19, 1.25, 1.32, 1.38, 1.40, 1.43, 1.53, 1.62, 1.76, 1.77, 1.86, 1.96, 2.26, 2.30, 2.60, 3.00, 5.00, 6.00];
      var outputRange = [0.510, 0.540, 0.606, 0.560, 0.628, 0.630, 0.647, 0.710, 0.736, 0.757, 0.780, 0.770, 0.800, 0.890, 0.975, 1.00, 1.07, 1.10, 1.15, 1.18, 1.22, 1.27, 1.30, 1.33, 1.39, 1.45, 1.54, 1.55, 1.58, 1.62, 1.72, 1.82, 1.92, 2.00, 2.24, 2.30];
      var rangeIdx = -1;

      for (var i = 0; i < inputRange.length - 1; i++) {
        if (inputRange[i] <= input && inputRange[i + 1] >= input) {
          rangeIdx = i;
          break;
        }
      }

      if (rangeIdx === -1) {
        if (inputRange[0] > input) {
          return outputRange[0];
        } else {
          return outputRange[outputRange[0].length - 1];
        }
      }

      var inputA = inputRange[rangeIdx];
      var inputB = inputRange[rangeIdx + 1];
      var outputA = outputRange[rangeIdx];
      var outputB = outputRange[rangeIdx + 1];
      return YawPitchControl.lerp(outputA, outputB, (input - inputA) / (inputB - inputA));
    };

    YawPitchControl.lerp = function lerp(a, b, fraction) {
      return a + fraction * (b - a);
    }
    /**
     * Enable YawPitch functionality
     *
     * @method eg.YawPitch#enable
     */
    ;

    _proto.enable = function enable() {
      if (this._enabled) {
        return this;
      }

      this._enabled = true; // touchDirection is decided by parameter is valid string (Ref. Axes.connect)

      this._applyOptions(Object.keys(this.options), this.options); // TODO: Is this code is needed? Check later.


      this.updatePanScale();
      return this;
    }
    /**
     * Disable YawPitch functionality
     *
     * @method eg.YawPitch#disable
     */
    ;

    _proto.disable = function disable(persistOrientation) {
      if (!this._enabled) {
        return this;
      } // TODO: Check peristOrientation is needed!


      if (!persistOrientation) {
        this._resetOrientation();
      }

      this.axes.disconnect();
      this._enabled = false;
      return this;
    };

    _proto._resetOrientation = function _resetOrientation() {
      var opt = this.options;
      this.axes.setTo({
        yaw: opt.yaw,
        pitch: opt.pitch,
        fov: opt.fov
      }, 0);
      return this;
    }
    /**
     * Set one or more of yaw, pitch, fov
     *
     * @param {Object} coordinate yaw, pitch, fov
     * @param {Number} duration Animation duration. if it is above 0 then it's animated.
     */
    ;

    _proto.lookAt = function lookAt(_ref, duration) {
      var yaw = _ref.yaw,
          pitch = _ref.pitch,
          fov = _ref.fov;
      var pos = this.axes.get();
      var y = yaw === undefined ? 0 : yaw - pos.yaw;
      var p = pitch === undefined ? 0 : pitch - pos.pitch;
      var f = fov === undefined ? 0 : fov - pos.fov; // Allow duration of animation to have more than MC_MAXIMUM_DURATION.

      this.axes.options.maximumDuration = Infinity;
      this.axes.setBy({
        yaw: y,
        pitch: p,
        fov: f
      }, duration);
    };

    _proto.get = function get() {
      return this.axes.get();
    };

    _proto.getYaw = function getYaw() {
      return this.axes.get().yaw;
    };

    _proto.getPitch = function getPitch() {
      return this.axes.get().pitch;
    };

    _proto.getFov = function getFov() {
      return this.axes.get().fov;
    }
    /**
     * Destroys objects
     */
    ;

    _proto.destroy = function destroy() {
      this.axes && this.axes.destroy();
      this.axisPanInput && this.axisPanInput.destroy();
      this.axesWheelInput && this.axesWheelInput.destroy();
      this.axesTiltMotionInput && this.axesTiltMotionInput.destroy();
      this.axesDeviceOrientationInput && this.axesDeviceOrientationInput.destroy();
      this.axesPinchInput && this.axesPinchInput.destroy();
      this.axesMoveKeyInput && this.axesMoveKeyInput.destroy();
      this._deviceQuaternion && this._deviceQuaternion.destroy();
    };

    return YawPitchControl;
  }(component_root_eg_Component_default.a);

  YawPitchControl.VERSION = src_version["VERSION"];
  YawPitchControl.CONTROL_MODE_VR = CONTROL_MODE_VR;
  YawPitchControl.CONTROL_MODE_YAWPITCH = CONTROL_MODE_YAWPITCH;
  YawPitchControl.TOUCH_DIRECTION_ALL = TOUCH_DIRECTION_ALL;
  YawPitchControl.TOUCH_DIRECTION_YAW = TOUCH_DIRECTION_YAW;
  YawPitchControl.TOUCH_DIRECTION_PITCH = TOUCH_DIRECTION_PITCH;
  YawPitchControl.TOUCH_DIRECTION_NONE = TOUCH_DIRECTION_NONE;
  return YawPitchControl;
}();


// CONCATENATED MODULE: ./src/PanoImageRenderer/ImageLoader.js
function ImageLoader_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }



var _Promise = typeof Promise === 'undefined' ? es6_promise_default.a.Promise : Promise;


var STATUS = {
  "NONE": 0,
  "LOADING": 1,
  "LOADED": 2,
  "ERROR": 3
};
var EVENT = {
  "READYSTATECHANGE": "readystatechange"
};

var ImageLoader_ImageLoader =
/*#__PURE__*/
function () {
  var ImageLoader =
  /*#__PURE__*/
  function (_Component) {
    ImageLoader_inheritsLoose(ImageLoader, _Component);

    function ImageLoader(image) {
      var _this;

      // Super constructor
      _this = _Component.call(this) || this;
      _this._image = null;
      _this._onceHandlers = [];
      _this._loadStatus = STATUS.NONE;
      image && _this.set(image);
      return _this;
    }

    var _proto = ImageLoader.prototype;

    _proto.get = function get() {
      var _this2 = this;

      return new _Promise(function (res, rej) {
        if (!_this2._image) {
          rej("ImageLoader: image is not defiend");
        } else if (_this2._loadStatus === STATUS.LOADED) {
          res(_this2.getElement());
        } else if (_this2._loadStatus === STATUS.LOADING) {
          /* Check isMaybeLoaded() first because there may have
          	posibilities that image already loaded before get is called.
          	for example calling get on external image onload callback.*/
          if (ImageLoader.isMaybeLoaded(_this2._image)) {
            _this2._loadStatus = STATUS.LOADED;
            res(_this2.getElement());
          } else {
            _this2.on(EVENT.READYSTATECHANGE, function (e) {
              if (e.type === STATUS.LOADED) {
                res(_this2.getElement());
              } else {
                rej("ImageLoader: failed to load images.");
              }
            });
          }
        } else {
          rej("ImageLoader: failed to load images");
        }
      });
    }
    /**
     * @param image img element or img url or array of img element or array of img url
     */
    ;

    _proto.set = function set(image) {
      var _this3 = this;

      this._loadStatus = STATUS.LOADING;
      this._image = ImageLoader.createElement(image);

      if (ImageLoader.isMaybeLoaded(this._image)) {
        this._loadStatus = STATUS.LOADED;
        return;
      }

      this.onceLoaded(this._image, function () {
        _this3._loadStatus = STATUS.LOADED;

        _this3.trigger(EVENT.READYSTATECHANGE, {
          type: STATUS.LOADED
        });
      }, function () {
        _this3._loadStatus = STATUS.ERROR;

        _this3.trigger(EVENT.READYSTATECHANGE, {
          type: STATUS.ERROR
        });
      });
    };

    ImageLoader.createElement = function createElement(image) {
      var images = image instanceof Array ? image : [image];
      return images.map(function (img) {
        var _img = img;

        if (typeof img === "string") {
          _img = new Image();
          _img.crossOrigin = "anonymous";
          _img.src = img;
        }

        return _img;
      });
    };

    _proto.getElement = function getElement() {
      return this._image.length === 1 ? this._image[0] : this._image;
    };

    ImageLoader.isMaybeLoaded = function isMaybeLoaded(image) {
      var result = false;

      if (image instanceof Image) {
        result = image.complete && image.naturalWidth !== 0;
      } else if (image instanceof Array) {
        result = !image.some(function (img) {
          return !img.complete || img.naturalWidth === 0;
        });
      }

      return result;
    };

    _proto.onceLoaded = function onceLoaded(target, onload, onerror) {
      var _this4 = this;

      var targets = target instanceof Array ? target : [target];
      var targetsNotLoaded = targets.filter(function (img) {
        return !ImageLoader.isMaybeLoaded(img);
      });
      var loadPromises = targetsNotLoaded.map(function (img) {
        return new _Promise(function (res, rej) {
          _this4._once(img, "load", function () {
            return res(img);
          });

          _this4._once(img, "error", function () {
            return rej(img);
          });
        });
      });

      _Promise.all(loadPromises).then(function (result) {
        return onload(targets.length === 1 ? targets[0] : targets);
      }, function (reason) {
        return onerror(reason);
      });
    };

    _proto._once = function _once(target, type, listener) {
      var fn = function fn(event) {
        target.removeEventListener(type, fn);
        listener(event);
      };

      target.addEventListener(type, fn);

      this._onceHandlers.push({
        target: target,
        type: type,
        fn: fn
      });
    };

    _proto.getStatus = function getStatus() {
      return this._loadStatus;
    };

    _proto.destroy = function destroy() {
      this._onceHandlers.forEach(function (handler) {
        handler.target.removeEventListener(handler.type, handler.fn);
      });

      this._onceHandlers = [];
      this._image.src = "";
      this._image = null;
      this._loadStatus = STATUS.NONE;
    };

    return ImageLoader;
  }(component_root_eg_Component_default.a);

  ImageLoader.STATUS = STATUS;
  return ImageLoader;
}();


// CONCATENATED MODULE: ./src/PanoImageRenderer/VideoLoader.js


var VideoLoader_Promise = typeof Promise === 'undefined' ? es6_promise_default.a.Promise : Promise;

// import Agent from "@egjs/agent";

/* Ref https://www.w3schools.com/tags/av_prop_readystate.asp */
var READY_STATUS = {
  HAVE_NOTHING: 0,
  // no information whether or not the audio/video is ready
  HAVE_METADATA: 1,
  // HAVE_METADATA - metadata for the audio/video is ready
  HAVE_CURRENT_DATA: 2,
  // data for the current playback position is available, but not enough data to play next frame/millisecond
  HAVE_FUTURE_DATA: 3,
  // data for the current and at least the next frame is available
  HAVE_ENOUGH_DATA: 4,
  // enough data available to start playing
  // below is custom status for failed to load status
  LOADING_FAILED: -1
};
var READYSTATECHANGE_EVENT_NAME = {};
READYSTATECHANGE_EVENT_NAME[READY_STATUS.HAVE_METADATA] = "loadedmetadata";
READYSTATECHANGE_EVENT_NAME[READY_STATUS.HAVE_CURRENT_DATA] = "loadeddata";
READYSTATECHANGE_EVENT_NAME[READY_STATUS.HAVE_FUTURE_DATA] = "canplay";
READYSTATECHANGE_EVENT_NAME[READY_STATUS.HAVE_ENOUGH_DATA] = "canplaythrough";

var VideoLoader =
/*#__PURE__*/
function () {
  function VideoLoader(video) {
    this._handlers = [];
    this._sourceCount = 0; // on iOS safari, 'loadeddata' will not triggered unless the user hits play,
    // so used 'loadedmetadata' instead.

    this._thresholdReadyState = READY_STATUS.HAVE_METADATA;
    this._thresholdEventName = READYSTATECHANGE_EVENT_NAME[this._thresholdReadyState];
    this._loadStatus = video && video.readyState || READY_STATUS.HAVE_NOTHING;
    this._onerror = this._onerror.bind(this);
    video && this.set(video);
  }

  var _proto = VideoLoader.prototype;

  _proto._onerror = function _onerror() {
    this._errorCount++;

    if (this._errorCount >= this._sourceCount) {
      this._loadStatus = READY_STATUS.LOADING_FAILED;

      this._detachErrorHandler(this._onerror);
    }
  }
  /**
   *
   * @param {Object | String} video Object or String containing Video Source URL<ko> URL      {type, src}</ko>
   */
  ;

  _proto._appendSourceElement = function _appendSourceElement(videoUrl) {
    var videoSrc;
    var videoType;

    if (typeof videoUrl === "object") {
      videoSrc = videoUrl.src;
      videoType = videoUrl.type;
    } else if (typeof videoUrl === "string") {
      videoSrc = videoUrl;
    }

    if (!videoSrc) {
      return false;
    }

    var sourceElement = document.createElement("source");
    sourceElement.src = videoSrc;
    videoType && (sourceElement.type = videoType);

    this._video.appendChild(sourceElement);

    return true;
  };

  _proto.set = function set(video) {
    var _this = this;

    this._reset(); // reset resources.


    if (!video) {
      return;
    }

    if (video instanceof HTMLVideoElement) {
      // video tag
      this._video = video;
    } else if (typeof video === "string" || typeof video === "object") {
      // url
      this._video = document.createElement("video");

      this._video.setAttribute("crossorigin", "anonymous");

      this._video.setAttribute("webkit-playsinline", "");

      this._video.setAttribute("playsinline", "");

      if (video instanceof Array) {
        video.forEach(function (v) {
          return _this._appendSourceElement(v);
        });
      } else {
        this._appendSourceElement(video);
      }

      this._sourceCount = this._video.querySelectorAll("source").length;

      if (this._sourceCount > 0) {
        if (this._video.readyState < this._thresholdReadyState) {
          this._video.load(); // attach loading error listener


          this._attachErrorHandler(this._onerror);
        }
      } else {
        this._video = null;
      }
    }
  };

  _proto._attachErrorHandler = function _attachErrorHandler(handler) {
    this._video.addEventListener("error", handler);

    this._sources = this._video.querySelectorAll("source");
    [].forEach.call(this._sources, function (source) {
      source.addEventListener("error", handler);
    });
  };

  _proto._detachErrorHandler = function _detachErrorHandler(handler) {
    this._video.removeEventListener("error", handler);

    [].forEach.call(this._sources, function (source) {
      source.removeEventListener("error", handler);
    });
  };

  _proto.get = function get() {
    var _this2 = this;

    return new VideoLoader_Promise(function (res, rej) {
      if (!_this2._video) {
        rej("VideoLoader: video is undefined");
      } else if (_this2._loadStatus === READY_STATUS.LOADING_FAILED) {
        rej("VideoLoader: video source is invalid");
      } else if (_this2._video.readyState >= _this2._thresholdReadyState) {
        res(_this2._video);
      } else {
        // check errorCnt and reject
        var rejector = function rejector() {
          if (_this2._loadStatus === READY_STATUS.LOADING_FAILED) {
            _this2._detachErrorHandler(rejector);

            rej("VideoLoader: video source is invalid");
          }
        };

        _this2._attachErrorHandler(rejector);

        _this2._once(_this2._thresholdEventName, function () {
          return res(_this2._video);
        });
      }
    });
  };

  _proto.getElement = function getElement() {
    return this._video;
  };

  _proto.destroy = function destroy() {
    this._reset();
  };

  _proto._reset = function _reset() {
    var _this3 = this;

    this._handlers.forEach(function (handler) {
      _this3._video.removeEventListener(handler.type, handler.fn);
    });

    this._handlers = [];
    this._video = null;
    this._sourceCount = 0;
    this._errorCount = 0;
  };

  _proto._once = function _once(type, listener) {
    var target = this._video;

    var fn = function fn(event) {
      target.removeEventListener(type, fn);
      listener(event);
    };
    /* By useCapture mode enabled, you can capture the error event being fired on source(child)*/


    target.addEventListener(type, fn, true);

    this._handlers.push({
      type: type,
      fn: fn
    });
  };

  return VideoLoader;
}();


// CONCATENATED MODULE: ./node_modules/@egjs/agent/dist/agent.esm.js
/*
Copyright (c) 2017 NAVER Corp.
@egjs/agent project is licensed under the MIT license

@egjs/agent JavaScript library


@version 2.1.5
*/
var win = typeof window !== "undefined" && window || {};
var RegExp$1 = win.RegExp;
var agent_esm_navigator = win.navigator;

var parseRules = {
	browser: [{
		criteria: "PhantomJS",
		identity: "PhantomJS"
	}, {
		criteria: /Whale/,
		identity: "Whale",
		versionSearch: "Whale"
	}, {
		criteria: /Edge/,
		identity: "Edge",
		versionSearch: "Edge"
	}, {
		criteria: /MSIE|Trident|Windows Phone/,
		identity: "IE",
		versionSearch: "IEMobile|MSIE|rv"
	}, {
		criteria: /MiuiBrowser/,
		identity: "MIUI Browser",
		versionSearch: "MiuiBrowser"
	}, {
		criteria: /SamsungBrowser/,
		identity: "Samsung Internet",
		versionSearch: "SamsungBrowser"
	}, {
		criteria: /SAMSUNG /,
		identity: "Samsung Internet",
		versionSearch: "Version"
	}, {
		criteria: /Chrome|CriOS/,
		identity: "Chrome"
	}, {
		criteria: /Android/,
		identity: "Android Browser",
		versionSearch: "Version"
	}, {
		criteria: /iPhone|iPad/,
		identity: "Safari",
		versionSearch: "Version"
	}, {
		criteria: "Apple",
		identity: "Safari",
		versionSearch: "Version"
	}, {
		criteria: "Firefox",
		identity: "Firefox"
	}],
	os: [{
		criteria: /Windows Phone/,
		identity: "Windows Phone",
		versionSearch: "Windows Phone"
	}, {
		criteria: "Windows 2000",
		identity: "Window",
		versionAlias: "5.0"
	}, {
		criteria: /Windows NT/,
		identity: "Window",
		versionSearch: "Windows NT"
	}, {
		criteria: /iPhone|iPad/,
		identity: "iOS",
		versionSearch: "iPhone OS|CPU OS"
	}, {
		criteria: "Mac",
		versionSearch: "OS X",
		identity: "MAC"
	}, {
		criteria: /Android/,
		identity: "Android"
	}, {
		criteria: /Tizen/,
		identity: "Tizen"
	}, {
		criteria: /Web0S/,
		identity: "WebOS"
	}],

	// Webview check condition
	// ios: If has no version information
	// Android 5.0 && chrome 40+: Presence of "; wv" in userAgent
	// Under android 5.0: Presence of "NAVER" or "Daum" in userAgent
	webview: [{
		criteria: /iPhone|iPad/,
		browserVersionSearch: "Version",
		webviewBrowserVersion: /-1/
	}, {
		criteria: /iPhone|iPad|Android/,
		webviewToken: /NAVER|DAUM|; wv/

	}],
	defaultString: {
		browser: {
			version: "-1",
			name: "unknown"
		},
		os: {
			version: "-1",
			name: "unknown"
		}
	}
};

function filter(arr, compare) {
	var result = [];

	for (var i = 0; i < arr.length; i++) {
		compare(arr[i]) && result.push(arr[i]);
	}
	return result;
}

function some(arr, compare) {
	for (var i = 0; i < arr.length; i++) {
		if (compare(arr[i])) {
			return true;
		}
	}
	return false;
}

var UA = void 0;

function setUa(ua) {
	UA = ua;
}

function isMatched(base, target) {
	return target && target.test ? !!target.test(base) : base.indexOf(target) > -1;
}

function getIdentityStringFromArray(rules, defaultStrings) {
	var matchedRule = filter(rules, function (rule) {
		return isMatched(UA, rule.criteria);
	})[0];

	return matchedRule && matchedRule.identity || defaultStrings.name;
}

function getRule(rules, targetIdentity) {
	return filter(rules, function (rule) {
		var criteria = rule.criteria;
		var identityMatched = new RegExp(rule.identity, "i").test(targetIdentity);

		if (criteria ? identityMatched && isMatched(UA, criteria) : identityMatched) {
			return true;
		} else {
			return false;
		}
	})[0];
}

function getBrowserName() {
	return getIdentityStringFromArray(parseRules.browser, parseRules.defaultString.browser);
}

function getBrowserRule(browserName) {
	var rule = getRule(parseRules.browser, browserName);

	if (!rule) {
		rule = {
			criteria: browserName,
			versionSearch: browserName,
			identity: browserName
		};
	}

	return rule;
}

function extractBrowserVersion(versionToken, ua) {
	var browserVersion = parseRules.defaultString.browser.version;
	var versionRegexResult = new RegExp("(" + versionToken + ")", "i").exec(ua);

	if (!versionRegexResult) {
		return browserVersion;
	}

	var versionTokenIndex = versionRegexResult.index;
	var verTkn = versionRegexResult[0];

	if (versionTokenIndex > -1) {
		var versionIndex = versionTokenIndex + verTkn.length + 1;

		browserVersion = ua.substring(versionIndex).split(" ")[0].replace(/_/g, ".").replace(/;|\)/g, "");
	}
	return browserVersion;
}

function getBrowserVersion(browserName) {
	if (!browserName) {
		return undefined;
	}

	// console.log(browserRule);
	// const versionToken = browserRule ? browserRule.versionSearch : browserName;
	var browserRule = getBrowserRule(browserName);
	var versionToken = browserRule.versionSearch || browserName;
	var browserVersion = extractBrowserVersion(versionToken, UA);

	return browserVersion;
}

function isWebview() {
	var webviewRules = parseRules.webview;
	var browserVersion = void 0;

	return some(filter(webviewRules, function (rule) {
		return isMatched(UA, rule.criteria);
	}), function (rule) {
		browserVersion = extractBrowserVersion(rule.browserVersionSearch, UA);
		if (isMatched(UA, rule.webviewToken) || isMatched(browserVersion, rule.webviewBrowserVersion)) {
			return true;
		} else {
			return false;
		}
	});
}

function getOSRule(osName) {
	return getRule(parseRules.os, osName);
}

function getOsName() {
	return getIdentityStringFromArray(parseRules.os, parseRules.defaultString.os);
}

function getOsVersion(osName) {
	var osRule = getOSRule(osName) || {};
	var defaultOSVersion = parseRules.defaultString.os.version;
	var osVersion = void 0;

	if (!osName) {
		return undefined;
	}
	if (osRule.versionAlias) {
		return osRule.versionAlias;
	}
	var osVersionToken = osRule.versionSearch || osName;
	var osVersionRegex = new RegExp("(" + osVersionToken + ")\\s([\\d_\\.]+|\\d_0)", "i");
	var osVersionRegexResult = osVersionRegex.exec(UA);

	if (osVersionRegexResult) {
		osVersion = osVersionRegex.exec(UA)[2].replace(/_/g, ".").replace(/;|\)/g, "");
	}
	return osVersion || defaultOSVersion;
}

function getOs() {
	var name = getOsName();
	var version = getOsVersion(name);

	return { name: name, version: version };
}

function getBrowser() {
	var name = getBrowserName();
	var version = getBrowserVersion(name);

	return { name: name, version: version, webview: isWebview() };
}

function getIsMobile() {
	return UA.indexOf("Mobi") !== -1;
}

/**
 * Copyright (c) NAVER Corp.
 * egjs-agent projects are licensed under the MIT license
 */

/**
 * @namespace eg.agent
 */
/**
 * Extracts browser and operating system information from the user agent string.
 * @ko       .
 * @function eg.agent#agent
 * @param {String} [userAgent=navigator.userAgent] user agent string to parse <ko>  </ko>
 * @return {Object} agentInfo
 * @return {Object} agentInfo.os os Operating system information <ko> </ko>
 * @return {String} agentInfo.os.name Operating system name (android, ios, window, mac, unknown) <ko>  (android, ios, window, mac, unknown)</ko>
 * @return {String} agentInfo.os.version Operating system version <ko> </ko>
 * @return {String} agentInfo.browser Browser information <ko> </ko>
 * @return {String} agentInfo.browser.name Browser name (safari, chrome, sbrowser, ie, firefox, unknown) <ko>  (safari, chrome, sbrowser, ie, firefox, unknown)</ko>
 * @return {String} agentInfo.browser.version Browser version <ko>  </ko>
 * @return {Boolean} agentInfo.browser.webview Indicates whether the browser is inapp<ko>  </ko>
 * @return {Boolean} agentInfo.isMobile Indicates whether the browser is for mobile<ko>  </ko>
 * @example
import agent from "@egjs/agent";

const {os, browser, isMobile} = agent();
 */
function agent_esm_agent() {
  var ua = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : agent_esm_navigator.userAgent;

  setUa(ua);

  var agentInfo = {
    os: getOs(),
    browser: getBrowser(),
    isMobile: getIsMobile()
  };

  agentInfo.browser.name = agentInfo.browser.name.toLowerCase();
  agentInfo.os.name = agentInfo.os.name.toLowerCase();
  agentInfo.os.version = agentInfo.os.version.toLowerCase();

  if (agentInfo.os.name === "ios" && agentInfo.browser.webview) {
    agentInfo.browser.version = "-1";
  }

  return agentInfo;
}
/**
 * Version info string
 * @ko  
 * @name VERSION
 * @static
 * @type {String}
 * @example
 * eg.agent.VERSION;  // ex) 2.2.0
 * @memberof eg.agent
 */
agent_esm_agent.VERSION = "2.1.5";

/* harmony default export */ var agent_esm = (agent_esm_agent);
//# sourceMappingURL=agent.esm.js.map

// CONCATENATED MODULE: ./src/PanoImageRenderer/WebGLUtils.js
function WebGLUtils_extends() { WebGLUtils_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return WebGLUtils_extends.apply(this, arguments); }


var WEBGL_ERROR_CODE = {
  "0": "NO_ERROR",
  "1280": "INVALID_ENUM",
  "1281": "INVALID_VALUE",
  "1282": "INVALID_OPERATION",
  "1285": "OUT_OF_MEMORY",
  "1286": "INVALID_FRAMEBUFFER_OPERATION",
  "37442": "CONTEXT_LOST_WEBGL"
};
var webglAvailability = null;
var MAX_TEXTURE_SIZE_FOR_TEST = null;

var WebGLUtils_WebGLUtils =
/*#__PURE__*/
function () {
  function WebGLUtils() {}

  WebGLUtils.createShader = function createShader(gl, type, source) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

    if (success) {
      return shader;
    }

    gl.deleteShader(shader);
    return null;
  };

  WebGLUtils.createProgram = function createProgram(gl, vertexShader, fragmentShader) {
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    var success = gl.getProgramParameter(program, gl.LINK_STATUS);

    if (success) {
      return program;
    }

    gl.deleteProgram(program);
    return null;
  };

  WebGLUtils.initBuffer = function initBuffer(gl, target
  /* bind point */
  , data, itemSize, attr) {
    var buffer = gl.createBuffer();
    gl.bindBuffer(target, buffer);
    gl.bufferData(target, data, gl.STATIC_DRAW);

    if (buffer) {
      buffer.itemSize = itemSize;
      buffer.numItems = data.length / itemSize;
    }

    if (attr !== undefined) {
      gl.enableVertexAttribArray(attr);
      gl.vertexAttribPointer(attr, buffer.itemSize, gl.FLOAT, false, 0, 0);
    }

    return buffer;
  };

  WebGLUtils.getWebglContext = function getWebglContext(canvas, userContextAttributes) {
    var webglIdentifiers = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
    var context = null;

    var contextAttributes = WebGLUtils_extends({
      preserveDrawingBuffer: false,
      antialias: false
    }, userContextAttributes);

    function onWebglcontextcreationerror(e) {
      return e.statusMessage;
    }

    canvas.addEventListener("webglcontextcreationerror", onWebglcontextcreationerror);

    for (var i = 0; i < webglIdentifiers.length; i++) {
      try {
        context = canvas.getContext(webglIdentifiers[i], contextAttributes);
      } catch (t) {}

      if (context) {
        break;
      }
    }

    canvas.removeEventListener("webglcontextcreationerror", onWebglcontextcreationerror);
    return context;
  };

  WebGLUtils.createTexture = function createTexture(gl, textureTarget) {
    var texture = gl.createTexture();
    gl.bindTexture(textureTarget, texture);
    gl.texParameteri(textureTarget, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(textureTarget, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(textureTarget, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(textureTarget, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.bindTexture(textureTarget, null);
    return texture;
  }
  /**
   * Returns the webgl availability of the current browser.
   * @method WebGLUtils#isWebGLAvailable
   * @retuen {Boolean} isWebGLAvailable
   */
  ;

  WebGLUtils.isWebGLAvailable = function isWebGLAvailable() {
    if (webglAvailability === null) {
      var canvas = document.createElement("canvas");
      var webglContext = WebGLUtils.getWebglContext(canvas);
      webglAvailability = !!webglContext; // webglContext Resource forced collection

      if (webglContext) {
        var loseContextExtension = webglContext.getExtension("WEBGL_lose_context");
        loseContextExtension && loseContextExtension.loseContext();
      }
    }

    return webglAvailability;
  }
  /**
   * Returns whether webgl is stable in the current browser.
   * @method WebGLUtils#isStableWebGL
   * @retuen {Boolean} isStableWebGL
   */
  ;

  WebGLUtils.isStableWebGL = function isStableWebGL() {
    var agentInfo = agent_esm();
    var isStableWebgl = true;

    if (agentInfo.os.name === "android" && parseFloat(agentInfo.os.version) <= 4.3) {
      isStableWebgl = false;
    } else if (agentInfo.os.name === "android" && parseFloat(agentInfo.os.version) === 4.4) {
      if (agentInfo.browser.name !== "chrome") {
        isStableWebgl = false;
      }
    }

    return isStableWebgl;
  };

  WebGLUtils.getErrorNameFromWebGLErrorCode = function getErrorNameFromWebGLErrorCode(code) {
    if (!(code in WEBGL_ERROR_CODE)) {
      return "UNKNOWN_ERROR";
    }

    return WEBGL_ERROR_CODE[code];
  }
  /**
   * This function is wrapper for texImage2D to handle exceptions on texImage2D.
   * Purpose is to prevent service from being stopped by script error.
   *
   * @param {*} gl
   * @param {*} target
   * @param {*} pixels
   */
  ;

  WebGLUtils.texImage2D = function texImage2D(gl, target, pixels) {
    try {
      gl.texImage2D(target, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    } catch (error) {
      /* eslint-disable no-console */
      console.error("WebGLUtils.texImage2D error:", error);
      /* eslint-enable no-console */
    }
  };

  WebGLUtils.getMaxTextureSize = function getMaxTextureSize(gl) {
    // WARN: MAX_TEXTURE_SIZE_FOR_TEST is used for test
    return MAX_TEXTURE_SIZE_FOR_TEST || gl.getParameter(gl.MAX_TEXTURE_SIZE);
  };

  return WebGLUtils;
}();
/**
 * This function should not be used in service code. It's provided only for test purpose.
 * It should be set to null or 0 when test is done.
 *
 * @param {Number} size
 */




function setMaxTextureSizeForTestOnlyPurpose(size) {
  MAX_TEXTURE_SIZE_FOR_TEST = size;
}


// CONCATENATED MODULE: ./src/PanoImageRenderer/renderer/Renderer.js
function Renderer_extends() { Renderer_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Renderer_extends.apply(this, arguments); }

function Renderer_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }



var Renderer_agent = agent_esm();
var isIE11 = Renderer_agent.browser.name === "ie" && Renderer_agent.browser.version === "11.0";
var EVENTS = {
  ERROR: "error"
};
/**
 *
 * Extends Component for firing errors occurs internally.
 */

var Renderer_Renderer =
/*#__PURE__*/
function () {
  var Renderer =
  /*#__PURE__*/
  function (_Component) {
    Renderer_inheritsLoose(Renderer, _Component);

    function Renderer() {
      var _this;

      _this = _Component.call(this) || this;
      _this._forceDimension = null;
      _this._pixelCanvas = null;
      _this._pixelContext = null;
      return _this;
    } // Define interface for Renderers

    /**
     * Following MUST BE DEFINED on Child of Renderer
     *
     * DATA
     *
     *  - getVertexPositionData
     *  - getIndexData
     *  - getTextureCoordData
     *
     * SOURCE
     *
     *  - getVertexShaderSource
     *  - getFragmentShaderSource
     *
     * TEXTURE
     *
     *  - bindTexture
     */


    var _proto = Renderer.prototype;

    _proto.getDimension = function getDimension(pixelSource) {
      var width = pixelSource.naturalWidth || pixelSource.videoWidth;
      var height = pixelSource.naturalHeight || pixelSource.videoHeight;
      return {
        width: width,
        height: height
      };
    }
    /**
     * Update data used by shader
     * 	-
     *
     *
     * @param {*} param
     */
    ;

    _proto.updateShaderData = function updateShaderData(param) {}
    /*
    * Update following data in implementation layer.
    * If the data is not changed, it does not need to implement this function.
    *
    * - _VERTEX_POSITION_DATA
    * - _TEXTURE_COORD_DATA
    * - _INDEX_DATA
    */

    /**
     *
     * @param {HTMLImageElement | HTMLVideoElement} image
     * @param {Object = {width, height}} forceDimension Forced dimension to resize
     */
    ;

    _proto._initPixelSource = function _initPixelSource(image, forceDimension) {
      var isIE11Video = isIE11 && image instanceof HTMLVideoElement;

      if (isIE11Video || forceDimension) {
        var _ref = forceDimension || this.getDimension(image),
            width = _ref.width,
            height = _ref.height;

        this._pixelCanvas = document.createElement("canvas");
        this._pixelCanvas.width = width;
        this._pixelCanvas.height = height;
        this._pixelContext = this._pixelCanvas.getContext("2d");
      }

      this._forceDimension = forceDimension;
    };

    _proto._getPixelSource = function _getPixelSource(image) {
      if (!this._pixelCanvas) {
        return image;
      }
      /**
       * IE11 && Video
       * or
       * Dimension is forced (Image is larger than texture size.)
       */


      var contentDimension = this.getDimension(image);
      var textureDimension = this._forceDimension || contentDimension;

      if (this._pixelCanvas.width !== textureDimension.width) {
        this._pixelCanvas.width = textureDimension.width;
      }

      if (this._pixelCanvas.height !== textureDimension.height) {
        this._pixelCanvas.height = textureDimension.height;
      }

      if (this._forceDimension) {
        this._pixelContext.drawImage(image, 0, 0, contentDimension.width, contentDimension.height, 0, 0, textureDimension.width, textureDimension.height);
      } else {
        this._pixelContext.drawImage(image, 0, 0);
      }

      return this._pixelCanvas;
    };

    _proto._extractTileConfig = function _extractTileConfig(imageConfig) {
      var tileConfig = Array.isArray(imageConfig.tileConfig) ? imageConfig.tileConfig : Array.apply(void 0, Array(6)).map(function () {
        return imageConfig.tileConfig;
      });
      tileConfig = tileConfig.map(function (config) {
        return Renderer_extends({
          flipHorizontal: false,
          rotation: 0
        }, config);
      });
      return tileConfig;
    };

    _proto._triggerError = function _triggerError(error) {
      /* eslint-disable no-console */
      console.error("Renderer Error:", error);
      /* eslint-enable no-console */

      this.trigger(EVENTS.ERROR, {
        message: typeof error === "string" ? error : error.message
      });
    };

    return Renderer;
  }(component_root_eg_Component_default.a);

  Renderer.EVENTS = EVENTS;
  return Renderer;
}();


// CONCATENATED MODULE: ./src/PanoImageRenderer/renderer/CubeRenderer.js
function CubeRenderer_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }






var CubeRenderer_CubeRenderer =
/*#__PURE__*/
function () {
  var CubeRenderer =
  /*#__PURE__*/
  function (_Renderer) {
    CubeRenderer_inheritsLoose(CubeRenderer, _Renderer);

    function CubeRenderer() {
      return _Renderer.apply(this, arguments) || this;
    }

    var _proto = CubeRenderer.prototype;

    _proto.getVertexPositionData = function getVertexPositionData() {
      CubeRenderer._VERTEX_POSITION_DATA = CubeRenderer._VERTEX_POSITION_DATA !== null ? CubeRenderer._VERTEX_POSITION_DATA : [// back
      1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, // front
      -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, // top
      -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, // bottom
      1, -1, -1, -1, -1, -1, -1, -1, 1, 1, -1, 1, // right
      1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, -1, // left
      -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1];
      return CubeRenderer._VERTEX_POSITION_DATA;
    };

    _proto.getIndexData = function getIndexData() {
      if (CubeRenderer._INDEX_DATA) {
        return CubeRenderer._INDEX_DATA;
      }

      var indexData = [];
      var vertexPositionData = this.getVertexPositionData();

      for (var i = 0; i < vertexPositionData.length / 3; i += 4) {
        indexData.push(i, i + 2, i + 1, i, i + 3, i + 2);
      }

      CubeRenderer._INDEX_DATA = indexData;
      return indexData;
    };

    CubeRenderer.extractOrder = function extractOrder(imageConfig) {
      return imageConfig.order || "RLUDBF";
    };

    _proto.getTextureCoordData = function getTextureCoordData(imageConfig) {
      var vertexOrder = "BFUDRL";
      var order = CubeRenderer.extractOrder(imageConfig);
      var base = this.getVertexPositionData();

      var tileConfig = this._extractTileConfig(imageConfig);

      var elemSize = 3;
      var vertexPerTile = 4;
      var textureCoordData = vertexOrder.split("").map(function (face) {
        return tileConfig[order.indexOf(face)];
      }).map(function (config, i) {
        var rotation = parseInt(config.rotation / 90, 10);
        var ordermap_ = config.flipHorizontal ? [0, 1, 2, 3] : [1, 0, 3, 2];

        for (var r = 0; r < Math.abs(rotation); r++) {
          if (config.flipHorizontal && rotation > 0 || !config.flipHorizontal && rotation < 0) {
            ordermap_.push(ordermap_.shift());
          } else {
            ordermap_.unshift(ordermap_.pop());
          }
        }

        var elemPerTile = elemSize * vertexPerTile;
        var tileVertex = base.slice(i * elemPerTile, i * elemPerTile + elemPerTile);
        var tileTemp = [];

        for (var j = 0; j < vertexPerTile; j++) {
          tileTemp[ordermap_[j]] = tileVertex.splice(0, elemSize);
        }

        return tileTemp;
      }).join().split(",").map(function (v) {
        return parseInt(v, 10);
      });
      return textureCoordData;
    };

    _proto.getVertexShaderSource = function getVertexShaderSource() {
      return "\n\t\t\tattribute vec3 aVertexPosition;\n\t\t\tattribute vec3 aTextureCoord;\n\t\t\tuniform mat4 uMVMatrix;\n\t\t\tuniform mat4 uPMatrix;\n\t\t\tvarying highp vec3 vVertexDirectionVector;\n\t\t\tvoid main(void) {\n\t\t\t\tgl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n\t\t\t\tvVertexDirectionVector = aTextureCoord;\n\t\t\t}";
    };

    _proto.getFragmentShaderSource = function getFragmentShaderSource() {
      return "\n\t\t\tvarying highp vec3 vVertexDirectionVector;\n\t\t\tuniform samplerCube uSampler;\n\t\t\tvoid main(void) {\n\t\t\t\tgl_FragColor = textureCube(uSampler, vVertexDirectionVector);\n\t\t\t}";
    };

    _proto.updateTexture = function updateTexture(gl, image, imageConfig) {
      var baseOrder = "RLUDBF";
      var order = CubeRenderer.extractOrder(imageConfig);
      var orderMap = {};
      order.split("").forEach(function (v, i) {
        orderMap[v] = i;
      });

      try {
        if (image instanceof Array) {
          for (var surfaceIdx = 0; surfaceIdx < 6; surfaceIdx++) {
            var tileIdx = orderMap[baseOrder[surfaceIdx]];
            WebGLUtils_WebGLUtils.texImage2D(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X + surfaceIdx, image[tileIdx]);
          }
        } else {
          var maxCubeMapTextureSize = this.getMaxCubeMapTextureSize(gl, image);

          for (var _surfaceIdx = 0; _surfaceIdx < 6; _surfaceIdx++) {
            var _tileIdx = orderMap[baseOrder[_surfaceIdx]];
            var tile = this.extractTileFromImage(image, _tileIdx, maxCubeMapTextureSize);
            WebGLUtils_WebGLUtils.texImage2D(gl, gl.TEXTURE_CUBE_MAP_POSITIVE_X + _surfaceIdx, tile);
          }
        }
      } catch (e) {
        this._triggerError(e);
      }
    };

    _proto.bindTexture = function bindTexture(gl, texture, image, imageConfig) {
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
      this.updateTexture(gl, image, imageConfig);
    };

    _proto.getSourceTileSize = function getSourceTileSize(image) {
      var _this$getDimension = this.getDimension(image),
          width = _this$getDimension.width,
          height = _this$getDimension.height;

      var aspectRatio = width / height;
      var inputTextureSize;

      if (aspectRatio === 1 / 6) {
        inputTextureSize = width;
      } else if (aspectRatio === 6) {
        inputTextureSize = height;
      } else if (aspectRatio === 2 / 3) {
        inputTextureSize = width / 2;
      } else {
        inputTextureSize = width / 3;
      }

      return inputTextureSize;
    };

    _proto.extractTileFromImage = function extractTileFromImage(image, tileIdx, outputTextureSize) {
      var _this$getDimension2 = this.getDimension(image),
          width = _this$getDimension2.width;

      var inputTextureSize = this.getSourceTileSize(image);
      var canvas = document.createElement("canvas");
      canvas.width = outputTextureSize;
      canvas.height = outputTextureSize;
      var context = canvas.getContext("2d");
      var tilePerRow = width / inputTextureSize;
      var x = inputTextureSize * tileIdx % (inputTextureSize * tilePerRow);
      var y = parseInt(tileIdx / tilePerRow, 10) * inputTextureSize;
      context.drawImage(image, x, y, inputTextureSize, inputTextureSize, 0, 0, outputTextureSize, outputTextureSize);
      return canvas;
    };

    _proto.getMaxCubeMapTextureSize = function getMaxCubeMapTextureSize(gl, image) {
      var agent = agent_esm();
      var maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);

      var _imageWidth = this.getSourceTileSize(image);

      if (agent.browser.name === "ie" && parseInt(agent.browser.version, 10) === 11) {
        if (!math_util_util.isPowerOfTwo(_imageWidth)) {
          for (var i = 1; i < maxCubeMapTextureSize; i *= 2) {
            if (i < _imageWidth) {
              continue;
            } else {
              _imageWidth = i;
              break;
            }
          }
        }
      } // ios 9     1024 .


      if (agent.os.name === "ios" && parseInt(agent.os.version, 10) === 9) {
        _imageWidth = 1024;
      } // ios 8     512 .


      if (agent.os.name === "ios" && parseInt(agent.os.version, 10) === 8) {
        _imageWidth = 512;
      } // maxCubeMapTextureSize  , imageWidth   2     


      return Math.min(maxCubeMapTextureSize, _imageWidth);
    };

    return CubeRenderer;
  }(Renderer_Renderer);

  CubeRenderer._VERTEX_POSITION_DATA = null;
  CubeRenderer._INDEX_DATA = null;
  return CubeRenderer;
}();


// CONCATENATED MODULE: ./src/PanoImageRenderer/renderer/CubeStripRenderer.js
function CubeStripRenderer_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }




var CubeStripRenderer_CubeStripRenderer =
/*#__PURE__*/
function (_Renderer) {
  CubeStripRenderer_inheritsLoose(CubeStripRenderer, _Renderer);

  function CubeStripRenderer() {
    return _Renderer.apply(this, arguments) || this;
  }

  var _proto = CubeStripRenderer.prototype;

  _proto.getVertexShaderSource = function getVertexShaderSource() {
    return "\n\t\t\tattribute vec3 aVertexPosition;\n\t\t\tattribute vec2 aTextureCoord;\n\t\t\tuniform mat4 uMVMatrix;\n\t\t\tuniform mat4 uPMatrix;\n\t\t\tvarying highp vec2 vTextureCoord;\n\t\t\tvoid main(void) {\n\t\t\t\tgl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n\t\t\t\tvTextureCoord = aTextureCoord;\n\t\t\t}";
  };

  _proto.getFragmentShaderSource = function getFragmentShaderSource() {
    return "\n\t\t\t#define PI 3.14159265359\n\n\t\t\tprecision mediump float;\n\t\t\tvarying highp vec2 vTextureCoord;\n\t\t\tuniform sampler2D uSampler;\n\t\t\tuniform bool uIsEAC;\n\n\t\t\tconst vec2 OPERATE_COORDS_RANGE = vec2(-1.0, 1.0);\n\t\t\tconst vec2 TEXTURE_COORDS_RANGE = vec2(0.0, 1.0);\n\t\t\t// vector type is used for initializing values instead of array.\n\t\t\tconst vec4 TEXTURE_DIVISION_X = vec4(0.0, 1.0 / 3.0, 2.0 / 3.0, 1.0);\n\t\t\tconst vec3 TEXTURE_DIVISION_Y = vec3(0.0, 1.0 / 2.0, 1.0);\n\t\t\tconst float EAC_CONST = 2.0 / PI;\n\n\t\t\tfloat scale(vec2 domainRange, vec2 targetRange, float val) {\n\t\t\t\tfloat unit = 1.0 / (domainRange[1] - domainRange[0]);\n\t\t\t\treturn targetRange[0] + (targetRange[1] - targetRange[0]) * (val - domainRange[0]) * unit;\n\t\t\t}\n\n\t\t\tvoid main(void) {\n\t\t\t\tfloat transformedCoordX;\n\t\t\t\tfloat transformedCoordY;\n\n\t\t\t\tif (uIsEAC) {\n\t\t\t\t\tvec2 orgTextureRangeX;\n\t\t\t\t\tvec2 orgTextureRangeY;\n\n\t\t\t\t\t// Apply EAC transform\n\t\t\t\t\tif (vTextureCoord.s >= TEXTURE_DIVISION_X[2]) {\n\t\t\t\t\t\torgTextureRangeX = vec2(TEXTURE_DIVISION_X[2], TEXTURE_DIVISION_X[3]);\n\t\t\t\t\t} else if (vTextureCoord.s >= TEXTURE_DIVISION_X[1]) {\n\t\t\t\t\t\torgTextureRangeX = vec2(TEXTURE_DIVISION_X[1], TEXTURE_DIVISION_X[2]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\torgTextureRangeX = vec2(TEXTURE_DIVISION_X[0], TEXTURE_DIVISION_X[1]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (vTextureCoord.t >= TEXTURE_DIVISION_Y[1]) {\n\t\t\t\t\t\torgTextureRangeY = vec2(TEXTURE_DIVISION_Y[1], TEXTURE_DIVISION_Y[2]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\torgTextureRangeY = vec2(TEXTURE_DIVISION_Y[0], TEXTURE_DIVISION_Y[1]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// scaling coors by the coordinates following the range from -1.0 to 1.0.\n\t\t\t\t\tfloat px = scale(orgTextureRangeX, OPERATE_COORDS_RANGE, vTextureCoord.s);\n\t\t\t\t\tfloat py = scale(orgTextureRangeY, OPERATE_COORDS_RANGE, vTextureCoord.t);\n\n\t\t\t\t\tfloat qu = EAC_CONST * atan(px) + 0.5;\n\t\t\t\t\tfloat qv = EAC_CONST * atan(py) + 0.5;\n\n\t\t\t\t\t// re-scaling coors by original coordinates ranges\n\t\t\t\t\ttransformedCoordX = scale(TEXTURE_COORDS_RANGE, orgTextureRangeX, qu);\n\t\t\t\t\ttransformedCoordY = scale(TEXTURE_COORDS_RANGE, orgTextureRangeY, qv);\n\t\t\t\t} else {\n\t\t\t\t\t// normal cubemap\n\t\t\t\t\ttransformedCoordX = vTextureCoord.s;\n\t\t\t\t\ttransformedCoordY = vTextureCoord.t;\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = texture2D(uSampler, vec2(transformedCoordX, transformedCoordY));\n\t\t\t}";
  };

  _proto.getVertexPositionData = function getVertexPositionData() {
    if (!this._vertices) {
      this._vertices = [// back
      1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, // front
      -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, // up
      -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, // down
      -1, -1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, // right
      1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, -1, // left
      -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1];
    }

    return this._vertices;
  };

  _proto.getIndexData = function getIndexData() {
    var _this = this;

    // TODO:   
    var indices = function () {
      var indexData = [];

      for (var i = 0; i < _this._vertices.length / 3; i += 4) {
        indexData.push(i, i + 1, i + 2, i, i + 2, i + 3);
      }

      return indexData;
    }();

    return indices;
  };

  _proto.getTextureCoordData = function getTextureCoordData(imageConfig) {
    var _this2 = this;

    // TODO: make it cols, rows as config.
    var cols = 3;
    var rows = 2;
    var order = imageConfig.order || "RLUDFB";
    var coords = []; //       row   .

    for (var r = rows - 1; r >= 0; r--) {
      for (var c = 0; c < cols; c++) {
        var coord = [c / cols, r / rows, (c + 1) / cols, r / rows, (c + 1) / cols, (r + 1) / rows, c / cols, (r + 1) / rows];
        coords.push(coord);
      }
    }

    var tileConfigs = this._extractTileConfig(imageConfig); // Transform Coord By Flip & Rotation


    coords = coords // shrink coord to avoid pixel bleeding
    .map(function (coord) {
      return _this2._shrinkCoord(coord);
    }).map(function (coord, i) {
      return _this2._transformCoord(coord, tileConfigs[i]);
    }); // vertices       vertex   BFUDRL  

    return "BFUDRL".split("").map(function (face) {
      return order.indexOf(face);
    }).map(function (index) {
      return coords[index];
    }).reduce(function (acc, val) {
      return acc.concat(val);
    }, []);
  };

  _proto.updateTexture = function updateTexture(gl, image) {
    WebGLUtils_WebGLUtils.texImage2D(gl, gl.TEXTURE_2D, this._getPixelSource(image));
  };

  _proto.bindTexture = function bindTexture(gl, texture, image) {
    // Make sure image isn't too big
    var _this$getDimension = this.getDimension(image),
        width = _this$getDimension.width,
        height = _this$getDimension.height;

    var size = Math.max(width, height);
    var maxSize = WebGLUtils_WebGLUtils.getMaxTextureSize(gl);

    if (size > maxSize) {
      this._triggerError("Image width(" + width + ") exceeds device limit(" + maxSize + "))");

      return;
    } // Pixel Source for IE11 & Video


    this._initPixelSource(image);

    gl.activeTexture(gl.TEXTURE0);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    this.updateTexture(gl, image);
  };

  _proto._transformCoord = function _transformCoord(coord, tileConfig) {
    var newCoord = coord.slice();

    if (tileConfig.flipHorizontal) {
      newCoord = this._flipHorizontalCoord(newCoord);
    }

    if (tileConfig.rotation) {
      newCoord = this._rotateCoord(newCoord, tileConfig.rotation);
    }

    return newCoord;
  };

  _proto._shrinkCoord = function _shrinkCoord(coord) {
    var SHRINK_Y = 0.00;
    var SHRINK_X = 0.00;
    return [coord[0] + SHRINK_X, coord[1] + SHRINK_Y, coord[2] - SHRINK_X, coord[3] + SHRINK_Y, coord[4] - SHRINK_X, coord[5] - SHRINK_Y, coord[6] + SHRINK_X, coord[7] - SHRINK_Y];
  };

  _proto._rotateCoord = function _rotateCoord(coord, rotationAngle) {
    var SIZE = 2; // coord means x,y coordinates. Two values(x, y) makes a one coord.

    var shiftCount = parseInt(rotationAngle / 90, 10) % 4;

    if (shiftCount === 0) {
      return coord;
    }

    var moved;
    var rotatedCoord = [];

    if (shiftCount > 0) {
      moved = coord.splice(0, shiftCount * SIZE);
      rotatedCoord = coord.concat(moved);
    } else {
      moved = coord.splice((4 + shiftCount) * SIZE, -shiftCount * SIZE);
      rotatedCoord = moved.concat(coord);
    }

    return rotatedCoord;
  };

  _proto._flipHorizontalCoord = function _flipHorizontalCoord(coord) {
    return [coord[2], coord[3], coord[0], coord[1], coord[6], coord[7], coord[4], coord[5]];
  };

  return CubeStripRenderer;
}(Renderer_Renderer);


// CONCATENATED MODULE: ./src/PanoImageRenderer/renderer/SphereRenderer.js
function SphereRenderer_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }



var latitudeBands = 60;
var longitudeBands = 60;
var radius = 2;
var ANGLE_CORRECTION_FOR_CENTER_ALIGN = -0.5 * Math.PI;
var SphereRenderer_textureCoordData = [];
var SphereRenderer_vertexPositionData = [];
var SphereRenderer_indexData = [];
var latIdx;
var SphereRenderer_lngIdx;

for (latIdx = 0; latIdx <= latitudeBands; latIdx++) {
  var SphereRenderer_theta = (latIdx / latitudeBands - 0.5) * Math.PI;
  var SphereRenderer_sinTheta = Math.sin(SphereRenderer_theta);
  var SphereRenderer_cosTheta = Math.cos(SphereRenderer_theta);

  for (SphereRenderer_lngIdx = 0; SphereRenderer_lngIdx <= longitudeBands; SphereRenderer_lngIdx++) {
    var phi = (SphereRenderer_lngIdx / longitudeBands - 0.5) * 2 * Math.PI + ANGLE_CORRECTION_FOR_CENTER_ALIGN;
    var sinPhi = Math.sin(phi);
    var cosPhi = Math.cos(phi);
    var SphereRenderer_x = cosPhi * SphereRenderer_cosTheta;
    var SphereRenderer_y = SphereRenderer_sinTheta;
    var SphereRenderer_z = sinPhi * SphereRenderer_cosTheta;
    var SphereRenderer_u = SphereRenderer_lngIdx / longitudeBands;
    var SphereRenderer_v = latIdx / latitudeBands;
    SphereRenderer_textureCoordData.push(SphereRenderer_u, SphereRenderer_v);
    SphereRenderer_vertexPositionData.push(radius * SphereRenderer_x, radius * SphereRenderer_y, radius * SphereRenderer_z);

    if (SphereRenderer_lngIdx !== longitudeBands && latIdx !== latitudeBands) {
      var SphereRenderer_a = latIdx * (longitudeBands + 1) + SphereRenderer_lngIdx;
      var SphereRenderer_b = SphereRenderer_a + longitudeBands + 1;
      SphereRenderer_indexData.push(SphereRenderer_a, SphereRenderer_b, SphereRenderer_a + 1, SphereRenderer_b, SphereRenderer_b + 1, SphereRenderer_a + 1);
    }
  }
}

var SphereRenderer_SphereRenderer =
/*#__PURE__*/
function () {
  var SphereRenderer =
  /*#__PURE__*/
  function (_Renderer) {
    SphereRenderer_inheritsLoose(SphereRenderer, _Renderer);

    function SphereRenderer(config) {
      var _this;

      _this = _Renderer.call(this) || this;
      _this._isStereoscopic = config && config.isStereoscopic || false;
      return _this;
    }

    var _proto = SphereRenderer.prototype;

    _proto.getVertexPositionData = function getVertexPositionData() {
      return SphereRenderer._VERTEX_POSITION_DATA;
    };

    _proto.getIndexData = function getIndexData() {
      return SphereRenderer._INDEX_DATA;
    };

    _proto.getTextureCoordData = function getTextureCoordData() {
      if (this._isStereoscopic) {
        // Use vertical half size of image.
        return SphereRenderer._TEXTURE_COORD_DATA.map(function (value, index) {
          return index % 2 === 1 ? value / 2 : value;
        });
      }

      return SphereRenderer._TEXTURE_COORD_DATA;
    };

    _proto.getVertexShaderSource = function getVertexShaderSource() {
      return "\n\t\t\tattribute vec3 aVertexPosition;\n\t\t\tattribute vec2 aTextureCoord;\n\t\t\tuniform mat4 uMVMatrix;\n\t\t\tuniform mat4 uPMatrix;\n\t\t\tvarying highp vec2 vTextureCoord;\n\t\t\tvoid main(void) {\n\t\t\t\tgl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n\t\t\t\tvTextureCoord = aTextureCoord;\n\t\t\t}";
    };

    _proto.getFragmentShaderSource = function getFragmentShaderSource() {
      return "\n\t\t\tvarying highp vec2 vTextureCoord;\n\t\t\tuniform sampler2D uSampler;\n\t\t\tvoid main(void) {\n\t\t\t\tgl_FragColor = texture2D(\n\t\t\t\t\tuSampler,\n\t\t\t\t\tvec2(vTextureCoord.s, vTextureCoord.t)\n\t\t\t\t);\n\t\t\t}";
    };

    _proto.updateTexture = function updateTexture(gl, image) {
      WebGLUtils_WebGLUtils.texImage2D(gl, gl.TEXTURE_2D, this._getPixelSource(image));
    };

    _proto.bindTexture = function bindTexture(gl, texture, image) {
      // Make sure image isn't too big
      var _this$getDimension = this.getDimension(image),
          width = _this$getDimension.width,
          height = _this$getDimension.height;

      var size = Math.max(width, height);
      var maxSize = WebGLUtils_WebGLUtils.getMaxTextureSize(gl);

      if (size > maxSize) {
        this._triggerError("Image width(" + width + ") exceeds device limit(" + maxSize + "))");

        return;
      } // Pixel Source for IE11 & Video


      this._initPixelSource(image);

      gl.activeTexture(gl.TEXTURE0);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      this.updateTexture(gl, image);
    };

    return SphereRenderer;
  }(Renderer_Renderer);

  SphereRenderer._VERTEX_POSITION_DATA = SphereRenderer_vertexPositionData;
  SphereRenderer._TEXTURE_COORD_DATA = SphereRenderer_textureCoordData;
  SphereRenderer._INDEX_DATA = SphereRenderer_indexData;
  return SphereRenderer;
}();


// CONCATENATED MODULE: ./src/PanoImageRenderer/renderer/CylinderRenderer.js
function CylinderRenderer_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }



 // const latitudeBands = 60;

var MIN_ASPECT_RATIO_FOR_FULL_PANORAMA = 6;
var CylinderRenderer_longitudeBands = 60;
var CylinderRenderer_textureCoordData = [];
var CylinderRenderer_vertexPositionData = [];
var CylinderRenderer_indexData = [];

var CylinderRenderer_CylinderRenderer =
/*#__PURE__*/
function () {
  var CylinderRenderer =
  /*#__PURE__*/
  function (_Renderer) {
    CylinderRenderer_inheritsLoose(CylinderRenderer, _Renderer);

    function CylinderRenderer() {
      return _Renderer.apply(this, arguments) || this;
    }

    var _proto = CylinderRenderer.prototype;

    _proto.getVertexPositionData = function getVertexPositionData() {
      return CylinderRenderer._VERTEX_POSITION_DATA;
    };

    _proto.getIndexData = function getIndexData() {
      return CylinderRenderer._INDEX_DATA;
    };

    _proto.getTextureCoordData = function getTextureCoordData() {
      return CylinderRenderer._TEXTURE_COORD_DATA;
    };

    _proto.getVertexShaderSource = function getVertexShaderSource() {
      return "\n\t\t\tattribute vec3 aVertexPosition;\n\t\t\tattribute vec2 aTextureCoord;\n\t\t\tuniform mat4 uMVMatrix;\n\t\t\tuniform mat4 uPMatrix;\n\t\t\tvarying highp vec2 vTextureCoord;\n\t\t\tvoid main(void) {\n\t\t\t\tgl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n\t\t\t\tvTextureCoord = aTextureCoord;\n\t\t\t}";
    };

    _proto.getFragmentShaderSource = function getFragmentShaderSource() {
      return "\n\t\t\tvarying highp vec2 vTextureCoord;\n\t\t\tuniform sampler2D uSampler;\n\t\t\tvoid main(void) {\n\t\t\t\tgl_FragColor = texture2D(\n\t\t\t\t\tuSampler,\n\t\t\t\t\tvec2(vTextureCoord.s, vTextureCoord.t)\n\t\t\t\t);\n\t\t\t}";
    };

    _proto.updateTexture = function updateTexture(gl, image) {
      WebGLUtils_WebGLUtils.texImage2D(gl, gl.TEXTURE_2D, this._getPixelSource(image));
    };

    _proto.bindTexture = function bindTexture(gl, texture, image) {
      // Make sure image isn't too big
      var _this$getDimension = this.getDimension(image),
          width = _this$getDimension.width,
          height = _this$getDimension.height;

      var size = Math.max(width, height);
      var maxSize = WebGLUtils_WebGLUtils.getMaxTextureSize(gl);
      var resizeDimension;

      if (size > maxSize) {
        this._triggerError("Image width(" + width + ") exceeds device texture limit(" + maxSize + "))"); // Request resizing texture.

        /**
         * TODO: Is it need to apply on another projection type?
         */


        resizeDimension = width > height ? {
          width: maxSize,
          height: maxSize * height / width
        } : {
          width: maxSize * width / height,
          height: maxSize
        };
      } // Pixel Source for IE11 & Video or resizing needed


      this._initPixelSource(image, resizeDimension);

      gl.activeTexture(gl.TEXTURE0);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      this.updateTexture(gl, image);
    };

    _proto.updateShaderData = function updateShaderData(_ref) {
      var _ref$imageAspectRatio = _ref.imageAspectRatio,
          imageAspectRatio = _ref$imageAspectRatio === void 0 ? MIN_ASPECT_RATIO_FOR_FULL_PANORAMA : _ref$imageAspectRatio;
      var lngIdx;
      var cylinderMaxRadian;
      var halfCylinderY;
      var rotated;
      var aspectRatio; // Exception case: orientation is rotated.

      if (imageAspectRatio < 1) {
        /**
         * If rotated is true, we assume that image is rotated counter clockwise.
         * TODO: If there's other rotation, it is need to implement by each rotation.
         */
        rotated = true;
        aspectRatio = 1 / imageAspectRatio;
      } else {
        rotated = false;
        aspectRatio = imageAspectRatio;
      }

      if (aspectRatio >= MIN_ASPECT_RATIO_FOR_FULL_PANORAMA) {
        var fov = 360 / aspectRatio;
        cylinderMaxRadian = 2 * Math.PI; // 360 deg

        halfCylinderY = Math.tan(common.toRadian(fov / 2));
      } else {
        cylinderMaxRadian = aspectRatio;
        halfCylinderY = 0.5; // Range of cylinder is [-0.5, 0.5] to make height to 1.
      } // intialize shader data before update


      CylinderRenderer_textureCoordData.length = 0;
      CylinderRenderer_vertexPositionData.length = 0;
      CylinderRenderer_indexData.length = 0;
      var CYLIDER_Y = [-halfCylinderY, halfCylinderY];
      var startAngleForCenterAlign = Math.PI / 2 + (2 * Math.PI - cylinderMaxRadian) / 2; // Math.PI / 2 start point when cylinderMaxRadian is 2 phi(360)
      // console.log("cylinderMaxRadian:", glMatrix.toDegree(cylinderMaxRadian), "CYLIDER_Y", CYLIDER_Y, "start angle", glMatrix.toDegree(startAngleForCenterAlign));

      for (var yIdx = 0, yLength = CYLIDER_Y.length; yIdx < yLength
      /* bottom & top */
      ; yIdx++) {
        for (lngIdx = 0; lngIdx <= CylinderRenderer_longitudeBands; lngIdx++) {
          var angle = startAngleForCenterAlign + lngIdx / CylinderRenderer_longitudeBands * cylinderMaxRadian;
          var x = Math.cos(angle);
          var y = CYLIDER_Y[yIdx];
          var z = Math.sin(angle);
          var u = void 0;
          var v = void 0;

          if (rotated) {
            // Rotated 90 degree (counter clock wise)
            u = 1 - yIdx; // yLength - yIdx;

            v = lngIdx / CylinderRenderer_longitudeBands;
          } else {
            // 	// Normal case (Not rotated)
            u = lngIdx / CylinderRenderer_longitudeBands;
            v = yIdx;
          }

          CylinderRenderer_textureCoordData.push(u, v);
          CylinderRenderer_vertexPositionData.push(x, y, z);

          if (yIdx === 0 && lngIdx < CylinderRenderer_longitudeBands) {
            var a = lngIdx;
            var b = a + CylinderRenderer_longitudeBands + 1;
            CylinderRenderer_indexData.push(a, b, a + 1, b, b + 1, a + 1);
          }
        }
      }
    };

    return CylinderRenderer;
  }(Renderer_Renderer);

  CylinderRenderer._VERTEX_POSITION_DATA = CylinderRenderer_vertexPositionData;
  CylinderRenderer._TEXTURE_COORD_DATA = CylinderRenderer_textureCoordData;
  CylinderRenderer._INDEX_DATA = CylinderRenderer_indexData;
  return CylinderRenderer;
}();


// CONCATENATED MODULE: ./src/PanoViewer/consts.js
/**
 * Constant value for gyro mode. <br>(Reference {@link https://github.com/naver/egjs-view360/wiki/PanoViewer-3.0-User-Guide})
 * @ko gyro    . <br>({@link https://github.com/naver/egjs-view360/wiki/PanoViewer-3.0-User-Guide} )
 * @namespace
 * @name GYRO_MODE
 * @memberof eg.view360.PanoViewer
 */

/**
 * Disable gyro
 * @ko gyro 
 * @name NONE
 * @memberof eg.view360.PanoViewer.GYRO_MODE
 * @constant
 * @type {String}
 * @default "none"
 */

/**
 * YawPitch Mode
 * @ko YawPitch Mode
 * @name YAWPITCH
 * @memberof eg.view360.PanoViewer.GYRO_MODE
 * @constant
 * @type {String}
 * @default "yawPitch"
 */

/**
 * VR Mode
 * @ko VR Mode
 * @name VR
 * @memberof eg.view360.PanoViewer.GYRO_MODE
 * @constant
 * @type {String}
 * @default "VR"
 */

/**
 * Constant value for errors
 * @ko    
 * @namespace
 * @name ERROR_TYPE
 * @memberof eg.view360.PanoViewer
 */

var ERROR_TYPE = {
  /**
   * Unsupported device
   * @ko  
   * @name INVALID_DEVICE
   * @memberof eg.view360.PanoViewer.ERROR_TYPE
   * @constant
   * @type {Number}
   * @default 10
   */
  INVALID_DEVICE: 10,

  /**
   * Webgl not support
   * @ko WEBGL 
   * @name NO_WEBGL
   * @memberof eg.view360.PanoViewer.ERROR_TYPE
   * @constant
   * @type {Number}
   * @default 11
   */
  NO_WEBGL: 11,

  /**
   * Failed to load image
   * @ko   
   * @name FAIL_IMAGE_LOAD
   * @memberof eg.view360.PanoViewer.ERROR_TYPE
   * @constant
   * @type {Number}
   * @default 12
   */
  FAIL_IMAGE_LOAD: 12,

  /**
   * Failed to bind texture
   * @ko   
   * @name FAIL_BIND_TEXTURE
   * @memberof eg.view360.PanoViewer.ERROR_TYPE
   * @constant
   * @type {Number}
   * @default 13
   */
  FAIL_BIND_TEXTURE: 13,

  /**
   * Only one resource(image or video) should be specified
   * @ko    (image  video    )
   * @name INVALID_RESOURCE
   * @memberof eg.view360.PanoViewer.ERROR_TYPE
   * @constant
   * @type {Number}
   * @default 14
   */
  INVALID_RESOURCE: 14,

  /**
   * WebGL context lost occurred
   * @ko WebGL context lost 
   * @name RENDERING_CONTEXT_LOST
   * @memberof eg.view360.PanoViewer.ERROR_TYPE
   * @constant
   * @type {Number}
   * @default 15
   */
  RENDERING_CONTEXT_LOST: 15
};
/**
 * Constant value for events
 * @ko    
 * @namespace
 * @name EVENTS
 * @memberof eg.view360.PanoViewer
 */

var consts_EVENTS = {
  /**
   * Events that is fired when PanoViewer is ready to show image and handle user interaction.
   * @ko PanoViewer        
   * @name READY
   * @memberof eg.view360.PanoViewer.EVENTS
   * @constant
   * @type {String}
   * @default ready
   */
  READY: "ready",

  /**
   * Events that is fired when direction or fov is changed.
   * @ko PanoViewer     FOV()   
   * @name VIEW_CHANGE
   * @memberof eg.view360.PanoViewer.EVENTS
   * @constant
   * @type {String}
   * @default viewChange
   */
  VIEW_CHANGE: "viewChange",

  /**
   * Events that is fired when animation which is triggered by inertia is ended.
   * @ko       
   * @name ANIMATION_END
   * @memberof eg.view360.PanoViewer.EVENTS
   * @constant
   * @type {String}
   * @default animationEnd
   */
  ANIMATION_END: "animationEnd",

  /**
   * Events that is fired when error occurs
   * @ko     
   * @name ERROR
   * @memberof eg.view360.PanoViewer.EVENTS
   * @constant
   * @type {String}
   * @default error
   */
  ERROR: "error"
};
/**
 * Constant value for projection type
 * @ko     
 * @namespace
 * @name PROJECTION_TYPE
 * @memberof eg.view360.PanoViewer
 */

var PROJECTION_TYPE = {
  /**
   * Constant value for equirectangular type.
   * @ko equirectangular    .
   * @name EQUIRECTANGULAR
   * @memberof eg.view360.PanoViewer.PROJECTION_TYPE
   * @constant
   * @type {String}
   * @default equirectangular
   */
  EQUIRECTANGULAR: "equirectangular",

  /**
   * Constant value for cubemap type.
   * @ko cubemap    .
   * @name CUBEMAP
   * @memberof eg.view360.PanoViewer.PROJECTION_TYPE
   * @constant
   * @type {String}
   * @default cubemap
   */
  CUBEMAP: "cubemap",

  /**
   * Constant value for cubestrip type.
   * Cubestrip is a format for a single image with a combination of six cube faces. It is almost identical to cubemap, but it is implemented in a different way. It aims at better performance and efficiency. In addition, it automatically detects and supports EAC.
   *
   * @ko cubemap    .Cubestrip  cube  6      . cubemap       .      .   EAC   .
   * @name CUBESTRIP
   * @memberof eg.view360.PanoViewer.PROJECTION_TYPE
   * @constant
   * @type {String}
   * @default cubestrip
   */
  CUBESTRIP: "cubestrip",

  /**
   * Constant value for PANORAMA type.
   *
   * PANORAMA is a format for a panorma image which is taken from smartphone.
   *
   * @ko PANORAMA   .       .
   *
   * @name PANORAMA
   * @memberof eg.view360.PanoViewer.PROJECTION_TYPE
   * @constant
   * @type {String}
   * @default panorama
   */
  PANORAMA: "panorama",

  /**
   * Constant value for EQUI_STEREOSCOPY type.
   *
   * Constant value for EQUI_STEREOSCOPY. Stereoscopy image format of EQUIRECTANGULAR. It is an experimental function to show a stereoscopic type equirectangular image on a plane. It does not support stereoscopic viewing function through special visual equipment at present.
   *
   * @ko EQUI_STEREOSCOPY   . EQUIRECTANGULAR  Stereoscopy  . Stereoscopic  equirectangular                .
   *
   * @name STEREOSCOPIC_EQUI
   * @memberof eg.view360.PanoViewer.PROJECTION_TYPE
   * @constant
   * @type {String}
   * @default stereoequi
   */
  STEREOSCOPIC_EQUI: "stereoequi"
};

// CONCATENATED MODULE: ./src/PanoImageRenderer/PanoImageRenderer.js
function PanoImageRenderer_extends() { PanoImageRenderer_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return PanoImageRenderer_extends.apply(this, arguments); }

function PanoImageRenderer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function PanoImageRenderer_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }



var PanoImageRenderer_Promise = typeof Promise === 'undefined' ? es6_promise_default.a.Promise : Promise;













var ImageType = PROJECTION_TYPE;
var DEVICE_PIXEL_RATIO = browserFeature["devicePixelRatio"] || 1; // DEVICE_PIXEL_RATIO  2     2 .

if (DEVICE_PIXEL_RATIO > 2) {
  DEVICE_PIXEL_RATIO = 2;
} // define custom events name

/**
 * TODO: how to manage events/errortype with PanoViewer
 *
 * I think renderer events should be seperated from viewer events although it has same name.
 */


var PanoImageRenderer_EVENTS = {
  BIND_TEXTURE: "bindTexture",
  IMAGE_LOADED: "imageLoaded",
  ERROR: "error",
  RENDERING_CONTEXT_LOST: "renderingContextLost",
  RENDERING_CONTEXT_RESTORE: "renderingContextRestore"
};
var PanoImageRenderer_ERROR_TYPE = {
  INVALID_DEVICE: 10,
  NO_WEBGL: 11,
  FAIL_IMAGE_LOAD: 12,
  RENDERER_ERROR: 13
};

var PanoImageRenderer_PanoImageRenderer =
/*#__PURE__*/
function () {
  var PanoImageRenderer =
  /*#__PURE__*/
  function (_Component) {
    PanoImageRenderer_inheritsLoose(PanoImageRenderer, _Component);

    function PanoImageRenderer(image, width, height, isVideo, sphericalConfig, renderingContextAttributes) {
      var _this;

      // Super constructor
      _this = _Component.call(this) || this;
      _this.sphericalConfig = sphericalConfig;
      _this.fieldOfView = sphericalConfig.fieldOfView;
      _this.width = width;
      _this.height = height;
      _this._lastQuaternion = null;
      _this._lastYaw = null;
      _this._lastPitch = null;
      _this._lastFieldOfView = null;
      _this.pMatrix = mathUtil_mat4.create();
      _this.mvMatrix = mathUtil_mat4.create(); // initialzie pMatrix

      mathUtil_mat4.perspective(_this.pMatrix, common.toRadian(_this.fieldOfView), width / height, 0.1, 100);
      _this.textureCoordBuffer = null;
      _this.vertexBuffer = null;
      _this.indexBuffer = null;
      _this.canvas = _this._initCanvas(width, height);
      _this._renderingContextAttributes = renderingContextAttributes;
      _this._image = null;
      _this._imageConfig = null;
      _this._imageIsReady = false;
      _this._shouldForceDraw = false;
      _this._keepUpdate = false; // Flag to specify 'continuous update' on video even when still.

      _this._onContentLoad = _this._onContentLoad.bind(PanoImageRenderer_assertThisInitialized(_this));
      _this._onContentError = _this._onContentError.bind(PanoImageRenderer_assertThisInitialized(_this));

      if (image) {
        _this.setImage({
          image: image,
          imageType: sphericalConfig.imageType,
          isVideo: isVideo,
          cubemapConfig: sphericalConfig.cubemapConfig
        });
      }

      return _this;
    }

    var _proto = PanoImageRenderer.prototype;

    _proto.getContent = function getContent() {
      return this._image;
    };

    _proto.setImage = function setImage(_ref) {
      var image = _ref.image,
          imageType = _ref.imageType,
          _ref$isVideo = _ref.isVideo,
          isVideo = _ref$isVideo === void 0 ? false : _ref$isVideo,
          cubemapConfig = _ref.cubemapConfig;
      this._imageIsReady = false;
      this._isVideo = isVideo;
      this._imageConfig = PanoImageRenderer_extends({
        /* RLUDBF is abnormal, we use it on CUBEMAP only */
        order: imageType === ImageType.CUBEMAP ? "RLUDBF" : "RLUDFB",
        tileConfig: {
          flipHirozontal: false,
          rotation: 0
        }
      }, cubemapConfig);

      this._setImageType(imageType);

      if (this._contentLoader) {
        this._contentLoader.destroy();
      }

      if (isVideo) {
        this._contentLoader = new VideoLoader();
        this._keepUpdate = true;
      } else {
        this._contentLoader = new ImageLoader_ImageLoader();
        this._keepUpdate = false;
      } // img element or img url


      this._contentLoader.set(image); //   .
      // image is reference for content in contentLoader, so it may be not valid if contentLoader is destroyed.


      this._image = this._contentLoader.getElement();
      return this._contentLoader.get().then(this._onContentLoad, this._onContentError)["catch"](function (e) {
        return setTimeout(function () {
          throw e;
        });
      }); // Prevent exceptions from being isolated in promise chain.
    };

    _proto._setImageType = function _setImageType(imageType) {
      var _this2 = this;

      if (!imageType || this._imageType === imageType) {
        return;
      }

      this._imageType = imageType;
      this._isCubeMap = imageType === ImageType.CUBEMAP;

      if (this._renderer) {
        this._renderer.off();
      }

      switch (imageType) {
        case ImageType.CUBEMAP:
          this._renderer = new CubeRenderer_CubeRenderer();
          break;

        case ImageType.CUBESTRIP:
          this._renderer = new CubeStripRenderer_CubeStripRenderer();
          break;

        case ImageType.PANORAMA:
          this._renderer = new CylinderRenderer_CylinderRenderer();
          break;

        case ImageType.STEREOSCOPIC_EQUI:
          this._renderer = new SphereRenderer_SphereRenderer({
            isStereoscopic: true
          });
          break;

        default:
          this._renderer = new SphereRenderer_SphereRenderer();
          break;
      }

      this._renderer.on(Renderer_Renderer.EVENTS.ERROR, function (e) {
        _this2.trigger(PanoImageRenderer_EVENTS.ERROR, {
          type: PanoImageRenderer_ERROR_TYPE.RENDERER_ERROR,
          message: e.message
        });
      });

      this._initWebGL();
    };

    _proto._initCanvas = function _initCanvas(width, height) {
      var canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      canvas.style.bottom = 0;
      canvas.style.left = 0;
      canvas.style.right = 0;
      canvas.style.top = 0;
      canvas.style.margin = "auto";
      canvas.style.maxHeight = "100%";
      canvas.style.maxWidth = "100%";
      canvas.style.outline = "none";
      canvas.style.position = "absolute";
      this._onWebglcontextlost = this._onWebglcontextlost.bind(this);
      this._onWebglcontextrestored = this._onWebglcontextrestored.bind(this);
      canvas.addEventListener("webglcontextlost", this._onWebglcontextlost);
      canvas.addEventListener("webglcontextrestored", this._onWebglcontextrestored);
      return canvas;
    };

    _proto._onContentError = function _onContentError(error) {
      this._imageIsReady = false;
      this._image = null;
      this.trigger(PanoImageRenderer_EVENTS.ERROR, {
        type: PanoImageRenderer_ERROR_TYPE.FAIL_IMAGE_LOAD,
        message: "failed to load image"
      });
      return false;
    };

    _proto._triggerContentLoad = function _triggerContentLoad() {
      this.trigger(PanoImageRenderer_EVENTS.IMAGE_LOADED, {
        content: this._image,
        isVideo: this._isVideo,
        projectionType: this._imageType
      });
    };

    _proto._onContentLoad = function _onContentLoad(image) {
      this._imageIsReady = true;

      this._triggerContentLoad();

      return true;
    };

    _proto.isImageLoaded = function isImageLoaded() {
      return !!this._image && this._imageIsReady && (!this._isVideo || this._image.readyState >= 2
      /* HAVE_CURRENT_DATA */
      );
    };

    _proto.bindTexture = function bindTexture() {
      var _this3 = this;

      return new PanoImageRenderer_Promise(function (res, rej) {
        if (!_this3._contentLoader) {
          rej("ImageLoader is not initialized");
          return;
        }

        _this3._contentLoader.get().then(function () {
          return _this3._bindTexture();
        }, rej).then(res);
      });
    } //   canvas  
    ;

    _proto.attachTo = function attachTo(parentElement) {
      this.detach();
      parentElement.appendChild(this.canvas);
    };

    _proto.forceContextLoss = function forceContextLoss() {
      if (this.hasRenderingContext()) {
        var loseContextExtension = this.context.getExtension("WEBGL_lose_context");

        if (loseContextExtension) {
          loseContextExtension.loseContext();
        }
      }
    } //   canvas  
    ;

    _proto.detach = function detach() {
      if (this.canvas.parentElement) {
        this.canvas.parentElement.removeChild(this.canvas);
      }
    };

    _proto.destroy = function destroy() {
      if (this._contentLoader) {
        this._contentLoader.destroy();
      }

      this.detach();
      this.forceContextLoss();
      this.off();
      this.canvas.removeEventListener("webglcontextlost", this._onWebglcontextlost);
      this.canvas.removeEventListener("webglcontextrestored", this._onWebglcontextrestored);
    };

    _proto.hasRenderingContext = function hasRenderingContext() {
      if (!(this.context && !this.context.isContextLost())) {
        return false;
      } else if (this.context && !this.context.getProgramParameter(this.shaderProgram, this.context.LINK_STATUS)) {
        return false;
      }

      return true;
    };

    _proto._onWebglcontextlost = function _onWebglcontextlost(e) {
      e.preventDefault();
      this.trigger(PanoImageRenderer_EVENTS.RENDERING_CONTEXT_LOST);
    };

    _proto._onWebglcontextrestored = function _onWebglcontextrestored(e) {
      this._initWebGL();

      this.trigger(PanoImageRenderer_EVENTS.RENDERING_CONTEXT_RESTORE);
    };

    _proto.updateFieldOfView = function updateFieldOfView(fieldOfView) {
      this.fieldOfView = fieldOfView;

      this._updateViewport();
    };

    _proto.updateViewportDimensions = function updateViewportDimensions(width, height) {
      var viewPortChanged = false;
      this.width = width;
      this.height = height;
      var w = width * DEVICE_PIXEL_RATIO;
      var h = height * DEVICE_PIXEL_RATIO;

      if (w !== this.canvas.width) {
        this.canvas.width = w;
        viewPortChanged = true;
      }

      if (h !== this.canvas.height) {
        this.canvas.height = h;
        viewPortChanged = true;
      }

      if (!viewPortChanged) {
        return;
      }

      this._updateViewport();

      this._shouldForceDraw = true;
    };

    _proto._updateViewport = function _updateViewport() {
      mathUtil_mat4.perspective(this.pMatrix, common.toRadian(this.fieldOfView), this.canvas.width / this.canvas.height, 0.1, 100);
      this.context.viewport(0, 0, this.context.drawingBufferWidth, this.context.drawingBufferHeight);
    };

    _proto._initWebGL = function _initWebGL() {
      var gl; // TODO: Following code does need to be executed only if width/height, cubicStrip property is changed.

      try {
        this._initRenderingContext();

        gl = this.context;
        this.updateViewportDimensions(this.width, this.height);

        if (this.shaderProgram) {
          gl.deleteProgram(this.shaderProgram);
        }

        this.shaderProgram = this._initShaderProgram(gl);

        if (!this.shaderProgram) {
          throw new Error("Failed to intialize shaders: " + WebGLUtils_WebGLUtils.getErrorNameFromWebGLErrorCode(gl.getError()));
        }
      } catch (e) {
        this.trigger(PanoImageRenderer_EVENTS.ERROR, {
          type: PanoImageRenderer_ERROR_TYPE.NO_WEBGL,
          message: "no webgl support"
        });
        this.destroy();
        console.error(e); // eslint-disable-line no-console

        return;
      } //   .


      gl.clearColor(0, 0, 0, 0);
      var textureTarget = this._isCubeMap ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;

      if (this.texture) {
        gl.deleteTexture(this.texture);
      }

      this.texture = WebGLUtils_WebGLUtils.createTexture(gl, textureTarget);

      if (this._imageType === ImageType.CUBESTRIP) {
        // TODO: Apply following options on other projection type.
        gl.enable(gl.CULL_FACE); // gl.enable(gl.DEPTH_TEST);
      }
    };

    _proto._initRenderingContext = function _initRenderingContext() {
      if (this.hasRenderingContext()) {
        return;
      }

      if (!window.WebGLRenderingContext) {
        throw new Error("WebGLRenderingContext not available.");
      }

      this.context = WebGLUtils_WebGLUtils.getWebglContext(this.canvas, this._renderingContextAttributes);

      if (!this.context) {
        throw new Error("Failed to acquire 3D rendering context");
      }
    };

    _proto._initShaderProgram = function _initShaderProgram(gl) {
      var vertexShaderSource = this._renderer.getVertexShaderSource();

      var vertexShader = WebGLUtils_WebGLUtils.createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);

      if (!vertexShader) {
        return false;
      }

      var fragmentShaderSource = this._renderer.getFragmentShaderSource();

      var fragmentShader = WebGLUtils_WebGLUtils.createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

      if (!fragmentShader) {
        return false;
      }

      var shaderProgram = WebGLUtils_WebGLUtils.createProgram(gl, vertexShader, fragmentShader);

      if (!shaderProgram) {
        return null;
      }

      gl.useProgram(shaderProgram);
      shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
      gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
      shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
      shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
      shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
      shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
      gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute); // clear buffer

      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT); // Use TEXTURE0

      gl.uniform1i(shaderProgram.samplerUniform, 0);
      return shaderProgram;
    };

    _proto._initBuffers = function _initBuffers() {
      var vertexPositionData = this._renderer.getVertexPositionData();

      var indexData = this._renderer.getIndexData();

      var textureCoordData = this._renderer.getTextureCoordData(this._imageConfig);

      var gl = this.context;
      this.vertexBuffer = WebGLUtils_WebGLUtils.initBuffer(gl, gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), 3, this.shaderProgram.vertexPositionAttribute);
      this.indexBuffer = WebGLUtils_WebGLUtils.initBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), 1);
      this.textureCoordBuffer = WebGLUtils_WebGLUtils.initBuffer(gl, gl.ARRAY_BUFFER, new Float32Array(textureCoordData), this._isCubeMap ? 3 : 2, this.shaderProgram.textureCoordAttribute);
    };

    _proto._bindTexture = function _bindTexture() {
      // Detect if it is EAC Format while CUBESTRIP mode.
      // We assume it is EAC if image is not 3/2 ratio.
      if (this._imageType === ImageType.CUBESTRIP) {
        var _this$_renderer$getDi = this._renderer.getDimension(this._image),
            width = _this$_renderer$getDi.width,
            height = _this$_renderer$getDi.height;

        var isEAC = width && height && width / height !== 1.5;
        this.context.uniform1f(this.context.getUniformLocation(this.shaderProgram, "uIsEAC"), isEAC);
      } else if (this._imageType === ImageType.PANORAMA) {
        var _this$_renderer$getDi2 = this._renderer.getDimension(this._image),
            _width = _this$_renderer$getDi2.width,
            _height = _this$_renderer$getDi2.height;

        var imageAspectRatio = _width && _height && _width / _height;

        this._renderer.updateShaderData({
          imageAspectRatio: imageAspectRatio
        });
      } // intialize shader buffers after image is loaded.(by updateShaderData)
      // because buffer may be differ by image size.(eg. CylinderRenderer)


      this._initBuffers();

      this._renderer.bindTexture(this.context, this.texture, this._image, this._imageConfig);

      this._shouldForceDraw = true;
      this.trigger(PanoImageRenderer_EVENTS.BIND_TEXTURE);
    };

    _proto._updateTexture = function _updateTexture() {
      this._renderer.updateTexture(this.context, this._image, this._imageConfig);
    };

    _proto.keepUpdate = function keepUpdate(doUpdate) {
      if (doUpdate && this.isImageLoaded() === false) {
        // Force to draw a frame after image is loaded on render()
        this._shouldForceDraw = true;
      }

      this._keepUpdate = doUpdate;
    };

    _proto.renderWithQuaternion = function renderWithQuaternion(quaternion, fieldOfView) {
      if (!this.isImageLoaded()) {
        return;
      }

      if (this._keepUpdate === false && this._lastQuaternion && mathUtil_quat.exactEquals(this._lastQuaternion, quaternion) && this.fieldOfView && this.fieldOfView === fieldOfView && this._shouldForceDraw === false) {
        return;
      } // updatefieldOfView only if fieldOfView is changed.


      if (fieldOfView !== undefined && fieldOfView !== this.fieldOfView) {
        this.updateFieldOfView(fieldOfView);
      }

      this.mvMatrix = mathUtil_mat4.fromQuat(mathUtil_mat4.create(), quaternion);

      this._draw();

      this._lastQuaternion = mathUtil_quat.clone(quaternion);

      if (this._shouldForceDraw) {
        this._shouldForceDraw = false;
      }
    };

    _proto.render = function render(yaw, pitch, fieldOfView) {
      if (!this.isImageLoaded()) {
        return;
      }

      if (this._keepUpdate === false && this._lastYaw !== null && this._lastYaw === yaw && this._lastPitch !== null && this._lastPitch === pitch && this.fieldOfView && this.fieldOfView === fieldOfView && this._shouldForceDraw === false) {
        return;
      } // fieldOfView        


      if (fieldOfView !== undefined && fieldOfView !== this.fieldOfView) {
        this.updateFieldOfView(fieldOfView);
      }

      mathUtil_mat4.identity(this.mvMatrix);
      mathUtil_mat4.rotateX(this.mvMatrix, this.mvMatrix, -common.toRadian(pitch));
      mathUtil_mat4.rotateY(this.mvMatrix, this.mvMatrix, -common.toRadian(yaw));

      this._draw();

      this._lastYaw = yaw;
      this._lastPitch = pitch;

      if (this._shouldForceDraw) {
        this._shouldForceDraw = false;
      }
    };

    _proto._draw = function _draw() {
      var gl = this.context;
      gl.uniformMatrix4fv(this.shaderProgram.pMatrixUniform, false, this.pMatrix);
      gl.uniformMatrix4fv(this.shaderProgram.mvMatrixUniform, false, this.mvMatrix);

      if (this._isVideo && this._keepUpdate) {
        this._updateTexture();
      }

      if (this.indexBuffer) {
        gl.drawElements(gl.TRIANGLES, this.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
      }
    }
    /**
     * Returns projection renderer by each type
     */
    ;

    _proto.getProjectionRenderer = function getProjectionRenderer() {
      return this._renderer;
    };

    return PanoImageRenderer;
  }(component_root_eg_Component_default.a);

  PanoImageRenderer.EVENTS = PanoImageRenderer_EVENTS;
  PanoImageRenderer.ERROR_TYPE = PanoImageRenderer_ERROR_TYPE;
  return PanoImageRenderer;
}();


// CONCATENATED MODULE: ./src/PanoViewer/PanoViewer.js
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PanoViewer_PanoViewer; });
function PanoViewer_extends() { PanoViewer_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return PanoViewer_extends.apply(this, arguments); }

function PanoViewer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function PanoViewer_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }



var PanoViewer_Promise = typeof Promise === 'undefined' ? es6_promise_default.a.Promise : Promise;











var PanoViewer_PanoViewer =
/*#__PURE__*/
function () {
  var PanoViewer =
  /*#__PURE__*/
  function (_Component) {
    PanoViewer_inheritsLoose(PanoViewer, _Component);

    /**
     * Version info string
     * @ko  
     * @name VERSION
     * @static
     * @type {String}
     * @example
     * eg.view360.PanoViewer.VERSION;  // ex) 3.0.1
     * @memberof eg.view360.PanoViewer
     */
    // It should be deprecated!

    /**
     * Constant value for touch directions
     * @ko     .
     * @namespace
     * @name TOUCH_DIRECTION
     * @memberof eg.view360.PanoViewer
     */

    /**
     * @classdesc 360 media viewer
     * @ko 360  
     * @class
     * @name eg.view360.PanoViewer
     * @extends eg.Component
     *
     * @param {HTMLElement} container The container element for the renderer. <ko>  </ko>
     * @param {Object} config
     *
     * @param {String|Image} config.image Input image url or element (Use only image property or video property)<ko>  URL  (image  video    )</ko>
     * @param {String|HTMLVideoElement} config.video Input video url or element(Use only image property or video property)<ko>  URL  (image  video    )</ko>
     * @param {String} [config.projectionType=equirectangular] The type of projection: equirectangular, cubemap <br/>{@link eg.view360.PanoViewer.PROJECTION_TYPE}<ko>Projection  : equirectangular, cubemap <br/>{@link eg.view360.PanoViewer.PROJECTION_TYPE}</ko>
     * @param {Object} config.cubemapConfig config cubemap projection layout. It is applied when projectionType is {@link eg.view360.PanoViewer.PROJECTION_TYPE.CUBEMAP} or {@link eg.view360.PanoViewer.PROJECTION_TYPE.CUBESTRIP}<ko>cubemap projection type   .   ProjectionType  {@link eg.view360.PanoViewer.PROJECTION_TYPE.CUBEMAP}  {@link eg.view360.PanoViewer.PROJECTION_TYPE.CUBESTRIP}   .</ko>
     * @param {Object} [config.cubemapConfig.order = "RLUDBF"(ProjectionType === CUBEMAP) | "RLUDFB" (ProjectionType === CUBESTRIP)] Order of cubemap faces <ko>Cubemap    </ko>
     * @param {Object} [config.cubemapConfig.tileConfig = {flipHirozontal:false, rotation: 0}] Setting about rotation angle(degree) and whether to flip horizontal for each cubemap faces, if you put this object as a array, you can set each faces with different setting. For example, [{flipHorizontal:false, rotation:90}, {flipHorizontal: true, rotation: 180}, ...]<ko> Cubemap    /  ,            .   [{flipHorizontal:false, rotation:90}, {flipHorizontal: true, rotation: 180}, ...]    .</ko>
     * @param {Number} [config.width=width of container] the viewer's width. (in px) <ko>  (px )</ko>
     * @param {Number} [config.height=height of container] the viewer's height.(in px) <ko>  (px )</ko>
     *
     * @param {Number} [config.yaw=0] Initial Yaw of camera (in degree) <ko>  Yaw (degree )</ko>
     * @param {Number} [config.pitch=0] Initial Pitch of camera (in degree) <ko>  Pitch (degree )</ko>
     * @param {Number} [config.fov=65] Initial vertical field of view of camera (in degree) <ko>   field of view (degree )</ko>
     * @param {Boolean} [config.showPolePoint=false] If false, the pole is not displayed inside the viewport <ko>false  ,     </ko>
     * @param {Boolean} [config.useZoom=true] When true, enables zoom with the wheel and Pinch gesture <ko>true        /    .</ko>
     * @param {Boolean} [config.useKeyboard=true] When true, enables the keyboard move key control: awsd, arrow keys <ko>true      : awsd,  </ko>
     * @param {String} [config.gyroMode=yawPitch] Enables control through device motion. ("none", "yawPitch", "VR") <br/>{@link eg.view360.PanoViewer.GYRO_MODE} <ko>     . ("none", "yawPitch", "VR") <br/>{@link eg.view360.PanoViewer.GYRO_MODE} </ko>
     * @param {Array} [config.yawRange=[-180, 180]] Range of controllable Yaw values <ko>  Yaw  </ko>
     * @param {Array} [config.pitchRange=[-90, 90]] Range of controllable Pitch values <ko>  Pitch  </ko>
     * @param {Array} [config.fovRange=[30, 110]] Range of controllable vertical field of view values <ko>   field of view  </ko>
     * @param {Number} [config.touchDirection= {@link eg.view360.PanoViewer.TOUCH_DIRECTION.ALL}(6)] Direction of touch that can be controlled by user <br/>{@link eg.view360.PanoViewer.TOUCH_DIRECTION}<ko>     <br/>{@link eg.view360.PanoViewer.TOUCH_DIRECTION}</ko>
     *
     * @example
     * // PanoViewer Creation
     * // create PanoViewer with option
     * var PanoViewer = eg.view360.PanoViewer;
     * // Area where the image will be displayed(HTMLElement)
     * var container = document.getElementById("myPanoViewer");
     *
     * var panoViewer = new PanoViewer(container, {
     *     // If projectionType is not specified, the default is "equirectangular".
     *     // Specifies an image of the "equirectangular" type.
     *     image: "/path/to/image/image.jpg"
     *});
     *
     * @example
     * // Cubemap Config Setting Example
     * // For support Youtube EAC projection, You should set cubemapConfig as follows.
     * cubemapConfig: {
     * 	order: "LFRDBU",
     * 	tileConfig: [
     * 		tileConfig: [{rotation: 0}, {rotation: 0}, {rotation: 0}, {rotation: 0}, {rotation: -90}, {rotation: 180}]
     * 	]
     * }
     */
    function PanoViewer(container, options) {
      var _this;

      if (options === void 0) {
        options = {};
      }

      _this = _Component.call(this) || this; // Raises the error event if webgl is not supported.

      if (!WebGLUtils_WebGLUtils.isWebGLAvailable()) {
        setTimeout(function () {
          _this.trigger(consts_EVENTS.ERROR, {
            type: ERROR_TYPE.NO_WEBGL,
            message: "no webgl support"
          });
        }, 0);
        return PanoViewer_assertThisInitialized(_this) || PanoViewer_assertThisInitialized(_this);
      }

      if (!WebGLUtils_WebGLUtils.isStableWebGL()) {
        setTimeout(function () {
          _this.trigger(consts_EVENTS.ERROR, {
            type: ERROR_TYPE.INVALID_DEVICE,
            message: "blacklisted browser"
          });
        }, 0);
        return PanoViewer_assertThisInitialized(_this) || PanoViewer_assertThisInitialized(_this);
      }

      if (!!options.image && !!options.video) {
        setTimeout(function () {
          _this.trigger(consts_EVENTS.ERROR, {
            type: ERROR_TYPE.INVALID_RESOURCE,
            message: "Specifying multi resouces(both image and video) is not valid."
          });
        }, 0);
        return PanoViewer_assertThisInitialized(_this) || PanoViewer_assertThisInitialized(_this);
      }

      _this._container = container;
      _this._image = options.image || options.video;
      _this._isVideo = !!options.video;
      _this._projectionType = options.projectionType || PROJECTION_TYPE.EQUIRECTANGULAR;
      _this._cubemapConfig = PanoViewer_extends({
        /* RLUDBF is abnormal, we use it on CUBEMAP only for backward compatibility*/
        order: _this._projectionType === PROJECTION_TYPE.CUBEMAP ? "RLUDBF" : "RLUDFB",
        tileConfig: {
          flipHirozontal: false,
          rotation: 0
        }
      }, options.cubemapConfig); // If the width and height are not provided, will use the size of the container.

      _this._width = options.width || parseInt(window.getComputedStyle(container).width, 10);
      _this._height = options.height || parseInt(window.getComputedStyle(container).height, 10);
      /**
       * Cache the direction for the performance in renderLoop
       *
       * This value should be updated by "change" event of YawPitchControl.
       */

      _this._yaw = options.yaw || 0;
      _this._pitch = options.pitch || 0;
      _this._fov = options.fov || 65;
      _this._gyroMode = options.gyroMode || GYRO_MODE.YAWPITCH;
      _this._quaternion = null;
      _this._aspectRatio = _this._height !== 0 ? _this._width / _this._height : 1;
      var fovRange = options.fovRange || [30, 110];
      var touchDirection = PanoViewer._isValidTouchDirection(options.touchDirection) ? options.touchDirection : YawPitchControl_YawPitchControl.TOUCH_DIRECTION_ALL;

      var yawPitchConfig = PanoViewer_extends(options, {
        element: container,
        yaw: _this._yaw,
        pitch: _this._pitch,
        fov: _this._fov,
        gyroMode: _this._gyroMode,
        fovRange: fovRange,
        aspectRatio: _this._aspectRatio,
        touchDirection: touchDirection
      });

      _this._isReady = false;

      _this._initYawPitchControl(yawPitchConfig);

      _this._initRenderer(_this._yaw, _this._pitch, _this._fov, _this._projectionType, _this._cubemapConfig);

      return _this;
    }
    /**
    	* Get the video element that the viewer is currently playing. You can use this for playback.
    	* @ko       .        .
    	* @method eg.view360.PanoViewer#getVideo
    	* @return {HTMLVideoElement} HTMLVideoElement<ko>HTMLVideoElement</ko>
    	* @example
    	* var videoTag = panoViewer.getVideo();
    	* videoTag.play(); // play video!
    	*/


    var _proto = PanoViewer.prototype;

    _proto.getVideo = function getVideo() {
      if (!this._isVideo) {
        return null;
      }

      return this._photoSphereRenderer.getContent();
    }
    /**
     * Set the video information to be used by the viewer.
     * @ko     .
     * @method eg.view360.PanoViewer#setVideo
     * @param {String|HTMLVideoElement|Object} video Input video url or element or config object<ko>  URL     (image  video    )</ko>
     * @param {Object} param
     * @param {String} [param.projectionType={@link eg.view360.PanoViewer.PROJECTION_TYPE.EQUIRECTANGULAR}("equirectangular")] Projection Type<ko> </ko>
     * @param {Object} param.cubemapConfig config cubemap projection layout. <ko>cubemap projection type   </ko>
     *
     * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer </ko>
     * @example
     * panoViewer.setVideo("/path/to/video/video.mp4", {
     *     projectionType: eg.view360.PanoViewer.PROJECTION_TYPE.EQUIRECTANGULAR
     * });
     */
    ;

    _proto.setVideo = function setVideo(video, param) {
      if (param === void 0) {
        param = {};
      }

      if (video) {
        this.setImage(video, {
          projectionType: param.projectionType,
          isVideo: true,
          cubemapConfig: param.cubemapConfig
        });
      }

      return this;
    }
    /**
     * Get the image information that the viewer is currently using.
     * @ko      .
     * @method eg.view360.PanoViewer#getImage
     * @return {Image} Image Object<ko> </ko>
     * @example
     * var imageObj = panoViewer.getImage();
     */
    ;

    _proto.getImage = function getImage() {
      if (this._isVideo) {
        return null;
      }

      return this._photoSphereRenderer.getContent();
    }
    /**
     * Set the image information to be used by the viewer.
     * @ko     .
     * @method eg.view360.PanoViewer#setImage
     * @param {String|Image|Object} image Input image url or element or config object<ko>  URL     (image  video    .)</ko>
     * @param {Object} param Additional information<ko>  </ko>
     * @param {String} [param.projectionType="equirectangular"] Projection Type<ko> </ko>
     * @param {Object} param.cubemapConfig config cubemap projection layout. <ko>cubemap projection type </ko>
     *
     * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer </ko>
     * @example
     * panoViewer.setImage("/path/to/image/image.png", {
     *     projectionType: eg.view360.PanoViewer.PROJECTION_TYPE.CUBEMAP
     * });
     */
    ;

    _proto.setImage = function setImage(image, param) {
      if (param === void 0) {
        param = {};
      }

      var cubemapConfig = PanoViewer_extends({
        order: "RLUDBF",
        tileConfig: {
          flipHirozontal: false,
          rotation: 0
        }
      }, param.cubemapConfig);

      var isVideo = !!param.isVideo;

      if (this._image && this._isVideo !== isVideo) {
        /* eslint-disable no-console */
        console.warn("Currently not supporting to change content type(Image <--> Video)");
        /* eslint-enable no-console */

        return this;
      }

      if (image) {
        this._image = image;
        this._isVideo = isVideo;
        this._projectionType = param.projectionType || PROJECTION_TYPE.EQUIRECTANGULAR;
        this._cubemapConfig = cubemapConfig;

        this._deactivate();

        this._initRenderer(this._yaw, this._pitch, this._fov, this._projectionType, this._cubemapConfig);
      }

      return this;
    }
    /**
     * Set whether the renderer always updates the texture and renders.
     * @ko           .
     *
     * @method eg.view360.PanoViewer#keepUpdate
     * @param {Boolean} doUpdate When true viewer will always update texture and render, when false viewer will not update texture and render only camera config is changed.<ko>true      , false    ,       .</ko>
     * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer </ko>
     */
    ;

    _proto.keepUpdate = function keepUpdate(doUpdate) {
      this._photoSphereRenderer.keepUpdate(doUpdate);

      return this;
    }
    /**
     * Get projection type (equirectangular/cube)
     * @ko  (Equirectangular  Cube) .
     *
     * @method eg.view360.PanoViewer#getProjectionType
     * @return {String} {@link eg.view360.PanoViewer.PROJECTION_TYPE}
     */
    ;

    _proto.getProjectionType = function getProjectionType() {
      return this._projectionType;
    };

    _proto._initRenderer = function _initRenderer(yaw, pitch, fov, projectionType, cubemapConfig) {
      var _this2 = this;

      this._photoSphereRenderer = new PanoImageRenderer_PanoImageRenderer(this._image, this._width, this._height, this._isVideo, {
        initialYaw: yaw,
        initialPitch: pitch,
        fieldOfView: fov,
        imageType: projectionType,
        cubemapConfig: cubemapConfig
      });

      this._bindRendererHandler();

      this._photoSphereRenderer.bindTexture().then(function () {
        return _this2._activate();
      })["catch"](function () {
        _this2._triggerEvent(consts_EVENTS.ERROR, {
          type: ERROR_TYPE.FAIL_BIND_TEXTURE,
          message: "failed to bind texture"
        });
      });
    }
    /**
     * update values of YawPitchControl if needed.
     * For example, In Panorama mode, initial fov and pitchRange is changed by aspect ratio of image.
     *
     * This function should be called after isReady status is true.
     */
    ;

    _proto._updateYawPitchIfNeeded = function _updateYawPitchIfNeeded() {
      if (this._projectionType === PanoViewer.ProjectionType.PANORAMA) {
        // update fov by aspect ratio
        var image = this._photoSphereRenderer.getContent();

        var imageAspectRatio = image.naturalWidth / image.naturalHeight;
        var isCircular;
        var yawSize;
        var maxFov; // If height is larger than width, then we assume it's rotated by 90 degree.

        if (imageAspectRatio < 1) {
          // So inverse the aspect ratio.
          imageAspectRatio = 1 / imageAspectRatio;
        }

        if (imageAspectRatio < 6) {
          yawSize = common.toDegree(imageAspectRatio);
          isCircular = false; // 0.5 means ratio of half height of cylinder(0.5) and radius of cylider(1). 0.5/1 = 0.5

          maxFov = common.toDegree(Math.atan(0.5)) * 2;
        } else {
          yawSize = 360;
          isCircular = true;
          maxFov = 360 / imageAspectRatio; // Make it 5 fixed as axes does.
        } // console.log("_updateYawPitchIfNeeded", maxFov, "aspectRatio", image.naturalWidth, image.naturalHeight, "yawSize", yawSize);


        var minFov = this._yawPitchControl.option("fovRange")[0]; // this option should be called after fov is set.


        this._yawPitchControl.option({
          "fov": maxFov,

          /* parameter for internal validation for pitchrange */
          "yawRange": [-yawSize / 2, yawSize / 2],
          isCircular: isCircular,
          "pitchRange": [-maxFov / 2, maxFov / 2],
          "fovRange": [minFov, maxFov]
        });

        this.lookAt({
          fov: maxFov
        });
      }
    };

    _proto._bindRendererHandler = function _bindRendererHandler() {
      var _this3 = this;

      this._photoSphereRenderer.on(PanoImageRenderer_PanoImageRenderer.EVENTS.ERROR, function (e) {
        _this3.trigger(consts_EVENTS.ERROR, e);
      });

      this._photoSphereRenderer.on(PanoImageRenderer_PanoImageRenderer.EVENTS.RENDERING_CONTEXT_LOST, function (e) {
        _this3._deactivate();

        _this3.trigger(consts_EVENTS.ERROR, {
          type: ERROR_TYPE.RENDERING_CONTEXT_LOST,
          message: "webgl rendering context lost"
        });
      });
    };

    _proto._initYawPitchControl = function _initYawPitchControl(yawPitchConfig) {
      var _this4 = this;

      this._yawPitchControl = new YawPitchControl_YawPitchControl(yawPitchConfig);

      this._yawPitchControl.on(consts_EVENTS.ANIMATION_END, function (e) {
        _this4._triggerEvent(consts_EVENTS.ANIMATION_END, e);
      });

      this._yawPitchControl.on("change", function (e) {
        _this4._yaw = e.yaw;
        _this4._pitch = e.pitch;
        _this4._fov = e.fov;
        _this4._quaternion = e.quaternion;

        _this4._triggerEvent(consts_EVENTS.VIEW_CHANGE, e);
      });
    };

    _proto._triggerEvent = function _triggerEvent(name, param) {
      var evt = param || {};
      /**
       * Events that is fired when error occurs
       * @ko     
       * @name eg.view360.PanoViewer#error
       * @event
       * @param {Object} param The object of data to be sent to an event <ko>   </ko>
       * @param {Number} param.type Error type
       * 		10: INVALID_DEVICE: Unsupported device
       * 		11: NO_WEBGL: Webgl not support
       * 		12, FAIL_IMAGE_LOAD: Failed to load image
       * 		13: FAIL_BIND_TEXTURE: Failed to bind texture
       * 		14: INVALID_RESOURCE: Only one resource(image or video) should be specified
       * 		15: RENDERING_CONTEXT_LOST: WebGL context lost occurred
       * <ko> 
       * 		10: INVALID_DEVICE:  
       * 		11: NO_WEBGL: WEBGL 
       * 		12, FAIL_IMAGE_LOAD:   
       * 		13: FAIL_BIND_TEXTURE:   
       * 		14: INVALID_RESOURCE:    (image  video    )
       * 		15: RENDERING_CONTEXT_LOST: WebGL context lost 
       * </ko>
       * @param {String} param.message Error message <ko> </ko>
       * @see {@link eg.view360.PanoViewer.ERROR_TYPE}
       * @example
       *
       * viwer.on({
       *	"error" : function(evt) {
       *		// evt.type === 13
       *		// evt.message === "failed to bind texture"
       * });
       *
       * // constant can be used
       * viwer.on({
       *	eg.view360.PanoViewer.EVENTS.ERROR : function(evt) {
       *		// evt.type === eg.view360.PanoViewer.ERROR_TYPE.FAIL_BIND_TEXTURE
       *		// evt.message === "failed to bind texture"
       * });
       */

      /**
       * Events that is fired when PanoViewer is ready to go.
       * @ko PanoViewer     
       * @name eg.view360.PanoViewer#ready
       * @event
       *
       * @example
       *
       * viwer.on({
       *	"ready" : function(evt) {
       *		// PanoViewer is ready to show image and handle user interaction.
       * });
       */

      /**
       * Events that is fired when direction or fov is changed.
       * @ko PanoViewer     FOV()   
       * @name eg.view360.PanoViewer#viewChange
       * @event
       * @param {Object} param The object of data to be sent to an event <ko>   </ko>
       * @param {Number} param.yaw yaw<ko>yaw</ko>
       * @param {Number} param.pitch pitch <ko>pitch</ko>
       * @param {Number} param.fov Field of view (fov) <ko></ko>
       * @example
       *
       * viwer.on({
       *	"viewChange" : function(evt) {
       *		//evt.yaw, evt.pitch, evt.fov is available.
       * });
       */

      /**
       * Events that is fired when animation which is triggered by inertia is ended.
       * @ko       
       * @name eg.view360.PanoViewer#animationEnd
       * @event
       * @example
       *
       * viwer.on({
       *	"animationEnd" : function(evt) {
       *		// animation is ended.
       * });
       */

      return this.trigger(name, evt);
    }
    /**
     * When set true, enables zoom with the wheel or pinch gesture. However, in the case of touch, pinch works only when the touchDirection setting is {@link eg.view360.PanoViewer.TOUCH_DIRECTION.ALL}.
     * @ko true        /   . false   /   . ,   touchDirection  {@link eg.view360.PanoViewer.TOUCH_DIRECTION.ALL}   pinch  .
     * @method eg.view360.PanoViewer#setUseZoom
     * @param {Boolean} useZoom
     * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer </ko>
     */
    ;

    _proto.setUseZoom = function setUseZoom(useZoom) {
      typeof useZoom === "boolean" && this._yawPitchControl.option("useZoom", useZoom);
      return this;
    }
    /**
     * When true, enables the keyboard move key control: awsd, arrow keys
     * @ko true     . (awsd,  )
     * @method eg.view360.PanoViewer#setUseKeyboard
     * @param {Boolean} useKeyboard
     * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer </ko>
     */
    ;

    _proto.setUseKeyboard = function setUseKeyboard(useKeyboard) {
      this._yawPitchControl.option("useKeyboard", useKeyboard);

      return this;
    }
    /**
     * Enables control through device motion. ("none", "yawPitch", "VR")
     * @ko      . ("none", "yawPitch", "VR")
     * @method eg.view360.PanoViewer#setGyroMode
     * @param {String} gyroMode {@link eg.view360.PanoViewer.GYRO_MODE}
     * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer </ko>
     * @example
     * panoViewer.setGyroMode("yawPitch");
     * //equivalent
     * panoViewer.setGyroMode(eg.view360.PanoViewer.GYRO_MODE.YAWPITCH);
     */
    ;

    _proto.setGyroMode = function setGyroMode(gyroMode) {
      this._yawPitchControl.option("gyroMode", gyroMode);

      return this;
    }
    /**
     * Set the range of controllable FOV values
     * @ko   FOV  .
     * @method eg.view360.PanoViewer#setFovRange
     * @param {Array} range
     * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer </ko>
     * @example
     * panoViewer.setFovRange([50, 90]);
     */
    ;

    _proto.setFovRange = function setFovRange(range) {
      this._yawPitchControl.option("fovRange", range);

      return this;
    }
    /**
     * Getting the range of controllable FOV values
     * @ko   FOV  .
     * @method eg.view360.PanoViewer#getFovRange
     * @return {Array}
     * @example
     * var range = panoViewer.getFovRange(); //[50, 90]
     */
    ;

    _proto.getFovRange = function getFovRange() {
      return this._yawPitchControl.option("fovRange");
    }
    /**
     * Update size of canvas element by it's container element's or specified size. If size is not specified, the size of the container area is obtained and updated to that size.
     * @ko         .  size          .
     * @method eg.view360.PanoViewer#updateViewportDimensions
     * @param {Object} [size]
     * @param {Number} [size.width=width of container]
     * @param {Number} [size.height=height of container]
     * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer </ko>
     */
    ;

    _proto.updateViewportDimensions = function updateViewportDimensions(size) {
      if (size === void 0) {
        size = {
          width: undefined,
          height: undefined
        };
      }

      if (!this._isReady) {
        return this;
      }

      var containerSize;

      if (size.width === undefined || size.height === undefined) {
        containerSize = window.getComputedStyle(this._container);
      }

      var width = size.width || parseInt(containerSize.width, 10);
      var height = size.height || parseInt(containerSize.height, 10); // Skip if viewport is not changed.

      if (width === this._width && height === this._height) {
        return this;
      }

      this._width = width;
      this._height = height;
      this._aspectRatio = width / height;

      this._photoSphereRenderer.updateViewportDimensions(width, height);

      this._yawPitchControl.option("aspectRatio", this._aspectRatio);

      this._yawPitchControl.updatePanScale({
        height: height
      });

      this.lookAt({}, 0);
      return this;
    }
    /**
     * Get the current field of view(FOV)
     * @ko  field of view(FOV)  .
     * @method eg.view360.PanoViewer#getFov
     * @return {Number}
     */
    ;

    _proto.getFov = function getFov() {
      return this._fov;
    }
    /**
     * Get the horizontal field of view in degree
     */
    ;

    _proto._getHFov = function _getHFov() {
      return common.toDegree(2 * Math.atan(this._aspectRatio * Math.tan(common.toRadian(this._fov) / 2)));
    }
    /**
     * Get current yaw value
     * @ko  yaw  .
     * @method eg.view360.PanoViewer#getYaw
     * @return {Number}
     */
    ;

    _proto.getYaw = function getYaw() {
      return this._yaw;
    }
    /**
     * Get current pitch value
     * @ko  pitch  .
     * @method eg.view360.PanoViewer#getPitch
     * @return {Number}
     */
    ;

    _proto.getPitch = function getPitch() {
      return this._pitch;
    }
    /**
     * Get the range of controllable Yaw values
     * @ko   Yaw  .
     * @method eg.view360.PanoViewer#getYawRange
     * @return {Array}
     */
    ;

    _proto.getYawRange = function getYawRange() {
      return this._yawPitchControl.option("yawRange");
    }
    /**
     * Get the range of controllable Pitch values
     * @ko   Pitch  .
     * @method eg.view360.PanoViewer#getPitchRange
     * @return {Array}
     */
    ;

    _proto.getPitchRange = function getPitchRange() {
      return this._yawPitchControl.option("pitchRange");
    }
    /**
     * Set the range of controllable yaw
     * @ko   Yaw  .
     * @method eg.view360.PanoViewer#setYawRange
     * @param {Array} range
     * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer </ko>
     * @example
     * panoViewer.setYawRange([-90, 90]);
     */
    ;

    _proto.setYawRange = function setYawRange(yawRange) {
      this._yawPitchControl.option("yawRange", yawRange);

      return this;
    }
    /**
     * Set the range of controllable Pitch values
     * @ko   Pitch  .
     * @method eg.view360.PanoViewer#setPitchRange
     * @param {Array} range
     * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer </ko>
     * @example
     * panoViewer.setPitchRange([-40, 40]);
     */
    ;

    _proto.setPitchRange = function setPitchRange(pitchRange) {
      this._yawPitchControl.option("pitchRange", pitchRange);

      return this;
    }
    /**
     * Specifies whether to display the pole by limiting the pitch range. If it is true, pole point can be displayed. If it is false, it is not displayed.
     * @ko pitch     . true       false     .
     * @method eg.view360.PanoViewer#setShowPolePoint
     * @param {Boolean} showPolePoint
     * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer </ko>
     */
    ;

    _proto.setShowPolePoint = function setShowPolePoint(showPolePoint) {
      this._yawPitchControl.option("showPolePoint", showPolePoint);

      return this;
    }
    /**
     * Set a new view by setting camera configuration. Any parameters not specified remain the same.
     * @ko     .      .
     * @method eg.view360.PanoViewer#lookAt
     * @param {Object} orientation
     * @param {Number} orientation.yaw Target yaw in degree <ko> yaw (degree )</ko>
     * @param {Number} orientation.pitch Target pitch in degree <ko> pitch (degree )</ko>
     * @param {Number} orientation.fov Target vertical fov in degree <ko>  fov (degree )</ko>
     * @param {Number} duration Animation duration in milliseconds <ko>  ( )</ko>
     * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer </ko>
     * @example
     * // Change the yaw angle (absolute angle) to 30 degrees for one second.
     * panoViewer.lookAt({yaw: 30}, 1000);
     */
    ;

    _proto.lookAt = function lookAt(orientation, duration) {
      if (!this._isReady) {
        return this;
      }

      var yaw = orientation.yaw !== undefined ? orientation.yaw : this._yaw;
      var pitch = orientation.pitch !== undefined ? orientation.pitch : this._pitch;

      var pitchRange = this._yawPitchControl.option("pitchRange");

      var verticalAngleOfImage = pitchRange[1] - pitchRange[0];
      var fov = orientation.fov !== undefined ? orientation.fov : this._fov;

      if (verticalAngleOfImage < fov) {
        fov = verticalAngleOfImage;
      }

      this._yawPitchControl.lookAt({
        yaw: yaw,
        pitch: pitch,
        fov: fov
      }, duration);

      if (duration === 0) {
        this._photoSphereRenderer.render(yaw, pitch, fov);
      }

      return this;
    };

    _proto._activate = function _activate() {
      this._photoSphereRenderer.attachTo(this._container);

      this._yawPitchControl.enable();

      this.updateViewportDimensions();
      this._isReady = true; // update yawPitchControl after isReady status is true.

      this._updateYawPitchIfNeeded();

      this._triggerEvent(consts_EVENTS.READY);

      this._startRender();
    }
    /**
     * Register the callback on the raf to call _renderLoop every frame.
     */
    ;

    _proto._startRender = function _startRender() {
      if (browser["IS_SAFARI_ON_DESKTOP"]) {
        this._renderLoop = this._renderLoopForNextTick.bind(this);
      } else {
        this._renderLoop = this._renderLoop.bind(this);
      }

      this._rafId = window.requestAnimationFrame(this._renderLoop);
    };

    _proto._render = function _render() {
      if (this._photoSphereRenderer) {
        if (this._quaternion) {
          this._photoSphereRenderer.renderWithQuaternion(this._quaternion, this._fov);
        } else {
          this._photoSphereRenderer.render(this._yaw, this._pitch, this._fov);
        }
      }
    };

    _proto._renderLoop = function _renderLoop() {
      this._render();

      this._rafId = window.requestAnimationFrame(this._renderLoop);
    }
    /**
     * MacOS X Safari Bug Fix
     * This code guarantees that rendering should be occurred.
     *
     * In MacOS X(10.14.2), Safari (12.0.2)
     * The requestAnimationFrame(RAF) callback is called just after previous RAF callback without term
     * only if requestAnimationFrame is called for next frame while updating frame is delayed (~over 2ms)
     * So browser cannot render the frame and may be freezing.
     */
    ;

    _proto._renderLoopForNextTick = function _renderLoopForNextTick() {
      var before = performance.now();

      this._render();

      var diff = performance.now() - before;

      if (this._rafTimer) {
        clearTimeout(this._rafTimer);
        this._rafTimer = null;
      }
      /** Use requestAnimationFrame only if current rendering could be possible over 60fps (1000/60) */


      if (diff < 16) {
        this._rafId = window.requestAnimationFrame(this._renderLoop);
      } else {
        /** Otherwise, Call setTimeout instead of requestAnimationFrame to gaurantee renering should be occurred*/
        this._rafTimer = setTimeout(this._renderLoop, 0);
      }
    };

    _proto._stopRender = function _stopRender() {
      if (this._rafId) {
        window.cancelAnimationFrame(this._rafId);
      }

      if (this._rafTimer) {
        clearTimeout(this._rafTimer);
      }

      delete this._rafId;
      delete this._rafTimer;
    }
    /**
     * Destroy webgl context and block user interaction and stop rendering
     */
    ;

    _proto._deactivate = function _deactivate() {
      if (this._photoSphereRenderer) {
        this._photoSphereRenderer.destroy();

        this._photoSphereRenderer = null;
      }

      if (this._isReady) {
        this._yawPitchControl.disable();

        this._stopRender();

        this._isReady = false;
      }
    };

    PanoViewer._isValidTouchDirection = function _isValidTouchDirection(direction) {
      return direction === PanoViewer.TOUCH_DIRECTION.NONE || direction === PanoViewer.TOUCH_DIRECTION.YAW || direction === PanoViewer.TOUCH_DIRECTION.PITCH || direction === PanoViewer.TOUCH_DIRECTION.ALL;
    }
    /**
     * Set touch direction by which user can control.
     * @ko     .
     * @method eg.view360.PanoViewer#setTouchDirection
     * @param {Number} direction of the touch. {@link eg.view360.PanoViewer.TOUCH_DIRECTION}<ko>   {@link eg.view360.PanoViewer.TOUCH_DIRECTION}</ko>
     * @return {eg.view360.PanoViewer} PanoViewer instance
     * @example
     *
     * panoViewer = new PanoViewer(el);
     * // Limit the touch direction to the yaw direction only.
     * panoViewer.setTouchDirection(eg.view360.PanoViewer.TOUCH_DIRECTION.YAW);
     */
    ;

    _proto.setTouchDirection = function setTouchDirection(direction) {
      if (PanoViewer._isValidTouchDirection(direction)) {
        this._yawPitchControl.option("touchDirection", direction);
      }

      return this;
    }
    /**
     * Returns touch direction by which user can control
     * @ko     .
     * @method eg.view360.PanoViewer#getTouchDirection
     * @return {Number} direction of the touch. {@link eg.view360.PanoViewer.TOUCH_DIRECTION}<ko>   {@link eg.view360.PanoViewer.TOUCH_DIRECTION}</ko>
     * @example
     *
     * panoViewer = new PanoViewer(el);
     * // Returns the current touch direction.
     * var dir = panoViewer.getTouchDirection();
     */
    ;

    _proto.getTouchDirection = function getTouchDirection() {
      return this._yawPitchControl.option("touchDirection");
    }
    /**
     * Destroy viewer. Remove all registered event listeners and remove viewer canvas.
     * @ko   .       .
     * @method eg.view360.PanoViewer#destroy
     * @return {eg.view360.PanoViewer} PanoViewer instance<ko>PanoViewer </ko>
     */
    ;

    _proto.destroy = function destroy() {
      this._deactivate();

      if (this._yawPitchControl) {
        this._yawPitchControl.destroy();

        this._yawPitchControl = null;
      }

      return this;
    }
    /**
     * Check whether the current environment can execute PanoViewer
     * @ko    PanoViewer    .
     * @function isSupported
     * @memberof eg.view360.PanoViewer
     * @return {Boolean} PanoViewer executable <ko>PanoViewer  </ko>
     * @static
     */
    ;

    PanoViewer.isSupported = function isSupported() {
      return WebGLUtils_WebGLUtils.isWebGLAvailable() && WebGLUtils_WebGLUtils.isStableWebGL();
    }
    /**
     * Check whether the current environment supports the WebGL
     * @ko    WebGL    .
     * @function isWebGLAvailable
     * @memberof eg.view360.PanoViewer
     * @return {Boolean} WebGL support <ko>WebGL </ko>
     * @static
     */
    ;

    PanoViewer.isWebGLAvailable = function isWebGLAvailable() {
      return WebGLUtils_WebGLUtils.isWebGLAvailable();
    }
    /**
     * Check whether the current environment supports the gyro sensor.
     * @ko        .
     * @function isGyroSensorAvailable
     * @memberof eg.view360.PanoViewer
     * @param {Function} callback Function to take the gyro sensor availability as argument <ko>      </ko>
     * @static
     */
    ;

    PanoViewer.isGyroSensorAvailable = function isGyroSensorAvailable(callback) {
      if (!browserFeature["DeviceMotionEvent"]) {
        callback && callback(false);
        return;
      }

      var onDeviceMotionChange;

      function checkGyro() {
        return new PanoViewer_Promise(function (res, rej) {
          onDeviceMotionChange = function onDeviceMotionChange(deviceMotion) {
            var isGyroSensorAvailable = !(deviceMotion.rotationRate.alpha == null);
            res(isGyroSensorAvailable);
          };

          window.addEventListener("devicemotion", onDeviceMotionChange);
        });
      }

      function timeout() {
        return new PanoViewer_Promise(function (res, rej) {
          setTimeout(function () {
            return res(false);
          }, 1000);
        });
      }

      PanoViewer_Promise.race([checkGyro(), timeout()]).then(function (isGyroSensorAvailable) {
        window.removeEventListener("devicemotion", onDeviceMotionChange);
        callback && callback(isGyroSensorAvailable);

        PanoViewer.isGyroSensorAvailable = function (fb) {
          fb && fb(isGyroSensorAvailable);
          return isGyroSensorAvailable;
        };
      });
    };

    return PanoViewer;
  }(component_root_eg_Component_default.a);

  PanoViewer.VERSION = src_version["VERSION"];
  PanoViewer.ERROR_TYPE = ERROR_TYPE;
  PanoViewer.EVENTS = consts_EVENTS;
  PanoViewer.PROJECTION_TYPE = PROJECTION_TYPE;
  PanoViewer.GYRO_MODE = GYRO_MODE;
  PanoViewer.ProjectionType = PROJECTION_TYPE;
  PanoViewer.TOUCH_DIRECTION = {
    /**
     * Constant value for none direction.
     * @ko none    .
     * @name NONE
     * @memberof eg.view360.PanoViewer.TOUCH_DIRECTION
     * @constant
     * @type {Number}
     * @default 1
     */
    NONE: YawPitchControl_YawPitchControl.TOUCH_DIRECTION_NONE,

    /**
     * Constant value for horizontal(yaw) direction.
     * @ko horizontal(yaw)    .
     * @name YAW
     * @memberof eg.view360.PanoViewer.TOUCH_DIRECTION
     * @constant
     * @type {Number}
     * @default 6
     */
    YAW: YawPitchControl_YawPitchControl.TOUCH_DIRECTION_YAW,

    /**
     * Constant value for vertical direction.
     * @ko vertical(pitch)    .
     * @name PITCH
     * @memberof eg.view360.PanoViewer.TOUCH_DIRECTION
     * @constant
     * @type {Number}
     * @default 24
     */
    PITCH: YawPitchControl_YawPitchControl.TOUCH_DIRECTION_PITCH,

    /**
     * Constant value for all direction.
     * @ko all    .
     * @name ALL
     * @memberof eg.view360.PanoViewer.TOUCH_DIRECTION
     * @constant
     * @type {Number}
     * @default 30
     */
    ALL: YawPitchControl_YawPitchControl.TOUCH_DIRECTION_ALL
  };
  return PanoViewer;
}();



/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZy52aWV3MzYwL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9lZy52aWV3MzYwL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2VnLnZpZXczNjAvKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50PzkwMzkiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwid2VicGFjazovL2VnLnZpZXczNjAvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLy4vbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8uL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLy4vbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwid2VicGFjazovL2VnLnZpZXczNjAvLi9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLy4vbm9kZV9tb2R1bGVzL2Fuc2ktcmVnZXgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8uL25vZGVfbW9kdWxlcy9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvc29ja2V0LmpzIiwid2VicGFjazovL2VnLnZpZXczNjAvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L3NvY2tqcy5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5LmpzIiwid2VicGFjazovL2VnLnZpZXczNjAvLi9ub2RlX21vZHVsZXMvYW5zaS1odG1sL2luZGV4LmpzIiwid2VicGFjazovL2VnLnZpZXczNjAvLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL3htbC1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2h0bWw0LWVudGl0aWVzLmpzIiwid2VicGFjazovL2VnLnZpZXczNjAvLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaHRtbDUtZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8od2VicGFjaykvaG90IHN5bmMgbm9ucmVjdXJzaXZlIF5cXC5cXC9sb2ckIiwid2VicGFjazovL2VnLnZpZXczNjAvKHdlYnBhY2spL2hvdC9sb2cuanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8od2VicGFjaykvaG90L2VtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovL2VnLnZpZXczNjAvLi9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJAZWdqcy9jb21wb25lbnRcIixcImNvbW1vbmpzMlwiOlwiQGVnanMvY29tcG9uZW50XCIsXCJhbWRcIjpcIkBlZ2pzL2NvbXBvbmVudFwiLFwicm9vdFwiOltcImVnXCIsXCJDb21wb25lbnRcIl19Iiwid2VicGFjazovL2VnLnZpZXczNjAvLi9zcmMvdXRpbHMvYnJvd3NlckZlYXR1cmUuanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8uL3NyYy91dGlscy9icm93c2VyLmpzIiwid2VicGFjazovL2VnLnZpZXczNjAvZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcIkBlZ2pzL2F4ZXNcIixcImNvbW1vbmpzMlwiOlwiQGVnanMvYXhlc1wiLFwiYW1kXCI6XCJAZWdqcy9heGVzXCIsXCJyb290XCI6W1wiZWdcIixcIkF4ZXNcIl19Iiwid2VicGFjazovL2VnLnZpZXczNjAvLi9ub2RlX21vZHVsZXMvd2VidnItcG9seWZpbGwvc3JjL3NlbnNvci1mdXNpb24vcG9zZS1wcmVkaWN0b3IuanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8uL25vZGVfbW9kdWxlcy93ZWJ2ci1wb2x5ZmlsbC9zcmMvbWF0aC11dGlsLmpzIiwid2VicGFjazovL2VnLnZpZXczNjAvLi9ub2RlX21vZHVsZXMvd2VidnItcG9seWZpbGwvc3JjL3V0aWwuanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8uL25vZGVfbW9kdWxlcy93ZWJ2ci1wb2x5ZmlsbC9zcmMvc2Vuc29yLWZ1c2lvbi9jb21wbGVtZW50YXJ5LWZpbHRlci5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLy4vbm9kZV9tb2R1bGVzL3dlYnZyLXBvbHlmaWxsL3NyYy9zZW5zb3ItZnVzaW9uL3NlbnNvci1zYW1wbGUuanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8uL3NyYy92ZXJzaW9uLmpzIiwid2VicGFjazovL2VnLnZpZXczNjAvLi9zcmMvUGFub1ZpZXdlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLy4vc3JjL1lhd1BpdGNoQ29udHJvbC91dGlscy5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLy4vc3JjL3V0aWxzL21hdGhVdGlsL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLy4vc3JjL3V0aWxzL21hdGhVdGlsL3ZlYzMuanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8uL3NyYy91dGlscy9tYXRoVXRpbC92ZWMyLmpzIiwid2VicGFjazovL2VnLnZpZXczNjAvLi9zcmMvdXRpbHMvbWF0aFV0aWwvcXVhdC5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLy4vc3JjL3V0aWxzL21hdGhVdGlsL21hdDQuanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8uL3NyYy91dGlscy9tYXRoLXV0aWwuanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8uL3NyYy9ZYXdQaXRjaENvbnRyb2wvY29uc3RzLmpzIiwid2VicGFjazovL2VnLnZpZXczNjAvLi9zcmMvWWF3UGl0Y2hDb250cm9sL2lucHV0L0RldmljZU1vdGlvbi5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLy4vc3JjL1lhd1BpdGNoQ29udHJvbC9pbnB1dC9Db21wbGVtZW50YXJ5RmlsdGVyLmpzIiwid2VicGFjazovL2VnLnZpZXczNjAvLi9zcmMvWWF3UGl0Y2hDb250cm9sL2lucHV0L0Z1c2lvblBvc2VTZW5zb3IuanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8uL3NyYy9ZYXdQaXRjaENvbnRyb2wvaW5wdXQvVGlsdE1vdGlvbklucHV0LmpzIiwid2VicGFjazovL2VnLnZpZXczNjAvLi9zcmMvWWF3UGl0Y2hDb250cm9sL1NjcmVlblJvdGF0aW9uQW5nbGUuanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8uL3NyYy9ZYXdQaXRjaENvbnRyb2wvaW5wdXQvUm90YXRpb25QYW5JbnB1dC5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLy4vc3JjL1lhd1BpdGNoQ29udHJvbC9EZXZpY2VRdWF0ZXJuaW9uLmpzIiwid2VicGFjazovL2VnLnZpZXczNjAvLi9zcmMvWWF3UGl0Y2hDb250cm9sL1lhd1BpdGNoQ29udHJvbC5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLy4vc3JjL1Bhbm9JbWFnZVJlbmRlcmVyL0ltYWdlTG9hZGVyLmpzIiwid2VicGFjazovL2VnLnZpZXczNjAvLi9zcmMvUGFub0ltYWdlUmVuZGVyZXIvVmlkZW9Mb2FkZXIuanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8uL25vZGVfbW9kdWxlcy9AZWdqcy9hZ2VudC9kaXN0L2FnZW50LmVzbS5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLy4vc3JjL1Bhbm9JbWFnZVJlbmRlcmVyL1dlYkdMVXRpbHMuanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8uL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9yZW5kZXJlci9SZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLy4vc3JjL1Bhbm9JbWFnZVJlbmRlcmVyL3JlbmRlcmVyL0N1YmVSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLy4vc3JjL1Bhbm9JbWFnZVJlbmRlcmVyL3JlbmRlcmVyL0N1YmVTdHJpcFJlbmRlcmVyLmpzIiwid2VicGFjazovL2VnLnZpZXczNjAvLi9zcmMvUGFub0ltYWdlUmVuZGVyZXIvcmVuZGVyZXIvU3BoZXJlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8uL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9yZW5kZXJlci9DeWxpbmRlclJlbmRlcmVyLmpzIiwid2VicGFjazovL2VnLnZpZXczNjAvLi9zcmMvUGFub1ZpZXdlci9jb25zdHMuanMiLCJ3ZWJwYWNrOi8vZWcudmlldzM2MC8uL3NyYy9QYW5vSW1hZ2VSZW5kZXJlci9QYW5vSW1hZ2VSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly9lZy52aWV3MzYwLy4vc3JjL1Bhbm9WaWV3ZXIvUGFub1ZpZXdlci5qcyJdLCJuYW1lcyI6WyJGbG9hdDMyQXJyYXkiLCJBcnJheSIsImdldENvbXB1dGVkU3R5bGUiLCJ1c2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJTVVBQT1JUX1RPVUNIIiwiU1VQUE9SVF9ERVZJQ0VNT1RJT04iLCJEZXZpY2VNb3Rpb25FdmVudCIsImRldmljZVBpeGVsUmF0aW8iLCJUUkFOU0ZPUk0iLCJkb2NTdHlsZSIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlIiwidGFyZ2V0IiwiaSIsImxlbiIsImxlbmd0aCIsIlNVUFBPUlRfV0lMTENIQU5HRSIsIkNTUyIsInN1cHBvcnRzIiwid2luIiwid2luZG93IiwiTWF0aCIsInNlbGYiLCJGdW5jdGlvbiIsImRvYyIsImRvY3VtZW50IiwiSVNfU0FGQVJJX09OX0RFU0tUT1AiLCJpbmRleE9mIiwiVkVSU0lPTiIsInRvQXhpcyIsInNvdXJjZSIsIm9mZnNldCIsInJlZHVjZSIsImFjYyIsInYiLCJnbE1hdHJpeCIsIkFSUkFZX1RZUEUiLCJkZWdyZWUiLCJQSSIsInRvUmFkaWFuIiwiYSIsInRvRGVncmVlIiwiRVBTSUxPTiIsInZlYzMiLCJjcmVhdGUiLCJvdXQiLCJmcm9tVmFsdWVzIiwieCIsInkiLCJ6Iiwic2V0IiwiY29weSIsInNjYWxlIiwiYiIsInN1YnRyYWN0Iiwic3FydCIsIm5vcm1hbGl6ZSIsImRvdCIsImNyb3NzIiwiYXgiLCJheSIsImF6IiwiYngiLCJieSIsImJ6IiwidHJhbnNmb3JtUXVhdCIsInEiLCJxeCIsInF5IiwicXoiLCJxdyIsIml4IiwiaXkiLCJpeiIsIml3Iiwicm90YXRlWiIsImMiLCJwIiwiciIsImNvcyIsInNpbiIsInZlYzIiLCJxdWF0IiwiY2xvbmUiLCJ3Iiwic2V0QXhpc0FuZ2xlIiwiYXhpcyIsInJhZCIsInMiLCJtdWx0aXBseSIsImF3IiwiYnciLCJyb3RhdGVYIiwicm90YXRlWSIsImNvbmp1Z2F0ZSIsImVxdWFscyIsImEwIiwiYTEiLCJhMiIsImEzIiwiYjAiLCJiMSIsImIyIiwiYjMiLCJhYnMiLCJtYXgiLCJleGFjdEVxdWFscyIsIm1hdDQiLCJpZGVudGl0eSIsImExMCIsImExMSIsImExMiIsImExMyIsImEyMCIsImEyMSIsImEyMiIsImEyMyIsImEwMCIsImEwMSIsImEwMiIsImEwMyIsImZyb21RdWF0IiwieDIiLCJ5MiIsInoyIiwieHgiLCJ5eCIsInl5IiwiengiLCJ6eSIsInp6Iiwid3giLCJ3eSIsInd6IiwicGVyc3BlY3RpdmUiLCJmb3Z5IiwiYXNwZWN0IiwibmVhciIsImZhciIsImYiLCJ0YW4iLCJuZiIsInF1YXRUb1ZlYzMiLCJxdWF0ZXJuaW9uIiwiYmFzZVYiLCJpc1Bvd2VyT2ZUd28iLCJuIiwiZXh0cmFjdFBpdGNoRnJvbVF1YXQiLCJhdGFuMiIsInBvdyIsIlJPVEFURV9DT05TVEFOVCIsIlBJVENIX0RFTFRBIiwiWUFXX0RFTFRBX0JZX1JPTEwiLCJZQVdfREVMVEFfQllfWUFXIiwidGFyZ2V0QXhpcyIsIm1lc2hQb2ludCIsImdldFJvdGF0aW9uRGVsdGEiLCJwcmV2USIsImN1clEiLCJyb3RhdGVLaW5kIiwicHJldlF1YXRlcm5pb24iLCJjdXJRdWF0ZXJuaW9uIiwicHJldlBvaW50IiwiY3VyUG9pbnQiLCJyb3RhdGVEaXN0YW5jZSIsInJvdGF0ZURpcmVjdGlvbiIsIm1lc2hQb2ludDIiLCJtZXNoUG9pbnQzIiwidmVjVSIsInZlY1YiLCJ2ZWNOIiwiY29lZmZpY2llbnRBIiwiY29lZmZpY2llbnRCIiwiY29lZmZpY2llbnRDIiwiZGlzdGFuY2UiLCJwcm9qZWN0ZWRQcmV2UG9pbnQiLCJ0cmlnb25vbWV0cmljUmF0aW8iLCJ0aGV0YSIsImFjb3MiLCJjcm9zc1ZlYyIsInRoZXRhRGlyZWN0aW9uIiwiZGVsdGFSYWRpYW4iLCJ2ZXJzaW9uIiwiYnJhbmNoIiwiYnVpbGQiLCJtYXRjaCIsImV4ZWMiLCJwYXJzZUludCIsIkNIUk9NRV9WRVJTSU9OIiwiSVNfQ0hST01FX1dJVEhPVVRfREVWSUNFX01PVElPTiIsIklTX0FORFJPSUQiLCJ0ZXN0IiwiQ09OVFJPTF9NT0RFX1ZSIiwiQ09OVFJPTF9NT0RFX1lBV1BJVENIIiwiVE9VQ0hfRElSRUNUSU9OX05PTkUiLCJUT1VDSF9ESVJFQ1RJT05fWUFXIiwiVE9VQ0hfRElSRUNUSU9OX1BJVENIIiwiVE9VQ0hfRElSRUNUSU9OX0FMTCIsIk1DX0RFQ0VMRVJBVElPTiIsIk1DX01BWElNVU1fRFVSQVRJT04iLCJNQ19CSU5EX1NDQUxFIiwiTUlOX0ZJRUxEX09GX1ZJRVciLCJNQVhfRklFTERfT0ZfVklFVyIsIlBBTl9TQ0FMRSIsIkRFTFRBX1RIUkVTSE9MRCIsIllBV19SQU5HRV9IQUxGIiwiUElUQ0hfUkFOR0VfSEFMRiIsIkNJUkNVTEFSX1BJVENIX1JBTkdFX0hBTEYiLCJQSU5DSF9FVkVOVFMiLCJLRVlNQVAiLCJMRUZUX0FSUk9XIiwiQSIsIlVQX0FSUk9XIiwiVyIsIlJJR0hUX0FSUk9XIiwiRCIsIkRPV05fQVJST1ciLCJTIiwiR1lST19NT0RFIiwiTk9ORSIsIllBV1BJVENIIiwiVlIiLCJTVElMTE5FU1NfVEhSRVNIT0xEIiwiX29uRGV2aWNlTW90aW9uIiwiYmluZCIsIl9vbkRldmljZU9yaWVudGF0aW9uIiwiX29uQ2hyb21lV2l0aG91dERldmljZU1vdGlvbiIsImlzV2l0aG91dERldmljZU1vdGlvbiIsImlzQW5kcm9pZCIsInN0aWxsR3lyb1ZlYyIsInJhd0d5cm9WZWMiLCJhZGp1c3RlZEd5cm9WZWMiLCJfdGltZXIiLCJsYXN0RGV2aWNlbW90aW9uVGltZXN0YW1wIiwiX2lzRW5hYmxlZCIsImVuYWJsZSIsImUiLCJhbHBoYSIsImJldGEiLCJnYW1tYSIsInRyaWdnZXIiLCJpbnB1dEV2ZW50IiwiZGV2aWNlb3JpZW50YXRpb24iLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiRGF0ZSIsImdldFRpbWUiLCJpc0d5cm9TZW5zb3JBdmFpbGFibGUiLCJyb3RhdGlvblJhdGUiLCJpc0dyYXZpdHlTZW5zb3JBdmFpbGFibGUiLCJhY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5IiwiaW50ZXJ2YWwiLCJkZXZpY2Vtb3Rpb25FdmVudCIsInRpbWVTdGFtcCIsInR5cGUiLCJhY2NlbGVyYXRpb24iLCJhZGp1c3RlZFJvdGF0aW9uUmF0ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJkaXNhYmxlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInByb3RvdHlwZSIsInJ1bl8iLCJpc09yaWVudGF0aW9uSW5pdGlhbGl6ZWQiLCJhY2NlbFEiLCJhY2NlbFRvUXVhdGVybmlvbl8iLCJjdXJyZW50QWNjZWxNZWFzdXJlbWVudCIsInNhbXBsZSIsInByZXZpb3VzRmlsdGVyUSIsImRlbHRhVCIsImN1cnJlbnRHeXJvTWVhc3VyZW1lbnQiLCJ0aW1lc3RhbXBTIiwicHJldmlvdXNHeXJvTWVhc3VyZW1lbnQiLCJneXJvRGVsdGFRIiwiZ3lyb1RvUXVhdGVybmlvbkRlbHRhXyIsImd5cm9JbnRlZ3JhbFEiLCJmaWx0ZXJRIiwiaW52RmlsdGVyUSIsIlF1YXRlcm5pb24iLCJpbnZlcnNlIiwiZXN0aW1hdGVkR3Jhdml0eSIsImFwcGx5UXVhdGVybmlvbiIsIm1lYXN1cmVkR3Jhdml0eSIsImRlbHRhUSIsInNldEZyb21Vbml0VmVjdG9ycyIsInRhcmdldFEiLCJzbGVycCIsImtGaWx0ZXIiLCJpc0ZpbHRlclF1YXRlcm5pb25Jbml0aWFsaXplZCIsImdldE9yaWVudGF0aW9uIiwiS19GSUxURVIiLCJQUkVESUNUSU9OX1RJTUVfUyIsImRldmljZU1vdGlvbiIsImFjY2VsZXJvbWV0ZXIiLCJWZWN0b3IzIiwiZ3lyb3Njb3BlIiwiX29uRGV2aWNlTW90aW9uQ2hhbmdlIiwiX29uU2NyZWVuT3JpZW50YXRpb25DaGFuZ2UiLCJmaWx0ZXIiLCJwb3NlUHJlZGljdG9yIiwiZmlsdGVyVG9Xb3JsZFEiLCJpc0ZpcmVmb3hBbmRyb2lkIiwiaXNJT1MiLCJpc0Nocm9tZVVzaW5nRGVncmVlcyIsInNldEZyb21BeGlzQW5nbGUiLCJpbnZlcnNlV29ybGRUb1NjcmVlblEiLCJ3b3JsZFRvU2NyZWVuUSIsIm9yaWdpbmFsUG9zZUFkanVzdFEiLCJvcmllbnRhdGlvbiIsIl9zZXRTY3JlZW5UcmFuc2Zvcm0iLCJpc0xhbmRzY2FwZU1vZGUiLCJyZXNldFEiLCJvbiIsImlzRW5hYmxlZCIsImRlc3Ryb3kiLCJfdHJpZ2dlckNoYW5nZSIsIl9wcmV2T3JpZW50YXRpb24iLCJfZGV2aWNlT3JpZW50YXRpb25RIiwiZGV2aWNlT3JpZW50YXRpb25GaXhRIiwiX2FscGhhIiwibXVsdGlwbHlRdWF0ZXJuaW9ucyIsIm91dF8iLCJfY29udmVydEZ1c2lvblRvUHJlZGljdGVkIiwicHJlZGljdGVkUSIsImdldFByZWRpY3Rpb24iLCJwcmV2aW91c1RpbWVzdGFtcFMiLCJhY2NHcmF2aXR5Iiwicm90UmF0ZSIsInNldEZyb21FdWxlcllYWiIsIm11bHRpcGx5U2NhbGFyIiwiYWRkQWNjZWxNZWFzdXJlbWVudCIsImFkZEd5cm9NZWFzdXJlbWVudCIsInNjcmVlbk9yaWVudGF0aW9uIiwiZ2V0RGVsdGFZYXciLCJwcnZRIiwieWF3RGVsdGFCeVlhdyIsInlhd0RlbHRhQnlSb2xsIiwiZ2V0RGVsdGFQaXRjaCIsInBpdGNoRGVsdGEiLCJlbCIsIm9wdGlvbnMiLCJlbGVtZW50IiwiX3ByZXZRdWF0ZXJuaW9uIiwiX3F1YXRlcm5pb24iLCJmdXNpb25Qb3NlU2Vuc29yIiwidGhyZXNob2xkIiwiX29uUG9zZUNoYW5nZSIsIm1hcEF4ZXMiLCJheGVzIiwiY29ubmVjdCIsIm9ic2VydmVyIiwiX2F0dGFjaEV2ZW50IiwiZGlzY29ubmVjdCIsIl9kZXR0YWNoRXZlbnQiLCJldmVudCIsImNoYW5nZSIsIm9mZiIsInNjcmVlblJvdGF0aW9uQW5nbGVJbnN0IiwicmVmQ291bnQiLCJfb25PcmllbnRhdGlvbkNoYW5nZSIsIl9zcGluUiIsIl9zY3JlZW5PcmllbnRhdGlvbkFuZ2xlIiwiYmV0YVIiLCJnYW1tYVIiLCJzY3JlZW4iLCJhbmdsZSIsInVuZGVmaW5lZCIsImdldFJhZGlhbiIsInVucmVmIiwiX3VzZVJvdGF0aW9uIiwiX3NjcmVlblJvdGF0aW9uQW5nbGUiLCJzZXRVc2VSb3RhdGlvbiIsInVzZVJvdGF0aW9uIiwiX3VzZXJEaXJlY3Rpb24iLCJESVJFQ1RJT05fQUxMIiwiX2RpcmVjdGlvbiIsImdldE9mZnNldCIsInByb3BlcnRpZXMiLCJ1c2VEaXJlY3Rpb24iLCJuZXdPZmZzZXQiLCJjb3NUaGV0YSIsInNpblRoZXRhIiwiRElSRUNUSU9OX0hPUklaT05UQUwiLCJESVJFQ1RJT05fVkVSVElDQUwiLCJPUklHSU5fVkVDVE9SIiwiWF9BWElTX1ZFQ1RPUiIsIllfQVhJU19WRUNUT1IiLCJfZnVzaW9uUG9zZVNlbnNvciIsImlzVHJ1c3RlZCIsImdldENvbWJpbmVkUXVhdGVybmlvbiIsInlhdyIsInBpdGNoIiwiZGV2aWNlUiIsInBpdGNoQXhpcyIsInlhd1EiLCJwaXRjaFEiLCJjb25qIiwib3V0USIsIkRFRkFVTFRfWUFXX1JBTkdFIiwiREVGQVVMVF9QSVRDSF9SQU5HRSIsIkNJUkNVTEFSX1BJVENIX1JBTkdFIiwiWWF3UGl0Y2hDb250cm9sIiwib3B0IiwiZm92Iiwic2hvd1BvbGVQb2ludCIsInVzZVpvb20iLCJ1c2VLZXlib2FyZCIsImd5cm9Nb2RlIiwidG91Y2hEaXJlY3Rpb24iLCJ5YXdSYW5nZSIsInBpdGNoUmFuZ2UiLCJmb3ZSYW5nZSIsImFzcGVjdFJhdGlvIiwiX2VsZW1lbnQiLCJfaW5pdGlhbEZvdiIsIl9lbmFibGVkIiwiX2lzQW5pbWF0aW5nIiwiX2RldmljZVF1YXRlcm5pb24iLCJfaW5pdEF4ZXMiLCJvcHRpb24iLCJ5UmFuZ2UiLCJfdXBkYXRlWWF3UmFuZ2UiLCJwUmFuZ2UiLCJfdXBkYXRlUGl0Y2hSYW5nZSIsImF4ZXNQYW5JbnB1dCIsImF4ZXNXaGVlbElucHV0IiwiYXhlc1RpbHRNb3Rpb25JbnB1dCIsImF4ZXNQaW5jaElucHV0IiwiYXhlc01vdmVLZXlJbnB1dCIsInJhbmdlIiwiY2lyY3VsYXIiLCJpc0NpcmN1bGFyIiwiYm91bmNlIiwiZGVjZWxlcmF0aW9uIiwibWF4aW11bUR1cmF0aW9uIiwiaG9sZCIsImV2dCIsImRlbHRhIiwiX3VwZGF0ZUNvbnRyb2xTY2FsZSIsInVwZGF0ZVBhblNjYWxlIiwicmVsZWFzZSIsImFuaW1hdGlvblN0YXJ0IiwiYW5pbWF0aW9uRW5kIiwicGFyYW0iLCJnZXQiLCJhcmVhSGVpZ2h0IiwiaGVpZ2h0IiwiYXJncyIsImFyZ0xlbiIsIl9nZXRPcHRpb25zIiwiYmVmb3JlT3B0aW9ucyIsIm5ld09wdGlvbnMiLCJjaGFuZ2VkS2V5TGlzdCIsIk9iamVjdCIsImtleXMiLCJwdXNoIiwiX3NldE9wdGlvbnMiLCJfZ2V0VmFsaWRhdGVkT3B0aW9ucyIsIl9hcHBseU9wdGlvbnMiLCJfZ2V0VmFsaWRZYXdSYW5nZSIsIl9nZXRWYWxpZFBpdGNoUmFuZ2UiLCJrZXkiLCJ2YWx1ZSIsImFyZ3VtZW50cyIsInByZXZPcHRpb25zIiwic29tZSIsIm1hcCIsInRvRml4ZWQiLCJwcmV2Rm92IiwibmV4dEZvdiIsInNldFRvIiwiaXNWUiIsImlzWWF3UGl0Y2giLCJfaW5pdERldmljZVF1YXRlcm5pb24iLCJfdG9nZ2xlUGluY2hJbnB1dEJ5T3B0aW9uIiwiX2VuYWJsZVRvdWNoIiwiX2lucHV0cyIsImRpcmVjdGlvbiIsInlhd0VuYWJsZWQiLCJwaXRjaEVuYWJsZWQiLCJuZXdZYXdSYW5nZSIsIm5ld0ZvdiIsIm5ld0FzcGVjdFJhdGlvIiwicmF0aW8iLCJhZGp1c3RBc3BlY3RSYXRpbyIsImhvcml6b250YWxGb3YiLCJpc1ZhbGlkIiwibmV3UGl0Y2hSYW5nZSIsImNoYW5nZUV2dCIsInBvcyIsInZlcnRpY2FsQW5nbGUiLCJoYWxmRm92IiwiaXNQYW5vcmFtYSIsImhvcml6b250YWxBbmdsZSIsIk1BR0lDX05VTUJFUiIsImhhbGZIb3Jpem9udGFsRm92IiwidGFyZ2V0RWxlbWVudCIsImlucHV0IiwiaW5wdXRSYW5nZSIsIm91dHB1dFJhbmdlIiwicmFuZ2VJZHgiLCJpbnB1dEEiLCJpbnB1dEIiLCJvdXRwdXRBIiwib3V0cHV0QiIsImxlcnAiLCJmcmFjdGlvbiIsInBlcnNpc3RPcmllbnRhdGlvbiIsIl9yZXNldE9yaWVudGF0aW9uIiwibG9va0F0IiwiZHVyYXRpb24iLCJJbmZpbml0eSIsInNldEJ5IiwiZ2V0WWF3IiwiZ2V0UGl0Y2giLCJnZXRGb3YiLCJheGlzUGFuSW5wdXQiLCJheGVzRGV2aWNlT3JpZW50YXRpb25JbnB1dCIsIlNUQVRVUyIsIkVWRU5UIiwiSW1hZ2VMb2FkZXIiLCJpbWFnZSIsIl9pbWFnZSIsIl9vbmNlSGFuZGxlcnMiLCJfbG9hZFN0YXR1cyIsInJlcyIsInJlaiIsIkxPQURFRCIsImdldEVsZW1lbnQiLCJMT0FESU5HIiwiaXNNYXliZUxvYWRlZCIsIlJFQURZU1RBVEVDSEFOR0UiLCJjcmVhdGVFbGVtZW50Iiwib25jZUxvYWRlZCIsIkVSUk9SIiwiaW1hZ2VzIiwiaW1nIiwiX2ltZyIsIkltYWdlIiwiY3Jvc3NPcmlnaW4iLCJzcmMiLCJyZXN1bHQiLCJjb21wbGV0ZSIsIm5hdHVyYWxXaWR0aCIsIm9ubG9hZCIsIm9uZXJyb3IiLCJ0YXJnZXRzIiwidGFyZ2V0c05vdExvYWRlZCIsImxvYWRQcm9taXNlcyIsIl9vbmNlIiwiYWxsIiwidGhlbiIsInJlYXNvbiIsImxpc3RlbmVyIiwiZm4iLCJnZXRTdGF0dXMiLCJmb3JFYWNoIiwiaGFuZGxlciIsIlJFQURZX1NUQVRVUyIsIkhBVkVfTk9USElORyIsIkhBVkVfTUVUQURBVEEiLCJIQVZFX0NVUlJFTlRfREFUQSIsIkhBVkVfRlVUVVJFX0RBVEEiLCJIQVZFX0VOT1VHSF9EQVRBIiwiTE9BRElOR19GQUlMRUQiLCJSRUFEWVNUQVRFQ0hBTkdFX0VWRU5UX05BTUUiLCJWaWRlb0xvYWRlciIsInZpZGVvIiwiX2hhbmRsZXJzIiwiX3NvdXJjZUNvdW50IiwiX3RocmVzaG9sZFJlYWR5U3RhdGUiLCJfdGhyZXNob2xkRXZlbnROYW1lIiwicmVhZHlTdGF0ZSIsIl9vbmVycm9yIiwiX2Vycm9yQ291bnQiLCJfZGV0YWNoRXJyb3JIYW5kbGVyIiwiX2FwcGVuZFNvdXJjZUVsZW1lbnQiLCJ2aWRlb1VybCIsInZpZGVvU3JjIiwidmlkZW9UeXBlIiwic291cmNlRWxlbWVudCIsIl92aWRlbyIsImFwcGVuZENoaWxkIiwiX3Jlc2V0IiwiSFRNTFZpZGVvRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJsb2FkIiwiX2F0dGFjaEVycm9ySGFuZGxlciIsIl9zb3VyY2VzIiwiY2FsbCIsInJlamVjdG9yIiwiV0VCR0xfRVJST1JfQ09ERSIsIndlYmdsQXZhaWxhYmlsaXR5IiwiTUFYX1RFWFRVUkVfU0laRV9GT1JfVEVTVCIsImNyZWF0ZVNoYWRlciIsImdsIiwic2hhZGVyIiwic2hhZGVyU291cmNlIiwiY29tcGlsZVNoYWRlciIsInN1Y2Nlc3MiLCJnZXRTaGFkZXJQYXJhbWV0ZXIiLCJDT01QSUxFX1NUQVRVUyIsImRlbGV0ZVNoYWRlciIsImNyZWF0ZVByb2dyYW0iLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciIsInByb2dyYW0iLCJhdHRhY2hTaGFkZXIiLCJsaW5rUHJvZ3JhbSIsImdldFByb2dyYW1QYXJhbWV0ZXIiLCJMSU5LX1NUQVRVUyIsImRlbGV0ZVByb2dyYW0iLCJpbml0QnVmZmVyIiwiZGF0YSIsIml0ZW1TaXplIiwiYXR0ciIsImJ1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsImJpbmRCdWZmZXIiLCJidWZmZXJEYXRhIiwiU1RBVElDX0RSQVciLCJudW1JdGVtcyIsImVuYWJsZVZlcnRleEF0dHJpYkFycmF5IiwidmVydGV4QXR0cmliUG9pbnRlciIsIkZMT0FUIiwiZ2V0V2ViZ2xDb250ZXh0IiwiY2FudmFzIiwidXNlckNvbnRleHRBdHRyaWJ1dGVzIiwid2ViZ2xJZGVudGlmaWVycyIsImNvbnRleHQiLCJjb250ZXh0QXR0cmlidXRlcyIsInByZXNlcnZlRHJhd2luZ0J1ZmZlciIsImFudGlhbGlhcyIsIm9uV2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvciIsInN0YXR1c01lc3NhZ2UiLCJnZXRDb250ZXh0IiwidCIsImNyZWF0ZVRleHR1cmUiLCJ0ZXh0dXJlVGFyZ2V0IiwidGV4dHVyZSIsImJpbmRUZXh0dXJlIiwidGV4UGFyYW1ldGVyaSIsIlRFWFRVUkVfTUFHX0ZJTFRFUiIsIkxJTkVBUiIsIlRFWFRVUkVfTUlOX0ZJTFRFUiIsIlRFWFRVUkVfV1JBUF9TIiwiQ0xBTVBfVE9fRURHRSIsIlRFWFRVUkVfV1JBUF9UIiwiaXNXZWJHTEF2YWlsYWJsZSIsIndlYmdsQ29udGV4dCIsIldlYkdMVXRpbHMiLCJsb3NlQ29udGV4dEV4dGVuc2lvbiIsImdldEV4dGVuc2lvbiIsImxvc2VDb250ZXh0IiwiaXNTdGFibGVXZWJHTCIsImFnZW50SW5mbyIsImlzU3RhYmxlV2ViZ2wiLCJvcyIsIm5hbWUiLCJwYXJzZUZsb2F0IiwiYnJvd3NlciIsImdldEVycm9yTmFtZUZyb21XZWJHTEVycm9yQ29kZSIsImNvZGUiLCJ0ZXhJbWFnZTJEIiwicGl4ZWxzIiwiUkdCQSIsIlVOU0lHTkVEX0JZVEUiLCJlcnJvciIsImNvbnNvbGUiLCJnZXRNYXhUZXh0dXJlU2l6ZSIsImdldFBhcmFtZXRlciIsIk1BWF9URVhUVVJFX1NJWkUiLCJzZXRNYXhUZXh0dXJlU2l6ZUZvclRlc3RPbmx5UHVycG9zZSIsInNpemUiLCJpc0lFMTEiLCJFVkVOVFMiLCJSZW5kZXJlciIsIl9mb3JjZURpbWVuc2lvbiIsIl9waXhlbENhbnZhcyIsIl9waXhlbENvbnRleHQiLCJnZXREaW1lbnNpb24iLCJwaXhlbFNvdXJjZSIsIndpZHRoIiwidmlkZW9XaWR0aCIsIm5hdHVyYWxIZWlnaHQiLCJ2aWRlb0hlaWdodCIsInVwZGF0ZVNoYWRlckRhdGEiLCJfaW5pdFBpeGVsU291cmNlIiwiZm9yY2VEaW1lbnNpb24iLCJpc0lFMTFWaWRlbyIsIl9nZXRQaXhlbFNvdXJjZSIsImNvbnRlbnREaW1lbnNpb24iLCJ0ZXh0dXJlRGltZW5zaW9uIiwiZHJhd0ltYWdlIiwiX2V4dHJhY3RUaWxlQ29uZmlnIiwiaW1hZ2VDb25maWciLCJ0aWxlQ29uZmlnIiwiaXNBcnJheSIsImNvbmZpZyIsImZsaXBIb3Jpem9udGFsIiwicm90YXRpb24iLCJfdHJpZ2dlckVycm9yIiwibWVzc2FnZSIsIkN1YmVSZW5kZXJlciIsImdldFZlcnRleFBvc2l0aW9uRGF0YSIsIl9WRVJURVhfUE9TSVRJT05fREFUQSIsImdldEluZGV4RGF0YSIsIl9JTkRFWF9EQVRBIiwiaW5kZXhEYXRhIiwidmVydGV4UG9zaXRpb25EYXRhIiwiZXh0cmFjdE9yZGVyIiwib3JkZXIiLCJnZXRUZXh0dXJlQ29vcmREYXRhIiwidmVydGV4T3JkZXIiLCJiYXNlIiwiZWxlbVNpemUiLCJ2ZXJ0ZXhQZXJUaWxlIiwidGV4dHVyZUNvb3JkRGF0YSIsInNwbGl0IiwiZmFjZSIsIm9yZGVybWFwXyIsInNoaWZ0IiwidW5zaGlmdCIsInBvcCIsImVsZW1QZXJUaWxlIiwidGlsZVZlcnRleCIsInNsaWNlIiwidGlsZVRlbXAiLCJqIiwic3BsaWNlIiwiam9pbiIsImdldFZlcnRleFNoYWRlclNvdXJjZSIsImdldEZyYWdtZW50U2hhZGVyU291cmNlIiwidXBkYXRlVGV4dHVyZSIsImJhc2VPcmRlciIsIm9yZGVyTWFwIiwic3VyZmFjZUlkeCIsInRpbGVJZHgiLCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1giLCJtYXhDdWJlTWFwVGV4dHVyZVNpemUiLCJnZXRNYXhDdWJlTWFwVGV4dHVyZVNpemUiLCJ0aWxlIiwiZXh0cmFjdFRpbGVGcm9tSW1hZ2UiLCJURVhUVVJFX0NVQkVfTUFQIiwiZ2V0U291cmNlVGlsZVNpemUiLCJpbnB1dFRleHR1cmVTaXplIiwib3V0cHV0VGV4dHVyZVNpemUiLCJ0aWxlUGVyUm93IiwiYWdlbnQiLCJNQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFIiwiX2ltYWdlV2lkdGgiLCJtaW4iLCJfdmVydGljZXMiLCJpbmRpY2VzIiwiY29scyIsInJvd3MiLCJjb29yZHMiLCJjb29yZCIsInRpbGVDb25maWdzIiwiX3Nocmlua0Nvb3JkIiwiX3RyYW5zZm9ybUNvb3JkIiwiaW5kZXgiLCJ2YWwiLCJjb25jYXQiLCJURVhUVVJFXzJEIiwibWF4U2l6ZSIsImFjdGl2ZVRleHR1cmUiLCJURVhUVVJFMCIsInBpeGVsU3RvcmVpIiwiVU5QQUNLX0ZMSVBfWV9XRUJHTCIsIm5ld0Nvb3JkIiwiX2ZsaXBIb3Jpem9udGFsQ29vcmQiLCJfcm90YXRlQ29vcmQiLCJTSFJJTktfWSIsIlNIUklOS19YIiwicm90YXRpb25BbmdsZSIsIlNJWkUiLCJzaGlmdENvdW50IiwibW92ZWQiLCJyb3RhdGVkQ29vcmQiLCJsYXRpdHVkZUJhbmRzIiwibG9uZ2l0dWRlQmFuZHMiLCJyYWRpdXMiLCJBTkdMRV9DT1JSRUNUSU9OX0ZPUl9DRU5URVJfQUxJR04iLCJsYXRJZHgiLCJwaGkiLCJzaW5QaGkiLCJjb3NQaGkiLCJTcGhlcmVSZW5kZXJlciIsIl9pc1N0ZXJlb3Njb3BpYyIsImlzU3RlcmVvc2NvcGljIiwiX1RFWFRVUkVfQ09PUkRfREFUQSIsIk1JTl9BU1BFQ1RfUkFUSU9fRk9SX0ZVTExfUEFOT1JBTUEiLCJDeWxpbmRlclJlbmRlcmVyIiwicmVzaXplRGltZW5zaW9uIiwiaW1hZ2VBc3BlY3RSYXRpbyIsImxuZ0lkeCIsImN5bGluZGVyTWF4UmFkaWFuIiwiaGFsZkN5bGluZGVyWSIsInJvdGF0ZWQiLCJDWUxJREVSX1kiLCJzdGFydEFuZ2xlRm9yQ2VudGVyQWxpZ24iLCJ5SWR4IiwieUxlbmd0aCIsInUiLCJFUlJPUl9UWVBFIiwiSU5WQUxJRF9ERVZJQ0UiLCJOT19XRUJHTCIsIkZBSUxfSU1BR0VfTE9BRCIsIkZBSUxfQklORF9URVhUVVJFIiwiSU5WQUxJRF9SRVNPVVJDRSIsIlJFTkRFUklOR19DT05URVhUX0xPU1QiLCJSRUFEWSIsIlZJRVdfQ0hBTkdFIiwiQU5JTUFUSU9OX0VORCIsIlBST0pFQ1RJT05fVFlQRSIsIkVRVUlSRUNUQU5HVUxBUiIsIkNVQkVNQVAiLCJDVUJFU1RSSVAiLCJQQU5PUkFNQSIsIlNURVJFT1NDT1BJQ19FUVVJIiwiSW1hZ2VUeXBlIiwiREVWSUNFX1BJWEVMX1JBVElPIiwiQklORF9URVhUVVJFIiwiSU1BR0VfTE9BREVEIiwiUkVOREVSSU5HX0NPTlRFWFRfUkVTVE9SRSIsIlJFTkRFUkVSX0VSUk9SIiwiUGFub0ltYWdlUmVuZGVyZXIiLCJpc1ZpZGVvIiwic3BoZXJpY2FsQ29uZmlnIiwicmVuZGVyaW5nQ29udGV4dEF0dHJpYnV0ZXMiLCJmaWVsZE9mVmlldyIsIl9sYXN0UXVhdGVybmlvbiIsIl9sYXN0WWF3IiwiX2xhc3RQaXRjaCIsIl9sYXN0RmllbGRPZlZpZXciLCJwTWF0cml4IiwibXZNYXRyaXgiLCJ0ZXh0dXJlQ29vcmRCdWZmZXIiLCJ2ZXJ0ZXhCdWZmZXIiLCJpbmRleEJ1ZmZlciIsIl9pbml0Q2FudmFzIiwiX3JlbmRlcmluZ0NvbnRleHRBdHRyaWJ1dGVzIiwiX2ltYWdlQ29uZmlnIiwiX2ltYWdlSXNSZWFkeSIsIl9zaG91bGRGb3JjZURyYXciLCJfa2VlcFVwZGF0ZSIsIl9vbkNvbnRlbnRMb2FkIiwiX29uQ29udGVudEVycm9yIiwic2V0SW1hZ2UiLCJpbWFnZVR5cGUiLCJjdWJlbWFwQ29uZmlnIiwiZ2V0Q29udGVudCIsIl9pc1ZpZGVvIiwiZmxpcEhpcm96b250YWwiLCJfc2V0SW1hZ2VUeXBlIiwiX2NvbnRlbnRMb2FkZXIiLCJfaW1hZ2VUeXBlIiwiX2lzQ3ViZU1hcCIsIl9yZW5kZXJlciIsIl9pbml0V2ViR0wiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJtYXJnaW4iLCJtYXhIZWlnaHQiLCJtYXhXaWR0aCIsIm91dGxpbmUiLCJwb3NpdGlvbiIsIl9vbldlYmdsY29udGV4dGxvc3QiLCJfb25XZWJnbGNvbnRleHRyZXN0b3JlZCIsIl90cmlnZ2VyQ29udGVudExvYWQiLCJjb250ZW50IiwicHJvamVjdGlvblR5cGUiLCJpc0ltYWdlTG9hZGVkIiwiX2JpbmRUZXh0dXJlIiwiYXR0YWNoVG8iLCJwYXJlbnRFbGVtZW50IiwiZGV0YWNoIiwiZm9yY2VDb250ZXh0TG9zcyIsImhhc1JlbmRlcmluZ0NvbnRleHQiLCJyZW1vdmVDaGlsZCIsImlzQ29udGV4dExvc3QiLCJzaGFkZXJQcm9ncmFtIiwicHJldmVudERlZmF1bHQiLCJ1cGRhdGVGaWVsZE9mVmlldyIsIl91cGRhdGVWaWV3cG9ydCIsInVwZGF0ZVZpZXdwb3J0RGltZW5zaW9ucyIsInZpZXdQb3J0Q2hhbmdlZCIsImgiLCJ2aWV3cG9ydCIsImRyYXdpbmdCdWZmZXJXaWR0aCIsImRyYXdpbmdCdWZmZXJIZWlnaHQiLCJfaW5pdFJlbmRlcmluZ0NvbnRleHQiLCJfaW5pdFNoYWRlclByb2dyYW0iLCJFcnJvciIsImdldEVycm9yIiwiY2xlYXJDb2xvciIsImRlbGV0ZVRleHR1cmUiLCJDVUxMX0ZBQ0UiLCJXZWJHTFJlbmRlcmluZ0NvbnRleHQiLCJ2ZXJ0ZXhTaGFkZXJTb3VyY2UiLCJWRVJURVhfU0hBREVSIiwiZnJhZ21lbnRTaGFkZXJTb3VyY2UiLCJGUkFHTUVOVF9TSEFERVIiLCJ1c2VQcm9ncmFtIiwidmVydGV4UG9zaXRpb25BdHRyaWJ1dGUiLCJnZXRBdHRyaWJMb2NhdGlvbiIsInBNYXRyaXhVbmlmb3JtIiwiZ2V0VW5pZm9ybUxvY2F0aW9uIiwibXZNYXRyaXhVbmlmb3JtIiwic2FtcGxlclVuaWZvcm0iLCJ0ZXh0dXJlQ29vcmRBdHRyaWJ1dGUiLCJjbGVhciIsIkNPTE9SX0JVRkZFUl9CSVQiLCJERVBUSF9CVUZGRVJfQklUIiwiU1RFTkNJTF9CVUZGRVJfQklUIiwidW5pZm9ybTFpIiwiX2luaXRCdWZmZXJzIiwiQVJSQVlfQlVGRkVSIiwiRUxFTUVOVF9BUlJBWV9CVUZGRVIiLCJVaW50MTZBcnJheSIsImlzRUFDIiwidW5pZm9ybTFmIiwiX3VwZGF0ZVRleHR1cmUiLCJrZWVwVXBkYXRlIiwiZG9VcGRhdGUiLCJyZW5kZXJXaXRoUXVhdGVybmlvbiIsIl9kcmF3IiwicmVuZGVyIiwidW5pZm9ybU1hdHJpeDRmdiIsImRyYXdFbGVtZW50cyIsIlRSSUFOR0xFUyIsIlVOU0lHTkVEX1NIT1JUIiwiZ2V0UHJvamVjdGlvblJlbmRlcmVyIiwiUGFub1ZpZXdlciIsImNvbnRhaW5lciIsIl9jb250YWluZXIiLCJfcHJvamVjdGlvblR5cGUiLCJfY3ViZW1hcENvbmZpZyIsIl93aWR0aCIsIl9oZWlnaHQiLCJfeWF3IiwiX3BpdGNoIiwiX2ZvdiIsIl9neXJvTW9kZSIsIl9hc3BlY3RSYXRpbyIsIl9pc1ZhbGlkVG91Y2hEaXJlY3Rpb24iLCJ5YXdQaXRjaENvbmZpZyIsIl9pc1JlYWR5IiwiX2luaXRZYXdQaXRjaENvbnRyb2wiLCJfaW5pdFJlbmRlcmVyIiwiZ2V0VmlkZW8iLCJfcGhvdG9TcGhlcmVSZW5kZXJlciIsInNldFZpZGVvIiwiZ2V0SW1hZ2UiLCJ3YXJuIiwiX2RlYWN0aXZhdGUiLCJnZXRQcm9qZWN0aW9uVHlwZSIsImluaXRpYWxZYXciLCJpbml0aWFsUGl0Y2giLCJfYmluZFJlbmRlcmVySGFuZGxlciIsIl9hY3RpdmF0ZSIsIl90cmlnZ2VyRXZlbnQiLCJfdXBkYXRlWWF3UGl0Y2hJZk5lZWRlZCIsIlByb2plY3Rpb25UeXBlIiwieWF3U2l6ZSIsIm1heEZvdiIsImF0YW4iLCJtaW5Gb3YiLCJfeWF3UGl0Y2hDb250cm9sIiwic2V0VXNlWm9vbSIsInNldFVzZUtleWJvYXJkIiwic2V0R3lyb01vZGUiLCJzZXRGb3ZSYW5nZSIsImdldEZvdlJhbmdlIiwiY29udGFpbmVyU2l6ZSIsIl9nZXRIRm92IiwiZ2V0WWF3UmFuZ2UiLCJnZXRQaXRjaFJhbmdlIiwic2V0WWF3UmFuZ2UiLCJzZXRQaXRjaFJhbmdlIiwic2V0U2hvd1BvbGVQb2ludCIsInZlcnRpY2FsQW5nbGVPZkltYWdlIiwiX3N0YXJ0UmVuZGVyIiwiX3JlbmRlckxvb3AiLCJfcmVuZGVyTG9vcEZvck5leHRUaWNrIiwiX3JhZklkIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiX3JlbmRlciIsImJlZm9yZSIsInBlcmZvcm1hbmNlIiwibm93IiwiZGlmZiIsIl9yYWZUaW1lciIsIl9zdG9wUmVuZGVyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJUT1VDSF9ESVJFQ1RJT04iLCJZQVciLCJQSVRDSCIsIkFMTCIsInNldFRvdWNoRGlyZWN0aW9uIiwiZ2V0VG91Y2hEaXJlY3Rpb24iLCJpc1N1cHBvcnRlZCIsImNhbGxiYWNrIiwib25EZXZpY2VNb3Rpb25DaGFuZ2UiLCJjaGVja0d5cm8iLCJ0aW1l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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7O0FBRXhDLHFCQ0FBLG1CREFBLENDQUEsRURBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7O0FFL1NBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLEtBQUs7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztzREMzdEJBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLFNBQVM7QUFDckI7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxLQUFLO0FBQ0wsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4Qix5Q0FBeUMscUJBQXFCOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLGlCQUFpQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQUE7QUFDSCxFQUFFLFFBYUY7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNwaEJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3JCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7Ozs7Ozs7O0FDbkJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBLDZCQUE2QixZQUFZLElBQUksSUFBSSxNQUFNLElBQUk7QUFDM0Q7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsS0FBSyxRQUlMO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7OztBQ3pQRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCOzs7Ozs7MERDNUNBO0FBQ0EsYUFBYSxTQUEyRCxtQkFBbUIsZUFBcU4sQ0FBZ0IsYUFBYSwwQkFBMEIsbUJBQW1CLGtCQUFrQixnQkFBZ0IsVUFBVSxVQUFVLDBDQUEwQyw4QkFBd0Isb0JBQW9CLDhDQUE4QyxrQ0FBa0MsWUFBWSxZQUFZLG1DQUFtQyxpQkFBaUIsZUFBZSxzQkFBc0Isb0JBQW9CLGtEQUFrRCxXQUFXLFlBQVksU0FBUyxTQUFTLEtBQUs7QUFDM3pCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsRUFBRSxrQ0FBa0M7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsRUFBRSwwQkFBMEI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsZ0NBQWdDO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsMEJBQTBCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSwrQkFBK0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsdUlBQXVJO0FBQzFJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxtRUFBbUU7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsc0ZBQXNGO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSxzSEFBc0g7QUFDekg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSx3TkFBd047QUFDM047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUFFRCxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSwwUUFBMFE7QUFDN1E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsb0NBQW9DO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxvRkFBb0Y7QUFDdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUscURBQXFEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSx5R0FBeUc7QUFDNUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBCQUEwQixxREFBcUQsbUJBQW1CLFdBQVc7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLGtJQUFrSTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsb0NBQW9DO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLHdEQUF3RDtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUseUdBQXlHO0FBQzVHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLGlDQUFpQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxDQUFDLEVBQUUsV0FBVztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsRUFBRSxjQUFjO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvREFBb0Q7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDhCQUE4QjtBQUN2RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSw2QkFBNkI7QUFDN0YsdUVBQXVFLGlDQUFpQztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0EsdUNBQXVDLFVBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZix3REFBd0QsMEVBQTBFLE9BQU8sMEJBQTBCLFNBQVM7QUFDNUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0VBQWdFLGdCQUFnQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwyQkFBMkI7QUFDNUY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDLDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnQkFBZ0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsa0JBQWtCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkZBQTZGO0FBQ3JILG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtR0FBbUc7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtR0FBbUc7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVU7QUFDbkQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVELENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RCxHQUFHO0FBQ0gsc0NBQXNDO0FBQ3RDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGNBQWM7QUFDekIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHlCQUF5QjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxFQUFFLHVDQUF1QyxFQUFFLEdBQUc7QUFDL0MsQ0FBQzs7O0FBR0Q7Ozs7Ozs7OztBQ3hyTGE7QUFDYjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQSxHQUFHLEVBQUU7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRTs7Ozs7OztBQzFIQTs7QUFFQTs7QUFFQTtBQUNBLG1EQUFtRCxJQUFJLFNBQVMsTUFBTSxJQUFJOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsR0FBRztBQUNIO0FBQ0Esc0JBQXNCO0FBQ3RCLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtB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QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNILG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFDQTtBQUNBLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGOztBQUVoRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZDtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDZDQUE2QztBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQixVQUFVLE9BQU87QUFDakI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZDtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQixVQUFVLFNBQVM7QUFDbkI7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0EsV0FBVztBQUNYOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckIsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQ7Ozs7Ozs7O0FDOXBDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7Ozs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7Ozs7Ozs7QUNwV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsazdEQUFrN0Q7QUFDajhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUcsQ0FBQyxDQUFELENBQUgsR0FBUyxDQUFUO0FBQ0FBLEtBQUcsQ0FBQyxDQUFELENBQUgsR0FBUyxDQUFUO0FBQ0FBLEtBQUcsQ0FBQyxDQUFELENBQUgsR0FBUyxDQUFUO0FBQ0FBLEtBQUcsQ0FBQyxDQUFELENBQUgsR0FBUyxDQUFUO0FBQ0FBLEtBQUcsQ0FBQyxDQUFELENBQUgsR0FBUyxDQUFUO0FBQ0FBLEtBQUcsQ0FBQyxFQUFELENBQUgsR0FBVSxDQUFWO0FBQ0FBLEtBQUcsQ0FBQyxFQUFELENBQUgsR0FBVSxDQUFWO0FBQ0FBLEtBQUcsQ0FBQyxFQUFELENBQUgsR0FBVSxDQUFWO0FBQ0FBLEtBQUcsQ0FBQyxFQUFELENBQUgsR0FBVSxDQUFWO0FBQ0FBLEtBQUcsQ0FBQyxFQUFELENBQUgsR0FBVSxDQUFWO0FBQ0FBLEtBQUcsQ0FBQyxFQUFELENBQUgsR0FBVSxDQUFWO0FBQ0EsU0FBT0EsR0FBUDtBQUNILENBbkJEO0FBcUJBOzs7Ozs7OztBQU1BOEQsSUFBSSxDQUFDQyxRQUFMLEdBQWdCLFVBQVMvRCxHQUFULEVBQWM7QUFDMUJBLEtBQUcsQ0FBQyxDQUFELENBQUgsR0FBUyxDQUFUO0FBQ0FBLEtBQUcsQ0FBQyxDQUFELENBQUgsR0FBUyxDQUFUO0FBQ0FBLEtBQUcsQ0FBQyxDQUFELENBQUgsR0FBUyxDQUFUO0FBQ0FBLEtBQUcsQ0FBQyxDQUFELENBQUgsR0FBUyxDQUFUO0FBQ0FBLEtBQUcsQ0FBQyxDQUFELENBQUgsR0FBUyxDQUFUO0FBQ0FBLEtBQUcsQ0FBQyxDQUFELENBQUgsR0FBUyxDQUFUO0FBQ0FBLEtBQUcsQ0FBQyxDQUFELENBQUgsR0FBUyxDQUFUO0FBQ0FBLEtBQUcsQ0FBQyxDQUFELENBQUgsR0FBUyxDQUFUO0FBQ0FBLEtBQUcsQ0FBQyxDQUFELENBQUgsR0FBUyxDQUFUO0FBQ0FBLEtBQUcsQ0FBQyxDQUFELENBQUgsR0FBUyxDQUFUO0FBQ0FBLEtBQUcsQ0FBQyxFQUFELENBQUgsR0FBVSxDQUFWO0FBQ0FBLEtBQUcsQ0FBQyxFQUFELENBQUgsR0FB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QUFlLENBQUNweUIscUJBOUJDOztBQStCeEI7Ozs7Ozs7OztBQVNBcXlCLE9BQUcsRUFBRSwrQkFBZSxDQUFDcHlCO0FBeENHLEc7U0F6QkxtdUIsVSIsImZpbGUiOiJQYW5vVmlld2VyL3ZpZXczNjAucGFub3ZpZXdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIkBlZ2pzL2NvbXBvbmVudFwiKSwgcmVxdWlyZShcIkBlZ2pzL2F4ZXNcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJ2aWV3MzYwXCIsIFtcIkBlZ2pzL2NvbXBvbmVudFwiLCBcIkBlZ2pzL2F4ZXNcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1widmlldzM2MFwiXSA9IGZhY3RvcnkocmVxdWlyZShcIkBlZ2pzL2NvbXBvbmVudFwiKSwgcmVxdWlyZShcIkBlZ2pzL2F4ZXNcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImVnXCJdID0gcm9vdFtcImVnXCJdIHx8IHt9LCByb290W1wiZWdcIl1bXCJ2aWV3MzYwXCJdID0gZmFjdG9yeShyb290W1wiZWdcIl1bXCJDb21wb25lbnRcIl0sIHJvb3RbXCJlZ1wiXVtcIkF4ZXNcIl0pO1xufSkod2luZG93LCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18yOF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zMV9fKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDM5KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBfX3Jlc291cmNlUXVlcnkgV29ya2VyR2xvYmFsU2NvcGUgc2VsZiAqL1xuXG4vKiBlc2xpbnQgcHJlZmVyLWRlc3RydWN0dXJpbmc6IG9mZiAqL1xuXG52YXIgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbnZhciBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG5cbnZhciBsb2cgPSByZXF1aXJlKCdsb2dsZXZlbCcpLmdldExvZ2dlcignd2VicGFjay1kZXYtc2VydmVyJyk7XG5cbnZhciBzb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG52YXIgb3ZlcmxheSA9IHJlcXVpcmUoJy4vb3ZlcmxheScpO1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0U291cmNlKCkge1xuICAvLyBgZG9jdW1lbnQuY3VycmVudFNjcmlwdGAgaXMgdGhlIG1vc3QgYWNjdXJhdGUgd2F5IHRvIGZpbmQgdGhlIGN1cnJlbnQgc2NyaXB0LFxuICAvLyBidXQgaXMgbm90IHN1cHBvcnRlZCBpbiBhbGwgYnJvd3NlcnMuXG4gIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgfSAvLyBGYWxsIGJhY2sgdG8gZ2V0dGluZyBhbGwgc2NyaXB0cyBpbiB0aGUgZG9jdW1lbnQuXG5cblxuICB2YXIgc2NyaXB0RWxlbWVudHMgPSBkb2N1bWVudC5zY3JpcHRzIHx8IFtdO1xuICB2YXIgY3VycmVudFNjcmlwdCA9IHNjcmlwdEVsZW1lbnRzW3NjcmlwdEVsZW1lbnRzLmxlbmd0aCAtIDFdO1xuXG4gIGlmIChjdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgfSAvLyBGYWlsIGFzIHRoZXJlIHdhcyBubyBzY3JpcHQgdG8gdXNlLlxuXG5cbiAgdGhyb3cgbmV3IEVycm9yKCdbV0RTXSBGYWlsZWQgdG8gZ2V0IGN1cnJlbnQgc2NyaXB0IHNvdXJjZS4nKTtcbn1cblxudmFyIHVybFBhcnRzO1xudmFyIGhvdFJlbG9hZCA9IHRydWU7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB2YXIgcXMgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnRvTG93ZXJDYXNlKCk7XG4gIGhvdFJlbG9hZCA9IHFzLmluZGV4T2YoJ2hvdHJlbG9hZD1mYWxzZScpID09PSAtMTtcbn1cblxuaWYgKHR5cGVvZiBfX3Jlc291cmNlUXVlcnkgPT09ICdzdHJpbmcnICYmIF9fcmVzb3VyY2VRdWVyeSkge1xuICAvLyBJZiB0aGlzIGJ1bmRsZSBpcyBpbmxpbmVkLCB1c2UgdGhlIHJlc291cmNlIHF1ZXJ5IHRvIGdldCB0aGUgY29ycmVjdCB1cmwuXG4gIHVybFBhcnRzID0gdXJsLnBhcnNlKF9fcmVzb3VyY2VRdWVyeS5zdWJzdHIoMSkpO1xufSBlbHNlIHtcbiAgLy8gRWxzZSwgZ2V0IHRoZSB1cmwgZnJvbSB0aGUgPHNjcmlwdD4gdGhpcyBmaWxlIHdhcyBjYWxsZWQgd2l0aC5cbiAgdmFyIHNjcmlwdEhvc3QgPSBnZXRDdXJyZW50U2NyaXB0U291cmNlKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuXG4gIHNjcmlwdEhvc3QgPSBzY3JpcHRIb3N0LnJlcGxhY2UoL1xcL1teXFwvXSskLywgJycpO1xuICB1cmxQYXJ0cyA9IHVybC5wYXJzZShzY3JpcHRIb3N0IHx8ICcvJywgZmFsc2UsIHRydWUpO1xufVxuXG5pZiAoIXVybFBhcnRzLnBvcnQgfHwgdXJsUGFydHMucG9ydCA9PT0gJzAnKSB7XG4gIHVybFBhcnRzLnBvcnQgPSBzZWxmLmxvY2F0aW9uLnBvcnQ7XG59XG5cbnZhciBfaG90ID0gZmFsc2U7XG52YXIgaW5pdGlhbCA9IHRydWU7XG52YXIgY3VycmVudEhhc2ggPSAnJztcbnZhciB1c2VXYXJuaW5nT3ZlcmxheSA9IGZhbHNlO1xudmFyIHVzZUVycm9yT3ZlcmxheSA9IGZhbHNlO1xudmFyIHVzZVByb2dyZXNzID0gZmFsc2U7XG52YXIgSU5GTyA9ICdpbmZvJztcbnZhciBXQVJOSU5HID0gJ3dhcm5pbmcnO1xudmFyIEVSUk9SID0gJ2Vycm9yJztcbnZhciBOT05FID0gJ25vbmUnOyAvLyBTZXQgdGhlIGRlZmF1bHQgbG9nIGxldmVsXG5cbmxvZy5zZXREZWZhdWx0TGV2ZWwoSU5GTyk7IC8vIFNlbmQgbWVzc2FnZXMgdG8gdGhlIG91dHNpZGUsIHNvIHBsdWdpbnMgY2FuIGNvbnN1bWUgaXQuXG5cbmZ1bmN0aW9uIHNlbmRNc2codHlwZSwgZGF0YSkge1xuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPT09ICd1bmRlZmluZWQnIHx8ICEoc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSkpIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6IFwid2VicGFja1wiLmNvbmNhdCh0eXBlKSxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9LCAnKicpO1xuICB9XG59XG5cbnZhciBvblNvY2tldE1zZyA9IHtcbiAgaG90OiBmdW5jdGlvbiBob3QoKSB7XG4gICAgX2hvdCA9IHRydWU7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgZW5hYmxlZC4nKTtcbiAgfSxcbiAgaW52YWxpZDogZnVuY3Rpb24gaW52YWxpZCgpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIHVwZGF0ZWQuIFJlY29tcGlsaW5nLi4uJyk7IC8vIGZpeGVzICMxMDQyLiBvdmVybGF5IGRvZXNuJ3QgY2xlYXIgaWYgZXJyb3JzIGFyZSBmaXhlZCBidXQgd2FybmluZ3MgcmVtYWluLlxuXG4gICAgaWYgKHVzZVdhcm5pbmdPdmVybGF5IHx8IHVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5jbGVhcigpO1xuICAgIH1cblxuICAgIHNlbmRNc2coJ0ludmFsaWQnKTtcbiAgfSxcbiAgaGFzaDogZnVuY3Rpb24gaGFzaChfaGFzaCkge1xuICAgIGN1cnJlbnRIYXNoID0gX2hhc2g7XG4gIH0sXG4gICdzdGlsbC1vayc6IGZ1bmN0aW9uIHN0aWxsT2soKSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIE5vdGhpbmcgY2hhbmdlZC4nKTtcblxuICAgIGlmICh1c2VXYXJuaW5nT3ZlcmxheSB8fCB1c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBzZW5kTXNnKCdTdGlsbE9rJyk7XG4gIH0sXG4gICdsb2ctbGV2ZWwnOiBmdW5jdGlvbiBsb2dMZXZlbChsZXZlbCkge1xuICAgIHZhciBob3RDdHggPSByZXF1aXJlLmNvbnRleHQoJ3dlYnBhY2svaG90JywgZmFsc2UsIC9eXFwuXFwvbG9nJC8pO1xuXG4gICAgaWYgKGhvdEN0eC5rZXlzKCkuaW5kZXhPZignLi9sb2cnKSAhPT0gLTEpIHtcbiAgICAgIGhvdEN0eCgnLi9sb2cnKS5zZXRMb2dMZXZlbChsZXZlbCk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgY2FzZSBJTkZPOlxuICAgICAgY2FzZSBFUlJPUjpcbiAgICAgICAgbG9nLnNldExldmVsKGxldmVsKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgV0FSTklORzpcbiAgICAgICAgLy8gbG9nbGV2ZWwncyB3YXJuaW5nIG5hbWUgaXMgZGlmZmVyZW50IGZyb20gd2VicGFjaydzXG4gICAgICAgIGxvZy5zZXRMZXZlbCgnd2FybicpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBOT05FOlxuICAgICAgICBsb2cuZGlzYWJsZUFsbCgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbG9nLmVycm9yKFwiW1dEU10gVW5rbm93biBjbGllbnRMb2dMZXZlbCAnXCIuY29uY2F0KGxldmVsLCBcIidcIikpO1xuICAgIH1cbiAgfSxcbiAgb3ZlcmxheTogZnVuY3Rpb24gb3ZlcmxheSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdXNlV2FybmluZ092ZXJsYXkgPSBmYWxzZTtcbiAgICAgICAgdXNlRXJyb3JPdmVybGF5ID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIHVzZVdhcm5pbmdPdmVybGF5ID0gdmFsdWUud2FybmluZ3M7XG4gICAgICAgIHVzZUVycm9yT3ZlcmxheSA9IHZhbHVlLmVycm9ycztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHByb2dyZXNzOiBmdW5jdGlvbiBwcm9ncmVzcyhfcHJvZ3Jlc3MpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdXNlUHJvZ3Jlc3MgPSBfcHJvZ3Jlc3M7XG4gICAgfVxuICB9LFxuICAncHJvZ3Jlc3MtdXBkYXRlJzogZnVuY3Rpb24gcHJvZ3Jlc3NVcGRhdGUoZGF0YSkge1xuICAgIGlmICh1c2VQcm9ncmVzcykge1xuICAgICAgbG9nLmluZm8oXCJbV0RTXSBcIi5jb25jYXQoZGF0YS5wZXJjZW50LCBcIiUgLSBcIikuY29uY2F0KGRhdGEubXNnLCBcIi5cIikpO1xuICAgIH1cblxuICAgIHNlbmRNc2coJ1Byb2dyZXNzJywgZGF0YSk7XG4gIH0sXG4gIG9rOiBmdW5jdGlvbiBvaygpIHtcbiAgICBzZW5kTXNnKCdPaycpO1xuXG4gICAgaWYgKHVzZVdhcm5pbmdPdmVybGF5IHx8IHVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5jbGVhcigpO1xuICAgIH1cblxuICAgIGlmIChpbml0aWFsKSB7XG4gICAgICByZXR1cm4gaW5pdGlhbCA9IGZhbHNlO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXR1cm4tYXNzaWduXG5cblxuICAgIHJlbG9hZEFwcCgpO1xuICB9LFxuICAnY29udGVudC1jaGFuZ2VkJzogZnVuY3Rpb24gY29udGVudENoYW5nZWQoKSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIENvbnRlbnQgYmFzZSBjaGFuZ2VkLiBSZWxvYWRpbmcuLi4nKTtcbiAgICBzZWxmLmxvY2F0aW9uLnJlbG9hZCgpO1xuICB9LFxuICB3YXJuaW5nczogZnVuY3Rpb24gd2FybmluZ3MoX3dhcm5pbmdzKSB7XG4gICAgbG9nLndhcm4oJ1tXRFNdIFdhcm5pbmdzIHdoaWxlIGNvbXBpbGluZy4nKTtcblxuICAgIHZhciBzdHJpcHBlZFdhcm5pbmdzID0gX3dhcm5pbmdzLm1hcChmdW5jdGlvbiAod2FybmluZykge1xuICAgICAgcmV0dXJuIHN0cmlwQW5zaSh3YXJuaW5nKTtcbiAgICB9KTtcblxuICAgIHNlbmRNc2coJ1dhcm5pbmdzJywgc3RyaXBwZWRXYXJuaW5ncyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlwcGVkV2FybmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxvZy53YXJuKHN0cmlwcGVkV2FybmluZ3NbaV0pO1xuICAgIH1cblxuICAgIGlmICh1c2VXYXJuaW5nT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5zaG93TWVzc2FnZShfd2FybmluZ3MpO1xuICAgIH1cblxuICAgIGlmIChpbml0aWFsKSB7XG4gICAgICByZXR1cm4gaW5pdGlhbCA9IGZhbHNlO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXR1cm4tYXNzaWduXG5cblxuICAgIHJlbG9hZEFwcCgpO1xuICB9LFxuICBlcnJvcnM6IGZ1bmN0aW9uIGVycm9ycyhfZXJyb3JzKSB7XG4gICAgbG9nLmVycm9yKCdbV0RTXSBFcnJvcnMgd2hpbGUgY29tcGlsaW5nLiBSZWxvYWQgcHJldmVudGVkLicpO1xuXG4gICAgdmFyIHN0cmlwcGVkRXJyb3JzID0gX2Vycm9ycy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKGVycm9yKTtcbiAgICB9KTtcblxuICAgIHNlbmRNc2coJ0Vycm9ycycsIHN0cmlwcGVkRXJyb3JzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaXBwZWRFcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxvZy5lcnJvcihzdHJpcHBlZEVycm9yc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKHVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5zaG93TWVzc2FnZShfZXJyb3JzKTtcbiAgICB9XG5cbiAgICBpbml0aWFsID0gZmFsc2U7XG4gIH0sXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcihfZXJyb3IpIHtcbiAgICBsb2cuZXJyb3IoX2Vycm9yKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGxvZy5lcnJvcignW1dEU10gRGlzY29ubmVjdGVkIScpO1xuICAgIHNlbmRNc2coJ0Nsb3NlJyk7XG4gIH1cbn07XG52YXIgaG9zdG5hbWUgPSB1cmxQYXJ0cy5ob3N0bmFtZTtcbnZhciBwcm90b2NvbCA9IHVybFBhcnRzLnByb3RvY29sO1xudmFyIHBvcnQgPSB1cmxQYXJ0cy5wb3J0OyAvLyBjaGVjayBpcHY0IGFuZCBpcHY2IGBhbGwgaG9zdG5hbWVgXG5cbmlmIChob3N0bmFtZSA9PT0gJzAuMC4wLjAnIHx8IGhvc3RuYW1lID09PSAnOjonKSB7XG4gIC8vIHdoeSBkbyB3ZSBuZWVkIHRoaXMgY2hlY2s/XG4gIC8vIGhvc3RuYW1lIG4vYSBmb3IgZmlsZSBwcm90b2NvbCAoZXhhbXBsZSwgd2hlbiB1c2luZyBlbGVjdHJvbiwgaW9uaWMpXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMzg0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gIGlmIChzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICYmICEhfnNlbGYubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cCcpKSB7XG4gICAgaG9zdG5hbWUgPSBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgIHBvcnQgPSBzZWxmLmxvY2F0aW9uLnBvcnQ7XG4gIH1cbn0gLy8gYGhvc3RuYW1lYCBjYW4gYmUgZW1wdHkgd2hlbiB0aGUgc2NyaXB0IHBhdGggaXMgcmVsYXRpdmUuIEluIHRoYXQgY2FzZSwgc3BlY2lmeWluZ1xuLy8gYSBwcm90b2NvbCB3b3VsZCByZXN1bHQgaW4gYW4gaW52YWxpZCBVUkwuXG4vLyBXaGVuIGh0dHBzIGlzIHVzZWQgaW4gdGhlIGFwcCwgc2VjdXJlIHdlYnNvY2tldHMgYXJlIGFsd2F5cyBuZWNlc3Nhcnlcbi8vIGJlY2F1c2UgdGhlIGJyb3dzZXIgZG9lc24ndCBhY2NlcHQgbm9uLXNlY3VyZSB3ZWJzb2NrZXRzLlxuXG5cbmlmIChob3N0bmFtZSAmJiAoc2VsZi5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgfHwgdXJsUGFydHMuaG9zdG5hbWUgPT09ICcwLjAuMC4wJykpIHtcbiAgcHJvdG9jb2wgPSBzZWxmLmxvY2F0aW9uLnByb3RvY29sO1xufVxuXG52YXIgc29ja2V0VXJsID0gdXJsLmZvcm1hdCh7XG4gIHByb3RvY29sOiBwcm90b2NvbCxcbiAgYXV0aDogdXJsUGFydHMuYXV0aCxcbiAgaG9zdG5hbWU6IGhvc3RuYW1lLFxuICBwb3J0OiBwb3J0LFxuICAvLyBJZiBzb2NrUGF0aCBpcyBwcm92aWRlZCBpdCdsbCBiZSBwYXNzZWQgaW4gdmlhIHRoZSBfX3Jlc291cmNlUXVlcnkgYXMgYVxuICAvLyBxdWVyeSBwYXJhbSBzbyBpdCBoYXMgdG8gYmUgcGFyc2VkIG91dCBvZiB0aGUgcXVlcnlzdHJpbmcgaW4gb3JkZXIgZm9yIHRoZVxuICAvLyBjbGllbnQgdG8gb3BlbiB0aGUgc29ja2V0IHRvIHRoZSBjb3JyZWN0IGxvY2F0aW9uLlxuICBwYXRobmFtZTogdXJsUGFydHMucGF0aCA9PSBudWxsIHx8IHVybFBhcnRzLnBhdGggPT09ICcvJyA/ICcvc29ja2pzLW5vZGUnIDogcXVlcnlzdHJpbmcucGFyc2UodXJsUGFydHMucGF0aCkuc29ja1BhdGggfHwgdXJsUGFydHMucGF0aFxufSk7XG5zb2NrZXQoc29ja2V0VXJsLCBvblNvY2tldE1zZyk7XG52YXIgaXNVbmxvYWRpbmcgPSBmYWxzZTtcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICBpc1VubG9hZGluZyA9IHRydWU7XG59KTtcblxuZnVuY3Rpb24gcmVsb2FkQXBwKCkge1xuICBpZiAoaXNVbmxvYWRpbmcgfHwgIWhvdFJlbG9hZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChfaG90KSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEFwcCBob3QgdXBkYXRlLi4uJyk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZVxuXG4gICAgdmFyIGhvdEVtaXR0ZXIgPSByZXF1aXJlKCd3ZWJwYWNrL2hvdC9lbWl0dGVyJyk7XG5cbiAgICBob3RFbWl0dGVyLmVtaXQoJ3dlYnBhY2tIb3RVcGRhdGUnLCBjdXJyZW50SGFzaCk7XG5cbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYud2luZG93KSB7XG4gICAgICAvLyBicm9hZGNhc3QgdXBkYXRlIHRvIHdpbmRvd1xuICAgICAgc2VsZi5wb3N0TWVzc2FnZShcIndlYnBhY2tIb3RVcGRhdGVcIi5jb25jYXQoY3VycmVudEhhc2gpLCAnKicpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcm9vdFdpbmRvdyA9IHNlbGY7IC8vIHVzZSBwYXJlbnQgd2luZG93IGZvciByZWxvYWQgKGluIGNhc2Ugd2UncmUgaW4gYW4gaWZyYW1lIHdpdGggbm8gdmFsaWQgc3JjKVxuXG4gICAgdmFyIGludGVydmFsSWQgPSBzZWxmLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChyb290V2luZG93LmxvY2F0aW9uLnByb3RvY29sICE9PSAnYWJvdXQ6Jykge1xuICAgICAgICAvLyByZWxvYWQgaW1tZWRpYXRlbHkgaWYgcHJvdG9jb2wgaXMgdmFsaWRcbiAgICAgICAgYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290V2luZG93ID0gcm9vdFdpbmRvdy5wYXJlbnQ7XG5cbiAgICAgICAgaWYgKHJvb3RXaW5kb3cucGFyZW50ID09PSByb290V2luZG93KSB7XG4gICAgICAgICAgLy8gaWYgcGFyZW50IGVxdWFscyBjdXJyZW50IHdpbmRvdyB3ZSd2ZSByZWFjaGVkIHRoZSByb290IHdoaWNoIHdvdWxkIGNvbnRpbnVlIGZvcmV2ZXIsIHNvIHRyaWdnZXIgYSByZWxvYWQgYW55d2F5c1xuICAgICAgICAgIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKSB7XG4gICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIHVwZGF0ZWQuIFJlbG9hZGluZy4uLicpO1xuICAgIHJvb3RXaW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gIH1cbn0iLG51bGwsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsIGV2YWwpKFwidGhpc1wiKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4JykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKGFuc2lSZWdleCwgJycpIDogc3RyO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gL1tcXHUwMDFiXFx1MDA5Yl1bWygpIzs/XSooPzpbMC05XXsxLDR9KD86O1swLTldezAsNH0pKik/WzAtOUEtUFJaY2YtbnFyeT0+PF0vZztcbn07XG4iLCIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xuXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuXG4gICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWxcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyBcIldBUk5cIiA6IGRlZmF1bHRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG59KSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBTb2NrSlMgPSByZXF1aXJlKCdzb2NranMtY2xpZW50L2Rpc3Qvc29ja2pzJyk7XG5cbnZhciByZXRyaWVzID0gMDtcbnZhciBzb2NrID0gbnVsbDtcblxudmFyIHNvY2tldCA9IGZ1bmN0aW9uIGluaXRTb2NrZXQodXJsLCBoYW5kbGVycykge1xuICBzb2NrID0gbmV3IFNvY2tKUyh1cmwpO1xuXG4gIHNvY2sub25vcGVuID0gZnVuY3Rpb24gb25vcGVuKCkge1xuICAgIHJldHJpZXMgPSAwO1xuICB9O1xuXG4gIHNvY2sub25jbG9zZSA9IGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKHJldHJpZXMgPT09IDApIHtcbiAgICAgIGhhbmRsZXJzLmNsb3NlKCk7XG4gICAgfSAvLyBUcnkgdG8gcmVjb25uZWN0LlxuXG5cbiAgICBzb2NrID0gbnVsbDsgLy8gQWZ0ZXIgMTAgcmV0cmllcyBzdG9wIHRyeWluZywgdG8gcHJldmVudCBsb2dzcGFtLlxuXG4gICAgaWYgKHJldHJpZXMgPD0gMTApIHtcbiAgICAgIC8vIEV4cG9uZW50aWFsbHkgaW5jcmVhc2UgdGltZW91dCB0byByZWNvbm5lY3QuXG4gICAgICAvLyBSZXNwZWN0ZnVsbHkgY29waWVkIGZyb20gdGhlIHBhY2thZ2UgYGdvdGAuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcbiAgICAgIHZhciByZXRyeUluTXMgPSAxMDAwICogTWF0aC5wb3coMiwgcmV0cmllcykgKyBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgcmV0cmllcyArPSAxO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNvY2tldCh1cmwsIGhhbmRsZXJzKTtcbiAgICAgIH0sIHJldHJ5SW5Ncyk7XG4gICAgfVxuICB9O1xuXG4gIHNvY2sub25tZXNzYWdlID0gZnVuY3Rpb24gb25tZXNzYWdlKGUpIHtcbiAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCBhbGwgZGF0YSBzZW50IHZpYSB0aGUgd2Vic29ja2V0IGlzIEpTT04uXG4gICAgdmFyIG1zZyA9IEpTT04ucGFyc2UoZS5kYXRhKTtcblxuICAgIGlmIChoYW5kbGVyc1ttc2cudHlwZV0pIHtcbiAgICAgIGhhbmRsZXJzW21zZy50eXBlXShtc2cuZGF0YSk7XG4gICAgfVxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzb2NrZXQ7IiwiLyogc29ja2pzLWNsaWVudCB2MS4zLjAgfCBodHRwOi8vc29ja2pzLm9yZyB8IE1JVCBsaWNlbnNlICovXG4oZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5Tb2NrSlMgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHRyYW5zcG9ydExpc3QgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC1saXN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tYWluJykodHJhbnNwb3J0TGlzdCk7XG5cbi8vIFRPRE8gY2FuJ3QgZ2V0IHJpZCBvZiB0aGlzIHVudGlsIGFsbCBzZXJ2ZXJzIGRvXG5pZiAoJ19zb2NranNfb25sb2FkJyBpbiBnbG9iYWwpIHtcbiAgc2V0VGltZW91dChnbG9iYWwuX3NvY2tqc19vbmxvYWQsIDEpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL21haW5cIjoxNCxcIi4vdHJhbnNwb3J0LWxpc3RcIjoxNn1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgO1xuXG5mdW5jdGlvbiBDbG9zZUV2ZW50KCkge1xuICBFdmVudC5jYWxsKHRoaXMpO1xuICB0aGlzLmluaXRFdmVudCgnY2xvc2UnLCBmYWxzZSwgZmFsc2UpO1xuICB0aGlzLndhc0NsZWFuID0gZmFsc2U7XG4gIHRoaXMuY29kZSA9IDA7XG4gIHRoaXMucmVhc29uID0gJyc7XG59XG5cbmluaGVyaXRzKENsb3NlRXZlbnQsIEV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9zZUV2ZW50O1xuXG59LHtcIi4vZXZlbnRcIjo0LFwiaW5oZXJpdHNcIjo1N31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2V2ZW50dGFyZ2V0JylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG59XG5cbmluaGVyaXRzKEV2ZW50RW1pdHRlciwgRXZlbnRUYXJnZXQpO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHR5cGUpIHtcbiAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLm9uKHR5cGUsIGcpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0eXBlID0gYXJndW1lbnRzWzBdO1xuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBlcXVpdmFsZW50IG9mIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuICBmb3IgKHZhciBhaSA9IDE7IGFpIDwgbDsgYWkrKykge1xuICAgIGFyZ3NbYWkgLSAxXSA9IGFyZ3VtZW50c1thaV07XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxufSx7XCIuL2V2ZW50dGFyZ2V0XCI6NSxcImluaGVyaXRzXCI6NTd9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gRXZlbnQoZXZlbnRUeXBlKSB7XG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbn1cblxuRXZlbnQucHJvdG90eXBlLmluaXRFdmVudCA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgY2FuQnViYmxlLCBjYW5jZWxhYmxlKSB7XG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbiAgdGhpcy5idWJibGVzID0gY2FuQnViYmxlO1xuICB0aGlzLmNhbmNlbGFibGUgPSBjYW5jZWxhYmxlO1xuICB0aGlzLnRpbWVTdGFtcCA9ICtuZXcgRGF0ZSgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHt9O1xuRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7fTtcblxuRXZlbnQuQ0FQVFVSSU5HX1BIQVNFID0gMTtcbkV2ZW50LkFUX1RBUkdFVCA9IDI7XG5FdmVudC5CVUJCTElOR19QSEFTRSA9IDM7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnQ7XG5cbn0se31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiBTaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIERPTTIgRXZlbnRUYXJnZXQuXG4gKiAgIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgdGhpcy5fbGlzdGVuZXJzID0ge307XG59XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIShldmVudFR5cGUgaW4gdGhpcy5fbGlzdGVuZXJzKSkge1xuICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gW107XG4gIH1cbiAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAvLyAjNFxuICBpZiAoYXJyLmluZGV4T2YobGlzdGVuZXIpID09PSAtMSkge1xuICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICBhcnIgPSBhcnIuY29uY2F0KFtsaXN0ZW5lcl0pO1xuICB9XG4gIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyO1xufTtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgaWYgKCFhcnIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlkeCA9IGFyci5pbmRleE9mKGxpc3RlbmVyKTtcbiAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyLnNsaWNlKDAsIGlkeCkuY29uY2F0KGFyci5zbGljZShpZHggKyAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG59O1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZXZlbnQgPSBhcmd1bWVudHNbMF07XG4gIHZhciB0ID0gZXZlbnQudHlwZTtcbiAgLy8gZXF1aXZhbGVudCBvZiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBbZXZlbnRdIDogQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgLy8gVE9ETzogVGhpcyBkb2Vzbid0IG1hdGNoIHRoZSByZWFsIGJlaGF2aW9yOyBwZXIgc3BlYywgb25mb28gZ2V0XG4gIC8vIHRoZWlyIHBsYWNlIGluIGxpbmUgZnJvbSB0aGUgL2ZpcnN0LyB0aW1lIHRoZXkncmUgc2V0IGZyb21cbiAgLy8gbm9uLW51bGwuIEFsdGhvdWdoIFdlYktpdCBidW1wcyBpdCB0byB0aGUgZW5kIGV2ZXJ5IHRpbWUgaXQnc1xuICAvLyBzZXQuXG4gIGlmICh0aGlzWydvbicgKyB0XSkge1xuICAgIHRoaXNbJ29uJyArIHRdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG4gIGlmICh0IGluIHRoaXMuX2xpc3RlbmVycykge1xuICAgIC8vIEdyYWIgYSByZWZlcmVuY2UgdG8gdGhlIGxpc3RlbmVycyBsaXN0LiByZW1vdmVFdmVudExpc3RlbmVyIG1heSBhbHRlciB0aGUgbGlzdC5cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3RdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50VGFyZ2V0O1xuXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gIDtcblxuZnVuY3Rpb24gVHJhbnNwb3J0TWVzc2FnZUV2ZW50KGRhdGEpIHtcbiAgRXZlbnQuY2FsbCh0aGlzKTtcbiAgdGhpcy5pbml0RXZlbnQoJ21lc3NhZ2UnLCBmYWxzZSwgZmFsc2UpO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xufVxuXG5pbmhlcml0cyhUcmFuc3BvcnRNZXNzYWdlRXZlbnQsIEV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnRNZXNzYWdlRXZlbnQ7XG5cbn0se1wiLi9ldmVudFwiOjQsXCJpbmhlcml0c1wiOjU3fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaWZyYW1lJylcbiAgO1xuXG5mdW5jdGlvbiBGYWNhZGVKUyh0cmFuc3BvcnQpIHtcbiAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0cmFuc3BvcnQub24oJ21lc3NhZ2UnLCB0aGlzLl90cmFuc3BvcnRNZXNzYWdlLmJpbmQodGhpcykpO1xuICB0cmFuc3BvcnQub24oJ2Nsb3NlJywgdGhpcy5fdHJhbnNwb3J0Q2xvc2UuYmluZCh0aGlzKSk7XG59XG5cbkZhY2FkZUpTLnByb3RvdHlwZS5fdHJhbnNwb3J0Q2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ2MnLCBKU09OMy5zdHJpbmdpZnkoW2NvZGUsIHJlYXNvbl0pKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbihmcmFtZSkge1xuICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgndCcsIGZyYW1lKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGRhdGEpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjYWRlSlM7XG5cbn0se1wiLi91dGlscy9pZnJhbWVcIjo0NyxcImpzb24zXCI6NTh9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgRmFjYWRlSlMgPSByZXF1aXJlKCcuL2ZhY2FkZScpXG4gICwgSW5mb0lmcmFtZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2lmcmFtZScpXG4gICwgbG9jID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppZnJhbWUtYm9vdHN0cmFwJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oU29ja0pTLCBhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHZhciB0cmFuc3BvcnRNYXAgPSB7fTtcbiAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKGF0KSB7XG4gICAgaWYgKGF0LmZhY2FkZVRyYW5zcG9ydCkge1xuICAgICAgdHJhbnNwb3J0TWFwW2F0LmZhY2FkZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lXSA9IGF0LmZhY2FkZVRyYW5zcG9ydDtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGhhcmQtY29kZWQgZm9yIHRoZSBpbmZvIGlmcmFtZVxuICAvLyBUT0RPIHNlZSBpZiB3ZSBjYW4gbWFrZSB0aGlzIG1vcmUgZHluYW1pY1xuICB0cmFuc3BvcnRNYXBbSW5mb0lmcmFtZVJlY2VpdmVyLnRyYW5zcG9ydE5hbWVdID0gSW5mb0lmcmFtZVJlY2VpdmVyO1xuICB2YXIgcGFyZW50T3JpZ2luO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICBTb2NrSlMuYm9vdHN0cmFwX2lmcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgdmFyIGZhY2FkZTtcbiAgICBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQgPSBsb2MuaGFzaC5zbGljZSgxKTtcbiAgICB2YXIgb25NZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUuc291cmNlICE9PSBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJlbnRPcmlnaW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBhcmVudE9yaWdpbiA9IGUub3JpZ2luO1xuICAgICAgfVxuICAgICAgaWYgKGUub3JpZ2luICE9PSBwYXJlbnRPcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWZyYW1lTWVzc2FnZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmcmFtZU1lc3NhZ2UgPSBKU09OMy5wYXJzZShlLmRhdGEpO1xuICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpZnJhbWVNZXNzYWdlLndpbmRvd0lkICE9PSBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3MnOlxuICAgICAgICB2YXIgcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwID0gSlNPTjMucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZlcnNpb24gPSBwWzBdO1xuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gcFsxXTtcbiAgICAgICAgdmFyIHRyYW5zVXJsID0gcFsyXTtcbiAgICAgICAgdmFyIGJhc2VVcmwgPSBwWzNdO1xuICAgICAgICBkZWJ1Zyh2ZXJzaW9uLCB0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKTtcbiAgICAgICAgLy8gY2hhbmdlIHRoaXMgdG8gc2VtdmVyIGxvZ2ljXG4gICAgICAgIGlmICh2ZXJzaW9uICE9PSBTb2NrSlMudmVyc2lvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmxlIFNvY2tKUyEgTWFpbiBzaXRlIHVzZXM6JyArXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgdmVyc2lvbiArICdcIiwgdGhlIGlmcmFtZTonICtcbiAgICAgICAgICAgICAgICAgICAgJyBcIicgKyBTb2NrSlMudmVyc2lvbiArICdcIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXJsVXRpbHMuaXNPcmlnaW5FcXVhbCh0cmFuc1VybCwgbG9jLmhyZWYpIHx8XG4gICAgICAgICAgICAhdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChiYXNlVXJsLCBsb2MuaHJlZikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgY29ubmVjdCB0byBkaWZmZXJlbnQgZG9tYWluIGZyb20gd2l0aGluIGFuICcgK1xuICAgICAgICAgICAgICAgICAgICAnaWZyYW1lLiAoJyArIGxvYy5ocmVmICsgJywgJyArIHRyYW5zVXJsICsgJywgJyArIGJhc2VVcmwgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGZhY2FkZSA9IG5ldyBGYWNhZGVKUyhuZXcgdHJhbnNwb3J0TWFwW3RyYW5zcG9ydF0odHJhbnNVcmwsIGJhc2VVcmwpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtJzpcbiAgICAgICAgZmFjYWRlLl9zZW5kKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYyc6XG4gICAgICAgIGlmIChmYWNhZGUpIHtcbiAgICAgICAgICBmYWNhZGUuX2Nsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmFjYWRlID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuXG4gICAgLy8gU3RhcnRcbiAgICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgncycpO1xuICB9O1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vZmFjYWRlXCI6NyxcIi4vaW5mby1pZnJhbWUtcmVjZWl2ZXJcIjoxMCxcIi4vbG9jYXRpb25cIjoxMyxcIi4vdXRpbHMvZXZlbnRcIjo0NixcIi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImpzb24zXCI6NTh9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8tYWpheCcpO1xufVxuXG5mdW5jdGlvbiBJbmZvQWpheCh1cmwsIEFqYXhPYmplY3QpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdDAgPSArbmV3IERhdGUoKTtcbiAgdGhpcy54byA9IG5ldyBBamF4T2JqZWN0KCdHRVQnLCB1cmwpO1xuXG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgdmFyIGluZm8sIHJ0dDtcbiAgICBpZiAoc3RhdHVzID09PSAyMDApIHtcbiAgICAgIHJ0dCA9ICgrbmV3IERhdGUoKSkgLSB0MDtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5mbyA9IEpTT04zLnBhcnNlKHRleHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFvYmplY3RVdGlscy5pc09iamVjdChpbmZvKSkge1xuICAgICAgICBpbmZvID0ge307XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSW5mb0FqYXgsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9BamF4LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLnhvLmNsb3NlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9BamF4O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi91dGlscy9vYmplY3RcIjo0OSxcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwnKVxuICAsIEluZm9BamF4ID0gcmVxdWlyZSgnLi9pbmZvLWFqYXgnKVxuICA7XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcklmcmFtZSh0cmFuc1VybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuaXIgPSBuZXcgSW5mb0FqYXgodHJhbnNVcmwsIFhIUkxvY2FsT2JqZWN0KTtcbiAgdGhpcy5pci5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBzZWxmLmlyID0gbnVsbDtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBKU09OMy5zdHJpbmdpZnkoW2luZm8sIHJ0dF0pKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlcklmcmFtZSwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lLWluZm8tcmVjZWl2ZXInO1xuXG5JbmZvUmVjZWl2ZXJJZnJhbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlyKSB7XG4gICAgdGhpcy5pci5jbG9zZSgpO1xuICAgIHRoaXMuaXIgPSBudWxsO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9SZWNlaXZlcklmcmFtZTtcblxufSx7XCIuL2luZm8tYWpheFwiOjksXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgSWZyYW1lVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvaWZyYW1lJylcbiAgLCBJbmZvUmVjZWl2ZXJJZnJhbWUgPSByZXF1aXJlKCcuL2luZm8taWZyYW1lLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8taWZyYW1lJyk7XG59XG5cbmZ1bmN0aW9uIEluZm9JZnJhbWUoYmFzZVVybCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlmciA9IHNlbGYuaWZyID0gbmV3IElmcmFtZVRyYW5zcG9ydChJbmZvUmVjZWl2ZXJJZnJhbWUudHJhbnNwb3J0TmFtZSwgdXJsLCBiYXNlVXJsKTtcblxuICAgIGlmci5vbmNlKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgICBpZiAobXNnKSB7XG4gICAgICAgIHZhciBkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGQgPSBKU09OMy5wYXJzZShtc2cpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgbXNnKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5mbyA9IGRbMF0sIHJ0dCA9IGRbMV07XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICB9KTtcblxuICAgIGlmci5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBUT0RPIHRoaXMgc2VlbXMgdGhlIHNhbWUgYXMgdGhlICduZWVkQm9keScgZnJvbSB0cmFuc3BvcnRzXG4gIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkpIHtcbiAgICB1dGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIGdvKTtcbiAgfSBlbHNlIHtcbiAgICBnbygpO1xuICB9XG59XG5cbmluaGVyaXRzKEluZm9JZnJhbWUsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9JZnJhbWUuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKTtcbn07XG5cbkluZm9JZnJhbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlmcikge1xuICAgIHRoaXMuaWZyLmNsb3NlKCk7XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5pZnIgPSBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvSWZyYW1lO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2luZm8taWZyYW1lLXJlY2VpdmVyXCI6MTAsXCIuL3RyYW5zcG9ydC9pZnJhbWVcIjoyMixcIi4vdXRpbHMvZXZlbnRcIjo0NixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgWERSID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hkcicpXG4gICwgWEhSQ29ycyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWwgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBYSFJGYWtlID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1mYWtlJylcbiAgLCBJbmZvSWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZScpXG4gICwgSW5mb0FqYXggPSByZXF1aXJlKCcuL2luZm8tYWpheCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLXJlY2VpdmVyJyk7XG59XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIGRlYnVnKGJhc2VVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5kb1hocihiYXNlVXJsLCB1cmxJbmZvKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuLy8gVE9ETyB0aGlzIGlzIGN1cnJlbnRseSBpZ25vcmluZyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgdHJhbnNwb3J0cyBhbmQgdGhlIHdoaXRlbGlzdFxuXG5JbmZvUmVjZWl2ZXIuX2dldFJlY2VpdmVyID0gZnVuY3Rpb24oYmFzZVVybCwgdXJsLCB1cmxJbmZvKSB7XG4gIC8vIGRldGVybWluZSBtZXRob2Qgb2YgQ09SUyBzdXBwb3J0IChpZiBuZWVkZWQpXG4gIGlmICh1cmxJbmZvLnNhbWVPcmlnaW4pIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSTG9jYWwpO1xuICB9XG4gIGlmIChYSFJDb3JzLmVuYWJsZWQpIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSQ29ycyk7XG4gIH1cbiAgaWYgKFhEUi5lbmFibGVkICYmIHVybEluZm8uc2FtZVNjaGVtZSkge1xuICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYRFIpO1xuICB9XG4gIGlmIChJbmZvSWZyYW1lLmVuYWJsZWQoKSkge1xuICAgIHJldHVybiBuZXcgSW5mb0lmcmFtZShiYXNlVXJsLCB1cmwpO1xuICB9XG4gIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJGYWtlKTtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUuZG9YaHIgPSBmdW5jdGlvbihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2luZm8nKVxuICAgIDtcbiAgZGVidWcoJ2RvWGhyJywgdXJsKTtcblxuICB0aGlzLnhvID0gSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlcihiYXNlVXJsLCB1cmwsIHVybEluZm8pO1xuXG4gIHRoaXMudGltZW91dFJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICB9LCBJbmZvUmVjZWl2ZXIudGltZW91dCk7XG5cbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBkZWJ1ZygnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgfSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24od2FzQ2xlYW4pIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRSZWYpO1xuICB0aGlzLnRpbWVvdXRSZWYgPSBudWxsO1xuICBpZiAoIXdhc0NsZWFuICYmIHRoaXMueG8pIHtcbiAgICB0aGlzLnhvLmNsb3NlKCk7XG4gIH1cbiAgdGhpcy54byA9IG51bGw7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbn07XG5cbkluZm9SZWNlaXZlci50aW1lb3V0ID0gODAwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2luZm8tYWpheFwiOjksXCIuL2luZm8taWZyYW1lXCI6MTEsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGRyXCI6MzQsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZVwiOjM2LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwubG9jYXRpb24gfHwge1xuICBvcmlnaW46ICdodHRwOi8vbG9jYWxob3N0OjgwJ1xuLCBwcm90b2NvbDogJ2h0dHA6J1xuLCBob3N0OiAnbG9jYWxob3N0J1xuLCBwb3J0OiA4MFxuLCBocmVmOiAnaHR0cDovL2xvY2FsaG9zdC8nXG4sIGhhc2g6ICcnXG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vc2hpbXMnKTtcblxudmFyIFVSTCA9IHJlcXVpcmUoJ3VybC1wYXJzZScpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi91dGlscy9yYW5kb20nKVxuICAsIGVzY2FwZSA9IHJlcXVpcmUoJy4vdXRpbHMvZXNjYXBlJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgdHJhbnNwb3J0ID0gcmVxdWlyZSgnLi91dGlscy90cmFuc3BvcnQnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3QnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuL3V0aWxzL2Jyb3dzZXInKVxuICAsIGxvZyA9IHJlcXVpcmUoJy4vdXRpbHMvbG9nJylcbiAgLCBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvZXZlbnQnKVxuICAsIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9ldmVudC9ldmVudHRhcmdldCcpXG4gICwgbG9jID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpXG4gICwgQ2xvc2VFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvY2xvc2UnKVxuICAsIFRyYW5zcG9ydE1lc3NhZ2VFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvdHJhbnMtbWVzc2FnZScpXG4gICwgSW5mb1JlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50Om1haW4nKTtcbn1cblxudmFyIHRyYW5zcG9ydHM7XG5cbi8vIGZvbGxvdyBjb25zdHJ1Y3RvciBzdGVwcyBkZWZpbmVkIGF0IGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnNvY2tldHMvI3RoZS13ZWJzb2NrZXQtaW50ZXJmYWNlXG5mdW5jdGlvbiBTb2NrSlModXJsLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tKUykpIHtcbiAgICByZXR1cm4gbmV3IFNvY2tKUyh1cmwsIHByb3RvY29scywgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1NvY2tKUzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50XCIpO1xuICB9XG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLkNPTk5FQ1RJTkc7XG4gIHRoaXMuZXh0ZW5zaW9ucyA9ICcnO1xuICB0aGlzLnByb3RvY29sID0gJyc7XG5cbiAgLy8gbm9uLXN0YW5kYXJkIGV4dGVuc2lvblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKG9wdGlvbnMucHJvdG9jb2xzX3doaXRlbGlzdCkge1xuICAgIGxvZy53YXJuKFwiJ3Byb3RvY29sc193aGl0ZWxpc3QnIGlzIERFUFJFQ0FURUQuIFVzZSAndHJhbnNwb3J0cycgaW5zdGVhZC5cIik7XG4gIH1cbiAgdGhpcy5fdHJhbnNwb3J0c1doaXRlbGlzdCA9IG9wdGlvbnMudHJhbnNwb3J0cztcbiAgdGhpcy5fdHJhbnNwb3J0T3B0aW9ucyA9IG9wdGlvbnMudHJhbnNwb3J0T3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc2Vzc2lvbklkID0gb3B0aW9ucy5zZXNzaW9uSWQgfHwgODtcbiAgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAnbnVtYmVyJykge1xuICAgIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmFuZG9tLnN0cmluZyhzZXNzaW9uSWQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWYgc2Vzc2lvbklkIGlzIHVzZWQgaW4gdGhlIG9wdGlvbnMsIGl0IG5lZWRzIHRvIGJlIGEgbnVtYmVyIG9yIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB0aGlzLl9zZXJ2ZXIgPSBvcHRpb25zLnNlcnZlciB8fCByYW5kb20ubnVtYmVyU3RyaW5nKDEwMDApO1xuXG4gIC8vIFN0ZXAgMSBvZiBXUyBzcGVjIC0gcGFyc2UgYW5kIHZhbGlkYXRlIHRoZSB1cmwuIElzc3VlICM4XG4gIHZhciBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybCk7XG4gIGlmICghcGFyc2VkVXJsLmhvc3QgfHwgIXBhcnNlZFVybC5wcm90b2NvbCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBVUkwgJ1wiICsgdXJsICsgXCInIGlzIGludmFsaWRcIik7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RoZSBVUkwgbXVzdCBub3QgY29udGFpbiBhIGZyYWdtZW50Jyk7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSAnaHR0cDonICYmIHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMJ3Mgc2NoZW1lIG11c3QgYmUgZWl0aGVyICdodHRwOicgb3IgJ2h0dHBzOicuICdcIiArIHBhcnNlZFVybC5wcm90b2NvbCArIFwiJyBpcyBub3QgYWxsb3dlZC5cIik7XG4gIH1cblxuICB2YXIgc2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgLy8gU3RlcCAyIC0gZG9uJ3QgYWxsb3cgc2VjdXJlIG9yaWdpbiB3aXRoIGFuIGluc2VjdXJlIHByb3RvY29sXG4gIGlmIChsb2MucHJvdG9jb2wgPT09ICdodHRwczonICYmICFzZWN1cmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3VyaXR5RXJyb3I6IEFuIGluc2VjdXJlIFNvY2tKUyBjb25uZWN0aW9uIG1heSBub3QgYmUgaW5pdGlhdGVkIGZyb20gYSBwYWdlIGxvYWRlZCBvdmVyIEhUVFBTJyk7XG4gIH1cblxuICAvLyBTdGVwIDMgLSBjaGVjayBwb3J0IGFjY2VzcyAtIG5vIG5lZWQgaGVyZVxuICAvLyBTdGVwIDQgLSBwYXJzZSBwcm90b2NvbHMgYXJndW1lbnRcbiAgaWYgKCFwcm90b2NvbHMpIHtcbiAgICBwcm90b2NvbHMgPSBbXTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gIH1cblxuICAvLyBTdGVwIDUgLSBjaGVjayBwcm90b2NvbHMgYXJndW1lbnRcbiAgdmFyIHNvcnRlZFByb3RvY29scyA9IHByb3RvY29scy5zb3J0KCk7XG4gIHNvcnRlZFByb3RvY29scy5mb3JFYWNoKGZ1bmN0aW9uKHByb3RvLCBpKSB7XG4gICAgaWYgKCFwcm90bykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG4gICAgaWYgKGkgPCAoc29ydGVkUHJvdG9jb2xzLmxlbmd0aCAtIDEpICYmIHByb3RvID09PSBzb3J0ZWRQcm90b2NvbHNbaSArIDFdKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgcHJvdG9jb2xzIGVudHJ5ICdcIiArIHByb3RvICsgXCInIGlzIGR1cGxpY2F0ZWQuXCIpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gU3RlcCA2IC0gY29udmVydCBvcmlnaW5cbiAgdmFyIG8gPSB1cmxVdGlscy5nZXRPcmlnaW4obG9jLmhyZWYpO1xuICB0aGlzLl9vcmlnaW4gPSBvID8gby50b0xvd2VyQ2FzZSgpIDogbnVsbDtcblxuICAvLyByZW1vdmUgdGhlIHRyYWlsaW5nIHNsYXNoXG4gIHBhcnNlZFVybC5zZXQoJ3BhdGhuYW1lJywgcGFyc2VkVXJsLnBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgJycpKTtcblxuICAvLyBzdG9yZSB0aGUgc2FuaXRpemVkIHVybFxuICB0aGlzLnVybCA9IHBhcnNlZFVybC5ocmVmO1xuICBkZWJ1ZygndXNpbmcgdXJsJywgdGhpcy51cmwpO1xuXG4gIC8vIFN0ZXAgNyAtIHN0YXJ0IGNvbm5lY3Rpb24gaW4gYmFja2dyb3VuZFxuICAvLyBvYnRhaW4gc2VydmVyIGluZm9cbiAgLy8gaHR0cDovL3NvY2tqcy5naXRodWIuaW8vc29ja2pzLXByb3RvY29sL3NvY2tqcy1wcm90b2NvbC0wLjMuMy5odG1sI3NlY3Rpb24tMjZcbiAgdGhpcy5fdXJsSW5mbyA9IHtcbiAgICBudWxsT3JpZ2luOiAhYnJvd3Nlci5oYXNEb21haW4oKVxuICAsIHNhbWVPcmlnaW46IHVybFV0aWxzLmlzT3JpZ2luRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxuICAsIHNhbWVTY2hlbWU6IHVybFV0aWxzLmlzU2NoZW1lRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxuICB9O1xuXG4gIHRoaXMuX2lyID0gbmV3IEluZm9SZWNlaXZlcih0aGlzLnVybCwgdGhpcy5fdXJsSW5mbyk7XG4gIHRoaXMuX2lyLm9uY2UoJ2ZpbmlzaCcsIHRoaXMuX3JlY2VpdmVJbmZvLmJpbmQodGhpcykpO1xufVxuXG5pbmhlcml0cyhTb2NrSlMsIEV2ZW50VGFyZ2V0KTtcblxuZnVuY3Rpb24gdXNlclNldENvZGUoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAwMCB8fCAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSk7XG59XG5cblNvY2tKUy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgLy8gU3RlcCAxXG4gIGlmIChjb2RlICYmICF1c2VyU2V0Q29kZShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZEFjY2Vzc0Vycm9yOiBJbnZhbGlkIGNvZGUnKTtcbiAgfVxuICAvLyBTdGVwIDIuNCBzdGF0ZXMgdGhlIG1heCBpcyAxMjMgYnl0ZXMsIGJ1dCB3ZSBhcmUganVzdCBjaGVja2luZyBsZW5ndGhcbiAgaWYgKHJlYXNvbiAmJiByZWFzb24ubGVuZ3RoID4gMTIzKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdyZWFzb24gYXJndW1lbnQgaGFzIGFuIGludmFsaWQgbGVuZ3RoJyk7XG4gIH1cblxuICAvLyBTdGVwIDMuMVxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0lORyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUT0RPIGxvb2sgYXQgZG9jcyB0byBkZXRlcm1pbmUgaG93IHRvIHNldCB0aGlzXG4gIHZhciB3YXNDbGVhbiA9IHRydWU7XG4gIHRoaXMuX2Nsb3NlKGNvZGUgfHwgMTAwMCwgcmVhc29uIHx8ICdOb3JtYWwgY2xvc3VyZScsIHdhc0NsZWFuKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgLy8gIzEzIC0gY29udmVydCBhbnl0aGluZyBub24tc3RyaW5nIHRvIHN0cmluZ1xuICAvLyBUT0RPIHRoaXMgY3VycmVudGx5IHR1cm5zIG9iamVjdHMgaW50byBbb2JqZWN0IE9iamVjdF1cbiAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yOiBUaGUgY29ubmVjdGlvbiBoYXMgbm90IGJlZW4gZXN0YWJsaXNoZWQgeWV0Jyk7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gU29ja0pTLk9QRU4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoZXNjYXBlLnF1b3RlKGRhdGEpKTtcbn07XG5cblNvY2tKUy52ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cblNvY2tKUy5DT05ORUNUSU5HID0gMDtcblNvY2tKUy5PUEVOID0gMTtcblNvY2tKUy5DTE9TSU5HID0gMjtcblNvY2tKUy5DTE9TRUQgPSAzO1xuXG5Tb2NrSlMucHJvdG90eXBlLl9yZWNlaXZlSW5mbyA9IGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICBkZWJ1ZygnX3JlY2VpdmVJbmZvJywgcnR0KTtcbiAgdGhpcy5faXIgPSBudWxsO1xuICBpZiAoIWluZm8pIHtcbiAgICB0aGlzLl9jbG9zZSgxMDAyLCAnQ2Fubm90IGNvbm5lY3QgdG8gc2VydmVyJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZXN0YWJsaXNoIGEgcm91bmQtdHJpcCB0aW1lb3V0IChSVE8pIGJhc2VkIG9uIHRoZVxuICAvLyByb3VuZC10cmlwIHRpbWUgKFJUVClcbiAgdGhpcy5fcnRvID0gdGhpcy5jb3VudFJUTyhydHQpO1xuICAvLyBhbGxvdyBzZXJ2ZXIgdG8gb3ZlcnJpZGUgdXJsIHVzZWQgZm9yIHRoZSBhY3R1YWwgdHJhbnNwb3J0XG4gIHRoaXMuX3RyYW5zVXJsID0gaW5mby5iYXNlX3VybCA/IGluZm8uYmFzZV91cmwgOiB0aGlzLnVybDtcbiAgaW5mbyA9IG9iamVjdFV0aWxzLmV4dGVuZChpbmZvLCB0aGlzLl91cmxJbmZvKTtcbiAgZGVidWcoJ2luZm8nLCBpbmZvKTtcbiAgLy8gZGV0ZXJtaW5lIGxpc3Qgb2YgZGVzaXJlZCBhbmQgc3VwcG9ydGVkIHRyYW5zcG9ydHNcbiAgdmFyIGVuYWJsZWRUcmFuc3BvcnRzID0gdHJhbnNwb3J0cy5maWx0ZXJUb0VuYWJsZWQodGhpcy5fdHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbyk7XG4gIHRoaXMuX3RyYW5zcG9ydHMgPSBlbmFibGVkVHJhbnNwb3J0cy5tYWluO1xuICBkZWJ1Zyh0aGlzLl90cmFuc3BvcnRzLmxlbmd0aCArICcgZW5hYmxlZCB0cmFuc3BvcnRzJyk7XG5cbiAgdGhpcy5fY29ubmVjdCgpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBUcmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnRzLnNoaWZ0KCk7IFRyYW5zcG9ydDsgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpKSB7XG4gICAgZGVidWcoJ2F0dGVtcHQnLCBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSk7XG4gICAgaWYgKFRyYW5zcG9ydC5uZWVkQm9keSkge1xuICAgICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQuYm9keSB8fFxuICAgICAgICAgICh0eXBlb2YgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBnbG9iYWwuZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJyAmJlxuICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdpbnRlcmFjdGl2ZScpKSB7XG4gICAgICAgIGRlYnVnKCd3YWl0aW5nIGZvciBib2R5Jyk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydHMudW5zaGlmdChUcmFuc3BvcnQpO1xuICAgICAgICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdsb2FkJywgdGhpcy5fY29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSB0aW1lb3V0IGJhc2VkIG9uIFJUTyBhbmQgcm91bmQgdHJpcHMuIERlZmF1bHQgdG8gNXNcbiAgICB2YXIgdGltZW91dE1zID0gKHRoaXMuX3J0byAqIFRyYW5zcG9ydC5yb3VuZFRyaXBzKSB8fCA1MDAwO1xuICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dC5iaW5kKHRoaXMpLCB0aW1lb3V0TXMpO1xuICAgIGRlYnVnKCd1c2luZyB0aW1lb3V0JywgdGltZW91dE1zKTtcblxuICAgIHZhciB0cmFuc3BvcnRVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHRoaXMuX3RyYW5zVXJsLCAnLycgKyB0aGlzLl9zZXJ2ZXIgKyAnLycgKyB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCgpKTtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX3RyYW5zcG9ydE9wdGlvbnNbVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWVdO1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgdXJsJywgdHJhbnNwb3J0VXJsKTtcbiAgICB2YXIgdHJhbnNwb3J0T2JqID0gbmV3IFRyYW5zcG9ydCh0cmFuc3BvcnRVcmwsIHRoaXMuX3RyYW5zVXJsLCBvcHRpb25zKTtcbiAgICB0cmFuc3BvcnRPYmoub24oJ21lc3NhZ2UnLCB0aGlzLl90cmFuc3BvcnRNZXNzYWdlLmJpbmQodGhpcykpO1xuICAgIHRyYW5zcG9ydE9iai5vbmNlKCdjbG9zZScsIHRoaXMuX3RyYW5zcG9ydENsb3NlLmJpbmQodGhpcykpO1xuICAgIHRyYW5zcG9ydE9iai50cmFuc3BvcnROYW1lID0gVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0T2JqO1xuXG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2Nsb3NlKDIwMDAsICdBbGwgdHJhbnNwb3J0cyBmYWlsZWQnLCBmYWxzZSk7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0VGltZW91dCcpO1xuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICAgIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3RyYW5zcG9ydENsb3NlKDIwMDcsICdUcmFuc3BvcnQgdGltZWQgb3V0Jyk7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgZGVidWcoJ190cmFuc3BvcnRNZXNzYWdlJywgbXNnKTtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCB0eXBlID0gbXNnLnNsaWNlKDAsIDEpXG4gICAgLCBjb250ZW50ID0gbXNnLnNsaWNlKDEpXG4gICAgLCBwYXlsb2FkXG4gICAgO1xuXG4gIC8vIGZpcnN0IGNoZWNrIGZvciBtZXNzYWdlcyB0aGF0IGRvbid0IG5lZWQgYSBwYXlsb2FkXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ28nOlxuICAgICAgdGhpcy5fb3BlbigpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ2gnOlxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaGVhcnRiZWF0JykpO1xuICAgICAgZGVidWcoJ2hlYXJ0YmVhdCcsIHRoaXMudHJhbnNwb3J0KTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb250ZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIHBheWxvYWQgPSBKU09OMy5wYXJzZShjb250ZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygnYmFkIGpzb24nLCBjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGVidWcoJ2VtcHR5IHBheWxvYWQnLCBjb250ZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdhJzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICAgIHBheWxvYWQuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgZGVidWcoJ21lc3NhZ2UnLCBzZWxmLnRyYW5zcG9ydCwgcCk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ20nOlxuICAgICAgZGVidWcoJ21lc3NhZ2UnLCB0aGlzLnRyYW5zcG9ydCwgcGF5bG9hZCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IFRyYW5zcG9ydE1lc3NhZ2VFdmVudChwYXlsb2FkKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjJzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpICYmIHBheWxvYWQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlKHBheWxvYWRbMF0sIHBheWxvYWRbMV0sIHRydWUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydENsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0Q2xvc2UnLCB0aGlzLnRyYW5zcG9ydCwgY29kZSwgcmVhc29uKTtcbiAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdXNlclNldENvZGUoY29kZSkgJiYgY29kZSAhPT0gMjAwMCAmJiB0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgdGhpcy5fY29ubmVjdCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2Nsb3NlKGNvZGUsIHJlYXNvbik7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfb3BlbicsIHRoaXMuX3RyYW5zcG9ydC50cmFuc3BvcnROYW1lLCB0aGlzLnJlYWR5U3RhdGUpO1xuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQpO1xuICAgICAgdGhpcy5fdHJhbnNwb3J0VGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLk9QRU47XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdvcGVuJykpO1xuICAgIGRlYnVnKCdjb25uZWN0ZWQnLCB0aGlzLnRyYW5zcG9ydCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIHNlcnZlciBtaWdodCBoYXZlIGJlZW4gcmVzdGFydGVkLCBhbmQgbG9zdCB0cmFjayBvZiBvdXJcbiAgICAvLyBjb25uZWN0aW9uLlxuICAgIHRoaXMuX2Nsb3NlKDEwMDYsICdTZXJ2ZXIgbG9zdCBzZXNzaW9uJyk7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uLCB3YXNDbGVhbikge1xuICBkZWJ1ZygnX2Nsb3NlJywgdGhpcy50cmFuc3BvcnQsIGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4sIHRoaXMucmVhZHlTdGF0ZSk7XG4gIHZhciBmb3JjZUZhaWwgPSBmYWxzZTtcblxuICBpZiAodGhpcy5faXIpIHtcbiAgICBmb3JjZUZhaWwgPSB0cnVlO1xuICAgIHRoaXMuX2lyLmNsb3NlKCk7XG4gICAgdGhpcy5faXIgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yOiBTb2NrSlMgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQnKTtcbiAgfVxuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DTE9TSU5HO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DTE9TRUQ7XG5cbiAgICBpZiAoZm9yY2VGYWlsKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKTtcbiAgICB9XG5cbiAgICB2YXIgZSA9IG5ldyBDbG9zZUV2ZW50KCdjbG9zZScpO1xuICAgIGUud2FzQ2xlYW4gPSB3YXNDbGVhbiB8fCBmYWxzZTtcbiAgICBlLmNvZGUgPSBjb2RlIHx8IDEwMDA7XG4gICAgZS5yZWFzb24gPSByZWFzb247XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgdGhpcy5vbm1lc3NhZ2UgPSB0aGlzLm9uY2xvc2UgPSB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgIGRlYnVnKCdkaXNjb25uZWN0ZWQnKTtcbiAgfS5iaW5kKHRoaXMpLCAwKTtcbn07XG5cbi8vIFNlZTogaHR0cDovL3d3dy5lcmcuYWJkbi5hYy51ay9+Z2Vycml0L2RjY3Avbm90ZXMvY2NpZDIvcnRvX2VzdGltYXRvci9cbi8vIGFuZCBSRkMgMjk4OC5cblNvY2tKUy5wcm90b3R5cGUuY291bnRSVE8gPSBmdW5jdGlvbihydHQpIHtcbiAgLy8gSW4gYSBsb2NhbCBlbnZpcm9ubWVudCwgd2hlbiB1c2luZyBJRTgvOSBhbmQgdGhlIGBqc29ucC1wb2xsaW5nYFxuICAvLyB0cmFuc3BvcnQgdGhlIHRpbWUgbmVlZGVkIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gKHRoZSB0aW1lIHRoYXQgcGFzc1xuICAvLyBmcm9tIHRoZSBvcGVuaW5nIG9mIHRoZSB0cmFuc3BvcnQgdG8gdGhlIGNhbGwgb2YgYF9kaXNwYXRjaE9wZW5gKSBpc1xuICAvLyBhcm91bmQgMjAwbXNlYyAodGhlIGxvd2VyIGJvdW5kIHVzZWQgaW4gdGhlIGFydGljbGUgYWJvdmUpIGFuZCB0aGlzXG4gIC8vIGNhdXNlcyBzcHVyaW91cyB0aW1lb3V0cy4gRm9yIHRoaXMgcmVhc29uIHdlIGNhbGN1bGF0ZSBhIHZhbHVlIHNsaWdodGx5XG4gIC8vIGxhcmdlciB0aGFuIHRoYXQgdXNlZCBpbiB0aGUgYXJ0aWNsZS5cbiAgaWYgKHJ0dCA+IDEwMCkge1xuICAgIHJldHVybiA0ICogcnR0OyAvLyBydG8gPiA0MDBtc2VjXG4gIH1cbiAgcmV0dXJuIDMwMCArIHJ0dDsgLy8gMzAwbXNlYyA8IHJ0byA8PSA0MDBtc2VjXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgdHJhbnNwb3J0cyA9IHRyYW5zcG9ydChhdmFpbGFibGVUcmFuc3BvcnRzKTtcbiAgcmVxdWlyZSgnLi9pZnJhbWUtYm9vdHN0cmFwJykoU29ja0pTLCBhdmFpbGFibGVUcmFuc3BvcnRzKTtcbiAgcmV0dXJuIFNvY2tKUztcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vZXZlbnQvY2xvc2VcIjoyLFwiLi9ldmVudC9ldmVudFwiOjQsXCIuL2V2ZW50L2V2ZW50dGFyZ2V0XCI6NSxcIi4vZXZlbnQvdHJhbnMtbWVzc2FnZVwiOjYsXCIuL2lmcmFtZS1ib290c3RyYXBcIjo4LFwiLi9pbmZvLXJlY2VpdmVyXCI6MTIsXCIuL2xvY2F0aW9uXCI6MTMsXCIuL3NoaW1zXCI6MTUsXCIuL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4vdXRpbHMvZXNjYXBlXCI6NDUsXCIuL3V0aWxzL2V2ZW50XCI6NDYsXCIuL3V0aWxzL2xvZ1wiOjQ4LFwiLi91dGlscy9vYmplY3RcIjo0OSxcIi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuL3V0aWxzL3RyYW5zcG9ydFwiOjUxLFwiLi91dGlscy91cmxcIjo1MixcIi4vdmVyc2lvblwiOjUzLFwiZGVidWdcIjo1NSxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4LFwidXJsLXBhcnNlXCI6NjF9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoganNjczogZGlzYWJsZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBwdWxsZWQgc3BlY2lmaWMgc2hpbXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cblxudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgU3RyaW5nUHJvdG90eXBlID0gU3RyaW5nLnByb3RvdHlwZTtcbnZhciBhcnJheV9zbGljZSA9IEFycmF5UHJvdG90eXBlLnNsaWNlO1xuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIE9iamVjdFByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xudmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn07XG5cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHt9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIEVTMyAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSgpKTtcblxuLy8gRGVmaW5lIGNvbmZpZ3VyYWJsZSwgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BzXG4vLyBpZiB0aGV5IGRvbid0IGV4aXN0LlxudmFyIGRlZmluZVByb3BlcnR5O1xuaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG1ldGhvZFxuICAgICAgICB9KTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICBvYmplY3RbbmFtZV0gPSBtZXRob2Q7XG4gICAgfTtcbn1cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwLCBmb3JjZUFzc2lnbikge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbWFwKSB7XG4gICAgICAgIGlmIChPYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIG5hbWUpKSB7XG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBtYXBbbmFtZV0sIGZvcmNlQXNzaWduKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciB0b09iamVjdCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKG8gPT0gbnVsbCkgeyAvLyB0aGlzIG1hdGNoZXMgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyBvICsgJyB0byBvYmplY3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdChvKTtcbn07XG5cbi8vXG4vLyBVdGlsXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSA5LjRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuNFxuLy8gaHR0cDovL2pzcGVyZi5jb20vdG8taW50ZWdlclxuXG5mdW5jdGlvbiB0b0ludGVnZXIobnVtKSB7XG4gICAgdmFyIG4gPSArbnVtO1xuICAgIGlmIChuICE9PSBuKSB7IC8vIGlzTmFOXG4gICAgICAgIG4gPSAwO1xuICAgIH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSAoMSAvIDApICYmIG4gIT09IC0oMSAvIDApKSB7XG4gICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBUb1VpbnQzMih4KSB7XG4gICAgcmV0dXJuIHggPj4+IDA7XG59XG5cbi8vXG4vLyBGdW5jdGlvblxuLy8gPT09PT09PT1cbi8vXG5cbi8vIEVTLTUgMTUuMy40LjVcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjMuNC41XG5cbmZ1bmN0aW9uIEVtcHR5KCkge31cblxuZGVmaW5lUHJvcGVydGllcyhGdW5jdGlvblByb3RvdHlwZSwge1xuICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQodGhhdCkgeyAvLyAubGVuZ3RoIGlzIDFcbiAgICAgICAgLy8gMS4gTGV0IFRhcmdldCBiZSB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgICAgIC8vIDIuIElmIElzQ2FsbGFibGUoVGFyZ2V0KSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnICsgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBMZXQgQSBiZSBhIG5ldyAocG9zc2libHkgZW1wdHkpIGludGVybmFsIGxpc3Qgb2YgYWxsIG9mIHRoZVxuICAgICAgICAvLyAgIGFyZ3VtZW50IHZhbHVlcyBwcm92aWRlZCBhZnRlciB0aGlzQXJnIChhcmcxLCBhcmcyIGV0YyksIGluIG9yZGVyLlxuICAgICAgICAvLyBYWFggc2xpY2VkQXJncyB3aWxsIHN0YW5kIGluIGZvciBcIkFcIiBpZiB1c2VkXG4gICAgICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBmb3Igbm9ybWFsIGNhbGxcbiAgICAgICAgLy8gNC4gTGV0IEYgYmUgYSBuZXcgbmF0aXZlIEVDTUFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAvLyAxMS4gU2V0IHRoZSBbW1Byb3RvdHlwZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdGhlIHN0YW5kYXJkXG4gICAgICAgIC8vICAgYnVpbHQtaW4gRnVuY3Rpb24gcHJvdG90eXBlIG9iamVjdCBhcyBzcGVjaWZpZWQgaW4gMTUuMy4zLjEuXG4gICAgICAgIC8vIDEyLiBTZXQgdGhlIFtbQ2FsbF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMS5cbiAgICAgICAgLy8gMTMuIFNldCB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjIuXG4gICAgICAgIC8vIDE0LiBTZXQgdGhlIFtbSGFzSW5zdGFuY2VdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjMuXG4gICAgICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4yIFtbQ29uc3RydWN0XV1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCxcbiAgICAgICAgICAgICAgICAvLyBGIHRoYXQgd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgIC8vIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXVxuICAgICAgICAgICAgICAgIC8vICAgaW50ZXJuYWwgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMi4gSWYgdGFyZ2V0IGhhcyBubyBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCwgYVxuICAgICAgICAgICAgICAgIC8vICAgVHlwZUVycm9yIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgICAgICAgICAgICAgLy8gMy4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBtZXRob2Qgb2YgdGFyZ2V0IHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4xIFtbQ2FsbF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LCBGLFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHZhbHVlIGFuZCBhIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgICAgICAgIC8vIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAvLyAxLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMi4gTGV0IGJvdW5kVGhpcyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRUaGlzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyAgIG9mIHRhcmdldCBwcm92aWRpbmcgYm91bmRUaGlzIGFzIHRoZSB0aGlzIHZhbHVlIGFuZFxuICAgICAgICAgICAgICAgIC8vICAgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cblxuICAgICAgICAgICAgICAgIC8vIGVxdWl2OiB0YXJnZXQuY2FsbCh0aGlzLCAuLi5ib3VuZEFyZ3MsIC4uLmFyZ3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIDE1LiBJZiB0aGUgW1tDbGFzc11dIGludGVybmFsIHByb3BlcnR5IG9mIFRhcmdldCBpcyBcIkZ1bmN0aW9uXCIsIHRoZW5cbiAgICAgICAgLy8gICAgIGEuIExldCBMIGJlIHRoZSBsZW5ndGggcHJvcGVydHkgb2YgVGFyZ2V0IG1pbnVzIHRoZSBsZW5ndGggb2YgQS5cbiAgICAgICAgLy8gICAgIGIuIFNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIGVpdGhlciAwIG9yIEwsIHdoaWNoZXZlciBpc1xuICAgICAgICAvLyAgICAgICBsYXJnZXIuXG4gICAgICAgIC8vIDE2LiBFbHNlIHNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIDAuXG5cbiAgICAgICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcblxuICAgICAgICAvLyAxNy4gU2V0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gdGhlIHZhbHVlc1xuICAgICAgICAvLyAgIHNwZWNpZmllZCBpbiAxNS4zLjUuMS5cbiAgICAgICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWFhYIEJ1aWxkIGEgZHluYW1pYyBmdW5jdGlvbiB3aXRoIGRlc2lyZWQgYW1vdW50IG9mIGFyZ3VtZW50cyBpcyB0aGUgb25seVxuICAgICAgICAvLyB3YXkgdG8gc2V0IHRoZSBsZW5ndGggcHJvcGVydHkgb2YgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gSW4gZW52aXJvbm1lbnRzIHdoZXJlIENvbnRlbnQgU2VjdXJpdHkgUG9saWNpZXMgZW5hYmxlZCAoQ2hyb21lIGV4dGVuc2lvbnMsXG4gICAgICAgIC8vIGZvciBleC4pIGFsbCB1c2Ugb2YgZXZhbCBvciBGdW5jdGlvbiBjb3N0cnVjdG9yIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgIC8vIEhvd2V2ZXIgaW4gYWxsIG9mIHRoZXNlIGVudmlyb25tZW50cyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBleGlzdHNcbiAgICAgICAgLy8gYW5kIHNvIHRoaXMgY29kZSB3aWxsIG5ldmVyIGJlIGV4ZWN1dGVkLlxuICAgICAgICB2YXIgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgICAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZGFuZ2xpbmcgcmVmZXJlbmNlcy5cbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE4LiBTZXQgdGhlIFtbRXh0ZW5zaWJsZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdHJ1ZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE5LiBMZXQgdGhyb3dlciBiZSB0aGUgW1tUaHJvd1R5cGVFcnJvcl1dIGZ1bmN0aW9uIE9iamVjdCAoMTMuMi4zKS5cbiAgICAgICAgLy8gMjAuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiY2FsbGVyXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlciwgW1tTZXRdXTpcbiAgICAgICAgLy8gICB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSwgYW5kXG4gICAgICAgIC8vICAgZmFsc2UuXG4gICAgICAgIC8vIDIxLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImFyZ3VtZW50c1wiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsXG4gICAgICAgIC8vICAgW1tTZXRdXTogdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sXG4gICAgICAgIC8vICAgYW5kIGZhbHNlLlxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gTk9URSBGdW5jdGlvbiBvYmplY3RzIGNyZWF0ZWQgdXNpbmcgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZG8gbm90XG4gICAgICAgIC8vIGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgb3IgdGhlIFtbQ29kZV1dLCBbW0Zvcm1hbFBhcmFtZXRlcnNdXSwgYW5kXG4gICAgICAgIC8vIFtbU2NvcGVdXSBpbnRlcm5hbCBwcm9wZXJ0aWVzLlxuICAgICAgICAvLyBYWFggY2FuJ3QgZGVsZXRlIHByb3RvdHlwZSBpbiBwdXJlLWpzLlxuXG4gICAgICAgIC8vIDIyLiBSZXR1cm4gRi5cbiAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cbn0pO1xuXG4vL1xuLy8gQXJyYXlcbi8vID09PT09XG4vL1xuXG4vLyBFUzUgMTUuNC4zLjJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuMy4yXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5LCB7IGlzQXJyYXk6IGlzQXJyYXkgfSk7XG5cblxudmFyIGJveGVkU3RyaW5nID0gT2JqZWN0KCdhJyk7XG52YXIgc3BsaXRTdHJpbmcgPSBib3hlZFN0cmluZ1swXSAhPT0gJ2EnIHx8ICEoMCBpbiBib3hlZFN0cmluZyk7XG5cbnZhciBwcm9wZXJseUJveGVzQ29udGV4dCA9IGZ1bmN0aW9uIHByb3Blcmx5Qm94ZWQobWV0aG9kKSB7XG4gICAgLy8gQ2hlY2sgbm9kZSAwLjYuMjEgYnVnIHdoZXJlIHRoaXJkIHBhcmFtZXRlciBpcyBub3QgYm94ZWRcbiAgICB2YXIgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IHRydWU7XG4gICAgdmFyIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0cnVlO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmNhbGwoJ2ZvbycsIGZ1bmN0aW9uIChfLCBfXywgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JykgeyBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gZmFsc2U7IH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWV0aG9kLmNhbGwoWzFdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgICAgICBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHlwZW9mIHRoaXMgPT09ICdzdHJpbmcnO1xuICAgICAgICB9LCAneCcpO1xuICAgIH1cbiAgICByZXR1cm4gISFtZXRob2QgJiYgcHJvcGVybHlCb3hlc05vblN0cmljdCAmJiBwcm9wZXJseUJveGVzU3RyaWN0O1xufTtcblxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZnVuIC8qLCB0aGlzcCovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogb2JqZWN0LFxuICAgICAgICAgICAgdGhpc3AgPSBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyAvLyBUT0RPIG1lc3NhZ2VcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggY2FsbCwgcGFzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dCwgcHJvcGVydHkgdmFsdWUsIHByb3BlcnR5IGtleSwgdGhpc0FyZyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0XG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc3AsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZm9yRWFjaCkpO1xuXG4vLyBFUzUgMTUuNC40LjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTRcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2ZcbnZhciBoYXNGaXJlZm94MkluZGV4T2ZCdWcgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAmJiBbMCwgMV0uaW5kZXhPZigxLCAyKSAhPT0gLTE7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzb3VnaHQgLyosIGZyb21JbmRleCAqLyApIHtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGkgPSB0b0ludGVnZXIoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBuZWdhdGl2ZSBpbmRpY2VzXG4gICAgICAgIGkgPSBpID49IDAgPyBpIDogTWF0aC5tYXgoMCwgbGVuZ3RoICsgaSk7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgc2VsZltpXSA9PT0gc291Z2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn0sIGhhc0ZpcmVmb3gySW5kZXhPZkJ1Zyk7XG5cbi8vXG4vLyBTdHJpbmdcbi8vID09PT09PVxuLy9cblxuLy8gRVM1IDE1LjUuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNS40LjE0XG5cbi8vIFtidWdmaXgsIElFIGx0IDksIGZpcmVmb3ggNCwgS29ucXVlcm9yLCBPcGVyYSwgb2JzY3VyZSBicm93c2Vyc11cbi8vIE1hbnkgYnJvd3NlcnMgZG8gbm90IHNwbGl0IHByb3Blcmx5IHdpdGggcmVndWxhciBleHByZXNzaW9ucyBvciB0aGV5XG4vLyBkbyBub3QgcGVyZm9ybSB0aGUgc3BsaXQgY29ycmVjdGx5IHVuZGVyIG9ic2N1cmUgY29uZGl0aW9ucy5cbi8vIFNlZSBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvY3Jvc3MtYnJvd3Nlci1zcGxpdFxuLy8gSSd2ZSB0ZXN0ZWQgaW4gbWFueSBicm93c2VycyBhbmQgdGhpcyBzZWVtcyB0byBjb3ZlciB0aGUgZGV2aWFudCBvbmVzOlxuLy8gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pIHNob3VsZCBiZSBbXCJcIiwgXCJcIl0sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKC4/KSguPykvKSBzaG91bGQgYmUgW1wiXCIsIFwiLlwiLCBcIlwiLCBcIlwiXSwgbm90IFtcIlwiLCBcIlwiXVxuLy8gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pIHNob3VsZCBiZSBbXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIFwic1wiLCBcInRcIl0sIG5vdFxuLy8gICAgICAgW3VuZGVmaW5lZCwgXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIC4uLl1cbi8vICAgICcnLnNwbGl0KC8uPy8pIHNob3VsZCBiZSBbXSwgbm90IFtcIlwiXVxuLy8gICAgJy4nLnNwbGl0KC8oKSgpLykgc2hvdWxkIGJlIFtcIi5cIl0sIG5vdCBbXCJcIiwgXCJcIiwgXCIuXCJdXG5cbnZhciBzdHJpbmdfc3BsaXQgPSBTdHJpbmdQcm90b3R5cGUuc3BsaXQ7XG5pZiAoXG4gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aCAhPT0gMiB8fFxuICAgICcuJy5zcGxpdCgvKC4/KSguPykvKS5sZW5ndGggIT09IDQgfHxcbiAgICAndGVzc3QnLnNwbGl0KC8ocykqLylbMV0gPT09ICd0JyB8fFxuICAgICd0ZXN0Jy5zcGxpdCgvKD86KS8sIC0xKS5sZW5ndGggIT09IDQgfHxcbiAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGggfHxcbiAgICAnLicuc3BsaXQoLygpKCkvKS5sZW5ndGggPiAxXG4pIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcGxpYW50RXhlY05wY2cgPSAvKCk/Py8uZXhlYygnJylbMV0gPT09IHZvaWQgMDsgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcblxuICAgICAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAgICAgdmFyIHN0cmluZyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICAgICAgICBpZiAoX3RvU3RyaW5nLmNhbGwoc2VwYXJhdG9yKSAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgICAgICAgICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSAgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5leHRlbmRlZCAgID8gJ3gnIDogJycpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgICAgID8gJ3knIDogJycpLCAvLyBGaXJlZm94IDMrXG4gICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICAgICAgICBzdHJpbmcgKz0gJyc7IC8vIFR5cGUtY29udmVydFxuICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgICAgICAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKCdeJyArIHNlcGFyYXRvci5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFZhbHVlcyBmb3IgYGxpbWl0YCwgcGVyIHRoZSBzcGVjOlxuICAgICAgICAgICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgICAgICAgICAqIElmIDAsIEluZmluaXR5LCBvciBOYU46IDBcbiAgICAgICAgICAgICAqIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBNYXRoLmZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID4gNDI5NDk2NzI5NSkgbGltaXQgLT0gNDI5NDk2NzI5NjtcbiAgICAgICAgICAgICAqIElmIG5lZ2F0aXZlIG51bWJlcjogNDI5NDk2NzI5NiAtIE1hdGguZmxvb3IoTWF0aC5hYnMobGltaXQpKVxuICAgICAgICAgICAgICogSWYgb3RoZXI6IFR5cGUtY29udmVydCwgdGhlbiB1c2UgdGhlIGFib3ZlIHJ1bGVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxpbWl0ID0gbGltaXQgPT09IHZvaWQgMCA/XG4gICAgICAgICAgICAgICAgLTEgPj4+IDAgOiAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICAgICAgICAgICAgVG9VaW50MzIobGltaXQpO1xuICAgICAgICAgICAgd2hpbGUgKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIC8vIGBzZXBhcmF0b3IubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbaV0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5UHJvdG90eXBlLnB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3IudGVzdCgnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgbGltaXQpIDogb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH0oKSk7XG5cbi8vIFtidWdmaXgsIGNocm9tZV1cbi8vIElmIHNlcGFyYXRvciBpcyB1bmRlZmluZWQsIHRoZW4gdGhlIHJlc3VsdCBhcnJheSBjb250YWlucyBqdXN0IG9uZSBTdHJpbmcsXG4vLyB3aGljaCBpcyB0aGUgdGhpcyB2YWx1ZSAoY29udmVydGVkIHRvIGEgU3RyaW5nKS4gSWYgbGltaXQgaXMgbm90IHVuZGVmaW5lZCxcbi8vIHRoZW4gdGhlIG91dHB1dCBhcnJheSBpcyB0cnVuY2F0ZWQgc28gdGhhdCBpdCBjb250YWlucyBubyBtb3JlIHRoYW4gbGltaXRcbi8vIGVsZW1lbnRzLlxuLy8gXCIwXCIuc3BsaXQodW5kZWZpbmVkLCAwKSAtPiBbXVxufSBlbHNlIGlmICgnMCcuc3BsaXQodm9pZCAwLCAwKS5sZW5ndGgpIHtcbiAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCAmJiBsaW1pdCA9PT0gMCkgeyByZXR1cm4gW107IH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG59XG5cbi8vIEVDTUEtMjYyLCAzcmQgQi4yLjNcbi8vIE5vdCBhbiBFQ01BU2NyaXB0IHN0YW5kYXJkLCBhbHRob3VnaCBFQ01BU2NyaXB0IDNyZCBFZGl0aW9uIGhhcyBhXG4vLyBub24tbm9ybWF0aXZlIHNlY3Rpb24gc3VnZ2VzdGluZyB1bmlmb3JtIHNlbWFudGljcyBhbmQgaXQgc2hvdWxkIGJlXG4vLyBub3JtYWxpemVkIGFjcm9zcyBhbGwgYnJvd3NlcnNcbi8vIFtidWdmaXgsIElFIGx0IDldIElFIDwgOSBzdWJzdHIoKSB3aXRoIG5lZ2F0aXZlIHZhbHVlIG5vdCB3b3JraW5nIGluIElFXG52YXIgc3RyaW5nX3N1YnN0ciA9IFN0cmluZ1Byb3RvdHlwZS5zdWJzdHI7XG52YXIgaGFzTmVnYXRpdmVTdWJzdHJCdWcgPSAnJy5zdWJzdHIgJiYgJzBiJy5zdWJzdHIoLTEpICE9PSAnYic7XG5kZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgIHN1YnN0cjogZnVuY3Rpb24gc3Vic3RyKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ19zdWJzdHIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBzdGFydCA8IDAgPyAoKHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydCkgPCAwID8gMCA6IHN0YXJ0KSA6IHN0YXJ0LFxuICAgICAgICAgICAgbGVuZ3RoXG4gICAgICAgICk7XG4gICAgfVxufSwgaGFzTmVnYXRpdmVTdWJzdHJCdWcpO1xuXG59LHt9XSwxNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAvLyBzdHJlYW1pbmcgdHJhbnNwb3J0c1xuICByZXF1aXJlKCcuL3RyYW5zcG9ydC93ZWJzb2NrZXQnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItc3RyZWFtaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGRyLXN0cmVhbWluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2V2ZW50c291cmNlJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvZXZlbnRzb3VyY2UnKSlcblxuICAvLyBwb2xsaW5nIHRyYW5zcG9ydHNcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvaHRtbGZpbGUnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC9odG1sZmlsZScpKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItcG9sbGluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1wb2xsaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXBvbGxpbmcnKSlcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvanNvbnAtcG9sbGluZycpXG5dO1xuXG59LHtcIi4vdHJhbnNwb3J0L2V2ZW50c291cmNlXCI6MjAsXCIuL3RyYW5zcG9ydC9odG1sZmlsZVwiOjIxLFwiLi90cmFuc3BvcnQvanNvbnAtcG9sbGluZ1wiOjIzLFwiLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwXCI6MjYsXCIuL3RyYW5zcG9ydC93ZWJzb2NrZXRcIjozOCxcIi4vdHJhbnNwb3J0L3hkci1wb2xsaW5nXCI6MzksXCIuL3RyYW5zcG9ydC94ZHItc3RyZWFtaW5nXCI6NDAsXCIuL3RyYW5zcG9ydC94aHItcG9sbGluZ1wiOjQxLFwiLi90cmFuc3BvcnQveGhyLXN0cmVhbWluZ1wiOjQyfV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2V2ZW50JylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgWEhSID0gZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0XG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpicm93c2VyOnhocicpO1xufVxuXG5mdW5jdGlvbiBBYnN0cmFjdFhIUk9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICBkZWJ1ZyhtZXRob2QsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoQWJzdHJhY3RYSFJPYmplY3QsIEV2ZW50RW1pdHRlcik7XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLnhociA9IG5ldyBYSFIoKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgfVxuXG4gIGlmICghdGhpcy54aHIpIHtcbiAgICBkZWJ1Zygnbm8geGhyJyk7XG4gICAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnbm8geGhyIHN1cHBvcnQnKTtcbiAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2V2ZXJhbCBicm93c2VycyBjYWNoZSBQT1NUc1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICd0PScgKyAoK25ldyBEYXRlKCkpKTtcblxuICAvLyBFeHBsb3JlciB0ZW5kcyB0byBrZWVwIGNvbm5lY3Rpb24gb3BlbiwgZXZlbiBhZnRlciB0aGVcbiAgLy8gdGFiIGdldHMgY2xvc2VkOiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC81MjgwXG4gIHRoaXMudW5sb2FkUmVmID0gdXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd1bmxvYWQgY2xlYW51cCcpO1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gIH0pO1xuICB0cnkge1xuICAgIHRoaXMueGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgIGlmICh0aGlzLnRpbWVvdXQgJiYgJ3RpbWVvdXQnIGluIHRoaXMueGhyKSB7XG4gICAgICB0aGlzLnhoci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgdGhpcy54aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlYnVnKCd4aHIgdGltZW91dCcpO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKCdleGNlcHRpb24nLCBlKTtcbiAgICAvLyBJRSByYWlzZXMgYW4gZXhjZXB0aW9uIG9uIHdyb25nIHBvcnQuXG4gICAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCghb3B0cyB8fCAhb3B0cy5ub0NyZWRlbnRpYWxzKSAmJiBBYnN0cmFjdFhIUk9iamVjdC5zdXBwb3J0c0NPUlMpIHtcbiAgICBkZWJ1Zygnd2l0aENyZWRlbnRpYWxzJyk7XG4gICAgLy8gTW96aWxsYSBkb2NzIHNheXMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vWE1MSHR0cFJlcXVlc3QgOlxuICAgIC8vIFwiVGhpcyBuZXZlciBhZmZlY3RzIHNhbWUtc2l0ZSByZXF1ZXN0cy5cIlxuXG4gICAgdGhpcy54aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgfVxuICBpZiAob3B0cyAmJiBvcHRzLmhlYWRlcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0cy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgb3B0cy5oZWFkZXJzW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnhocikge1xuICAgICAgdmFyIHggPSBzZWxmLnhocjtcbiAgICAgIHZhciB0ZXh0LCBzdGF0dXM7XG4gICAgICBkZWJ1ZygncmVhZHlTdGF0ZScsIHgucmVhZHlTdGF0ZSk7XG4gICAgICBzd2l0Y2ggKHgucmVhZHlTdGF0ZSkge1xuICAgICAgY2FzZSAzOlxuICAgICAgICAvLyBJRSBkb2Vzbid0IGxpa2UgcGVla2luZyBpbnRvIHJlc3BvbnNlVGV4dCBvciBzdGF0dXNcbiAgICAgICAgLy8gb24gTWljcm9zb2Z0LlhNTEhUVFAgYW5kIHJlYWR5c3RhdGU9M1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXR1cyA9IHguc3RhdHVzO1xuICAgICAgICAgIHRleHQgPSB4LnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Zygnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgLy8gSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTBcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgICAgICAgIHN0YXR1cyA9IDIwNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElFIGRvZXMgcmV0dXJuIHJlYWR5c3RhdGUgPT0gMyBmb3IgNDA0IGFuc3dlcnMuXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDIwMCAmJiB0ZXh0ICYmIHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRlYnVnKCdjaHVuaycpO1xuICAgICAgICAgIHNlbGYuZW1pdCgnY2h1bmsnLCBzdGF0dXMsIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICBzdGF0dXMgPSB4LnN0YXR1cztcbiAgICAgICAgZGVidWcoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgIC8vIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSUUgcmV0dXJucyB0aGlzIGZvciBhIGJhZCBwb3J0XG4gICAgICAgIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS93aW5kb3dzL2Rlc2t0b3AvYWEzODM3NzAodj12cy44NSkuYXNweFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjAwNSB8fCBzdGF0dXMgPT09IDEyMDI5KSB7XG4gICAgICAgICAgc3RhdHVzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB0cnkge1xuICAgIHNlbGYueGhyLnNlbmQocGF5bG9hZCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgfVxufTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oYWJvcnQpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcbiAgaWYgKCF0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB1dGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuXG4gIC8vIElFIG5lZWRzIHRoaXMgZmllbGQgdG8gYmUgYSBmdW5jdGlvblxuICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHt9O1xuICBpZiAodGhpcy54aHIub250aW1lb3V0KSB7XG4gICAgdGhpcy54aHIub250aW1lb3V0ID0gbnVsbDtcbiAgfVxuXG4gIGlmIChhYm9ydCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gIH1cbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLnhociA9IG51bGw7XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkID0gISFYSFI7XG4vLyBvdmVycmlkZSBYTUxIdHRwUmVxdWVzdCBmb3IgSUU2Lzdcbi8vIG9iZnVzY2F0ZSB0byBhdm9pZCBmaXJld2FsbHNcbnZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuaWYgKCFBYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkICYmIChheG8gaW4gZ2xvYmFsKSkge1xuICBkZWJ1Zygnb3ZlcnJpZGluZyB4bWxodHRwcmVxdWVzdCcpO1xuICBYSFIgPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBnbG9iYWxbYXhvXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG4gIEFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgPSAhIW5ldyBYSFIoKTtcbn1cblxudmFyIGNvcnMgPSBmYWxzZTtcbnRyeSB7XG4gIGNvcnMgPSAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWEhSKCk7XG59IGNhdGNoIChpZ25vcmVkKSB7XG4gIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbn1cblxuQWJzdHJhY3RYSFJPYmplY3Quc3VwcG9ydHNDT1JTID0gY29ycztcblxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdFhIUk9iamVjdDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuRXZlbnRTb3VyY2U7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBEcml2ZXIgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG5pZiAoRHJpdmVyKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gV2ViU29ja2V0QnJvd3NlckRyaXZlcih1cmwpIHtcblx0XHRyZXR1cm4gbmV3IERyaXZlcih1cmwpO1xuXHR9O1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSB1bmRlZmluZWQ7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBFdmVudFNvdXJjZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9ldmVudHNvdXJjZScpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudFNvdXJjZVRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG5cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvZXZlbnRzb3VyY2UnLCBFdmVudFNvdXJjZVJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoRXZlbnRTb3VyY2VUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cbkV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhRXZlbnRTb3VyY2VEcml2ZXI7XG59O1xuXG5FdmVudFNvdXJjZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2V2ZW50c291cmNlJztcbkV2ZW50U291cmNlVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIvZXZlbnRzb3VyY2VcIjoyOSxcIi4vc2VuZGVyL3hoci1jb3JzXCI6MzUsXCJldmVudHNvdXJjZVwiOjE4LFwiaW5oZXJpdHNcIjo1N31dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEh0bWxmaWxlUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2h0bWxmaWxlJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gIDtcblxuZnVuY3Rpb24gSHRtbEZpbGVUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFIdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9odG1sZmlsZScsIEh0bWxmaWxlUmVjZWl2ZXIsIFhIUkxvY2FsT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoSHRtbEZpbGVUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cbkh0bWxGaWxlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIHJldHVybiBIdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgJiYgaW5mby5zYW1lT3JpZ2luO1xufTtcblxuSHRtbEZpbGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdodG1sZmlsZSc7XG5IdG1sRmlsZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sRmlsZVRyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL2h0bWxmaWxlXCI6MzAsXCIuL3NlbmRlci94aHItbG9jYWxcIjozNyxcImluaGVyaXRzXCI6NTd9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBGZXcgY29vbCB0cmFuc3BvcnRzIGRvIHdvcmsgb25seSBmb3Igc2FtZS1vcmlnaW4uIEluIG9yZGVyIHRvIG1ha2Vcbi8vIHRoZW0gd29yayBjcm9zcy1kb21haW4gd2Ugc2hhbGwgdXNlIGlmcmFtZSwgc2VydmVkIGZyb20gdGhlXG4vLyByZW1vdGUgZG9tYWluLiBOZXcgYnJvd3NlcnMgaGF2ZSBjYXBhYmlsaXRpZXMgdG8gY29tbXVuaWNhdGUgd2l0aFxuLy8gY3Jvc3MgZG9tYWluIGlmcmFtZSB1c2luZyBwb3N0TWVzc2FnZSgpLiBJbiBJRSBpdCB3YXMgaW1wbGVtZW50ZWRcbi8vIGZyb20gSUUgOCssIGJ1dCBvZiBjb3Vyc2UsIElFIGdvdCBzb21lIGRldGFpbHMgd3Jvbmc6XG4vLyAgICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MxOTcwMTUodj1WUy44NSkuYXNweFxuLy8gICAgaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgdmVyc2lvbiA9IHJlcXVpcmUoJy4uL3ZlcnNpb24nKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXJsJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2lmcmFtZScpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2V2ZW50JylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi91dGlscy9yYW5kb20nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dHJhbnNwb3J0OmlmcmFtZScpO1xufVxuXG5mdW5jdGlvbiBJZnJhbWVUcmFuc3BvcnQodHJhbnNwb3J0LCB0cmFuc1VybCwgYmFzZVVybCkge1xuICBpZiAoIUlmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMub3JpZ2luID0gdXJsVXRpbHMuZ2V0T3JpZ2luKGJhc2VVcmwpO1xuICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB0aGlzLnRyYW5zVXJsID0gdHJhbnNVcmw7XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0aGlzLndpbmRvd0lkID0gcmFuZG9tLnN0cmluZyg4KTtcblxuICB2YXIgaWZyYW1lVXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2lmcmFtZS5odG1sJykgKyAnIycgKyB0aGlzLndpbmRvd0lkO1xuICBkZWJ1Zyh0cmFuc3BvcnQsIHRyYW5zVXJsLCBpZnJhbWVVcmwpO1xuXG4gIHRoaXMuaWZyYW1lT2JqID0gaWZyYW1lVXRpbHMuY3JlYXRlSWZyYW1lKGlmcmFtZVVybCwgZnVuY3Rpb24ocikge1xuICAgIGRlYnVnKCdlcnIgY2FsbGJhY2snKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgMTAwNiwgJ1VuYWJsZSB0byBsb2FkIGFuIGlmcmFtZSAoJyArIHIgKyAnKScpO1xuICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG5cbiAgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayA9IHRoaXMuX21lc3NhZ2UuYmluZCh0aGlzKTtcbiAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbWVzc2FnZScsIHRoaXMub25tZXNzYWdlQ2FsbGJhY2spO1xufVxuXG5pbmhlcml0cyhJZnJhbWVUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgIGV2ZW50VXRpbHMuZGV0YWNoRXZlbnQoJ21lc3NhZ2UnLCB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrKTtcbiAgICB0cnkge1xuICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgIHRoaXMucG9zdE1lc3NhZ2UoJ2MnKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gICAgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayA9IHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgfVxufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5fbWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwoZS5vcmlnaW4sIHRoaXMub3JpZ2luKSkge1xuICAgIGRlYnVnKCdub3Qgc2FtZSBvcmlnaW4nLCBlLm9yaWdpbiwgdGhpcy5vcmlnaW4pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpZnJhbWVNZXNzYWdlO1xuICB0cnkge1xuICAgIGlmcmFtZU1lc3NhZ2UgPSBKU09OMy5wYXJzZShlLmRhdGEpO1xuICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgZGVidWcoJ2JhZCBqc29uJywgZS5kYXRhKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gdGhpcy53aW5kb3dJZCkge1xuICAgIGRlYnVnKCdtaXNtYXRjaGVkIHdpbmRvdyBpZCcsIGlmcmFtZU1lc3NhZ2Uud2luZG93SWQsIHRoaXMud2luZG93SWQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoaWZyYW1lTWVzc2FnZS50eXBlKSB7XG4gIGNhc2UgJ3MnOlxuICAgIHRoaXMuaWZyYW1lT2JqLmxvYWRlZCgpO1xuICAgIC8vIHdpbmRvdyBnbG9iYWwgZGVwZW5kZW5jeVxuICAgIHRoaXMucG9zdE1lc3NhZ2UoJ3MnLCBKU09OMy5zdHJpbmdpZnkoW1xuICAgICAgdmVyc2lvblxuICAgICwgdGhpcy50cmFuc3BvcnRcbiAgICAsIHRoaXMudHJhbnNVcmxcbiAgICAsIHRoaXMuYmFzZVVybFxuICAgIF0pKTtcbiAgICBicmVhaztcbiAgY2FzZSAndCc6XG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICBicmVhaztcbiAgY2FzZSAnYyc6XG4gICAgdmFyIGNkYXRhO1xuICAgIHRyeSB7XG4gICAgICBjZGF0YSA9IEpTT04zLnBhcnNlKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgZGVidWcoJ2JhZCBqc29uJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIGNkYXRhWzBdLCBjZGF0YVsxXSk7XG4gICAgdGhpcy5jbG9zZSgpO1xuICAgIGJyZWFrO1xuICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICBkZWJ1ZygncG9zdE1lc3NhZ2UnLCB0eXBlLCBkYXRhKTtcbiAgdGhpcy5pZnJhbWVPYmoucG9zdChKU09OMy5zdHJpbmdpZnkoe1xuICAgIHdpbmRvd0lkOiB0aGlzLndpbmRvd0lkXG4gICwgdHlwZTogdHlwZVxuICAsIGRhdGE6IGRhdGEgfHwgJydcbiAgfSksIHRoaXMub3JpZ2luKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgZGVidWcoJ3NlbmQnLCBtZXNzYWdlKTtcbiAgdGhpcy5wb3N0TWVzc2FnZSgnbScsIG1lc3NhZ2UpO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGlmcmFtZVV0aWxzLmlmcmFtZUVuYWJsZWQ7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUnO1xuSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElmcmFtZVRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vdXRpbHMvdXJsXCI6NTIsXCIuLi92ZXJzaW9uXCI6NTMsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgc2ltcGxlc3QgYW5kIG1vc3Qgcm9idXN0IHRyYW5zcG9ydCwgdXNpbmcgdGhlIHdlbGwta25vdyBjcm9zc1xuLy8gZG9tYWluIGhhY2sgLSBKU09OUC4gVGhpcyB0cmFuc3BvcnQgaXMgcXVpdGUgaW5lZmZpY2llbnQgLSBvbmVcbi8vIG1lc3NhZ2UgY291bGQgdXNlIHVwIHRvIG9uZSBodHRwIHJlcXVlc3QuIEJ1dCBhdCBsZWFzdCBpdCB3b3JrcyBhbG1vc3Rcbi8vIGV2ZXJ5d2hlcmUuXG4vLyBLbm93biBsaW1pdGF0aW9uczpcbi8vICAgbyB5b3Ugd2lsbCBnZXQgYSBzcGlubmluZyBjdXJzb3Jcbi8vICAgbyBmb3IgS29ucXVlcm9yIGEgZHVtYiB0aW1lciBpcyBuZWVkZWQgdG8gZGV0ZWN0IGVycm9yc1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgU2VuZGVyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2xpYi9zZW5kZXItcmVjZWl2ZXInKVxuICAsIEpzb25wUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2pzb25wJylcbiAgLCBqc29ucFNlbmRlciA9IHJlcXVpcmUoJy4vc2VuZGVyL2pzb25wJylcbiAgO1xuXG5mdW5jdGlvbiBKc29uUFRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUpzb25QVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIFNlbmRlclJlY2VpdmVyLmNhbGwodGhpcywgdHJhbnNVcmwsICcvanNvbnAnLCBqc29ucFNlbmRlciwgSnNvbnBSZWNlaXZlcik7XG59XG5cbmluaGVyaXRzKEpzb25QVHJhbnNwb3J0LCBTZW5kZXJSZWNlaXZlcik7XG5cbkpzb25QVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhZ2xvYmFsLmRvY3VtZW50O1xufTtcblxuSnNvblBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdqc29ucC1wb2xsaW5nJztcbkpzb25QVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAxO1xuSnNvblBUcmFuc3BvcnQubmVlZEJvZHkgPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25QVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2xpYi9zZW5kZXItcmVjZWl2ZXJcIjoyOCxcIi4vcmVjZWl2ZXIvanNvbnBcIjozMSxcIi4vc2VuZGVyL2pzb25wXCI6MzMsXCJpbmhlcml0c1wiOjU3fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vc2VuZGVyLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmFqYXgtYmFzZWQnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQWpheFNlbmRlcihBamF4T2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgZGVidWcoJ2NyZWF0ZSBhamF4IHNlbmRlcicsIHVybCwgcGF5bG9hZCk7XG4gICAgdmFyIG9wdCA9IHt9O1xuICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdC5oZWFkZXJzID0geydDb250ZW50LXR5cGUnOiAndGV4dC9wbGFpbid9O1xuICAgIH1cbiAgICB2YXIgYWpheFVybCA9IHVybFV0aWxzLmFkZFBhdGgodXJsLCAnL3hocl9zZW5kJyk7XG4gICAgdmFyIHhvID0gbmV3IEFqYXhPYmplY3QoJ1BPU1QnLCBhamF4VXJsLCBwYXlsb2FkLCBvcHQpO1xuICAgIHhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cyk7XG4gICAgICB4byA9IG51bGw7XG5cbiAgICAgIGlmIChzdGF0dXMgIT09IDIwMCAmJiBzdGF0dXMgIT09IDIwNCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdodHRwIHN0YXR1cyAnICsgc3RhdHVzKSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdhYm9ydCcpO1xuICAgICAgeG8uY2xvc2UoKTtcbiAgICAgIHhvID0gbnVsbDtcblxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQWJvcnRlZCcpO1xuICAgICAgZXJyLmNvZGUgPSAxMDAwO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiBBamF4QmFzZWRUcmFuc3BvcnQodHJhbnNVcmwsIHVybFN1ZmZpeCwgUmVjZWl2ZXIsIEFqYXhPYmplY3QpIHtcbiAgU2VuZGVyUmVjZWl2ZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgdXJsU3VmZml4LCBjcmVhdGVBamF4U2VuZGVyKEFqYXhPYmplY3QpLCBSZWNlaXZlciwgQWpheE9iamVjdCk7XG59XG5cbmluaGVyaXRzKEFqYXhCYXNlZFRyYW5zcG9ydCwgU2VuZGVyUmVjZWl2ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFqYXhCYXNlZFRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiLi9zZW5kZXItcmVjZWl2ZXJcIjoyOCxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YnVmZmVyZWQtc2VuZGVyJyk7XG59XG5cbmZ1bmN0aW9uIEJ1ZmZlcmVkU2VuZGVyKHVybCwgc2VuZGVyKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kZXIgPSBzZW5kZXI7XG4gIHRoaXMudXJsID0gdXJsO1xufVxuXG5pbmhlcml0cyhCdWZmZXJlZFNlbmRlciwgRXZlbnRFbWl0dGVyKTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGRlYnVnKCdzZW5kJywgbWVzc2FnZSk7XG4gIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKG1lc3NhZ2UpO1xuICBpZiAoIXRoaXMuc2VuZFN0b3ApIHtcbiAgICB0aGlzLnNlbmRTY2hlZHVsZSgpO1xuICB9XG59O1xuXG4vLyBGb3IgcG9sbGluZyB0cmFuc3BvcnRzIGluIGEgc2l0dWF0aW9uIHdoZW4gaW4gdGhlIG1lc3NhZ2UgY2FsbGJhY2ssXG4vLyBuZXcgbWVzc2FnZSBpcyBiZWluZyBzZW5kLiBJZiB0aGUgc2VuZGluZyBjb25uZWN0aW9uIHdhcyBzdGFydGVkXG4vLyBiZWZvcmUgcmVjZWl2aW5nIG9uZSwgaXQgaXMgcG9zc2libGUgdG8gc2F0dXJhdGUgdGhlIG5ldHdvcmsgYW5kXG4vLyB0aW1lb3V0IGR1ZSB0byB0aGUgbGFjayBvZiByZWNlaXZpbmcgc29ja2V0LiBUbyBhdm9pZCB0aGF0IHdlIGRlbGF5XG4vLyBzZW5kaW5nIG1lc3NhZ2VzIGJ5IHNvbWUgc21hbGwgdGltZSwgaW4gb3JkZXIgdG8gbGV0IHJlY2VpdmluZ1xuLy8gY29ubmVjdGlvbiBiZSBzdGFydGVkIGJlZm9yZWhhbmQuIFRoaXMgaXMgb25seSBhIGhhbGZtZWFzdXJlIGFuZFxuLy8gZG9lcyBub3QgZml4IHRoZSBiaWcgcHJvYmxlbSwgYnV0IGl0IGRvZXMgbWFrZSB0aGUgdGVzdHMgZ28gbW9yZVxuLy8gc3RhYmxlIG9uIHNsb3cgbmV0d29ya3MuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZFNjaGVkdWxlV2FpdCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1Zygnc2VuZFNjaGVkdWxlV2FpdCcpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0cmVmO1xuICB0aGlzLnNlbmRTdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3NlbmRTdG9wJyk7XG4gICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICB9O1xuICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndGltZW91dCcpO1xuICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgIHNlbGYuc2VuZFNjaGVkdWxlKCk7XG4gIH0sIDI1KTtcbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kU2NoZWR1bGUgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ3NlbmRTY2hlZHVsZScsIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgIHZhciBwYXlsb2FkID0gJ1snICsgdGhpcy5zZW5kQnVmZmVyLmpvaW4oJywnKSArICddJztcbiAgICB0aGlzLnNlbmRTdG9wID0gdGhpcy5zZW5kZXIodGhpcy51cmwsIHBheWxvYWQsIGZ1bmN0aW9uKGVycikge1xuICAgICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGRlYnVnKCdlcnJvcicsIGVycik7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBlcnIuY29kZSB8fCAxMDA2LCAnU2VuZGluZyBlcnJvcjogJyArIGVycik7XG4gICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuc2VuZFNjaGVkdWxlV2FpdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB9XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgaWYgKHRoaXMuc2VuZFN0b3ApIHtcbiAgICB0aGlzLnNlbmRTdG9wKCk7XG4gICAgdGhpcy5zZW5kU3RvcCA9IG51bGw7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyZWRTZW5kZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBJZnJhbWVUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi9pZnJhbWUnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0JylcbiAgO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXG4gIGZ1bmN0aW9uIElmcmFtZVdyYXBUcmFuc3BvcnQodHJhbnNVcmwsIGJhc2VVcmwpIHtcbiAgICBJZnJhbWVUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdHJhbnNVcmwsIGJhc2VVcmwpO1xuICB9XG5cbiAgaW5oZXJpdHMoSWZyYW1lV3JhcFRyYW5zcG9ydCwgSWZyYW1lVHJhbnNwb3J0KTtcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbih1cmwsIGluZm8pIHtcbiAgICBpZiAoIWdsb2JhbC5kb2N1bWVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpZnJhbWVJbmZvID0gb2JqZWN0VXRpbHMuZXh0ZW5kKHt9LCBpbmZvKTtcbiAgICBpZnJhbWVJbmZvLnNhbWVPcmlnaW4gPSB0cnVlO1xuICAgIHJldHVybiB0cmFuc3BvcnQuZW5hYmxlZChpZnJhbWVJbmZvKSAmJiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xuICB9O1xuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUtJyArIHRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICBJZnJhbWVXcmFwVHJhbnNwb3J0Lm5lZWRCb2R5ID0gdHJ1ZTtcbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgKyB0cmFuc3BvcnQucm91bmRUcmlwcyAtIDE7IC8vIGh0bWwsIGphdmFzY3JpcHQgKDIpICsgdHJhbnNwb3J0IC0gbm8gQ09SUyAoMSlcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmZhY2FkZVRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICByZXR1cm4gSWZyYW1lV3JhcFRyYW5zcG9ydDtcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL29iamVjdFwiOjQ5LFwiLi4vaWZyYW1lXCI6MjIsXCJpbmhlcml0c1wiOjU3fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cG9sbGluZycpO1xufVxuXG5mdW5jdGlvbiBQb2xsaW5nKFJlY2VpdmVyLCByZWNlaXZlVXJsLCBBamF4T2JqZWN0KSB7XG4gIGRlYnVnKHJlY2VpdmVVcmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5SZWNlaXZlciA9IFJlY2VpdmVyO1xuICB0aGlzLnJlY2VpdmVVcmwgPSByZWNlaXZlVXJsO1xuICB0aGlzLkFqYXhPYmplY3QgPSBBamF4T2JqZWN0O1xuICB0aGlzLl9zY2hlZHVsZVJlY2VpdmVyKCk7XG59XG5cbmluaGVyaXRzKFBvbGxpbmcsIEV2ZW50RW1pdHRlcik7XG5cblBvbGxpbmcucHJvdG90eXBlLl9zY2hlZHVsZVJlY2VpdmVyID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfc2NoZWR1bGVSZWNlaXZlcicpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwb2xsID0gdGhpcy5wb2xsID0gbmV3IHRoaXMuUmVjZWl2ZXIodGhpcy5yZWNlaXZlVXJsLCB0aGlzLkFqYXhPYmplY3QpO1xuXG4gIHBvbGwub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIG1zZyk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgfSk7XG5cbiAgcG9sbC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGRlYnVnKCdjbG9zZScsIGNvZGUsIHJlYXNvbiwgc2VsZi5wb2xsSXNDbG9zaW5nKTtcbiAgICBzZWxmLnBvbGwgPSBwb2xsID0gbnVsbDtcblxuICAgIGlmICghc2VsZi5wb2xsSXNDbG9zaW5nKSB7XG4gICAgICBpZiAocmVhc29uID09PSAnbmV0d29yaycpIHtcbiAgICAgICAgc2VsZi5fc2NoZWR1bGVSZWNlaXZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIGNvZGUgfHwgMTAwNiwgcmVhc29uKTtcbiAgICAgICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuUG9sbGluZy5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMucG9sbElzQ2xvc2luZyA9IHRydWU7XG4gIGlmICh0aGlzLnBvbGwpIHtcbiAgICB0aGlzLnBvbGwuYWJvcnQoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBCdWZmZXJlZFNlbmRlciA9IHJlcXVpcmUoJy4vYnVmZmVyZWQtc2VuZGVyJylcbiAgLCBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlci1yZWNlaXZlcicpO1xufVxuXG5mdW5jdGlvbiBTZW5kZXJSZWNlaXZlcih0cmFuc1VybCwgdXJsU3VmZml4LCBzZW5kZXJGdW5jLCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xuICB2YXIgcG9sbFVybCA9IHVybFV0aWxzLmFkZFBhdGgodHJhbnNVcmwsIHVybFN1ZmZpeCk7XG4gIGRlYnVnKHBvbGxVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEJ1ZmZlcmVkU2VuZGVyLmNhbGwodGhpcywgdHJhbnNVcmwsIHNlbmRlckZ1bmMpO1xuXG4gIHRoaXMucG9sbCA9IG5ldyBQb2xsaW5nKFJlY2VpdmVyLCBwb2xsVXJsLCBBamF4T2JqZWN0KTtcbiAgdGhpcy5wb2xsLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgZGVidWcoJ3BvbGwgbWVzc2FnZScsIG1zZyk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgfSk7XG4gIHRoaXMucG9sbC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGRlYnVnKCdwb2xsIGNsb3NlJywgY29kZSwgcmVhc29uKTtcbiAgICBzZWxmLnBvbGwgPSBudWxsO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBjb2RlLCByZWFzb24pO1xuICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKFNlbmRlclJlY2VpdmVyLCBCdWZmZXJlZFNlbmRlcik7XG5cblNlbmRlclJlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBCdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuY2xvc2UuY2FsbCh0aGlzKTtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGlmICh0aGlzLnBvbGwpIHtcbiAgICB0aGlzLnBvbGwuYWJvcnQoKTtcbiAgICB0aGlzLnBvbGwgPSBudWxsO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlclJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCIuL2J1ZmZlcmVkLXNlbmRlclwiOjI1LFwiLi9wb2xsaW5nXCI6MjcsXCJkZWJ1Z1wiOjU1LFwiaW5oZXJpdHNcIjo1N31dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmV2ZW50c291cmNlJyk7XG59XG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVzID0gdGhpcy5lcyA9IG5ldyBFdmVudFNvdXJjZURyaXZlcih1cmwpO1xuICBlcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRlY29kZVVSSShlLmRhdGEpKTtcbiAgfTtcbiAgZXMub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnZXJyb3InLCBlcy5yZWFkeVN0YXRlLCBlKTtcbiAgICAvLyBFUyBvbiByZWNvbm5lY3Rpb24gaGFzIHJlYWR5U3RhdGUgPSAwIG9yIDEuXG4gICAgLy8gb24gbmV0d29yayBlcnJvciBpdCdzIENMT1NFRCA9IDJcbiAgICB2YXIgcmVhc29uID0gKGVzLnJlYWR5U3RhdGUgIT09IDIgPyAnbmV0d29yaycgOiAncGVybWFuZW50Jyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICAgIHNlbGYuX2Nsb3NlKHJlYXNvbik7XG4gIH07XG59XG5cbmluaGVyaXRzKEV2ZW50U291cmNlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuX2Nsb3NlKCd1c2VyJyk7XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuICB2YXIgZXMgPSB0aGlzLmVzO1xuICBpZiAoZXMpIHtcbiAgICBlcy5vbm1lc3NhZ2UgPSBlcy5vbmVycm9yID0gbnVsbDtcbiAgICBlcy5jbG9zZSgpO1xuICAgIHRoaXMuZXMgPSBudWxsO1xuICB9XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgZGVidWcoJ2Nsb3NlJywgcmVhc29uKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICAvLyBTYWZhcmkgYW5kIGNocm9tZSA8IDE1IGNyYXNoIGlmIHdlIGNsb3NlIHdpbmRvdyBiZWZvcmVcbiAgLy8gd2FpdGluZyBmb3IgRVMgY2xlYW51cC4gU2VlOlxuICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODkxNTVcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9LCAyMDApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFNvdXJjZVJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJldmVudHNvdXJjZVwiOjE4LFwiaW5oZXJpdHNcIjo1N31dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6aHRtbGZpbGUnKTtcbn1cblxuZnVuY3Rpb24gSHRtbGZpbGVSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWZyYW1lVXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBkZWNvZGVVUklDb21wb25lbnQoaWZyYW1lVXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcblxuICBkZWJ1ZygndXNpbmcgaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCk7XG4gIHZhciBjb25zdHJ1Y3RGdW5jID0gSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgP1xuICAgICAgaWZyYW1lVXRpbHMuY3JlYXRlSHRtbGZpbGUgOiBpZnJhbWVVdGlscy5jcmVhdGVJZnJhbWU7XG5cbiAgZ2xvYmFsW2lmcmFtZVV0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0ge1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdzdGFydCcpO1xuICAgICAgc2VsZi5pZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgfVxuICAsIG1lc3NhZ2U6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICB9XG4gICwgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnc3RvcCcpO1xuICAgICAgc2VsZi5fY2xlYW51cCgpO1xuICAgICAgc2VsZi5fY2xvc2UoJ25ldHdvcmsnKTtcbiAgICB9XG4gIH07XG4gIHRoaXMuaWZyYW1lT2JqID0gY29uc3RydWN0RnVuYyh1cmwsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdjYWxsYmFjaycpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICBzZWxmLl9jbG9zZSgncGVybWFuZW50Jyk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhIdG1sZmlsZVJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLl9jbG9zZSgndXNlcicpO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gIH1cbiAgZGVsZXRlIGdsb2JhbFtpZnJhbWVVdGlscy5XUHJlZml4XVt0aGlzLmlkXTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICBkZWJ1ZygnX2Nsb3NlJywgcmVhc29uKTtcbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA9IGZhbHNlO1xuXG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbmlmIChheG8gaW4gZ2xvYmFsKSB7XG4gIHRyeSB7XG4gICAgSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgPSAhIW5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgfVxufVxuXG5IdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgPSBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCB8fCBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxmaWxlUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Jyb3dzZXInKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmpzb25wJyk7XG59XG5cbmZ1bmN0aW9uIEpzb25wUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xuICB2YXIgdXJsV2l0aElkID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAnYz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHV0aWxzLldQcmVmaXggKyAnLicgKyB0aGlzLmlkKSk7XG5cbiAgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0gdGhpcy5fY2FsbGJhY2suYmluZCh0aGlzKTtcbiAgdGhpcy5fY3JlYXRlU2NyaXB0KHVybFdpdGhJZCk7XG5cbiAgLy8gRmFsbGJhY2sgbW9zdGx5IGZvciBLb25xdWVyb3IgLSBzdHVwaWQgdGltZXIsIDM1IHNlY29uZHMgc2hhbGwgYmUgcGxlbnR5LlxuICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAodGltZW91dCknKSk7XG4gIH0sIEpzb25wUmVjZWl2ZXIudGltZW91dCk7XG59XG5cbmluaGVyaXRzKEpzb25wUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICBpZiAoZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignSlNPTlAgdXNlciBhYm9ydGVkIHJlYWQnKTtcbiAgICBlcnIuY29kZSA9IDEwMDA7XG4gICAgdGhpcy5fYWJvcnQoZXJyKTtcbiAgfVxufTtcblxuSnNvbnBSZWNlaXZlci50aW1lb3V0ID0gMzUwMDA7XG5Kc29ucFJlY2VpdmVyLnNjcmlwdEVycm9yVGltZW91dCA9IDEwMDA7XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jYWxsYmFjayA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgZGVidWcoJ19jYWxsYmFjaycsIGRhdGEpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG5cbiAgaWYgKHRoaXMuYWJvcnRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZGF0YSkge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG4gIH1cbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICduZXR3b3JrJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fYWJvcnQgPSBmdW5jdGlvbihlcnIpIHtcbiAgZGVidWcoJ19hYm9ydCcsIGVycik7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5hYm9ydGluZyA9IHRydWU7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBlcnIuY29kZSwgZXJyLm1lc3NhZ2UpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gIGlmICh0aGlzLnNjcmlwdDIpIHtcbiAgICB0aGlzLnNjcmlwdDIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdDIpO1xuICAgIHRoaXMuc2NyaXB0MiA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdmFyIHNjcmlwdCA9IHRoaXMuc2NyaXB0O1xuICAgIC8vIFVuZm9ydHVuYXRlbHksIHlvdSBjYW4ndCByZWFsbHkgYWJvcnQgc2NyaXB0IGxvYWRpbmcgb2ZcbiAgICAvLyB0aGUgc2NyaXB0LlxuICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHNjcmlwdC5vbmVycm9yID1cbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbmNsaWNrID0gbnVsbDtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cbiAgZGVsZXRlIGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9zY3JpcHRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3NjcmlwdEVycm9yJyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuZXJyb3JUaW1lcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZXJyb3JUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFzZWxmLmxvYWRlZE9rYXkpIHtcbiAgICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmVycm9yKScpKTtcbiAgICB9XG4gIH0sIEpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0KTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jcmVhdGVTY3JpcHQgPSBmdW5jdGlvbih1cmwpIHtcbiAgZGVidWcoJ19jcmVhdGVTY3JpcHQnLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgdmFyIHNjcmlwdDI7ICAvLyBPcGVyYSBzeW5jaHJvbm91cyBsb2FkIHRyaWNrLlxuXG4gIHNjcmlwdC5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoOCk7XG4gIHNjcmlwdC5zcmMgPSB1cmw7XG4gIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gIHNjcmlwdC5jaGFyc2V0ID0gJ1VURi04JztcbiAgc2NyaXB0Lm9uZXJyb3IgPSB0aGlzLl9zY3JpcHRFcnJvci5iaW5kKHRoaXMpO1xuICBzY3JpcHQub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ubG9hZCcpO1xuICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmxvYWQpJykpO1xuICB9O1xuXG4gIC8vIElFOSBmaXJlcyAnZXJyb3InIGV2ZW50IGFmdGVyIG9ucmVhZHlzdGF0ZWNoYW5nZSBvciBiZWZvcmUsIGluIHJhbmRvbSBvcmRlci5cbiAgLy8gVXNlIGxvYWRlZE9rYXkgdG8gZGV0ZXJtaW5lIGlmIGFjdHVhbGx5IGVycm9yZWRcbiAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBzY3JpcHQucmVhZHlTdGF0ZSk7XG4gICAgaWYgKC9sb2FkZWR8Y2xvc2VkLy50ZXN0KHNjcmlwdC5yZWFkeVN0YXRlKSkge1xuICAgICAgaWYgKHNjcmlwdCAmJiBzY3JpcHQuaHRtbEZvciAmJiBzY3JpcHQub25jbGljaykge1xuICAgICAgICBzZWxmLmxvYWRlZE9rYXkgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEluIElFLCBhY3R1YWxseSBleGVjdXRlIHRoZSBzY3JpcHQuXG4gICAgICAgICAgc2NyaXB0Lm9uY2xpY2soKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNjcmlwdCkge1xuICAgICAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25yZWFkeXN0YXRlY2hhbmdlKScpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIElFOiBldmVudC9odG1sRm9yL29uY2xpY2sgdHJpY2suXG4gIC8vIE9uZSBjYW4ndCByZWx5IG9uIHByb3BlciBvcmRlciBmb3Igb25yZWFkeXN0YXRlY2hhbmdlLiBJbiBvcmRlciB0b1xuICAvLyBtYWtlIHN1cmUsIHNldCBhICdodG1sRm9yJyBhbmQgJ2V2ZW50JyBwcm9wZXJ0aWVzLCBzbyB0aGF0XG4gIC8vIHNjcmlwdCBjb2RlIHdpbGwgYmUgaW5zdGFsbGVkIGFzICdvbmNsaWNrJyBoYW5kbGVyIGZvciB0aGVcbiAgLy8gc2NyaXB0IG9iamVjdC4gTGF0ZXIsIG9ucmVhZHlzdGF0ZWNoYW5nZSwgbWFudWFsbHkgZXhlY3V0ZSB0aGlzXG4gIC8vIGNvZGUuIEZGIGFuZCBDaHJvbWUgZG9lc24ndCB3b3JrIHdpdGggJ2V2ZW50JyBhbmQgJ2h0bWxGb3InXG4gIC8vIHNldC4gRm9yIHJlZmVyZW5jZSBzZWU6XG4gIC8vICAgaHR0cDovL2phdWJvdXJnLm5ldC8yMDEwLzA3L2xvYWRpbmctc2NyaXB0LWFzLW9uY2xpY2staGFuZGxlci1vZi5odG1sXG4gIC8vIEFsc28sIHJlYWQgb24gdGhhdCBhYm91dCBzY3JpcHQgb3JkZXJpbmc6XG4gIC8vICAgaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0R5bmFtaWNfU2NyaXB0X0V4ZWN1dGlvbl9PcmRlclxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyA9PT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgLy8gQWNjb3JkaW5nIHRvIG1vemlsbGEgZG9jcywgaW4gcmVjZW50IGJyb3dzZXJzIHNjcmlwdC5hc3luYyBkZWZhdWx0c1xuICAgIC8vIHRvICd0cnVlJywgc28gd2UgbWF5IHVzZSBpdCB0byBkZXRlY3QgYSBnb29kIGJyb3dzZXI6XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSFRNTC9FbGVtZW50L3NjcmlwdFxuICAgIGlmICghYnJvd3Nlci5pc09wZXJhKCkpIHtcbiAgICAgIC8vIE5haXZlbHkgYXNzdW1lIHdlJ3JlIGluIElFXG4gICAgICB0cnkge1xuICAgICAgICBzY3JpcHQuaHRtbEZvciA9IHNjcmlwdC5pZDtcbiAgICAgICAgc2NyaXB0LmV2ZW50ID0gJ29uY2xpY2snO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPcGVyYSwgc2Vjb25kIHN5bmMgc2NyaXB0IGhhY2tcbiAgICAgIHNjcmlwdDIgPSB0aGlzLnNjcmlwdDIgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHQyLnRleHQgPSBcInRyeXt2YXIgYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdcIiArIHNjcmlwdC5pZCArIFwiJyk7IGlmKGEpYS5vbmVycm9yKCk7fWNhdGNoKHgpe307XCI7XG4gICAgICBzY3JpcHQuYXN5bmMgPSBzY3JpcHQyLmFzeW5jID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygc2NyaXB0LmFzeW5jICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIH1cblxuICB2YXIgaGVhZCA9IGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCk7XG4gIGlmIChzY3JpcHQyKSB7XG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0MiwgaGVhZC5maXJzdENoaWxkKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29ucFJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9icm93c2VyXCI6NDQsXCIuLi8uLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjp4aHInKTtcbn1cblxuZnVuY3Rpb24gWGhyUmVjZWl2ZXIodXJsLCBBamF4T2JqZWN0KSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5idWZmZXJQb3NpdGlvbiA9IDA7XG5cbiAgdGhpcy54byA9IG5ldyBBamF4T2JqZWN0KCdQT1NUJywgdXJsLCBudWxsKTtcbiAgdGhpcy54by5vbignY2h1bmsnLCB0aGlzLl9jaHVua0hhbmRsZXIuYmluZCh0aGlzKSk7XG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cywgdGV4dCk7XG4gICAgc2VsZi5fY2h1bmtIYW5kbGVyKHN0YXR1cywgdGV4dCk7XG4gICAgc2VsZi54byA9IG51bGw7XG4gICAgdmFyIHJlYXNvbiA9IHN0YXR1cyA9PT0gMjAwID8gJ25ldHdvcmsnIDogJ3Blcm1hbmVudCc7XG4gICAgZGVidWcoJ2Nsb3NlJywgcmVhc29uKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhYaHJSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLl9jaHVua0hhbmRsZXIgPSBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgZGVidWcoJ19jaHVua0hhbmRsZXInLCBzdGF0dXMpO1xuICBpZiAoc3RhdHVzICE9PSAyMDAgfHwgIXRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpZHggPSAtMTsgOyB0aGlzLmJ1ZmZlclBvc2l0aW9uICs9IGlkeCArIDEpIHtcbiAgICB2YXIgYnVmID0gdGV4dC5zbGljZSh0aGlzLmJ1ZmZlclBvc2l0aW9uKTtcbiAgICBpZHggPSBidWYuaW5kZXhPZignXFxuJyk7XG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgbXNnID0gYnVmLnNsaWNlKDAsIGlkeCk7XG4gICAgaWYgKG1zZykge1xuICAgICAgZGVidWcoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgICB9XG4gIH1cbn07XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgaWYgKHRoaXMueG8pIHtcbiAgICB0aGlzLnhvLmNsb3NlKCk7XG4gICAgZGVidWcoJ2Nsb3NlJyk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICd1c2VyJyk7XG4gICAgdGhpcy54byA9IG51bGw7XG4gIH1cbiAgdGhpcy5fY2xlYW51cCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXI6anNvbnAnKTtcbn1cblxudmFyIGZvcm0sIGFyZWE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUlmcmFtZShpZCkge1xuICBkZWJ1ZygnY3JlYXRlSWZyYW1lJywgaWQpO1xuICB0cnkge1xuICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgIHJldHVybiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGlmcmFtZSBuYW1lPVwiJyArIGlkICsgJ1wiPicpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgdmFyIGlmcmFtZSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZnJhbWUubmFtZSA9IGlkO1xuICAgIHJldHVybiBpZnJhbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRm9ybSgpIHtcbiAgZGVidWcoJ2NyZWF0ZUZvcm0nKTtcbiAgZm9ybSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gIGZvcm0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICBmb3JtLmVuY3R5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgZm9ybS5hY2NlcHRDaGFyc2V0ID0gJ1VURi04JztcblxuICBhcmVhID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gIGFyZWEubmFtZSA9ICdkJztcbiAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcblxuICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gIGRlYnVnKHVybCwgcGF5bG9hZCk7XG4gIGlmICghZm9ybSkge1xuICAgIGNyZWF0ZUZvcm0oKTtcbiAgfVxuICB2YXIgaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDgpO1xuICBmb3JtLnRhcmdldCA9IGlkO1xuICBmb3JtLmFjdGlvbiA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybFV0aWxzLmFkZFBhdGgodXJsLCAnL2pzb25wX3NlbmQnKSwgJ2k9JyArIGlkKTtcblxuICB2YXIgaWZyYW1lID0gY3JlYXRlSWZyYW1lKGlkKTtcbiAgaWZyYW1lLmlkID0gaWQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBmb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cbiAgdHJ5IHtcbiAgICBhcmVhLnZhbHVlID0gcGF5bG9hZDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHNlcmlvdXNseSBicm9rZW4gYnJvd3NlcnMgZ2V0IGhlcmVcbiAgfVxuICBmb3JtLnN1Ym1pdCgpO1xuXG4gIHZhciBjb21wbGV0ZWQgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBkZWJ1ZygnY29tcGxldGVkJywgaWQsIGVycik7XG4gICAgaWYgKCFpZnJhbWUub25lcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gaWZyYW1lLm9uZXJyb3IgPSBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAvLyBPcGVyYSBtaW5pIGRvZXNuJ3QgbGlrZSBpZiB3ZSBHQyBpZnJhbWVcbiAgICAvLyBpbW1lZGlhdGVseSwgdGh1cyB0aGlzIHRpbWVvdXQuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdjbGVhbmluZyB1cCcsIGlkKTtcbiAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICBpZnJhbWUgPSBudWxsO1xuICAgIH0sIDUwMCk7XG4gICAgYXJlYS52YWx1ZSA9ICcnO1xuICAgIC8vIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBkZXRlY3QgaWYgdGhlIGlmcmFtZSBzdWNjZWVkZWQgb3JcbiAgICAvLyBmYWlsZWQgdG8gc3VibWl0IG91ciBmb3JtLlxuICAgIGNhbGxiYWNrKGVycik7XG4gIH07XG4gIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBpZCk7XG4gICAgY29tcGxldGVkKCk7XG4gIH07XG4gIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25sb2FkJywgaWQpO1xuICAgIGNvbXBsZXRlZCgpO1xuICB9O1xuICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBpZCwgaWZyYW1lLnJlYWR5U3RhdGUsIGUpO1xuICAgIGlmIChpZnJhbWUucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2Fib3J0ZWQnLCBpZCk7XG4gICAgY29tcGxldGVkKG5ldyBFcnJvcignQWJvcnRlZCcpKTtcbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1fV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZXZlbnQnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9icm93c2VyJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXI6eGRyJyk7XG59XG5cbi8vIFJlZmVyZW5jZXM6XG4vLyAgIGh0dHA6Ly9hamF4aWFuLmNvbS9hcmNoaXZlcy8xMDAtbGluZS1hamF4LXdyYXBwZXJcbi8vICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjMjg4MDYwKHY9VlMuODUpLmFzcHhcblxuZnVuY3Rpb24gWERST2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gIGRlYnVnKG1ldGhvZCwgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX3N0YXJ0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKFhEUk9iamVjdCwgRXZlbnRFbWl0dGVyKTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCkge1xuICBkZWJ1ZygnX3N0YXJ0Jyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHhkciA9IG5ldyBnbG9iYWwuWERvbWFpblJlcXVlc3QoKTtcbiAgLy8gSUUgY2FjaGVzIGV2ZW4gUE9TVHNcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAndD0nICsgKCtuZXcgRGF0ZSgpKSk7XG5cbiAgeGRyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicpO1xuICAgIHNlbGYuX2Vycm9yKCk7XG4gIH07XG4gIHhkci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb250aW1lb3V0Jyk7XG4gICAgc2VsZi5fZXJyb3IoKTtcbiAgfTtcbiAgeGRyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygncHJvZ3Jlc3MnLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICBzZWxmLmVtaXQoJ2NodW5rJywgMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgfTtcbiAgeGRyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdsb2FkJyk7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICB9O1xuICB0aGlzLnhkciA9IHhkcjtcbiAgdGhpcy51bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICB9KTtcbiAgdHJ5IHtcbiAgICAvLyBGYWlscyB3aXRoIEFjY2Vzc0RlbmllZCBpZiBwb3J0IG51bWJlciBpcyBib2d1c1xuICAgIHRoaXMueGRyLm9wZW4obWV0aG9kLCB1cmwpO1xuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIHRoaXMueGRyLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgfVxuICAgIHRoaXMueGRyLnNlbmQocGF5bG9hZCk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICB0aGlzLl9lcnJvcigpO1xuICB9XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oYWJvcnQpIHtcbiAgZGVidWcoJ2NsZWFudXAnLCBhYm9ydCk7XG4gIGlmICghdGhpcy54ZHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgZXZlbnRVdGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuXG4gIHRoaXMueGRyLm9udGltZW91dCA9IHRoaXMueGRyLm9uZXJyb3IgPSB0aGlzLnhkci5vbnByb2dyZXNzID0gdGhpcy54ZHIub25sb2FkID0gbnVsbDtcbiAgaWYgKGFib3J0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGRyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgfVxuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMueGRyID0gbnVsbDtcbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG59O1xuXG4vLyBJRSA4LzkgaWYgdGhlIHJlcXVlc3QgdGFyZ2V0IHVzZXMgdGhlIHNhbWUgc2NoZW1lIC0gIzc5XG5YRFJPYmplY3QuZW5hYmxlZCA9ICEhKGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiBicm93c2VyLmhhc0RvbWFpbigpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBYRFJPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4uLy4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkNvcnNPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xufVxuXG5pbmhlcml0cyhYSFJDb3JzT2JqZWN0LCBYaHJEcml2ZXIpO1xuXG5YSFJDb3JzT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZCAmJiBYaHJEcml2ZXIuc3VwcG9ydHNDT1JTO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkNvcnNPYmplY3Q7XG5cbn0se1wiLi4vZHJpdmVyL3hoclwiOjE3LFwiaW5oZXJpdHNcIjo1N31dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkZha2UoLyogbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMgKi8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLnRvID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDIwMCwgJ3t9Jyk7XG4gIH0sIFhIUkZha2UudGltZW91dCk7XG59XG5cbmluaGVyaXRzKFhIUkZha2UsIEV2ZW50RW1pdHRlcik7XG5cblhIUkZha2UucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRvKTtcbn07XG5cblhIUkZha2UudGltZW91dCA9IDIwMDA7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSRmFrZTtcblxufSx7XCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkxvY2FsT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkIC8qLCBvcHRzICovKSB7XG4gIFhockRyaXZlci5jYWxsKHRoaXMsIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCB7XG4gICAgbm9DcmVkZW50aWFsczogdHJ1ZVxuICB9KTtcbn1cblxuaW5oZXJpdHMoWEhSTG9jYWxPYmplY3QsIFhockRyaXZlcik7XG5cblhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZDtcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJMb2NhbE9iamVjdDtcblxufSx7XCIuLi9kcml2ZXIveGhyXCI6MTcsXCJpbmhlcml0c1wiOjU3fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnQnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXJsJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBXZWJzb2NrZXREcml2ZXIgPSByZXF1aXJlKCcuL2RyaXZlci93ZWJzb2NrZXQnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6d2Vic29ja2V0Jyk7XG59XG5cbmZ1bmN0aW9uIFdlYlNvY2tldFRyYW5zcG9ydCh0cmFuc1VybCwgaWdub3JlLCBvcHRpb25zKSB7XG4gIGlmICghV2ViU29ja2V0VHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG5cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIGRlYnVnKCdjb25zdHJ1Y3RvcicsIHRyYW5zVXJsKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB1cmwgPSB1cmxVdGlscy5hZGRQYXRoKHRyYW5zVXJsLCAnL3dlYnNvY2tldCcpO1xuICBpZiAodXJsLnNsaWNlKDAsIDUpID09PSAnaHR0cHMnKSB7XG4gICAgdXJsID0gJ3dzcycgKyB1cmwuc2xpY2UoNSk7XG4gIH0gZWxzZSB7XG4gICAgdXJsID0gJ3dzJyArIHVybC5zbGljZSg0KTtcbiAgfVxuICB0aGlzLnVybCA9IHVybDtcblxuICB0aGlzLndzID0gbmV3IFdlYnNvY2tldERyaXZlcih0aGlzLnVybCwgW10sIG9wdGlvbnMpO1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZSBldmVudCcsIGUuZGF0YSk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgfTtcbiAgLy8gRmlyZWZveCBoYXMgYW4gaW50ZXJlc3RpbmcgYnVnLiBJZiBhIHdlYnNvY2tldCBjb25uZWN0aW9uIGlzXG4gIC8vIGNyZWF0ZWQgYWZ0ZXIgb251bmxvYWQsIGl0IHN0YXlzIGFsaXZlIGV2ZW4gd2hlbiB1c2VyXG4gIC8vIG5hdmlnYXRlcyBhd2F5IGZyb20gdGhlIHBhZ2UuIEluIHN1Y2ggc2l0dWF0aW9uIGxldCdzIGxpZSAtXG4gIC8vIGxldCdzIG5vdCBvcGVuIHRoZSB3cyBjb25uZWN0aW9uIGF0IGFsbC4gU2VlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vc29ja2pzL3NvY2tqcy1jbGllbnQvaXNzdWVzLzI4XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NjA4NVxuICB0aGlzLnVubG9hZFJlZiA9IHV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndW5sb2FkJyk7XG4gICAgc2VsZi53cy5jbG9zZSgpO1xuICB9KTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdjbG9zZSBldmVudCcsIGUuY29kZSwgZS5yZWFzb24pO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBlLmNvZGUsIGUucmVhc29uKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH07XG4gIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnZXJyb3IgZXZlbnQnLCBlKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgMTAwNiwgJ1dlYlNvY2tldCBjb25uZWN0aW9uIGJyb2tlbicpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfTtcbn1cblxuaW5oZXJpdHMoV2ViU29ja2V0VHJhbnNwb3J0LCBFdmVudEVtaXR0ZXIpO1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBtc2cgPSAnWycgKyBkYXRhICsgJ10nO1xuICBkZWJ1Zygnc2VuZCcsIG1zZyk7XG4gIHRoaXMud3Muc2VuZChtc2cpO1xufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdmFyIHdzID0gdGhpcy53cztcbiAgdGhpcy5fY2xlYW51cCgpO1xuICBpZiAod3MpIHtcbiAgICB3cy5jbG9zZSgpO1xuICB9XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB2YXIgd3MgPSB0aGlzLndzO1xuICBpZiAod3MpIHtcbiAgICB3cy5vbm1lc3NhZ2UgPSB3cy5vbmNsb3NlID0gd3Mub25lcnJvciA9IG51bGw7XG4gIH1cbiAgdXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLndzID0gbnVsbDtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdlbmFibGVkJyk7XG4gIHJldHVybiAhIVdlYnNvY2tldERyaXZlcjtcbn07XG5XZWJTb2NrZXRUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vLyBJbiB0aGVvcnksIHdzIHNob3VsZCByZXF1aXJlIDEgcm91bmQgdHJpcC4gQnV0IGluIGNocm9tZSwgdGhpcyBpc1xuLy8gbm90IHZlcnkgc3RhYmxlIG92ZXIgU1NMLiBNb3N0IGxpa2VseSBhIHdzIGNvbm5lY3Rpb24gcmVxdWlyZXMgYVxuLy8gc2VwYXJhdGUgU1NMIGNvbm5lY3Rpb24sIGluIHdoaWNoIGNhc2UgMiByb3VuZCB0cmlwcyBhcmUgYW5cbi8vIGFic29sdXRlIG1pbnVtdW0uXG5XZWJTb2NrZXRUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0VHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uL3V0aWxzL3VybFwiOjUyLFwiLi9kcml2ZXIvd2Vic29ja2V0XCI6MTksXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYZHJTdHJlYW1pbmdUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3hkci1zdHJlYW1pbmcnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhEUk9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hkcicpXG4gIDtcblxuZnVuY3Rpb24gWGRyUG9sbGluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhEUk9iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XG59XG5cbmluaGVyaXRzKFhkclBvbGxpbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhkclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkO1xuWGRyUG9sbGluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hkci1wb2xsaW5nJztcblhkclBvbGxpbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhkclBvbGxpbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hkclwiOjM0LFwiLi94ZHItc3RyZWFtaW5nXCI6NDAsXCJpbmhlcml0c1wiOjU3fV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWERST2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGRyJylcbiAgO1xuXG4vLyBBY2NvcmRpbmcgdG86XG4vLyAgIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY0MTUwNy9kZXRlY3QtYnJvd3Nlci1zdXBwb3J0LWZvci1jcm9zcy1kb21haW4teG1saHR0cHJlcXVlc3RzXG4vLyAgIGh0dHA6Ly9oYWNrcy5tb3ppbGxhLm9yZy8yMDA5LzA3L2Nyb3NzLXNpdGUteG1saHR0cHJlcXVlc3Qtd2l0aC1jb3JzL1xuXG5mdW5jdGlvbiBYZHJTdHJlYW1pbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYRFJPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgWERST2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGRyU3RyZWFtaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8uY29va2llX25lZWRlZCB8fCBpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIFhEUk9iamVjdC5lbmFibGVkICYmIGluZm8uc2FtZVNjaGVtZTtcbn07XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hkci1zdHJlYW1pbmcnO1xuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYZHJTdHJlYW1pbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hkclwiOjM0LFwiaW5oZXJpdHNcIjo1N31dLDQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICA7XG5cbmZ1bmN0aW9uIFhoclBvbGxpbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmICFYSFJDb3JzT2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKFhoclBvbGxpbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhoclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmIGluZm8uc2FtZU9yaWdpbikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBYSFJDb3JzT2JqZWN0LmVuYWJsZWQ7XG59O1xuXG5YaHJQb2xsaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGhyLXBvbGxpbmcnO1xuWGhyUG9sbGluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyUG9sbGluZ1RyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlscy9icm93c2VyJylcbiAgO1xuXG5mdW5jdGlvbiBYaHJTdHJlYW1pbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmICFYSFJDb3JzT2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYaHJTdHJlYW1pbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhoclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIE9wZXJhIGRvZXNuJ3Qgc3VwcG9ydCB4aHItc3RyZWFtaW5nICM2MFxuICAvLyBCdXQgaXQgbWlnaHQgYmUgYWJsZSB0byAjOTJcbiAgaWYgKGJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIFhIUkNvcnNPYmplY3QuZW5hYmxlZDtcbn07XG5cblhoclN0cmVhbWluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hoci1zdHJlYW1pbmcnO1xuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxuLy8gU2FmYXJpIGdldHMgY29uZnVzZWQgd2hlbiBhIHN0cmVhbWluZyBhamF4IHJlcXVlc3QgaXMgc3RhcnRlZFxuLy8gYmVmb3JlIG9ubG9hZC4gVGhpcyBjYXVzZXMgdGhlIGxvYWQgaW5kaWNhdG9yIHRvIHNwaW4gaW5kZWZpbmV0ZWx5LlxuLy8gT25seSByZXF1aXJlIGJvZHkgd2hlbiB1c2VkIGluIGEgYnJvd3NlclxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0Lm5lZWRCb2R5ID0gISFnbG9iYWwuZG9jdW1lbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyU3RyZWFtaW5nVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi91dGlscy9icm93c2VyXCI6NDQsXCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuaWYgKGdsb2JhbC5jcnlwdG8gJiYgZ2xvYmFsLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ5dGVzW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPcGVyYTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5uYXZpZ2F0b3IgJiZcbiAgICAgIC9vcGVyYS9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiwgaXNLb25xdWVyb3I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmXG4gICAgICAva29ucXVlcm9yL2kudGVzdChnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvLyAjMTg3IHdyYXAgZG9jdW1lbnQuZG9tYWluIGluIHRyeS9jYXRjaCBiZWNhdXNlIG9mIFdQOCBmcm9tIGZpbGU6Ly8vXG4sIGhhc0RvbWFpbjogZnVuY3Rpb24gKCkge1xuICAgIC8vIG5vbi1icm93c2VyIGNsaWVudCBhbHdheXMgaGFzIGEgZG9tYWluXG4gICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQuZG9tYWluO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJyk7XG5cbi8vIFNvbWUgZXh0cmEgY2hhcmFjdGVycyB0aGF0IENocm9tZSBnZXRzIHdyb25nLCBhbmQgc3Vic3RpdHV0ZXMgd2l0aFxuLy8gc29tZXRoaW5nIGVsc2Ugb24gdGhlIHdpcmUuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxudmFyIGV4dHJhRXNjYXBhYmxlID0gL1tcXHgwMC1cXHgxZlxcdWQ4MDAtXFx1ZGZmZlxcdWZmZmVcXHVmZmZmXFx1MDMwMC1cXHUwMzMzXFx1MDMzZC1cXHUwMzQ2XFx1MDM0YS1cXHUwMzRjXFx1MDM1MC1cXHUwMzUyXFx1MDM1Ny1cXHUwMzU4XFx1MDM1Yy1cXHUwMzYyXFx1MDM3NFxcdTAzN2VcXHUwMzg3XFx1MDU5MS1cXHUwNWFmXFx1MDVjNFxcdTA2MTAtXFx1MDYxN1xcdTA2NTMtXFx1MDY1NFxcdTA2NTctXFx1MDY1YlxcdTA2NWQtXFx1MDY1ZVxcdTA2ZGYtXFx1MDZlMlxcdTA2ZWItXFx1MDZlY1xcdTA3MzBcXHUwNzMyLVxcdTA3MzNcXHUwNzM1LVxcdTA3MzZcXHUwNzNhXFx1MDczZFxcdTA3M2YtXFx1MDc0MVxcdTA3NDNcXHUwNzQ1XFx1MDc0N1xcdTA3ZWItXFx1MDdmMVxcdTA5NTFcXHUwOTU4LVxcdTA5NWZcXHUwOWRjLVxcdTA5ZGRcXHUwOWRmXFx1MGEzM1xcdTBhMzZcXHUwYTU5LVxcdTBhNWJcXHUwYTVlXFx1MGI1Yy1cXHUwYjVkXFx1MGUzOC1cXHUwZTM5XFx1MGY0M1xcdTBmNGRcXHUwZjUyXFx1MGY1N1xcdTBmNWNcXHUwZjY5XFx1MGY3Mi1cXHUwZjc2XFx1MGY3OFxcdTBmODAtXFx1MGY4M1xcdTBmOTNcXHUwZjlkXFx1MGZhMlxcdTBmYTdcXHUwZmFjXFx1MGZiOVxcdTE5MzktXFx1MTkzYVxcdTFhMTdcXHUxYjZiXFx1MWNkYS1cXHUxY2RiXFx1MWRjMC1cXHUxZGNmXFx1MWRmY1xcdTFkZmVcXHUxZjcxXFx1MWY3M1xcdTFmNzVcXHUxZjc3XFx1MWY3OVxcdTFmN2JcXHUxZjdkXFx1MWZiYlxcdTFmYmVcXHUxZmM5XFx1MWZjYlxcdTFmZDNcXHUxZmRiXFx1MWZlM1xcdTFmZWJcXHUxZmVlLVxcdTFmZWZcXHUxZmY5XFx1MWZmYlxcdTFmZmRcXHUyMDAwLVxcdTIwMDFcXHUyMGQwLVxcdTIwZDFcXHUyMGQ0LVxcdTIwZDdcXHUyMGU3LVxcdTIwZTlcXHUyMTI2XFx1MjEyYS1cXHUyMTJiXFx1MjMyOS1cXHUyMzJhXFx1MmFkY1xcdTMwMmItXFx1MzAyY1xcdWFhYjItXFx1YWFiM1xcdWY5MDAtXFx1ZmEwZFxcdWZhMTBcXHVmYTEyXFx1ZmExNS1cXHVmYTFlXFx1ZmEyMFxcdWZhMjJcXHVmYTI1LVxcdWZhMjZcXHVmYTJhLVxcdWZhMmRcXHVmYTMwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjFkXFx1ZmIxZlxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiNGVcXHVmZmYwLVxcdWZmZmZdL2dcbiAgLCBleHRyYUxvb2t1cDtcblxuLy8gVGhpcyBtYXkgYmUgcXVpdGUgc2xvdywgc28gbGV0J3MgZGVsYXkgdW50aWwgdXNlciBhY3R1YWxseSB1c2VzIGJhZFxuLy8gY2hhcmFjdGVycy5cbnZhciB1bnJvbGxMb29rdXAgPSBmdW5jdGlvbihlc2NhcGFibGUpIHtcbiAgdmFyIGk7XG4gIHZhciB1bnJvbGxlZCA9IHt9O1xuICB2YXIgYyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgNjU1MzY7IGkrKykge1xuICAgIGMucHVzaCggU3RyaW5nLmZyb21DaGFyQ29kZShpKSApO1xuICB9XG4gIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICBjLmpvaW4oJycpLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgdW5yb2xsZWRbIGEgXSA9ICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgIHJldHVybiAnJztcbiAgfSk7XG4gIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICByZXR1cm4gdW5yb2xsZWQ7XG59O1xuXG4vLyBRdW90ZSBzdHJpbmcsIGFsc28gdGFraW5nIGNhcmUgb2YgdW5pY29kZSBjaGFyYWN0ZXJzIHRoYXQgYnJvd3NlcnNcbi8vIG9mdGVuIGJyZWFrLiBFc3BlY2lhbGx5LCB0YWtlIGNhcmUgb2YgdW5pY29kZSBzdXJyb2dhdGVzOlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXBwaW5nX29mX1VuaWNvZGVfY2hhcmFjdGVycyNTdXJyb2dhdGVzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcXVvdGU6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBxdW90ZWQgPSBKU09OMy5zdHJpbmdpZnkoc3RyaW5nKTtcblxuICAgIC8vIEluIG1vc3QgY2FzZXMgdGhpcyBzaG91bGQgYmUgdmVyeSBmYXN0IGFuZCBnb29kIGVub3VnaC5cbiAgICBleHRyYUVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIGlmICghZXh0cmFFc2NhcGFibGUudGVzdChxdW90ZWQpKSB7XG4gICAgICByZXR1cm4gcXVvdGVkO1xuICAgIH1cblxuICAgIGlmICghZXh0cmFMb29rdXApIHtcbiAgICAgIGV4dHJhTG9va3VwID0gdW5yb2xsTG9va3VwKGV4dHJhRXNjYXBhYmxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVvdGVkLnJlcGxhY2UoZXh0cmFFc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBleHRyYUxvb2t1cFthXTtcbiAgICB9KTtcbiAgfVxufTtcblxufSx7XCJqc29uM1wiOjU4fV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcblxudmFyIG9uVW5sb2FkID0ge31cbiAgLCBhZnRlclVubG9hZCA9IGZhbHNlXG4gICAgLy8gZGV0ZWN0IGdvb2dsZSBjaHJvbWUgcGFja2FnZWQgYXBwcyBiZWNhdXNlIHRoZXkgZG9uJ3QgYWxsb3cgdGhlICd1bmxvYWQnIGV2ZW50XG4gICwgaXNDaHJvbWVQYWNrYWdlZEFwcCA9IGdsb2JhbC5jaHJvbWUgJiYgZ2xvYmFsLmNocm9tZS5hcHAgJiYgZ2xvYmFsLmNocm9tZS5hcHAucnVudGltZVxuICA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhdHRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hdHRhY2hFdmVudCkge1xuICAgICAgLy8gSUUgcXVpcmtzLlxuICAgICAgLy8gQWNjb3JkaW5nIHRvOiBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG4gICAgICAvLyB0aGUgbWVzc2FnZSBnZXRzIGRlbGl2ZXJlZCBvbmx5IHRvICdkb2N1bWVudCcsIG5vdCAnd2luZG93Jy5cbiAgICAgIGdsb2JhbC5kb2N1bWVudC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIC8vIEkgZ2V0ICd3aW5kb3cnIGZvciBpZTguXG4gICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiwgZGV0YWNoRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuZGV0YWNoRXZlbnQpIHtcbiAgICAgIGdsb2JhbC5kb2N1bWVudC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIGdsb2JhbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuLCB1bmxvYWRBZGQ6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgaWYgKGlzQ2hyb21lUGFja2FnZWRBcHApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciByZWYgPSByYW5kb20uc3RyaW5nKDgpO1xuICAgIG9uVW5sb2FkW3JlZl0gPSBsaXN0ZW5lcjtcbiAgICBpZiAoYWZ0ZXJVbmxvYWQpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy50cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuXG4sIHVubG9hZERlbDogZnVuY3Rpb24ocmVmKSB7XG4gICAgaWYgKHJlZiBpbiBvblVubG9hZCkge1xuICAgICAgZGVsZXRlIG9uVW5sb2FkW3JlZl07XG4gICAgfVxuICB9XG5cbiwgdHJpZ2dlclVubG9hZENhbGxiYWNrczogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcmVmIGluIG9uVW5sb2FkKSB7XG4gICAgICBvblVubG9hZFtyZWZdKCk7XG4gICAgICBkZWxldGUgb25VbmxvYWRbcmVmXTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB1bmxvYWRUcmlnZ2VyZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGFmdGVyVW5sb2FkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFmdGVyVW5sb2FkID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMudHJpZ2dlclVubG9hZENhbGxiYWNrcygpO1xufTtcblxuLy8gJ3VubG9hZCcgYWxvbmUgaXMgbm90IHJlbGlhYmxlIGluIG9wZXJhIHdpdGhpbiBhbiBpZnJhbWUsIGJ1dCB3ZVxuLy8gY2FuJ3QgdXNlIGBiZWZvcmV1bmxvYWRgIGFzIElFIGZpcmVzIGl0IG9uIGphdmFzY3JpcHQ6IGxpbmtzLlxuaWYgKCFpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XG4gIG1vZHVsZS5leHBvcnRzLmF0dGFjaEV2ZW50KCd1bmxvYWQnLCB1bmxvYWRUcmlnZ2VyZWQpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL3JhbmRvbVwiOjUwfV0sNDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudFV0aWxzID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4vYnJvd3NlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczppZnJhbWUnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdQcmVmaXg6ICdfanAnXG4sIGN1cnJlbnRXaW5kb3dJZDogbnVsbFxuXG4sIHBvbGx1dGVHbG9iYWxOYW1lc3BhY2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghKG1vZHVsZS5leHBvcnRzLldQcmVmaXggaW4gZ2xvYmFsKSkge1xuICAgICAgZ2xvYmFsW21vZHVsZS5leHBvcnRzLldQcmVmaXhdID0ge307XG4gICAgfVxuICB9XG5cbiwgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICBpZiAoZ2xvYmFsLnBhcmVudCAhPT0gZ2xvYmFsKSB7XG4gICAgICBnbG9iYWwucGFyZW50LnBvc3RNZXNzYWdlKEpTT04zLnN0cmluZ2lmeSh7XG4gICAgICAgIHdpbmRvd0lkOiBtb2R1bGUuZXhwb3J0cy5jdXJyZW50V2luZG93SWRcbiAgICAgICwgdHlwZTogdHlwZVxuICAgICAgLCBkYXRhOiBkYXRhIHx8ICcnXG4gICAgICB9KSwgJyonKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ0Nhbm5vdCBwb3N0TWVzc2FnZSwgbm8gcGFyZW50IHdpbmRvdy4nLCB0eXBlLCBkYXRhKTtcbiAgICB9XG4gIH1cblxuLCBjcmVhdGVJZnJhbWU6IGZ1bmN0aW9uKGlmcmFtZVVybCwgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgdmFyIHRyZWYsIHVubG9hZFJlZjtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCd1bmF0dGFjaCcpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgLy8gRXhwbG9yZXIgaGFkIHByb2JsZW1zIHdpdGggdGhhdC5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XG4gICAgfTtcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgLy8gVGhpcyB0aW1lb3V0IG1ha2VzIGNocm9tZSBmaXJlIG9uYmVmb3JldW5sb2FkIGV2ZW50XG4gICAgICAgIC8vIHdpdGhpbiBpZnJhbWUuIFdpdGhvdXQgdGhlIHRpbWVvdXQgaXQgZ29lcyBzdHJhaWdodCB0b1xuICAgICAgICAvLyBvbnVubG9hZC5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZnJhbWUgPSBudWxsO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgZXZlbnRVdGlscy51bmxvYWREZWwodW5sb2FkUmVmKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBkZWJ1Zygnb25lcnJvcicsIGVycik7XG4gICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgZGVidWcoJ3Bvc3QnLCBtc2csIG9yaWdpbik7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1zZywgb3JpZ2luKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH07XG5cbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lVXJsO1xuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGlmcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ29uZXJyb3InKTtcbiAgICB9O1xuICAgIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdvbmxvYWQnKTtcbiAgICAgIC8vIGBvbmxvYWRgIGlzIHRyaWdnZXJlZCBiZWZvcmUgc2NyaXB0cyBvbiB0aGUgaWZyYW1lIGFyZVxuICAgICAgLy8gZXhlY3V0ZWQuIEdpdmUgaXQgZmV3IHNlY29uZHMgdG8gYWN0dWFsbHkgbG9hZCBzdHVmZi5cbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBvbmVycm9yKCdvbmxvYWQgdGltZW91dCcpO1xuICAgICAgfSwgMjAwMCk7XG4gICAgfTtcbiAgICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcigndGltZW91dCcpO1xuICAgIH0sIDE1MDAwKTtcbiAgICB1bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChjbGVhbnVwKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zdDogcG9zdFxuICAgICwgY2xlYW51cDogY2xlYW51cFxuICAgICwgbG9hZGVkOiB1bmF0dGFjaFxuICAgIH07XG4gIH1cblxuLyogZXNsaW50IG5vLXVuZGVmOiBcIm9mZlwiLCBuZXctY2FwOiBcIm9mZlwiICovXG4sIGNyZWF0ZUh0bWxmaWxlOiBmdW5jdGlvbihpZnJhbWVVcmwsIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbiAgICB2YXIgZG9jID0gbmV3IGdsb2JhbFtheG9dKCdodG1sZmlsZScpO1xuICAgIHZhciB0cmVmLCB1bmxvYWRSZWY7XG4gICAgdmFyIGlmcmFtZTtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIGlmcmFtZS5vbmVycm9yID0gbnVsbDtcbiAgICB9O1xuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHVuYXR0YWNoKCk7XG4gICAgICAgIGV2ZW50VXRpbHMudW5sb2FkRGVsKHVubG9hZFJlZik7XG4gICAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgIGlmcmFtZSA9IGRvYyA9IG51bGw7XG4gICAgICAgIENvbGxlY3RHYXJiYWdlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgIGRlYnVnKCdvbmVycm9yJywgcik7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwb3N0ID0gZnVuY3Rpb24obXNnLCBvcmlnaW4pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaWZyYW1lICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1zZywgb3JpZ2luKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRvYy5vcGVuKCk7XG4gICAgZG9jLndyaXRlKCc8aHRtbD48cycgKyAnY3JpcHQ+JyArXG4gICAgICAgICAgICAgICdkb2N1bWVudC5kb21haW49XCInICsgZ2xvYmFsLmRvY3VtZW50LmRvbWFpbiArICdcIjsnICtcbiAgICAgICAgICAgICAgJzwvcycgKyAnY3JpcHQ+PC9odG1sPicpO1xuICAgIGRvYy5jbG9zZSgpO1xuICAgIGRvYy5wYXJlbnRXaW5kb3dbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF0gPSBnbG9iYWxbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF07XG4gICAgdmFyIGMgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoYyk7XG4gICAgaWZyYW1lID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGMuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lVXJsO1xuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCdvbmVycm9yJyk7XG4gICAgfTtcbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ3RpbWVvdXQnKTtcbiAgICB9LCAxNTAwMCk7XG4gICAgdW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoY2xlYW51cCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3Q6IHBvc3RcbiAgICAsIGNsZWFudXA6IGNsZWFudXBcbiAgICAsIGxvYWRlZDogdW5hdHRhY2hcbiAgICB9O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5pZnJhbWVFbmFibGVkID0gZmFsc2U7XG5pZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gIC8vIHBvc3RNZXNzYWdlIG1pc2JlaGF2ZXMgaW4ga29ucXVlcm9yIDQuNi41IC0gdGhlIG1lc3NhZ2VzIGFyZSBkZWxpdmVyZWQgd2l0aFxuICAvLyBodWdlIGRlbGF5LCBvciBub3QgYXQgYWxsLlxuICBtb2R1bGUuZXhwb3J0cy5pZnJhbWVFbmFibGVkID0gKHR5cGVvZiBnbG9iYWwucG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicgfHxcbiAgICB0eXBlb2YgZ2xvYmFsLnBvc3RNZXNzYWdlID09PSAnb2JqZWN0JykgJiYgKCFicm93c2VyLmlzS29ucXVlcm9yKCkpO1xufVxuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2Jyb3dzZXJcIjo0NCxcIi4vZXZlbnRcIjo0NixcImRlYnVnXCI6NTUsXCJqc29uM1wiOjU4fV0sNDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbG9nT2JqZWN0ID0ge307XG5bJ2xvZycsICdkZWJ1ZycsICd3YXJuJ10uZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgdmFyIGxldmVsRXhpc3RzO1xuXG4gIHRyeSB7XG4gICAgbGV2ZWxFeGlzdHMgPSBnbG9iYWwuY29uc29sZSAmJiBnbG9iYWwuY29uc29sZVtsZXZlbF0gJiYgZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdLmFwcGx5O1xuICB9IGNhdGNoKGUpIHtcbiAgICAvLyBkbyBub3RoaW5nXG4gIH1cblxuICBsb2dPYmplY3RbbGV2ZWxdID0gbGV2ZWxFeGlzdHMgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5jb25zb2xlW2xldmVsXS5hcHBseShnbG9iYWwuY29uc29sZSwgYXJndW1lbnRzKTtcbiAgfSA6IChsZXZlbCA9PT0gJ2xvZycgPyBmdW5jdGlvbiAoKSB7fSA6IGxvZ09iamVjdC5sb2cpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbG9nT2JqZWN0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfVxuXG4sIGV4dGVuZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCF0aGlzLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHZhciBzb3VyY2UsIHByb3A7XG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yIChwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufTtcblxufSx7fV0sNTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgY3J5cHRvOnRydWUgKi9cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuLy8gVGhpcyBzdHJpbmcgaGFzIGxlbmd0aCAzMiwgYSBwb3dlciBvZiAyLCBzbyB0aGUgbW9kdWx1cyBkb2Vzbid0IGludHJvZHVjZSBhXG4vLyBiaWFzLlxudmFyIF9yYW5kb21TdHJpbmdDaGFycyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NSc7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RyaW5nOiBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgbWF4ID0gX3JhbmRvbVN0cmluZ0NoYXJzLmxlbmd0aDtcbiAgICB2YXIgYnl0ZXMgPSBjcnlwdG8ucmFuZG9tQnl0ZXMobGVuZ3RoKTtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmV0LnB1c2goX3JhbmRvbVN0cmluZ0NoYXJzLnN1YnN0cihieXRlc1tpXSAlIG1heCwgMSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICB9XG5cbiwgbnVtYmVyOiBmdW5jdGlvbihtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KTtcbiAgfVxuXG4sIG51bWJlclN0cmluZzogZnVuY3Rpb24obWF4KSB7XG4gICAgdmFyIHQgPSAoJycgKyAobWF4IC0gMSkpLmxlbmd0aDtcbiAgICB2YXIgcCA9IG5ldyBBcnJheSh0ICsgMSkuam9pbignMCcpO1xuICAgIHJldHVybiAocCArIHRoaXMubnVtYmVyKG1heCkpLnNsaWNlKC10KTtcbiAgfVxufTtcblxufSx7XCJjcnlwdG9cIjo0M31dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6dHJhbnNwb3J0Jyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICByZXR1cm4ge1xuICAgIGZpbHRlclRvRW5hYmxlZDogZnVuY3Rpb24odHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbykge1xuICAgICAgdmFyIHRyYW5zcG9ydHMgPSB7XG4gICAgICAgIG1haW46IFtdXG4gICAgICAsIGZhY2FkZTogW11cbiAgICAgIH07XG4gICAgICBpZiAoIXRyYW5zcG9ydHNXaGl0ZWxpc3QpIHtcbiAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFtdO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHJhbnNwb3J0c1doaXRlbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFt0cmFuc3BvcnRzV2hpdGVsaXN0XTtcbiAgICAgIH1cblxuICAgICAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zKSB7XG4gICAgICAgIGlmICghdHJhbnMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnMudHJhbnNwb3J0TmFtZSA9PT0gJ3dlYnNvY2tldCcgJiYgaW5mby53ZWJzb2NrZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZGVidWcoJ2Rpc2FibGVkIGZyb20gc2VydmVyJywgJ3dlYnNvY2tldCcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc3BvcnRzV2hpdGVsaXN0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdC5pbmRleE9mKHRyYW5zLnRyYW5zcG9ydE5hbWUpID09PSAtMSkge1xuICAgICAgICAgIGRlYnVnKCdub3QgaW4gd2hpdGVsaXN0JywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zLmVuYWJsZWQoaW5mbykpIHtcbiAgICAgICAgICBkZWJ1ZygnZW5hYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICAgIHRyYW5zcG9ydHMubWFpbi5wdXNoKHRyYW5zKTtcbiAgICAgICAgICBpZiAodHJhbnMuZmFjYWRlVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0cmFuc3BvcnRzLmZhY2FkZS5wdXNoKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cmFuc3BvcnRzO1xuICAgIH1cbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1fV0sNTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIFVSTCA9IHJlcXVpcmUoJ3VybC1wYXJzZScpO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOnVybCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0T3JpZ2luOiBmdW5jdGlvbih1cmwpIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHAgPSBuZXcgVVJMKHVybCk7XG4gICAgaWYgKHAucHJvdG9jb2wgPT09ICdmaWxlOicpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwb3J0ID0gcC5wb3J0O1xuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IChwLnByb3RvY29sID09PSAnaHR0cHM6JykgPyAnNDQzJyA6ICc4MCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHAucHJvdG9jb2wgKyAnLy8nICsgcC5ob3N0bmFtZSArICc6JyArIHBvcnQ7XG4gIH1cblxuLCBpc09yaWdpbkVxdWFsOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMuZ2V0T3JpZ2luKGEpID09PSB0aGlzLmdldE9yaWdpbihiKTtcbiAgICBkZWJ1Zygnc2FtZScsIGEsIGIsIHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4sIGlzU2NoZW1lRXF1YWw6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gKGEuc3BsaXQoJzonKVswXSA9PT0gYi5zcGxpdCgnOicpWzBdKTtcbiAgfVxuXG4sIGFkZFBhdGg6IGZ1bmN0aW9uICh1cmwsIHBhdGgpIHtcbiAgICB2YXIgcXMgPSB1cmwuc3BsaXQoJz8nKTtcbiAgICByZXR1cm4gcXNbMF0gKyBwYXRoICsgKHFzWzFdID8gJz8nICsgcXNbMV0gOiAnJyk7XG4gIH1cblxuLCBhZGRRdWVyeTogZnVuY3Rpb24gKHVybCwgcSkge1xuICAgIHJldHVybiB1cmwgKyAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAoJz8nICsgcSkgOiAoJyYnICsgcSkpO1xuICB9XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcInVybC1wYXJzZVwiOjYxfV0sNTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSAnMS4zLjAnO1xuXG59LHt9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLT9cXGQ/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG5cbn0se31dLDU1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFsnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJywgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLCAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJywgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLCAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJywgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLCAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMyddO1xuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cblxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblxuXG4gIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UgfHwgLy8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCB3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpIHx8IC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSB8fCAvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pO1xufVxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICBhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArIHRoaXMubmFtZXNwYWNlICsgKHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICsgYXJnc1swXSArICh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArICcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF0aGlzLnVzZUNvbG9ycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7IC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIGlmIChtYXRjaCA9PT0gJyUlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluZGV4Kys7XG5cbiAgICBpZiAobWF0Y2ggPT09ICclYycpIHtcbiAgICAgIC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIF9jb25zb2xlO1xuXG4gIC8vIFRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAodHlwZW9mIGNvbnNvbGUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihjb25zb2xlKSkgPT09ICdvYmplY3QnICYmIGNvbnNvbGUubG9nICYmIChfY29uc29sZSA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZSwgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG5cbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fSAvLyBTd2FsbG93XG4gIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cblxuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgLy8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuICAgIC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTd2FsbG93XG4gICAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xudmFyIGZvcm1hdHRlcnMgPSBtb2R1bGUuZXhwb3J0cy5mb3JtYXR0ZXJzO1xuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vY29tbW9uXCI6NTZ9XSw1NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcbiAgY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1ZztcbiAgY3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuICBjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG4gIGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuICBjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG4gIGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuICBjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG4gIE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgY3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuICB9KTtcbiAgLyoqXG4gICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLmluc3RhbmNlcyA9IFtdO1xuICAvKipcbiAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAvKipcbiAgKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gICpcbiAgKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gICovXG5cbiAgY3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuICAvKipcbiAgKiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG4gIGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICAgIHZhciBoYXNoID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcbiAgfVxuXG4gIGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG4gIC8qKlxuICAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAqIEBhcGkgcHVibGljXG4gICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG4gICAgdmFyIHByZXZUaW1lO1xuXG4gICAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgLy8gRGlzYWJsZWQ/XG4gICAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZiA9IGRlYnVnOyAvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXG4gICAgICB2YXIgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcbiAgICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgICBzZWxmLmRpZmYgPSBtcztcbiAgICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICAgIHByZXZUaW1lID0gY3VycjtcbiAgICAgIGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICAgIGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgICAgfSAvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXG5cbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24gKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCsrO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTsgLy8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXG4gICAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGluZGV4LS07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTsgLy8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblxuICAgICAgY3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuICAgICAgdmFyIGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuICAgICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuXG4gICAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgIGRlYnVnLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gICAgZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG4gICAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICAgIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuICAgIGRlYnVnLmV4dGVuZCA9IGV4dGVuZDsgLy8gRGVidWcuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG4gICAgLy8gZGVidWcucmF3TG9nID0gcmF3TG9nO1xuICAgIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cbiAgICBpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuICAgIH1cblxuICAgIGNyZWF0ZURlYnVnLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcbiAgICByZXR1cm4gZGVidWc7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBpbmRleCA9IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY3JlYXRlRGVidWcuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcbiAgfVxuICAvKipcbiAgKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gICAgY3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcbiAgICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICAgIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIXNwbGl0W2ldKSB7XG4gICAgICAgIC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuICAgICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzW2ldO1xuICAgICAgaW5zdGFuY2UuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gICpcbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuICB9XG4gIC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gICAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAqIENvZXJjZSBgdmFsYC5cbiAgKlxuICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAqIEByZXR1cm4ge01peGVkfVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG5cbiAgZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgY3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG4gIHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcblxuXG59LHtcIm1zXCI6NTR9XSw1NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cblxufSx7fV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohIEpTT04gdjMuMy4yIHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTQsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xuOyhmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCB0aGUgYGRlZmluZWAgZnVuY3Rpb24gZXhwb3NlZCBieSBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuIFRoZVxuICAvLyBzdHJpY3QgYGRlZmluZWAgY2hlY2sgaXMgbmVjZXNzYXJ5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggYHIuanNgLlxuICB2YXIgaXNMb2FkZXIgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZDtcblxuICAvLyBBIHNldCBvZiB0eXBlcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIG9iamVjdHMgZnJvbSBwcmltaXRpdmVzLlxuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgIFwib2JqZWN0XCI6IHRydWVcbiAgfTtcblxuICAvLyBEZXRlY3QgdGhlIGBleHBvcnRzYCBvYmplY3QgZXhwb3NlZCBieSBDb21tb25KUyBpbXBsZW1lbnRhdGlvbnMuXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLy8gVXNlIHRoZSBgZ2xvYmFsYCBvYmplY3QgZXhwb3NlZCBieSBOb2RlIChpbmNsdWRpbmcgQnJvd3NlcmlmeSB2aWFcbiAgLy8gYGluc2VydC1tb2R1bGUtZ2xvYmFsc2ApLCBOYXJ3aGFsLCBhbmQgUmluZ28gYXMgdGhlIGRlZmF1bHQgY29udGV4dCxcbiAgLy8gYW5kIHRoZSBgd2luZG93YCBvYmplY3QgaW4gYnJvd3NlcnMuIFJoaW5vIGV4cG9ydHMgYSBgZ2xvYmFsYCBmdW5jdGlvblxuICAvLyBpbnN0ZWFkLlxuICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyB8fCB0aGlzLFxuICAgICAgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWw7XG5cbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWxbXCJnbG9iYWxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcIndpbmRvd1wiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wic2VsZlwiXSA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8vIFB1YmxpYzogSW5pdGlhbGl6ZXMgSlNPTiAzIHVzaW5nIHRoZSBnaXZlbiBgY29udGV4dGAgb2JqZWN0LCBhdHRhY2hpbmcgdGhlXG4gIC8vIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucyB0byB0aGUgc3BlY2lmaWVkIGBleHBvcnRzYCBvYmplY3QuXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0LCBleHBvcnRzKSB7XG4gICAgY29udGV4dCB8fCAoY29udGV4dCA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG4gICAgZXhwb3J0cyB8fCAoZXhwb3J0cyA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG5cbiAgICAvLyBOYXRpdmUgY29uc3RydWN0b3IgYWxpYXNlcy5cbiAgICB2YXIgTnVtYmVyID0gY29udGV4dFtcIk51bWJlclwiXSB8fCByb290W1wiTnVtYmVyXCJdLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0W1wiU3RyaW5nXCJdIHx8IHJvb3RbXCJTdHJpbmdcIl0sXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHRbXCJPYmplY3RcIl0gfHwgcm9vdFtcIk9iamVjdFwiXSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHRbXCJEYXRlXCJdIHx8IHJvb3RbXCJEYXRlXCJdLFxuICAgICAgICBTeW50YXhFcnJvciA9IGNvbnRleHRbXCJTeW50YXhFcnJvclwiXSB8fCByb290W1wiU3ludGF4RXJyb3JcIl0sXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHRbXCJUeXBlRXJyb3JcIl0gfHwgcm9vdFtcIlR5cGVFcnJvclwiXSxcbiAgICAgICAgTWF0aCA9IGNvbnRleHRbXCJNYXRoXCJdIHx8IHJvb3RbXCJNYXRoXCJdLFxuICAgICAgICBuYXRpdmVKU09OID0gY29udGV4dFtcIkpTT05cIl0gfHwgcm9vdFtcIkpTT05cIl07XG5cbiAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGltcGxlbWVudGF0aW9ucy5cbiAgICBpZiAodHlwZW9mIG5hdGl2ZUpTT04gPT0gXCJvYmplY3RcIiAmJiBuYXRpdmVKU09OKSB7XG4gICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IG5hdGl2ZUpTT04uc3RyaW5naWZ5O1xuICAgICAgZXhwb3J0cy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgYWxpYXNlcy5cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBnZXRDbGFzcyA9IG9iamVjdFByb3RvLnRvU3RyaW5nLFxuICAgICAgICBpc1Byb3BlcnR5LCBmb3JFYWNoLCB1bmRlZjtcblxuICAgIC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cbiAgICB2YXIgaXNFeHRlbmRlZCA9IG5ldyBEYXRlKC0zNTA5ODI3MzM0NTczMjkyKTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcbiAgICAgIC8vIHJlc3VsdHMgZm9yIGNlcnRhaW4gZGF0ZXMgaW4gT3BlcmEgPj0gMTAuNTMuXG4gICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXG4gICAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG4gICAgICAgIC8vIGJ1dCBjbGlwcyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBkYXRlIG1ldGhvZHMgdG8gdGhlIHJhbmdlIG9mXG4gICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cbiAgICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgd2hldGhlciB0aGUgbmF0aXZlIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBwYXJzZWBcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG4gICAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICAgIGlmIChoYXNbbmFtZV0gIT09IHVuZGVmKSB7XG4gICAgICAgIC8vIFJldHVybiBjYWNoZWQgZmVhdHVyZSB0ZXN0IHJlc3VsdC5cbiAgICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1N1cHBvcnRlZDtcbiAgICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcbiAgICAgICAgLy8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuICAgICAgICAvLyBicmFja2V0IG5vdGF0aW9uLiBJRSA4IG9ubHkgc3VwcG9ydHMgdGhpcyBmb3IgcHJpbWl0aXZlcy5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImpzb25cIikge1xuICAgICAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBib3RoIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBKU09OLnBhcnNlYCBhcmVcbiAgICAgICAgLy8gc3VwcG9ydGVkLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IGhhcyhcImpzb24tc3RyaW5naWZ5XCIpICYmIGhhcyhcImpzb24tcGFyc2VcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztcbiAgICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tc3RyaW5naWZ5XCIpIHtcbiAgICAgICAgICB2YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XG4gICAgICAgICAgaWYgKHN0cmluZ2lmeVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cbiAgICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9KS50b0pTT04gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxuICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgwKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IE51bWJlcigpKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IFN0cmluZygpKSA9PSAnXCJcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBkZWZpbmUgYSBjYW5vbmljYWwgSlNPTiByZXByZXNlbnRhdGlvbiAodGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGB0b0pTT05gIHByb3BlcnRpZXMgYXMgd2VsbCwgKnVubGVzcyogdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KGdldENsYXNzKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBJRSA4IHNlcmlhbGl6ZXMgYHVuZGVmaW5lZGAgYXMgYFwidW5kZWZpbmVkXCJgLiBTYWZhcmkgPD0gNS4xLjcgYW5kXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHVuZGVmKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjcgYW5kIEZGIDMuMWIzIHRocm93IGBFcnJvcmBzIGFuZCBgVHlwZUVycm9yYHMsXG4gICAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLFxuICAgICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcyBhcyB3ZWxsLCB1bmxlc3MgdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIG9iamVjdCBvciBhcnJheSBsaXRlcmFscy4gWVVJIDMuMC4wYjEgaWdub3JlcyBjdXN0b20gYHRvSlNPTmBcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt2YWx1ZV0pID09IFwiWzFdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcIltdXCJgIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgICAvLyBgXCJbbnVsbF1cImAuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZl0pID09IFwiW251bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsKSA9PSBcIm51bGxcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgICAvLyBgWzEsIHRydWUsIGdldENsYXNzLCAxXWAgc2VyaWFsaXplcyBhcyBcIlsxLHRydWUsXSxcIi4gRkYgMy4xYjNcbiAgICAgICAgICAgICAgICAvLyBlbGlkZXMgbm9uLUpTT04gdmFsdWVzIGZyb20gb2JqZWN0cyBhbmQgYXJyYXlzLCB1bmxlc3MgdGhleVxuICAgICAgICAgICAgICAgIC8vIGRlZmluZSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFwiW251bGwsbnVsbCxudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHNlcmlhbGl6YXRpb24gdGVzdC4gRkYgMy4xYjEgdXNlcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcYmAgPT4gYFxcdTAwMDhgKS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoeyBcImFcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXCJcXHgwMFxcYlxcblxcZlxcclxcdFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEgYW5kIGIyIGlnbm9yZSB0aGUgYGZpbHRlcmAgYW5kIGB3aWR0aGAgYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBKU09OIDIsIFByb3RvdHlwZSA8PSAxLjcsIGFuZCBvbGRlciBXZWJLaXQgYnVpbGRzIGluY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIGV4dGVuZGVkIHllYXJzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFRoZSBtaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCB5ZWFycyBpbnN0ZWFkIG9mIHNpeC1kaWdpdCB5ZWFycy4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgbGVzcyB0aGFuIDEwMDAuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSkgPT0gJ1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHN0cmluZ2lmeVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXBhcnNlXCIpIHtcbiAgICAgICAgICB2YXIgcGFyc2UgPSBleHBvcnRzLnBhcnNlO1xuICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2UgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xuICAgICAgICAgICAgICAvLyBhIHN0cmluZyBwcmlvciB0byBwYXJzaW5nLlxuICAgICAgICAgICAgICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuMiBhbmQgRkYgMy4xYjEgYWxsb3cgdW5lc2NhcGVkIHRhYnMgaW4gc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1wiXFx0XCInKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCBhbmQgNC4wLjEgYWxsb3cgbGVhZGluZyBgK2Agc2lnbnMgYW5kIGxlYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjAxXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAsIDQuMC4xLCBhbmQgUmhpbm8gMS43UjMtUjQgYWxsb3cgdHJhaWxpbmcgZGVjaW1hbFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cy4gVGhlc2UgZW52aXJvbm1lbnRzLCBhbG9uZyB3aXRoIEZGIDMuMWIxIGFuZCAyLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIxLlwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gcGFyc2VTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNbbmFtZV0gPSAhIWlzU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIGlmICghaGFzKFwianNvblwiKSkge1xuICAgICAgLy8gQ29tbW9uIGBbW0NsYXNzXV1gIG5hbWUgYWxpYXNlcy5cbiAgICAgIHZhciBmdW5jdGlvbkNsYXNzID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLFxuICAgICAgICAgIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiLFxuICAgICAgICAgIG51bWJlckNsYXNzID0gXCJbb2JqZWN0IE51bWJlcl1cIixcbiAgICAgICAgICBzdHJpbmdDbGFzcyA9IFwiW29iamVjdCBTdHJpbmddXCIsXG4gICAgICAgICAgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIixcbiAgICAgICAgICBib29sZWFuQ2xhc3MgPSBcIltvYmplY3QgQm9vbGVhbl1cIjtcblxuICAgICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuICAgICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG4gICAgICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cbiAgICAgIGlmICghaXNFeHRlbmRlZCkge1xuICAgICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgICAvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxuICAgICAgICAvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuICAgICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgICAgICAgLy8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxuICAgICAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiBhIHByb3BlcnR5IGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIHRoZSBnaXZlblxuICAgICAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG4gICAgICBpZiAoIShpc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XG4gICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG4gICAgICAgICAgICAvLyBUaGUgKnByb3RvKiBwcm9wZXJ0eSBjYW5ub3QgYmUgc2V0IG11bHRpcGxlIHRpbWVzIGluIHJlY2VudFxuICAgICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuICAgICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXG4gICAgICAgICAgfSwgbWVtYmVycykudG9TdHJpbmcgIT0gZ2V0Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG4gICAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuICAgICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXG4gICAgICAgICAgICAgIC8vIHVuc2FmZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gb3JpZ2luYWw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgdG8gc2ltdWxhdGUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW5cbiAgICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICh0aGlzLmNvbnN0cnVjdG9yIHx8IGNvbnN0cnVjdG9yKS5wcm90b3R5cGU7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lbWJlcnMgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xuICAgICAgLy8gZW52aXJvbm1lbnRzLiBFYWNoIGVudW1lcmF0ZWQga2V5IGlzIHlpZWxkZWQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLlxuICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XG5cbiAgICAgICAgLy8gVGVzdHMgZm9yIGJ1Z3MgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBgZm9yLi4uaW5gIGFsZ29yaXRobS4gVGhlXG4gICAgICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG4gICAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuICAgICAgICAoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuICAgICAgICB9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUHJvcGVydGllc2AgY2xhc3MuXG4gICAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuICAgICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYWxsIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcblxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGl0ZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgIC8vIEEgbGlzdCBvZiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBtZW1iZXJzID0gW1widmFsdWVPZlwiLCBcInRvU3RyaW5nXCIsIFwidG9Mb2NhbGVTdHJpbmdcIiwgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLCBcImlzUHJvdG90eXBlT2ZcIiwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdO1xuICAgICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuICAgICAgICAgIC8vIHByb3BlcnRpZXMuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSBcImZ1bmN0aW9uXCIgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eV0gJiYgb2JqZWN0Lmhhc093blByb3BlcnR5IHx8IGlzUHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXG4gICAgICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuNCBlbnVtZXJhdGVzIHNoYWRvd2VkIHByb3BlcnRpZXMgdHdpY2UuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxuICAgICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgICAgICAvLyBlbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGlzQ29uc3RydWN0b3I7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiAhKGlzQ29uc3RydWN0b3IgPSBwcm9wZXJ0eSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgZHVlIHRvXG4gICAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciB8fCBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCAocHJvcGVydHkgPSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcbiAgICAgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXG4gICAgICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcbiAgICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxuICAgICAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4gICAgICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgRXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXFxcXFwiJyxcbiAgICAgICAgICA4OiBcIlxcXFxiXCIsXG4gICAgICAgICAgMTI6IFwiXFxcXGZcIixcbiAgICAgICAgICAxMDogXCJcXFxcblwiLFxuICAgICAgICAgIDEzOiBcIlxcXFxyXCIsXG4gICAgICAgICAgOTogXCJcXFxcdFwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXG4gICAgICAgIC8vIGxlbmd0aCBpcyBhdCBsZWFzdCBlcXVhbCB0byBgd2lkdGhgLiBUaGUgYHdpZHRoYCBtdXN0IGJlIDw9IDYuXG4gICAgICAgIHZhciBsZWFkaW5nWmVyb2VzID0gXCIwMDAwMDBcIjtcbiAgICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xuICAgICAgICAgIC8vIFRoZSBgfHwgMGAgZXhwcmVzc2lvbiBpcyBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBidWcgaW5cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cbiAgICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgKGNoYXJhY3RlcnMgd2l0aCBjb2RlIHVuaXQgdmFsdWVzIGJldHdlZW4gMCBhbmQgMzEpIHdpdGhcbiAgICAgICAgLy8gdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgdmFyIHVuaWNvZGVQcmVmaXggPSBcIlxcXFx1MDBcIjtcbiAgICAgICAgdmFyIHF1b3RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XG4gICAgICAgICAgdmFyIHN5bWJvbHMgPSB1c2VDaGFySW5kZXggJiYgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuc3BsaXQoXCJcIikgOiB2YWx1ZSk7XG4gICAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXG4gICAgICAgICAgICAvLyBzaG9ydGhhbmQgZXNjYXBlIHNlcXVlbmNlOyBvdGhlcndpc2UsIGFwcGVuZCB0aGUgY2hhcmFjdGVyIGFzLWlzLlxuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5MjpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gRXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXG4gICAgICAgIC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxuICAgICAgICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvYmplY3QsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGRhdGVDbGFzcyAmJiAhaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xuICAgICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuOS41LjQ0LiBTZWUgc2VjdGlvbiAxNS45LjEuMTVcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNvbXB1dGUgdGhlIHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcyxcbiAgICAgICAgICAgICAgICAgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxuICAgICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cbiAgICAgICAgICAgICAgICAgIGRhdGUgPSBmbG9vcih2YWx1ZSAvIDg2NGU1KTtcbiAgICAgICAgICAgICAgICAgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xuICAgICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gMSArIGRhdGUgLSBnZXREYXkoeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuICAgICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgICAvLyB0byBjb21wdXRlIGBBIG1vZHVsbyBCYCwgYXMgdGhlIGAlYCBvcGVyYXRvciBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgYXJlIG9idGFpbmVkIGJ5XG4gICAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuICAgICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBmbG9vcih0aW1lIC8gNmU0KSAlIDYwO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSB2YWx1ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHZhbHVlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICtcbiAgICAgICAgICAgICAgICAgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xuICAgICAgICAgICAgICAgICAgLy8gTW9udGhzLCBkYXRlcywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHNob3VsZCBoYXZlIHR3b1xuICAgICAgICAgICAgICAgICAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXG4gICAgICAgICAgICAgICAgICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNS4wLCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgICAgXCIuXCIgKyB0b1BhZGRlZFN0cmluZygzLCBtaWxsaXNlY29uZHMpICsgXCJaXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcbiAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIGFkZHMgbm9uLXN0YW5kYXJkIGB0b0pTT05gIG1ldGhvZHMgdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYERhdGVgLCBhbmQgYEFycmF5YCBwcm90b3R5cGVzLiBKU09OIDNcbiAgICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxuICAgICAgICAgICAgICAvLyBkZWZpbmVkIGRpcmVjdGx5IG9uIGFuIGluc3RhbmNlLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxuICAgICAgICAgICAgLy8gZm9yIHNlcmlhbGl6YXRpb24uXG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXG4gICAgICAgICAgICAvLyBgXCJudWxsXCJgLlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDAgPyBcIlwiICsgdmFsdWUgOiBcIm51bGxcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgLy8gU3RyaW5ncyBhcmUgZG91YmxlLXF1b3RlZCBhbmQgZXNjYXBlZC5cbiAgICAgICAgICAgIHJldHVybiBxdW90ZShcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIC8vIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZiB1bmlxdWUgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIEN5Y2xpYyBzdHJ1Y3R1cmVzIGNhbm5vdCBiZSBzZXJpYWxpemVkIGJ5IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuICAgICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSB3aGl0ZXNwYWNlO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cbiAgICAgICAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXCJudWxsXCIgOiBlbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJbXFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIl1cIiA6IChcIltcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIl1cIikpIDogXCJbXVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdCBtZW1iZXJzLiBNZW1iZXJzIGFyZSBzZWxlY3RlZCBmcm9tXG4gICAgICAgICAgICAgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgICAgICBmb3JFYWNoKHByb3BlcnRpZXMgfHwgdmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMzogXCJJZiBgZ2FwYCB7d2hpdGVzcGFjZX1cbiAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuICAgICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxuICAgICAgICAgICAgICAgICAgLy8gVGhlIFwiYHNwYWNlYCBjaGFyYWN0ZXJcIiByZWZlcnMgdG8gdGhlIGxpdGVyYWwgc3BhY2VcbiAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocXVvdGUocHJvcGVydHkpICsgXCI6XCIgKyAod2hpdGVzcGFjZSA/IFwiIFwiIDogXCJcIikgKyBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJ7XFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIn1cIiA6IChcIntcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIn1cIikpIDogXCJ7fVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoc291cmNlLCBmaWx0ZXIsIHdpZHRoKSB7XG4gICAgICAgICAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG4gICAgICAgICAgaWYgKG9iamVjdFR5cGVzW3R5cGVvZiBmaWx0ZXJdICYmIGZpbHRlcikge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG4gICAgICAgICAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3RcbiAgICAgICAgICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXBhcnNlXCIpKSB7XG4gICAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG4gICAgICAgIC8vIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgVW5lc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcIixcbiAgICAgICAgICAzNDogJ1wiJyxcbiAgICAgICAgICA0NzogXCIvXCIsXG4gICAgICAgICAgOTg6IFwiXFxiXCIsXG4gICAgICAgICAgMTE2OiBcIlxcdFwiLFxuICAgICAgICAgIDExMDogXCJcXG5cIixcbiAgICAgICAgICAxMDI6IFwiXFxmXCIsXG4gICAgICAgICAgMTE0OiBcIlxcclwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICB2YXIgSW5kZXgsIFNvdXJjZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxuICAgICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG4gICAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xuICAgICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuICAgICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXG4gICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG4gICAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIHN0cmluZy5cbiAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cbiAgICAgICAgdmFyIGdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiW1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgbGl0ZXJhbCBjb250YWlucyBlbGVtZW50cywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dC5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVsaXNpb25zIGFuZCBsZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIGN1cmx5IGJyYWNlIG1hcmtzIHRoZSBlbmQgb2YgdGhlIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZCwgb2JqZWN0IHByb3BlcnR5IG5hbWVzIG11c3QgYmVcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIgfHwgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIgfHwgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pICE9IFwiQFwiIHx8IGxleCgpICE9IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXSA9IGdldChsZXgoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcbiAgICAgICAgLy8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLCBsZW5ndGg7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0cyBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGBmYWxzZWBcbiAgICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIGZvciAobGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcbiAgICAgICAgICBJbmRleCA9IDA7XG4gICAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xuICAgICAgICAgIC8vIElmIGEgSlNPTiBzdHJpbmcgY29udGFpbnMgbXVsdGlwbGUgdG9rZW5zLCBpdCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGdldENsYXNzLmNhbGwoY2FsbGJhY2spID09IGZ1bmN0aW9uQ2xhc3MgPyB3YWxrKCh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHJlc3VsdCwgdmFsdWUpLCBcIlwiLCBjYWxsYmFjaykgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfVxuXG4gIGlmIChmcmVlRXhwb3J0cyAmJiAhaXNMb2FkZXIpIHtcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIGVudmlyb25tZW50cy5cbiAgICBydW5JbkNvbnRleHQocm9vdCwgZnJlZUV4cG9ydHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzIGFuZCBKYXZhU2NyaXB0IGVuZ2luZXMuXG4gICAgdmFyIG5hdGl2ZUpTT04gPSByb290LkpTT04sXG4gICAgICAgIHByZXZpb3VzSlNPTiA9IHJvb3RbXCJKU09OM1wiXSxcbiAgICAgICAgaXNSZXN0b3JlZCA9IGZhbHNlO1xuXG4gICAgdmFyIEpTT04zID0gcnVuSW5Db250ZXh0KHJvb3QsIChyb290W1wiSlNPTjNcIl0gPSB7XG4gICAgICAvLyBQdWJsaWM6IFJlc3RvcmVzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgYW5kXG4gICAgICAvLyByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSlNPTjNgIG9iamVjdC5cbiAgICAgIFwibm9Db25mbGljdFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSZXN0b3JlZCkge1xuICAgICAgICAgIGlzUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgICAgIHJvb3QuSlNPTiA9IG5hdGl2ZUpTT047XG4gICAgICAgICAgcm9vdFtcIkpTT04zXCJdID0gcHJldmlvdXNKU09OO1xuICAgICAgICAgIG5hdGl2ZUpTT04gPSBwcmV2aW91c0pTT04gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OMztcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByb290LkpTT04gPSB7XG4gICAgICBcInBhcnNlXCI6IEpTT04zLnBhcnNlLFxuICAgICAgXCJzdHJpbmdpZnlcIjogSlNPTjMuc3RyaW5naWZ5XG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxuICBpZiAoaXNMb2FkZXIpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEpTT04zO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBEZWNvZGUgYSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoaW5wdXQucmVwbGFjZSgvXFwrL2csICcgJykpO1xufVxuXG4vKipcbiAqIFNpbXBsZSBxdWVyeSBzdHJpbmcgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5KSB7XG4gIHZhciBwYXJzZXIgPSAvKFtePT8mXSspPT8oW14mXSopL2dcbiAgICAsIHJlc3VsdCA9IHt9XG4gICAgLCBwYXJ0O1xuXG4gIHdoaWxlIChwYXJ0ID0gcGFyc2VyLmV4ZWMocXVlcnkpKSB7XG4gICAgdmFyIGtleSA9IGRlY29kZShwYXJ0WzFdKVxuICAgICAgLCB2YWx1ZSA9IGRlY29kZShwYXJ0WzJdKTtcblxuICAgIC8vXG4gICAgLy8gUHJldmVudCBvdmVycmlkaW5nIG9mIGV4aXN0aW5nIHByb3BlcnRpZXMuIFRoaXMgZW5zdXJlcyB0aGF0IGJ1aWxkLWluXG4gICAgLy8gbWV0aG9kcyBsaWtlIGB0b1N0cmluZ2Agb3IgX19wcm90b19fIGFyZSBub3Qgb3ZlcnJpZGVuIGJ5IG1hbGljaW91c1xuICAgIC8vIHF1ZXJ5c3RyaW5ncy5cbiAgICAvL1xuICAgIGlmIChrZXkgaW4gcmVzdWx0KSBjb250aW51ZTtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBxdWVyeSBzdHJpbmcgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBPcHRpb25hbCBwcmVmaXguXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdpZnkob2JqLCBwcmVmaXgpIHtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIHZhciBwYWlycyA9IFtdO1xuXG4gIC8vXG4gIC8vIE9wdGlvbmFsbHkgcHJlZml4IHdpdGggYSAnPycgaWYgbmVlZGVkXG4gIC8vXG4gIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByZWZpeCkgcHJlZml4ID0gJz8nO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsnPScrIGVuY29kZVVSSUNvbXBvbmVudChvYmpba2V5XSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWlycy5sZW5ndGggPyBwcmVmaXggKyBwYWlycy5qb2luKCcmJykgOiAnJztcbn1cblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmV4cG9ydHMuc3RyaW5naWZ5ID0gcXVlcnlzdHJpbmdpZnk7XG5leHBvcnRzLnBhcnNlID0gcXVlcnlzdHJpbmc7XG5cbn0se31dLDYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSdyZSByZXF1aXJlZCB0byBhZGQgYSBwb3J0IG51bWJlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZGVmYXVsdC1wb3J0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHBvcnQgUG9ydCBudW1iZXIgd2UgbmVlZCB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJcyBpdCBhIGRlZmF1bHQgcG9ydCBmb3IgdGhlIGdpdmVuIHByb3RvY29sXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlZChwb3J0LCBwcm90b2NvbCkge1xuICBwcm90b2NvbCA9IHByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gIHBvcnQgPSArcG9ydDtcblxuICBpZiAoIXBvcnQpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgY2FzZSAnaHR0cCc6XG4gICAgY2FzZSAnd3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA4MDtcblxuICAgIGNhc2UgJ2h0dHBzJzpcbiAgICBjYXNlICd3c3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA0NDM7XG5cbiAgICBjYXNlICdmdHAnOlxuICAgIHJldHVybiBwb3J0ICE9PSAyMTtcblxuICAgIGNhc2UgJ2dvcGhlcic6XG4gICAgcmV0dXJuIHBvcnQgIT09IDcwO1xuXG4gICAgY2FzZSAnZmlsZSc6XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHBvcnQgIT09IDA7XG59O1xuXG59LHt9XSw2MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKVxuICAsIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmdpZnknKVxuICAsIHByb3RvY29scmUgPSAvXihbYS16XVthLXowLTkuKy1dKjopPyhcXC9cXC8pPyhbXFxTXFxzXSopL2lcbiAgLCBzbGFzaGVzID0gL15bQS1aYS16XVtBLVphLXowLTkrLS5dKjpcXC9cXC8vO1xuXG4vKipcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2UgcnVsZXMgZm9yIHRoZSBVUkwgcGFyc2VyLCBpdCBpbmZvcm1zIHRoZSBwYXJzZXJcbiAqIGFib3V0OlxuICpcbiAqIDAuIFRoZSBjaGFyIGl0IE5lZWRzIHRvIHBhcnNlLCBpZiBpdCdzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBkb25lIHVzaW5nXG4gKiAgICBpbmRleE9mLCBSZWdFeHAgdXNpbmcgZXhlYyBhbmQgTmFOIG1lYW5zIHNldCBhcyBjdXJyZW50IHZhbHVlLlxuICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXG4gKiAyLiBJbmRpY2F0aW9uIGlmIGl0J3MgYmFja3dhcmRzIG9yIGZvcndhcmQgcGFyc2luZywgd2hlbiBzZXQgYXMgbnVtYmVyIGl0J3NcbiAqICAgIHRoZSB2YWx1ZSBvZiBleHRyYSBjaGFycyB0aGF0IHNob3VsZCBiZSBzcGxpdCBvZmYuXG4gKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXG4gKiA0LiBgdG9Mb3dlckNhc2VgIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKi9cbnZhciBydWxlcyA9IFtcbiAgWycjJywgJ2hhc2gnXSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnPycsICdxdWVyeSddLCAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBmdW5jdGlvbiBzYW5pdGl6ZShhZGRyZXNzKSB7ICAgICAgICAgIC8vIFNhbml0aXplIHdoYXQgaXMgbGVmdCBvZiB0aGUgYWRkcmVzc1xuICAgIHJldHVybiBhZGRyZXNzLnJlcGxhY2UoJ1xcXFwnLCAnLycpO1xuICB9LFxuICBbJy8nLCAncGF0aG5hbWUnXSwgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWydAJywgJ2F1dGgnLCAxXSwgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGZyb250LlxuICBbTmFOLCAnaG9zdCcsIHVuZGVmaW5lZCwgMSwgMV0sICAgICAgIC8vIFNldCBsZWZ0IG92ZXIgdmFsdWUuXG4gIFsvOihcXGQrKSQvLCAncG9ydCcsIHVuZGVmaW5lZCwgMV0sICAgIC8vIFJlZ0V4cCB0aGUgYmFjay5cbiAgW05hTiwgJ2hvc3RuYW1lJywgdW5kZWZpbmVkLCAxLCAxXSAgICAvLyBTZXQgbGVmdCBvdmVyLlxuXTtcblxuLyoqXG4gKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBub3QgYmUgY29waWVkIG9yIGluaGVyaXRlZCBmcm9tLiBUaGlzIGlzIG9ubHkgbmVlZGVkXG4gKiBmb3IgYWxsIG5vbiBibG9iIFVSTCdzIGFzIGEgYmxvYiBVUkwgZG9lcyBub3QgaW5jbHVkZSBhIGhhc2gsIG9ubHkgdGhlXG4gKiBvcmlnaW4uXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBpZ25vcmUgPSB7IGhhc2g6IDEsIHF1ZXJ5OiAxIH07XG5cbi8qKlxuICogVGhlIGxvY2F0aW9uIG9iamVjdCBkaWZmZXJzIHdoZW4geW91ciBjb2RlIGlzIGxvYWRlZCB0aHJvdWdoIGEgbm9ybWFsIHBhZ2UsXG4gKiBXb3JrZXIgb3IgdGhyb3VnaCBhIHdvcmtlciB1c2luZyBhIGJsb2IuIEFuZCB3aXRoIHRoZSBibG9iYmxlIGJlZ2lucyB0aGVcbiAqIHRyb3VibGUgYXMgdGhlIGxvY2F0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIFVSTCBvZiB0aGUgYmxvYiwgbm90IHRoZVxuICogbG9jYXRpb24gb2YgdGhlIHBhZ2Ugd2hlcmUgb3VyIGNvZGUgaXMgbG9hZGVkIGluLiBUaGUgYWN0dWFsIG9yaWdpbiBpc1xuICogZW5jb2RlZCBpbiB0aGUgYHBhdGhuYW1lYCBzbyB3ZSBjYW4gdGhhbmtmdWxseSBnZW5lcmF0ZSBhIGdvb2QgXCJkZWZhdWx0XCJcbiAqIGxvY2F0aW9uIGZyb20gaXQgc28gd2UgY2FuIGdlbmVyYXRlIHByb3BlciByZWxhdGl2ZSBVUkwncyBhZ2Fpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvYyBPcHRpb25hbCBkZWZhdWx0IGxvY2F0aW9uIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IGxvbGNhdGlvbiBvYmplY3QuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGxvbGNhdGlvbihsb2MpIHtcbiAgdmFyIGxvY2F0aW9uID0gZ2xvYmFsICYmIGdsb2JhbC5sb2NhdGlvbiB8fCB7fTtcbiAgbG9jID0gbG9jIHx8IGxvY2F0aW9uO1xuXG4gIHZhciBmaW5hbGRlc3RpbmF0aW9uID0ge31cbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jXG4gICAgLCBrZXk7XG5cbiAgaWYgKCdibG9iOicgPT09IGxvYy5wcm90b2NvbCkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKHVuZXNjYXBlKGxvYy5wYXRobmFtZSksIHt9KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZSkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKGxvYywge30pO1xuICAgIGZvciAoa2V5IGluIGlnbm9yZSkgZGVsZXRlIGZpbmFsZGVzdGluYXRpb25ba2V5XTtcbiAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZSkge1xuICAgIGZvciAoa2V5IGluIGxvYykge1xuICAgICAgaWYgKGtleSBpbiBpZ25vcmUpIGNvbnRpbnVlO1xuICAgICAgZmluYWxkZXN0aW5hdGlvbltrZXldID0gbG9jW2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPSBzbGFzaGVzLnRlc3QobG9jLmhyZWYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5hbGRlc3RpbmF0aW9uO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIFByb3RvY29sRXh0cmFjdFxuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgbWF0Y2hlZCBpbiB0aGUgVVJMLCBpbiBsb3dlcmNhc2UuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNsYXNoZXMgYHRydWVgIGlmIHByb3RvY29sIGlzIGZvbGxvd2VkIGJ5IFwiLy9cIiwgZWxzZSBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHJlc3QgUmVzdCBvZiB0aGUgVVJMIHRoYXQgaXMgbm90IHBhcnQgb2YgdGhlIHByb3RvY29sLlxuICovXG5cbi8qKlxuICogRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBmcm9tIGEgVVJMIHdpdGgvd2l0aG91dCBkb3VibGUgc2xhc2ggKFwiLy9cIikuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gZXh0cmFjdCBmcm9tLlxuICogQHJldHVybiB7UHJvdG9jb2xFeHRyYWN0fSBFeHRyYWN0ZWQgaW5mb3JtYXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBleHRyYWN0UHJvdG9jb2woYWRkcmVzcykge1xuICB2YXIgbWF0Y2ggPSBwcm90b2NvbHJlLmV4ZWMoYWRkcmVzcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogbWF0Y2hbMV0gPyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIDogJycsXG4gICAgc2xhc2hlczogISFtYXRjaFsyXSxcbiAgICByZXN0OiBtYXRjaFszXVxuICB9O1xufVxuXG4vKipcbiAqIFJlc29sdmUgYSByZWxhdGl2ZSBVUkwgcGF0aG5hbWUgYWdhaW5zdCBhIGJhc2UgVVJMIHBhdGhuYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWxhdGl2ZSBQYXRobmFtZSBvZiB0aGUgcmVsYXRpdmUgVVJMLlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2UgUGF0aG5hbWUgb2YgdGhlIGJhc2UgVVJMLlxuICogQHJldHVybiB7U3RyaW5nfSBSZXNvbHZlZCBwYXRobmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUocmVsYXRpdmUsIGJhc2UpIHtcbiAgdmFyIHBhdGggPSAoYmFzZSB8fCAnLycpLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmNvbmNhdChyZWxhdGl2ZS5zcGxpdCgnLycpKVxuICAgICwgaSA9IHBhdGgubGVuZ3RoXG4gICAgLCBsYXN0ID0gcGF0aFtpIC0gMV1cbiAgICAsIHVuc2hpZnQgPSBmYWxzZVxuICAgICwgdXAgPSAwO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocGF0aFtpXSA9PT0gJy4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhdGhbaV0gPT09ICcuLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBpZiAoaSA9PT0gMCkgdW5zaGlmdCA9IHRydWU7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuc2hpZnQpIHBhdGgudW5zaGlmdCgnJyk7XG4gIGlmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgcGF0aC5wdXNoKCcnKTtcblxuICByZXR1cm4gcGF0aC5qb2luKCcvJyk7XG59XG5cbi8qKlxuICogVGhlIGFjdHVhbCBVUkwgaW5zdGFuY2UuIEluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIG9iamVjdCB3ZSd2ZSBvcHRlZC1pbiB0b1xuICogY3JlYXRlIGFuIGFjdHVhbCBjb25zdHJ1Y3RvciBhcyBpdCdzIG11Y2ggbW9yZSBtZW1vcnkgZWZmaWNpZW50IGFuZFxuICogZmFzdGVyIGFuZCBpdCBwbGVhc2VzIG15IE9DRC5cbiAqXG4gKiBJdCBpcyB3b3J0aCBub3RpbmcgdGhhdCB3ZSBzaG91bGQgbm90IHVzZSBgVVJMYCBhcyBjbGFzcyBuYW1lIHRvIHByZXZlbnRcbiAqIGNsYXNoZXMgd2l0aCB0aGUgZ2xvYmFsIFVSTCBpbnN0YW5jZSB0aGF0IGdvdCBpbnRyb2R1Y2VkIGluIGJyb3dzZXJzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gcGFyc2UuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvY2F0aW9uIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gcGFyc2VyIFBhcnNlciBmb3IgdGhlIHF1ZXJ5IHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gIH1cblxuICB2YXIgcmVsYXRpdmUsIGV4dHJhY3RlZCwgcGFyc2UsIGluc3RydWN0aW9uLCBpbmRleCwga2V5XG4gICAgLCBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpXG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY2F0aW9uXG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBpID0gMDtcblxuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudHMgYWxsb3dzIHRoaXMgbW9kdWxlIHR3byBoYXZlIGNvbXBhdGliaWxpdHkgd2l0aFxuICAvLyAyIGRpZmZlcmVudCBBUEk6XG4gIC8vXG4gIC8vIDEuIE5vZGUuanMncyBgdXJsLnBhcnNlYCBhcGkgd2hpY2ggYWNjZXB0cyBhIFVSTCwgYm9vbGVhbiBhcyBhcmd1bWVudHNcbiAgLy8gICAgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgYWxzbyBiZSBwYXJzZWQuXG4gIC8vXG4gIC8vIDIuIFRoZSBgVVJMYCBpbnRlcmZhY2Ugb2YgdGhlIGJyb3dzZXIgd2hpY2ggYWNjZXB0cyBhIFVSTCwgb2JqZWN0IGFzXG4gIC8vICAgIGFyZ3VtZW50cy4gVGhlIHN1cHBsaWVkIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB2YWx1ZXMgLyBmYWxsLWJhY2tcbiAgLy8gICAgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICAvL1xuICBpZiAoJ29iamVjdCcgIT09IHR5cGUgJiYgJ3N0cmluZycgIT09IHR5cGUpIHtcbiAgICBwYXJzZXIgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICBpZiAocGFyc2VyICYmICdmdW5jdGlvbicgIT09IHR5cGVvZiBwYXJzZXIpIHBhcnNlciA9IHFzLnBhcnNlO1xuXG4gIGxvY2F0aW9uID0gbG9sY2F0aW9uKGxvY2F0aW9uKTtcblxuICAvL1xuICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXG4gIC8vXG4gIGV4dHJhY3RlZCA9IGV4dHJhY3RQcm90b2NvbChhZGRyZXNzIHx8ICcnKTtcbiAgcmVsYXRpdmUgPSAhZXh0cmFjdGVkLnByb3RvY29sICYmICFleHRyYWN0ZWQuc2xhc2hlcztcbiAgdXJsLnNsYXNoZXMgPSBleHRyYWN0ZWQuc2xhc2hlcyB8fCByZWxhdGl2ZSAmJiBsb2NhdGlvbi5zbGFzaGVzO1xuICB1cmwucHJvdG9jb2wgPSBleHRyYWN0ZWQucHJvdG9jb2wgfHwgbG9jYXRpb24ucHJvdG9jb2wgfHwgJyc7XG4gIGFkZHJlc3MgPSBleHRyYWN0ZWQucmVzdDtcblxuICAvL1xuICAvLyBXaGVuIHRoZSBhdXRob3JpdHkgY29tcG9uZW50IGlzIGFic2VudCB0aGUgVVJMIHN0YXJ0cyB3aXRoIGEgcGF0aFxuICAvLyBjb21wb25lbnQuXG4gIC8vXG4gIGlmICghZXh0cmFjdGVkLnNsYXNoZXMpIGluc3RydWN0aW9uc1szXSA9IFsvKC4qKS8sICdwYXRobmFtZSddO1xuXG4gIGZvciAoOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhZGRyZXNzID0gaW5zdHJ1Y3Rpb24oYWRkcmVzcyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwYXJzZSA9IGluc3RydWN0aW9uWzBdO1xuICAgIGtleSA9IGluc3RydWN0aW9uWzFdO1xuXG4gICAgaWYgKHBhcnNlICE9PSBwYXJzZSkge1xuICAgICAgdXJsW2tleV0gPSBhZGRyZXNzO1xuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBwYXJzZSkge1xuICAgICAgaWYgKH4oaW5kZXggPSBhZGRyZXNzLmluZGV4T2YocGFyc2UpKSkge1xuICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBpbnN0cnVjdGlvblsyXSkge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoaW5kZXggKyBpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChpbmRleCA9IHBhcnNlLmV4ZWMoYWRkcmVzcykpKSB7XG4gICAgICB1cmxba2V5XSA9IGluZGV4WzFdO1xuICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXguaW5kZXgpO1xuICAgIH1cblxuICAgIHVybFtrZXldID0gdXJsW2tleV0gfHwgKFxuICAgICAgcmVsYXRpdmUgJiYgaW5zdHJ1Y3Rpb25bM10gPyBsb2NhdGlvbltrZXldIHx8ICcnIDogJydcbiAgICApO1xuXG4gICAgLy9cbiAgICAvLyBIb3N0bmFtZSwgaG9zdCBhbmQgcHJvdG9jb2wgc2hvdWxkIGJlIGxvd2VyY2FzZWQgc28gdGhleSBjYW4gYmUgdXNlZCB0b1xuICAgIC8vIGNyZWF0ZSBhIHByb3BlciBgb3JpZ2luYC5cbiAgICAvL1xuICAgIGlmIChpbnN0cnVjdGlvbls0XSkgdXJsW2tleV0gPSB1cmxba2V5XS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcbiAgLy8gd2l0aCBhIGN1c3RvbSBwYXJzZXIgYXMgZnVuY3Rpb24gdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBidWlsZC1pblxuICAvLyBwYXJzZXIuXG4gIC8vXG4gIGlmIChwYXJzZXIpIHVybC5xdWVyeSA9IHBhcnNlcih1cmwucXVlcnkpO1xuXG4gIC8vXG4gIC8vIElmIHRoZSBVUkwgaXMgcmVsYXRpdmUsIHJlc29sdmUgdGhlIHBhdGhuYW1lIGFnYWluc3QgdGhlIGJhc2UgVVJMLlxuICAvL1xuICBpZiAoXG4gICAgICByZWxhdGl2ZVxuICAgICYmIGxvY2F0aW9uLnNsYXNoZXNcbiAgICAmJiB1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLydcbiAgICAmJiAodXJsLnBhdGhuYW1lICE9PSAnJyB8fCBsb2NhdGlvbi5wYXRobmFtZSAhPT0gJycpXG4gICkge1xuICAgIHVybC5wYXRobmFtZSA9IHJlc29sdmUodXJsLnBhdGhuYW1lLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH1cblxuICAvL1xuICAvLyBXZSBzaG91bGQgbm90IGFkZCBwb3J0IG51bWJlcnMgaWYgdGhleSBhcmUgYWxyZWFkeSB0aGUgZGVmYXVsdCBwb3J0IG51bWJlclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXG4gIC8vXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICB1cmwucG9ydCA9ICcnO1xuICB9XG5cbiAgLy9cbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAvL1xuICB1cmwudXNlcm5hbWUgPSB1cmwucGFzc3dvcmQgPSAnJztcbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSB1cmwuYXV0aC5zcGxpdCgnOicpO1xuICAgIHVybC51c2VybmFtZSA9IGluc3RydWN0aW9uWzBdIHx8ICcnO1xuICAgIHVybC5wYXNzd29yZCA9IGluc3RydWN0aW9uWzFdIHx8ICcnO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFydCAgICAgICAgICBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIHBhcnNlIHRoZSBxdWVyeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICogQHJldHVybnMge1VSTH0gVVJMIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKC86XFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWUuam9pbignOicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgdXJsLnByb3RvY29sID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRobmFtZSc6XG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBwYXJ0ID09PSAncGF0aG5hbWUnID8gJy8nIDogJyMnO1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZS5jaGFyQXQoMCkgIT09IGNoYXIgPyBjaGFyICsgdmFsdWUgOiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucyA9IHJ1bGVzW2ldO1xuXG4gICAgaWYgKGluc1s0XSkgdXJsW2luc1sxXV0gPSB1cmxbaW5zWzFdXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xuXG4gIHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZ2lmeSBPcHRpb25hbCBxdWVyeSBzdHJpbmdpZnkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBDb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBVUkwuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmeSkge1xuICBpZiAoIXN0cmluZ2lmeSB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2Ygc3RyaW5naWZ5KSBzdHJpbmdpZnkgPSBxcy5zdHJpbmdpZnk7XG5cbiAgdmFyIHF1ZXJ5XG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBwcm90b2NvbCA9IHVybC5wcm90b2NvbDtcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuY2hhckF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICB2YXIgcmVzdWx0ID0gcHJvdG9jb2wgKyAodXJsLnNsYXNoZXMgPyAnLy8nIDogJycpO1xuXG4gIGlmICh1cmwudXNlcm5hbWUpIHtcbiAgICByZXN1bHQgKz0gdXJsLnVzZXJuYW1lO1xuICAgIGlmICh1cmwucGFzc3dvcmQpIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5ob3N0ICsgdXJsLnBhdGhuYW1lO1xuXG4gIHF1ZXJ5ID0gJ29iamVjdCcgPT09IHR5cGVvZiB1cmwucXVlcnkgPyBzdHJpbmdpZnkodXJsLnF1ZXJ5KSA6IHVybC5xdWVyeTtcbiAgaWYgKHF1ZXJ5KSByZXN1bHQgKz0gJz8nICE9PSBxdWVyeS5jaGFyQXQoMCkgPyAnPycrIHF1ZXJ5IDogcXVlcnk7XG5cbiAgaWYgKHVybC5oYXNoKSByZXN1bHQgKz0gdXJsLmhhc2g7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuVXJsLnByb3RvdHlwZSA9IHsgc2V0OiBzZXQsIHRvU3RyaW5nOiB0b1N0cmluZyB9O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBVUkwgcGFyc2VyIGFuZCBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlIHVzZWZ1bCBmb3Jcbi8vIG90aGVycyBvciB0ZXN0aW5nLlxuLy9cblVybC5leHRyYWN0UHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2w7XG5VcmwubG9jYXRpb24gPSBsb2xjYXRpb247XG5VcmwucXMgPSBxcztcblxubW9kdWxlLmV4cG9ydHMgPSBVcmw7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcInF1ZXJ5c3RyaW5naWZ5XCI6NTksXCJyZXF1aXJlcy1wb3J0XCI6NjB9XX0se30sWzFdKSgxKVxufSk7XG5cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ja2pzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnOyAvLyBUaGUgZXJyb3Igb3ZlcmxheSBpcyBpbnNwaXJlZCAoYW5kIG1vc3RseSBjb3BpZWQpIGZyb20gQ3JlYXRlIFJlYWN0IEFwcCAoaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29raW5jdWJhdG9yL2NyZWF0ZS1yZWFjdC1hcHApXG4vLyBUaGV5LCBpbiB0dXJuLCBnb3QgaW5zcGlyZWQgYnkgd2VicGFjay1ob3QtbWlkZGxld2FyZSAoaHR0cHM6Ly9naXRodWIuY29tL2dsZW5qYW1pbi93ZWJwYWNrLWhvdC1taWRkbGV3YXJlKS5cblxudmFyIGFuc2lIVE1MID0gcmVxdWlyZSgnYW5zaS1odG1sJyk7XG5cbnZhciBFbnRpdGllcyA9IHJlcXVpcmUoJ2h0bWwtZW50aXRpZXMnKS5BbGxIdG1sRW50aXRpZXM7XG5cbnZhciBlbnRpdGllcyA9IG5ldyBFbnRpdGllcygpO1xudmFyIGNvbG9ycyA9IHtcbiAgcmVzZXQ6IFsndHJhbnNwYXJlbnQnLCAndHJhbnNwYXJlbnQnXSxcbiAgYmxhY2s6ICcxODE4MTgnLFxuICByZWQ6ICdFMzYwNDknLFxuICBncmVlbjogJ0IzQ0I3NCcsXG4gIHllbGxvdzogJ0ZGRDA4MCcsXG4gIGJsdWU6ICc3Q0FGQzInLFxuICBtYWdlbnRhOiAnN0ZBQ0NBJyxcbiAgY3lhbjogJ0MzQzJFRicsXG4gIGxpZ2h0Z3JleTogJ0VCRTdFMycsXG4gIGRhcmtncmV5OiAnNkQ3ODkxJ1xufTtcbmFuc2lIVE1MLnNldENvbG9ycyhjb2xvcnMpO1xuXG5mdW5jdGlvbiBjcmVhdGVPdmVybGF5SWZyYW1lKG9uSWZyYW1lTG9hZCkge1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gIGlmcmFtZS5pZCA9ICd3ZWJwYWNrLWRldi1zZXJ2ZXItY2xpZW50LW92ZXJsYXknO1xuICBpZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcbiAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgaWZyYW1lLnN0eWxlLmxlZnQgPSAwO1xuICBpZnJhbWUuc3R5bGUudG9wID0gMDtcbiAgaWZyYW1lLnN0eWxlLnJpZ2h0ID0gMDtcbiAgaWZyYW1lLnN0eWxlLmJvdHRvbSA9IDA7XG4gIGlmcmFtZS5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gIGlmcmFtZS5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICBpZnJhbWUuc3R5bGUuYm9yZGVyID0gJ25vbmUnO1xuICBpZnJhbWUuc3R5bGUuekluZGV4ID0gOTk5OTk5OTk5OTtcbiAgaWZyYW1lLm9ubG9hZCA9IG9uSWZyYW1lTG9hZDtcbiAgcmV0dXJuIGlmcmFtZTtcbn1cblxuZnVuY3Rpb24gYWRkT3ZlcmxheURpdlRvKGlmcmFtZSkge1xuICB2YXIgZGl2ID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlkID0gJ3dlYnBhY2stZGV2LXNlcnZlci1jbGllbnQtb3ZlcmxheS1kaXYnO1xuICBkaXYuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICBkaXYuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICBkaXYuc3R5bGUubGVmdCA9IDA7XG4gIGRpdi5zdHlsZS50b3AgPSAwO1xuICBkaXYuc3R5bGUucmlnaHQgPSAwO1xuICBkaXYuc3R5bGUuYm90dG9tID0gMDtcbiAgZGl2LnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgZGl2LnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLCAwLCAwLCAwLjg1KSc7XG4gIGRpdi5zdHlsZS5jb2xvciA9ICcjRThFOEU4JztcbiAgZGl2LnN0eWxlLmZvbnRGYW1pbHkgPSAnTWVubG8sIENvbnNvbGFzLCBtb25vc3BhY2UnO1xuICBkaXYuc3R5bGUuZm9udFNpemUgPSAnbGFyZ2UnO1xuICBkaXYuc3R5bGUucGFkZGluZyA9ICcycmVtJztcbiAgZGl2LnN0eWxlLmxpbmVIZWlnaHQgPSAnMS4yJztcbiAgZGl2LnN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnO1xuICBkaXYuc3R5bGUub3ZlcmZsb3cgPSAnYXV0byc7XG4gIGlmcmFtZS5jb250ZW50RG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICByZXR1cm4gZGl2O1xufVxuXG52YXIgb3ZlcmxheUlmcmFtZSA9IG51bGw7XG52YXIgb3ZlcmxheURpdiA9IG51bGw7XG52YXIgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gbnVsbDtcblxuZnVuY3Rpb24gZW5zdXJlT3ZlcmxheURpdkV4aXN0cyhvbk92ZXJsYXlEaXZSZWFkeSkge1xuICBpZiAob3ZlcmxheURpdikge1xuICAgIC8vIEV2ZXJ5dGhpbmcgaXMgcmVhZHksIGNhbGwgdGhlIGNhbGxiYWNrIHJpZ2h0IGF3YXkuXG4gICAgb25PdmVybGF5RGl2UmVhZHkob3ZlcmxheURpdik7XG4gICAgcmV0dXJuO1xuICB9IC8vIENyZWF0aW5nIGFuIGlmcmFtZSBtYXkgYmUgYXN5bmNocm9ub3VzIHNvIHdlJ2xsIHNjaGVkdWxlIHRoZSBjYWxsYmFjay5cbiAgLy8gSW4gY2FzZSBvZiBtdWx0aXBsZSBjYWxscywgbGFzdCBjYWxsYmFjayB3aW5zLlxuXG5cbiAgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gb25PdmVybGF5RGl2UmVhZHk7XG5cbiAgaWYgKG92ZXJsYXlJZnJhbWUpIHtcbiAgICAvLyBXZSdyZSBhbHJlYWR5IGNyZWF0aW5nIGl0LlxuICAgIHJldHVybjtcbiAgfSAvLyBDcmVhdGUgaWZyYW1lIGFuZCwgd2hlbiBpdCBpcyByZWFkeSwgYSBkaXYgaW5zaWRlIGl0LlxuXG5cbiAgb3ZlcmxheUlmcmFtZSA9IGNyZWF0ZU92ZXJsYXlJZnJhbWUoZnVuY3Rpb24gKCkge1xuICAgIG92ZXJsYXlEaXYgPSBhZGRPdmVybGF5RGl2VG8ob3ZlcmxheUlmcmFtZSk7IC8vIE5vdyB3ZSBjYW4gdGFsayFcblxuICAgIGxhc3RPbk92ZXJsYXlEaXZSZWFkeShvdmVybGF5RGl2KTtcbiAgfSk7IC8vIFphbGdvIGFsZXJ0OiBvbklmcmFtZUxvYWQoKSB3aWxsIGJlIGNhbGxlZCBlaXRoZXIgc3luY2hyb25vdXNseVxuICAvLyBvciBhc3luY2hyb25vdXNseSBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXIuXG4gIC8vIFdlIGRlbGF5IGFkZGluZyBpdCBzbyBgb3ZlcmxheUlmcmFtZWAgaXMgc2V0IHdoZW4gYG9uSWZyYW1lTG9hZGAgZmlyZXMuXG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdmVybGF5SWZyYW1lKTtcbn1cblxuZnVuY3Rpb24gc2hvd01lc3NhZ2VPdmVybGF5KG1lc3NhZ2UpIHtcbiAgZW5zdXJlT3ZlcmxheURpdkV4aXN0cyhmdW5jdGlvbiAoZGl2KSB7XG4gICAgLy8gTWFrZSBpdCBsb29rIHNpbWlsYXIgdG8gb3VyIHRlcm1pbmFsLlxuICAgIGRpdi5pbm5lckhUTUwgPSBcIjxzcGFuIHN0eWxlPVxcXCJjb2xvcjogI1wiLmNvbmNhdChjb2xvcnMucmVkLCBcIlxcXCI+RmFpbGVkIHRvIGNvbXBpbGUuPC9zcGFuPjxicj48YnI+XCIpLmNvbmNhdChhbnNpSFRNTChlbnRpdGllcy5lbmNvZGUobWVzc2FnZSkpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lFcnJvck92ZXJsYXkoKSB7XG4gIGlmICghb3ZlcmxheURpdikge1xuICAgIC8vIEl0IGlzIG5vdCB0aGVyZSBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gICAgcmV0dXJuO1xuICB9IC8vIENsZWFuIHVwIGFuZCByZXNldCBpbnRlcm5hbCBzdGF0ZS5cblxuXG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQob3ZlcmxheUlmcmFtZSk7XG4gIG92ZXJsYXlEaXYgPSBudWxsO1xuICBvdmVybGF5SWZyYW1lID0gbnVsbDtcbiAgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gbnVsbDtcbn0gLy8gU3VjY2Vzc2Z1bCBjb21waWxhdGlvbi5cblxuXG5leHBvcnRzLmNsZWFyID0gZnVuY3Rpb24gaGFuZGxlU3VjY2VzcygpIHtcbiAgZGVzdHJveUVycm9yT3ZlcmxheSgpO1xufTsgLy8gQ29tcGlsYXRpb24gd2l0aCBlcnJvcnMgKGUuZy4gc3ludGF4IGVycm9yIG9yIG1pc3NpbmcgbW9kdWxlcykuXG5cblxuZXhwb3J0cy5zaG93TWVzc2FnZSA9IGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UobWVzc2FnZXMpIHtcbiAgc2hvd01lc3NhZ2VPdmVybGF5KG1lc3NhZ2VzWzBdKTtcbn07IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYW5zaUhUTUxcblxuLy8gUmVmZXJlbmNlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvYW5zaS1yZWdleFxudmFyIF9yZWdBTlNJID0gLyg/Oig/OlxcdTAwMWJcXFspfFxcdTAwOWIpKD86KD86WzAtOV17MSwzfSk/KD86KD86O1swLTldezAsM30pKik/W0EtTXxmLW1dKXxcXHUwMDFiW0EtTV0vXG5cbnZhciBfZGVmQ29sb3JzID0ge1xuICByZXNldDogWydmZmYnLCAnMDAwJ10sIC8vIFtGT1JFR1JPVURfQ09MT1IsIEJBQ0tHUk9VTkRfQ09MT1JdXG4gIGJsYWNrOiAnMDAwJyxcbiAgcmVkOiAnZmYwMDAwJyxcbiAgZ3JlZW46ICcyMDk4MDUnLFxuICB5ZWxsb3c6ICdlOGJmMDMnLFxuICBibHVlOiAnMDAwMGZmJyxcbiAgbWFnZW50YTogJ2ZmMDBmZicsXG4gIGN5YW46ICcwMGZmZWUnLFxuICBsaWdodGdyZXk6ICdmMGYwZjAnLFxuICBkYXJrZ3JleTogJzg4OCdcbn1cbnZhciBfc3R5bGVzID0ge1xuICAzMDogJ2JsYWNrJyxcbiAgMzE6ICdyZWQnLFxuICAzMjogJ2dyZWVuJyxcbiAgMzM6ICd5ZWxsb3cnLFxuICAzNDogJ2JsdWUnLFxuICAzNTogJ21hZ2VudGEnLFxuICAzNjogJ2N5YW4nLFxuICAzNzogJ2xpZ2h0Z3JleSdcbn1cbnZhciBfb3BlblRhZ3MgPSB7XG4gICcxJzogJ2ZvbnQtd2VpZ2h0OmJvbGQnLCAvLyBib2xkXG4gICcyJzogJ29wYWNpdHk6MC41JywgLy8gZGltXG4gICczJzogJzxpPicsIC8vIGl0YWxpY1xuICAnNCc6ICc8dT4nLCAvLyB1bmRlcnNjb3JlXG4gICc4JzogJ2Rpc3BsYXk6bm9uZScsIC8vIGhpZGRlblxuICAnOSc6ICc8ZGVsPicgLy8gZGVsZXRlXG59XG52YXIgX2Nsb3NlVGFncyA9IHtcbiAgJzIzJzogJzwvaT4nLCAvLyByZXNldCBpdGFsaWNcbiAgJzI0JzogJzwvdT4nLCAvLyByZXNldCB1bmRlcnNjb3JlXG4gICcyOSc6ICc8L2RlbD4nIC8vIHJlc2V0IGRlbGV0ZVxufVxuXG47WzAsIDIxLCAyMiwgMjcsIDI4LCAzOSwgNDldLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgX2Nsb3NlVGFnc1tuXSA9ICc8L3NwYW4+J1xufSlcblxuLyoqXG4gKiBDb252ZXJ0cyB0ZXh0IHdpdGggQU5TSSBjb2xvciBjb2RlcyB0byBIVE1MIG1hcmt1cC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gYW5zaUhUTUwgKHRleHQpIHtcbiAgLy8gUmV0dXJucyB0aGUgdGV4dCBpZiB0aGUgc3RyaW5nIGhhcyBubyBBTlNJIGVzY2FwZSBjb2RlLlxuICBpZiAoIV9yZWdBTlNJLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgLy8gQ2FjaGUgb3BlbmVkIHNlcXVlbmNlLlxuICB2YXIgYW5zaUNvZGVzID0gW11cbiAgLy8gUmVwbGFjZSB3aXRoIG1hcmt1cC5cbiAgdmFyIHJldCA9IHRleHQucmVwbGFjZSgvXFwwMzNcXFsoXFxkKykqbS9nLCBmdW5jdGlvbiAobWF0Y2gsIHNlcSkge1xuICAgIHZhciBvdCA9IF9vcGVuVGFnc1tzZXFdXG4gICAgaWYgKG90KSB7XG4gICAgICAvLyBJZiBjdXJyZW50IHNlcXVlbmNlIGhhcyBiZWVuIG9wZW5lZCwgY2xvc2UgaXQuXG4gICAgICBpZiAoISF+YW5zaUNvZGVzLmluZGV4T2Yoc2VxKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV4dHJhLWJvb2xlYW4tY2FzdFxuICAgICAgICBhbnNpQ29kZXMucG9wKClcbiAgICAgICAgcmV0dXJuICc8L3NwYW4+J1xuICAgICAgfVxuICAgICAgLy8gT3BlbiB0YWcuXG4gICAgICBhbnNpQ29kZXMucHVzaChzZXEpXG4gICAgICByZXR1cm4gb3RbMF0gPT09ICc8JyA/IG90IDogJzxzcGFuIHN0eWxlPVwiJyArIG90ICsgJztcIj4nXG4gICAgfVxuXG4gICAgdmFyIGN0ID0gX2Nsb3NlVGFnc1tzZXFdXG4gICAgaWYgKGN0KSB7XG4gICAgICAvLyBQb3Agc2VxdWVuY2VcbiAgICAgIGFuc2lDb2Rlcy5wb3AoKVxuICAgICAgcmV0dXJuIGN0XG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9KVxuXG4gIC8vIE1ha2Ugc3VyZSB0YWdzIGFyZSBjbG9zZWQuXG4gIHZhciBsID0gYW5zaUNvZGVzLmxlbmd0aFxuICA7KGwgPiAwKSAmJiAocmV0ICs9IEFycmF5KGwgKyAxKS5qb2luKCc8L3NwYW4+JykpXG5cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIEN1c3RvbWl6ZSBjb2xvcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gY29sb3JzIHJlZmVyZW5jZSB0byBfZGVmQ29sb3JzXG4gKi9cbmFuc2lIVE1MLnNldENvbG9ycyA9IGZ1bmN0aW9uIChjb2xvcnMpIHtcbiAgaWYgKHR5cGVvZiBjb2xvcnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgY29sb3JzYCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBPYmplY3QuJylcbiAgfVxuXG4gIHZhciBfZmluYWxDb2xvcnMgPSB7fVxuICBmb3IgKHZhciBrZXkgaW4gX2RlZkNvbG9ycykge1xuICAgIHZhciBoZXggPSBjb2xvcnMuaGFzT3duUHJvcGVydHkoa2V5KSA/IGNvbG9yc1trZXldIDogbnVsbFxuICAgIGlmICghaGV4KSB7XG4gICAgICBfZmluYWxDb2xvcnNba2V5XSA9IF9kZWZDb2xvcnNba2V5XVxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKCdyZXNldCcgPT09IGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhleCA9IFtoZXhdXG4gICAgICB9XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGV4KSB8fCBoZXgubGVuZ3RoID09PSAwIHx8IGhleC5zb21lKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaCAhPT0gJ3N0cmluZydcbiAgICAgIH0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhbiBBcnJheSBhbmQgZWFjaCBpdGVtIGNvdWxkIG9ubHkgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKVxuICAgICAgfVxuICAgICAgdmFyIGRlZkhleENvbG9yID0gX2RlZkNvbG9yc1trZXldXG4gICAgICBpZiAoIWhleFswXSkge1xuICAgICAgICBoZXhbMF0gPSBkZWZIZXhDb2xvclswXVxuICAgICAgfVxuICAgICAgaWYgKGhleC5sZW5ndGggPT09IDEgfHwgIWhleFsxXSkge1xuICAgICAgICBoZXggPSBbaGV4WzBdXVxuICAgICAgICBoZXgucHVzaChkZWZIZXhDb2xvclsxXSlcbiAgICAgIH1cblxuICAgICAgaGV4ID0gaGV4LnNsaWNlKDAsIDIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGEgaGV4IHN0cmluZywgZS5nLjogRkYwMDAwJylcbiAgICB9XG4gICAgX2ZpbmFsQ29sb3JzW2tleV0gPSBoZXhcbiAgfVxuICBfc2V0VGFncyhfZmluYWxDb2xvcnMpXG59XG5cbi8qKlxuICogUmVzZXQgY29sb3JzLlxuICovXG5hbnNpSFRNTC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgX3NldFRhZ3MoX2RlZkNvbG9ycylcbn1cblxuLyoqXG4gKiBFeHBvc2UgdGFncywgaW5jbHVkaW5nIG9wZW4gYW5kIGNsb3NlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuYW5zaUhUTUwudGFncyA9IHt9XG5cbmlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdvcGVuJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX29wZW5UYWdzIH1cbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdjbG9zZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9jbG9zZVRhZ3MgfVxuICB9KVxufSBlbHNlIHtcbiAgYW5zaUhUTUwudGFncy5vcGVuID0gX29wZW5UYWdzXG4gIGFuc2lIVE1MLnRhZ3MuY2xvc2UgPSBfY2xvc2VUYWdzXG59XG5cbmZ1bmN0aW9uIF9zZXRUYWdzIChjb2xvcnMpIHtcbiAgLy8gcmVzZXQgYWxsXG4gIF9vcGVuVGFnc1snMCddID0gJ2ZvbnQtd2VpZ2h0Om5vcm1hbDtvcGFjaXR5OjE7Y29sb3I6IycgKyBjb2xvcnMucmVzZXRbMF0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMV1cbiAgLy8gaW52ZXJzZVxuICBfb3BlblRhZ3NbJzcnXSA9ICdjb2xvcjojJyArIGNvbG9ycy5yZXNldFsxXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFswXVxuICAvLyBkYXJrIGdyZXlcbiAgX29wZW5UYWdzWyc5MCddID0gJ2NvbG9yOiMnICsgY29sb3JzLmRhcmtncmV5XG5cbiAgZm9yICh2YXIgY29kZSBpbiBfc3R5bGVzKSB7XG4gICAgdmFyIGNvbG9yID0gX3N0eWxlc1tjb2RlXVxuICAgIHZhciBvcmlDb2xvciA9IGNvbG9yc1tjb2xvcl0gfHwgJzAwMCdcbiAgICBfb3BlblRhZ3NbY29kZV0gPSAnY29sb3I6IycgKyBvcmlDb2xvclxuICAgIGNvZGUgPSBwYXJzZUludChjb2RlKVxuICAgIF9vcGVuVGFnc1soY29kZSArIDEwKS50b1N0cmluZygpXSA9ICdiYWNrZ3JvdW5kOiMnICsgb3JpQ29sb3JcbiAgfVxufVxuXG5hbnNpSFRNTC5yZXNldCgpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgWG1sRW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL3htbC1lbnRpdGllcy5qcycpLFxuICBIdG1sNEVudGl0aWVzOiByZXF1aXJlKCcuL2xpYi9odG1sNC1lbnRpdGllcy5qcycpLFxuICBIdG1sNUVudGl0aWVzOiByZXF1aXJlKCcuL2xpYi9odG1sNS1lbnRpdGllcy5qcycpLFxuICBBbGxIdG1sRW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw1LWVudGl0aWVzLmpzJylcbn07XG4iLCJ2YXIgQUxQSEFfSU5ERVggPSB7XG4gICAgJyZsdCc6ICc8JyxcbiAgICAnJmd0JzogJz4nLFxuICAgICcmcXVvdCc6ICdcIicsXG4gICAgJyZhcG9zJzogJ1xcJycsXG4gICAgJyZhbXAnOiAnJicsXG4gICAgJyZsdDsnOiAnPCcsXG4gICAgJyZndDsnOiAnPicsXG4gICAgJyZxdW90Oyc6ICdcIicsXG4gICAgJyZhcG9zOyc6ICdcXCcnLFxuICAgICcmYW1wOyc6ICcmJ1xufTtcblxudmFyIENIQVJfSU5ERVggPSB7XG4gICAgNjA6ICdsdCcsXG4gICAgNjI6ICdndCcsXG4gICAgMzQ6ICdxdW90JyxcbiAgICAzOTogJ2Fwb3MnLFxuICAgIDM4OiAnYW1wJ1xufTtcblxudmFyIENIQVJfU19JTkRFWCA9IHtcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAnXFwnJzogJyZhcG9zOycsXG4gICAgJyYnOiAnJmFtcDsnXG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBYbWxFbnRpdGllcygpIHt9XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC88fD58XCJ8J3wmL2csIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIENIQVJfU19JTkRFWFtzXTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJiM/WzAtOWEtekEtWl0rOz8vZywgZnVuY3Rpb24ocykge1xuICAgICAgICBpZiAocy5jaGFyQXQoMSkgPT09ICcjJykge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBzLmNoYXJBdCgyKS50b0xvd2VyQ2FzZSgpID09PSAneCcgP1xuICAgICAgICAgICAgICAgIHBhcnNlSW50KHMuc3Vic3RyKDMpLCAxNikgOlxuICAgICAgICAgICAgICAgIHBhcnNlSW50KHMuc3Vic3RyKDIpKTtcblxuICAgICAgICAgICAgaWYgKGlzTmFOKGNvZGUpIHx8IGNvZGUgPCAtMzI3NjggfHwgY29kZSA+IDY1NTM1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFMUEhBX0lOREVYW3NdIHx8IHM7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBhbHBoYSA9IENIQVJfSU5ERVhbY107XG4gICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMzIgfHwgYyA+IDEyNikge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ2h0ID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ2h0KSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xuIH07XG5cbm1vZHVsZS5leHBvcnRzID0gWG1sRW50aXRpZXM7XG4iLCJ2YXIgSFRNTF9BTFBIQSA9IFsnYXBvcycsICduYnNwJywgJ2lleGNsJywgJ2NlbnQnLCAncG91bmQnLCAnY3VycmVuJywgJ3llbicsICdicnZiYXInLCAnc2VjdCcsICd1bWwnLCAnY29weScsICdvcmRmJywgJ2xhcXVvJywgJ25vdCcsICdzaHknLCAncmVnJywgJ21hY3InLCAnZGVnJywgJ3BsdXNtbicsICdzdXAyJywgJ3N1cDMnLCAnYWN1dGUnLCAnbWljcm8nLCAncGFyYScsICdtaWRkb3QnLCAnY2VkaWwnLCAnc3VwMScsICdvcmRtJywgJ3JhcXVvJywgJ2ZyYWMxNCcsICdmcmFjMTInLCAnZnJhYzM0JywgJ2lxdWVzdCcsICdBZ3JhdmUnLCAnQWFjdXRlJywgJ0FjaXJjJywgJ0F0aWxkZScsICdBdW1sJywgJ0FyaW5nJywgJ0FlbGlnJywgJ0NjZWRpbCcsICdFZ3JhdmUnLCAnRWFjdXRlJywgJ0VjaXJjJywgJ0V1bWwnLCAnSWdyYXZlJywgJ0lhY3V0ZScsICdJY2lyYycsICdJdW1sJywgJ0VUSCcsICdOdGlsZGUnLCAnT2dyYXZlJywgJ09hY3V0ZScsICdPY2lyYycsICdPdGlsZGUnLCAnT3VtbCcsICd0aW1lcycsICdPc2xhc2gnLCAnVWdyYXZlJywgJ1VhY3V0ZScsICdVY2lyYycsICdVdW1sJywgJ1lhY3V0ZScsICdUSE9STicsICdzemxpZycsICdhZ3JhdmUnLCAnYWFjdXRlJywgJ2FjaXJjJywgJ2F0aWxkZScsICdhdW1sJywgJ2FyaW5nJywgJ2FlbGlnJywgJ2NjZWRpbCcsICdlZ3JhdmUnLCAnZWFjdXRlJywgJ2VjaXJjJywgJ2V1bWwnLCAnaWdyYXZlJywgJ2lhY3V0ZScsICdpY2lyYycsICdpdW1sJywgJ2V0aCcsICdudGlsZGUnLCAnb2dyYXZlJywgJ29hY3V0ZScsICdvY2lyYycsICdvdGlsZGUnLCAnb3VtbCcsICdkaXZpZGUnLCAnb3NsYXNoJywgJ3VncmF2ZScsICd1YWN1dGUnLCAndWNpcmMnLCAndXVtbCcsICd5YWN1dGUnLCAndGhvcm4nLCAneXVtbCcsICdxdW90JywgJ2FtcCcsICdsdCcsICdndCcsICdPRWxpZycsICdvZWxpZycsICdTY2Fyb24nLCAnc2Nhcm9uJywgJ1l1bWwnLCAnY2lyYycsICd0aWxkZScsICdlbnNwJywgJ2Vtc3AnLCAndGhpbnNwJywgJ3p3bmonLCAnendqJywgJ2xybScsICdybG0nLCAnbmRhc2gnLCAnbWRhc2gnLCAnbHNxdW8nLCAncnNxdW8nLCAnc2JxdW8nLCAnbGRxdW8nLCAncmRxdW8nLCAnYmRxdW8nLCAnZGFnZ2VyJywgJ0RhZ2dlcicsICdwZXJtaWwnLCAnbHNhcXVvJywgJ3JzYXF1bycsICdldXJvJywgJ2Zub2YnLCAnQWxwaGEnLCAnQmV0YScsICdHYW1tYScsICdEZWx0YScsICdFcHNpbG9uJywgJ1pldGEnLCAnRXRhJywgJ1RoZXRhJywgJ0lvdGEnLCAnS2FwcGEnLCAnTGFtYmRhJywgJ011JywgJ051JywgJ1hpJywgJ09taWNyb24nLCAnUGknLCAnUmhvJywgJ1NpZ21hJywgJ1RhdScsICdVcHNpbG9uJywgJ1BoaScsICdDaGknLCAnUHNpJywgJ09tZWdhJywgJ2FscGhhJywgJ2JldGEnLCAnZ2FtbWEnLCAnZGVsdGEnLCAnZXBzaWxvbicsICd6ZXRhJywgJ2V0YScsICd0aGV0YScsICdpb3RhJywgJ2thcHBhJywgJ2xhbWJkYScsICdtdScsICdudScsICd4aScsICdvbWljcm9uJywgJ3BpJywgJ3JobycsICdzaWdtYWYnLCAnc2lnbWEnLCAndGF1JywgJ3Vwc2lsb24nLCAncGhpJywgJ2NoaScsICdwc2knLCAnb21lZ2EnLCAndGhldGFzeW0nLCAndXBzaWgnLCAncGl2JywgJ2J1bGwnLCAnaGVsbGlwJywgJ3ByaW1lJywgJ1ByaW1lJywgJ29saW5lJywgJ2ZyYXNsJywgJ3dlaWVycCcsICdpbWFnZScsICdyZWFsJywgJ3RyYWRlJywgJ2FsZWZzeW0nLCAnbGFycicsICd1YXJyJywgJ3JhcnInLCAnZGFycicsICdoYXJyJywgJ2NyYXJyJywgJ2xBcnInLCAndUFycicsICdyQXJyJywgJ2RBcnInLCAnaEFycicsICdmb3JhbGwnLCAncGFydCcsICdleGlzdCcsICdlbXB0eScsICduYWJsYScsICdpc2luJywgJ25vdGluJywgJ25pJywgJ3Byb2QnLCAnc3VtJywgJ21pbnVzJywgJ2xvd2FzdCcsICdyYWRpYycsICdwcm9wJywgJ2luZmluJywgJ2FuZycsICdhbmQnLCAnb3InLCAnY2FwJywgJ2N1cCcsICdpbnQnLCAndGhlcmU0JywgJ3NpbScsICdjb25nJywgJ2FzeW1wJywgJ25lJywgJ2VxdWl2JywgJ2xlJywgJ2dlJywgJ3N1YicsICdzdXAnLCAnbnN1YicsICdzdWJlJywgJ3N1cGUnLCAnb3BsdXMnLCAnb3RpbWVzJywgJ3BlcnAnLCAnc2RvdCcsICdsY2VpbCcsICdyY2VpbCcsICdsZmxvb3InLCAncmZsb29yJywgJ2xhbmcnLCAncmFuZycsICdsb3onLCAnc3BhZGVzJywgJ2NsdWJzJywgJ2hlYXJ0cycsICdkaWFtcyddO1xudmFyIEhUTUxfQ09ERVMgPSBbMzksIDE2MCwgMTYxLCAxNjIsIDE2MywgMTY0LCAxNjUsIDE2NiwgMTY3LCAxNjgsIDE2OSwgMTcwLCAxNzEsIDE3MiwgMTczLCAxNzQsIDE3NSwgMTc2LCAxNzcsIDE3OCwgMTc5LCAxODAsIDE4MSwgMTgyLCAxODMsIDE4NCwgMTg1LCAxODYsIDE4NywgMTg4LCAxODksIDE5MCwgMTkxLCAxOTIsIDE5MywgMTk0LCAxOTUsIDE5NiwgMTk3LCAxOTgsIDE5OSwgMjAwLCAyMDEsIDIwMiwgMjAzLCAyMDQsIDIwNSwgMjA2LCAyMDcsIDIwOCwgMjA5LCAyMTAsIDIxMSwgMjEyLCAyMTMsIDIxNCwgMjE1LCAyMTYsIDIxNywgMjE4LCAyMTksIDIyMCwgMjIxLCAyMjIsIDIyMywgMjI0LCAyMjUsIDIyNiwgMjI3LCAyMjgsIDIyOSwgMjMwLCAyMzEsIDIzMiwgMjMzLCAyMzQsIDIzNSwgMjM2LCAyMzcsIDIzOCwgMjM5LCAyNDAsIDI0MSwgMjQyLCAyNDMsIDI0NCwgMjQ1LCAyNDYsIDI0NywgMjQ4LCAyNDksIDI1MCwgMjUxLCAyNTIsIDI1MywgMjU0LCAyNTUsIDM0LCAzOCwgNjAsIDYyLCAzMzgsIDMzOSwgMzUyLCAzNTMsIDM3NiwgNzEwLCA3MzIsIDgxOTQsIDgxOTUsIDgyMDEsIDgyMDQsIDgyMDUsIDgyMDYsIDgyMDcsIDgyMTEsIDgyMTIsIDgyMTYsIDgyMTcsIDgyMTgsIDgyMjAsIDgyMjEsIDgyMjIsIDgyMjQsIDgyMjUsIDgyNDAsIDgyNDksIDgyNTAsIDgzNjQsIDQwMiwgOTEzLCA5MTQsIDkxNSwgOTE2LCA5MTcsIDkxOCwgOTE5LCA5MjAsIDkyMSwgOTIyLCA5MjMsIDkyNCwgOTI1LCA5MjYsIDkyNywgOTI4LCA5MjksIDkzMSwgOTMyLCA5MzMsIDkzNCwgOTM1LCA5MzYsIDkzNywgOTQ1LCA5NDYsIDk0NywgOTQ4LCA5NDksIDk1MCwgOTUxLCA5NTIsIDk1MywgOTU0LCA5NTUsIDk1NiwgOTU3LCA5NTgsIDk1OSwgOTYwLCA5NjEsIDk2MiwgOTYzLCA5NjQsIDk2NSwgOTY2LCA5NjcsIDk2OCwgOTY5LCA5NzcsIDk3OCwgOTgyLCA4MjI2LCA4MjMwLCA4MjQyLCA4MjQzLCA4MjU0LCA4MjYwLCA4NDcyLCA4NDY1LCA4NDc2LCA4NDgyLCA4NTAxLCA4NTkyLCA4NTkzLCA4NTk0LCA4NTk1LCA4NTk2LCA4NjI5LCA4NjU2LCA4NjU3LCA4NjU4LCA4NjU5LCA4NjYwLCA4NzA0LCA4NzA2LCA4NzA3LCA4NzA5LCA4NzExLCA4NzEyLCA4NzEzLCA4NzE1LCA4NzE5LCA4NzIxLCA4NzIyLCA4NzI3LCA4NzMwLCA4NzMzLCA4NzM0LCA4NzM2LCA4NzQzLCA4NzQ0LCA4NzQ1LCA4NzQ2LCA4NzQ3LCA4NzU2LCA4NzY0LCA4NzczLCA4Nzc2LCA4ODAwLCA4ODAxLCA4ODA0LCA4ODA1LCA4ODM0LCA4ODM1LCA4ODM2LCA4ODM4LCA4ODM5LCA4ODUzLCA4ODU1LCA4ODY5LCA4OTAxLCA4OTY4LCA4OTY5LCA4OTcwLCA4OTcxLCA5MDAxLCA5MDAyLCA5Njc0LCA5ODI0LCA5ODI3LCA5ODI5LCA5ODMwXTtcblxudmFyIGFscGhhSW5kZXggPSB7fTtcbnZhciBudW1JbmRleCA9IHt9O1xuXG52YXIgaSA9IDA7XG52YXIgbGVuZ3RoID0gSFRNTF9BTFBIQS5sZW5ndGg7XG53aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIHZhciBhID0gSFRNTF9BTFBIQVtpXTtcbiAgICB2YXIgYyA9IEhUTUxfQ09ERVNbaV07XG4gICAgYWxwaGFJbmRleFthXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgbnVtSW5kZXhbY10gPSBhO1xuICAgIGkrKztcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSHRtbDRFbnRpdGllcygpIHt9XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYoIz9bXFx3XFxkXSspOz8vZywgZnVuY3Rpb24ocywgZW50aXR5KSB7XG4gICAgICAgIHZhciBjaHI7XG4gICAgICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBlbnRpdHkuY2hhckF0KDEpLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigyKSwgMTYpIDpcbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDEpKTtcblxuICAgICAgICAgICAgaWYgKCEoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpKSB7XG4gICAgICAgICAgICAgICAgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNociA9IGFscGhhSW5kZXhbZW50aXR5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hyIHx8IHM7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYWxwaGEgPSBudW1JbmRleFtzdHIuY2hhckNvZGVBdChpKV07XG4gICAgICAgIHJlc3VsdCArPSBhbHBoYSA/IFwiJlwiICsgYWxwaGEgKyBcIjtcIiA6IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgYWxwaGEgPSBudW1JbmRleFtjY107XG4gICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjYyA8IDMyIHx8IGNjID4gMTI2KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCImI1wiICsgY2MgKyBcIjtcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWw0RW50aXRpZXM7XG4iLCJ2YXIgRU5USVRJRVMgPSBbWydBYWN1dGUnLCBbMTkzXV0sIFsnYWFjdXRlJywgWzIyNV1dLCBbJ0FicmV2ZScsIFsyNThdXSwgWydhYnJldmUnLCBbMjU5XV0sIFsnYWMnLCBbODc2Nl1dLCBbJ2FjZCcsIFs4NzY3XV0sIFsnYWNFJywgWzg3NjYsIDgxOV1dLCBbJ0FjaXJjJywgWzE5NF1dLCBbJ2FjaXJjJywgWzIyNl1dLCBbJ2FjdXRlJywgWzE4MF1dLCBbJ0FjeScsIFsxMDQwXV0sIFsnYWN5JywgWzEwNzJdXSwgWydBRWxpZycsIFsxOThdXSwgWydhZWxpZycsIFsyMzBdXSwgWydhZicsIFs4Mjg5XV0sIFsnQWZyJywgWzEyMDA2OF1dLCBbJ2FmcicsIFsxMjAwOTRdXSwgWydBZ3JhdmUnLCBbMTkyXV0sIFsnYWdyYXZlJywgWzIyNF1dLCBbJ2FsZWZzeW0nLCBbODUwMV1dLCBbJ2FsZXBoJywgWzg1MDFdXSwgWydBbHBoYScsIFs5MTNdXSwgWydhbHBoYScsIFs5NDVdXSwgWydBbWFjcicsIFsyNTZdXSwgWydhbWFjcicsIFsyNTddXSwgWydhbWFsZycsIFsxMDgxNV1dLCBbJ2FtcCcsIFszOF1dLCBbJ0FNUCcsIFszOF1dLCBbJ2FuZGFuZCcsIFsxMDgzN11dLCBbJ0FuZCcsIFsxMDgzNV1dLCBbJ2FuZCcsIFs4NzQzXV0sIFsnYW5kZCcsIFsxMDg0NF1dLCBbJ2FuZHNsb3BlJywgWzEwODQwXV0sIFsnYW5kdicsIFsxMDg0Ml1dLCBbJ2FuZycsIFs4NzM2XV0sIFsnYW5nZScsIFsxMDY2MF1dLCBbJ2FuZ2xlJywgWzg3MzZdXSwgWydhbmdtc2RhYScsIFsxMDY2NF1dLCBbJ2FuZ21zZGFiJywgWzEwNjY1XV0sIFsnYW5nbXNkYWMnLCBbMTA2NjZdXSwgWydhbmdtc2RhZCcsIFsxMDY2N11dLCBbJ2FuZ21zZGFlJywgWzEwNjY4XV0sIFsnYW5nbXNkYWYnLCBbMTA2NjldXSwgWydhbmdtc2RhZycsIFsxMDY3MF1dLCBbJ2FuZ21zZGFoJywgWzEwNjcxXV0sIFsnYW5nbXNkJywgWzg3MzddXSwgWydhbmdydCcsIFs4NzM1XV0sIFsnYW5ncnR2YicsIFs4ODk0XV0sIFsnYW5ncnR2YmQnLCBbMTA2NTNdXSwgWydhbmdzcGgnLCBbODczOF1dLCBbJ2FuZ3N0JywgWzE5N11dLCBbJ2FuZ3phcnInLCBbOTA4NF1dLCBbJ0FvZ29uJywgWzI2MF1dLCBbJ2FvZ29uJywgWzI2MV1dLCBbJ0FvcGYnLCBbMTIwMTIwXV0sIFsnYW9wZicsIFsxMjAxNDZdXSwgWydhcGFjaXInLCBbMTA4NjNdXSwgWydhcCcsIFs4Nzc2XV0sIFsnYXBFJywgWzEwODY0XV0sIFsnYXBlJywgWzg3NzhdXSwgWydhcGlkJywgWzg3NzldXSwgWydhcG9zJywgWzM5XV0sIFsnQXBwbHlGdW5jdGlvbicsIFs4Mjg5XV0sIFsnYXBwcm94JywgWzg3NzZdXSwgWydhcHByb3hlcScsIFs4Nzc4XV0sIFsnQXJpbmcnLCBbMTk3XV0sIFsnYXJpbmcnLCBbMjI5XV0sIFsnQXNjcicsIFsxMTk5NjRdXSwgWydhc2NyJywgWzExOTk5MF1dLCBbJ0Fzc2lnbicsIFs4Nzg4XV0sIFsnYXN0JywgWzQyXV0sIFsnYXN5bXAnLCBbODc3Nl1dLCBbJ2FzeW1wZXEnLCBbODc4MV1dLCBbJ0F0aWxkZScsIFsxOTVdXSwgWydhdGlsZGUnLCBbMjI3XV0sIFsnQXVtbCcsIFsxOTZdXSwgWydhdW1sJywgWzIyOF1dLCBbJ2F3Y29uaW50JywgWzg3NTVdXSwgWydhd2ludCcsIFsxMDc2OV1dLCBbJ2JhY2tjb25nJywgWzg3ODBdXSwgWydiYWNrZXBzaWxvbicsIFsxMDE0XV0sIFsnYmFja3ByaW1lJywgWzgyNDVdXSwgWydiYWNrc2ltJywgWzg3NjVdXSwgWydiYWNrc2ltZXEnLCBbODkwOV1dLCBbJ0JhY2tzbGFzaCcsIFs4NzI2XV0sIFsnQmFydicsIFsxMDk4M11dLCBbJ2JhcnZlZScsIFs4ODkzXV0sIFsnYmFyd2VkJywgWzg5NjVdXSwgWydCYXJ3ZWQnLCBbODk2Nl1dLCBbJ2JhcndlZGdlJywgWzg5NjVdXSwgWydiYnJrJywgWzkxNDFdXSwgWydiYnJrdGJyaycsIFs5MTQyXV0sIFsnYmNvbmcnLCBbODc4MF1dLCBbJ0JjeScsIFsxMDQxXV0sIFsnYmN5JywgWzEwNzNdXSwgWydiZHF1bycsIFs4MjIyXV0sIFsnYmVjYXVzJywgWzg3NTddXSwgWydiZWNhdXNlJywgWzg3NTddXSwgWydCZWNhdXNlJywgWzg3NTddXSwgWydiZW1wdHl2JywgWzEwNjcyXV0sIFsnYmVwc2knLCBbMTAxNF1dLCBbJ2Jlcm5vdScsIFs4NDkyXV0sIFsnQmVybm91bGxpcycsIFs4NDkyXV0sIFsnQmV0YScsIFs5MTRdXSwgWydiZXRhJywgWzk0Nl1dLCBbJ2JldGgnLCBbODUwMl1dLCBbJ2JldHdlZW4nLCBbODgxMl1dLCBbJ0JmcicsIFsxMjAwNjldXSwgWydiZnInLCBbMTIwMDk1XV0sIFsnYmlnY2FwJywgWzg4OThdXSwgWydiaWdjaXJjJywgWzk3MTFdXSwgWydiaWdjdXAnLCBbODg5OV1dLCBbJ2JpZ29kb3QnLCBbMTA3NTJdXSwgWydiaWdvcGx1cycsIFsxMDc1M11dLCBbJ2JpZ290aW1lcycsIFsxMDc1NF1dLCBbJ2JpZ3NxY3VwJywgWzEwNzU4XV0sIFsnYmlnc3RhcicsIFs5NzMzXV0sIFsnYmlndHJpYW5nbGVkb3duJywgWzk2NjFdXSwgWydiaWd0cmlhbmdsZXVwJywgWzk2NTFdXSwgWydiaWd1cGx1cycsIFsxMDc1Nl1dLCBbJ2JpZ3ZlZScsIFs4ODk3XV0sIFsnYmlnd2VkZ2UnLCBbODg5Nl1dLCBbJ2JrYXJvdycsIFsxMDUwOV1dLCBbJ2JsYWNrbG96ZW5nZScsIFsxMDczMV1dLCBbJ2JsYWNrc3F1YXJlJywgWzk2NDJdXSwgWydibGFja3RyaWFuZ2xlJywgWzk2NTJdXSwgWydibGFja3RyaWFuZ2xlZG93bicsIFs5NjYyXV0sIFsnYmxhY2t0cmlhbmdsZWxlZnQnLCBbOTY2Nl1dLCBbJ2JsYWNrdHJpYW5nbGVyaWdodCcsIFs5NjU2XV0sIFsnYmxhbmsnLCBbOTI1MV1dLCBbJ2JsazEyJywgWzk2MThdXSwgWydibGsxNCcsIFs5NjE3XV0sIFsnYmxrMzQnLCBbOTYxOV1dLCBbJ2Jsb2NrJywgWzk2MDhdXSwgWydibmUnLCBbNjEsIDg0MjFdXSwgWydibmVxdWl2JywgWzg4MDEsIDg0MjFdXSwgWydiTm90JywgWzEwOTg5XV0sIFsnYm5vdCcsIFs4OTc2XV0sIFsnQm9wZicsIFsxMjAxMjFdXSwgWydib3BmJywgWzEyMDE0N11dLCBbJ2JvdCcsIFs4ODY5XV0sIFsnYm90dG9tJywgWzg4NjldXSwgWydib3d0aWUnLCBbODkwNF1dLCBbJ2JveGJveCcsIFsxMDY5N11dLCBbJ2JveGRsJywgWzk0ODhdXSwgWydib3hkTCcsIFs5NTU3XV0sIFsnYm94RGwnLCBbOTU1OF1dLCBbJ2JveERMJywgWzk1NTldXSwgWydib3hkcicsIFs5NDg0XV0sIFsnYm94ZFInLCBbOTU1NF1dLCBbJ2JveERyJywgWzk1NTVdXSwgWydib3hEUicsIFs5NTU2XV0sIFsnYm94aCcsIFs5NDcyXV0sIFsnYm94SCcsIFs5NTUyXV0sIFsnYm94aGQnLCBbOTUxNl1dLCBbJ2JveEhkJywgWzk1NzJdXSwgWydib3hoRCcsIFs5NTczXV0sIFsnYm94SEQnLCBbOTU3NF1dLCBbJ2JveGh1JywgWzk1MjRdXSwgWydib3hIdScsIFs5NTc1XV0sIFsnYm94aFUnLCBbOTU3Nl1dLCBbJ2JveEhVJywgWzk1NzddXSwgWydib3htaW51cycsIFs4ODYzXV0sIFsnYm94cGx1cycsIFs4ODYyXV0sIFsnYm94dGltZXMnLCBbODg2NF1dLCBbJ2JveHVsJywgWzk0OTZdXSwgWydib3h1TCcsIFs5NTYzXV0sIFsnYm94VWwnLCBbOTU2NF1dLCBbJ2JveFVMJywgWzk1NjVdXSwgWydib3h1cicsIFs5NDkyXV0sIFsnYm94dVInLCBbOTU2MF1dLCBbJ2JveFVyJywgWzk1NjFdXSwgWydib3hVUicsIFs5NTYyXV0sIFsnYm94dicsIFs5NDc0XV0sIFsnYm94VicsIFs5NTUzXV0sIFsnYm94dmgnLCBbOTUzMl1dLCBbJ2JveHZIJywgWzk1NzhdXSwgWydib3hWaCcsIFs5NTc5XV0sIFsnYm94VkgnLCBbOTU4MF1dLCBbJ2JveHZsJywgWzk1MDhdXSwgWydib3h2TCcsIFs5NTY5XV0sIFsnYm94VmwnLCBbOTU3MF1dLCBbJ2JveFZMJywgWzk1NzFdXSwgWydib3h2cicsIFs5NTAwXV0sIFsnYm94dlInLCBbOTU2Nl1dLCBbJ2JveFZyJywgWzk1NjddXSwgWydib3hWUicsIFs5NTY4XV0sIFsnYnByaW1lJywgWzgyNDVdXSwgWydicmV2ZScsIFs3MjhdXSwgWydCcmV2ZScsIFs3MjhdXSwgWydicnZiYXInLCBbMTY2XV0sIFsnYnNjcicsIFsxMTk5OTFdXSwgWydCc2NyJywgWzg0OTJdXSwgWydic2VtaScsIFs4MjcxXV0sIFsnYnNpbScsIFs4NzY1XV0sIFsnYnNpbWUnLCBbODkwOV1dLCBbJ2Jzb2xiJywgWzEwNjkzXV0sIFsnYnNvbCcsIFs5Ml1dLCBbJ2Jzb2xoc3ViJywgWzEwMTg0XV0sIFsnYnVsbCcsIFs4MjI2XV0sIFsnYnVsbGV0JywgWzgyMjZdXSwgWydidW1wJywgWzg3ODJdXSwgWydidW1wRScsIFsxMDkyNl1dLCBbJ2J1bXBlJywgWzg3ODNdXSwgWydCdW1wZXEnLCBbODc4Ml1dLCBbJ2J1bXBlcScsIFs4NzgzXV0sIFsnQ2FjdXRlJywgWzI2Ml1dLCBbJ2NhY3V0ZScsIFsyNjNdXSwgWydjYXBhbmQnLCBbMTA4MjBdXSwgWydjYXBicmN1cCcsIFsxMDgyNV1dLCBbJ2NhcGNhcCcsIFsxMDgyN11dLCBbJ2NhcCcsIFs4NzQ1XV0sIFsnQ2FwJywgWzg5MTRdXSwgWydjYXBjdXAnLCBbMTA4MjNdXSwgWydjYXBkb3QnLCBbMTA4MTZdXSwgWydDYXBpdGFsRGlmZmVyZW50aWFsRCcsIFs4NTE3XV0sIFsnY2FwcycsIFs4NzQ1LCA2NTAyNF1dLCBbJ2NhcmV0JywgWzgyNTddXSwgWydjYXJvbicsIFs3MTFdXSwgWydDYXlsZXlzJywgWzg0OTNdXSwgWydjY2FwcycsIFsxMDgyOV1dLCBbJ0NjYXJvbicsIFsyNjhdXSwgWydjY2Fyb24nLCBbMjY5XV0sIFsnQ2NlZGlsJywgWzE5OV1dLCBbJ2NjZWRpbCcsIFsyMzFdXSwgWydDY2lyYycsIFsyNjRdXSwgWydjY2lyYycsIFsyNjVdXSwgWydDY29uaW50JywgWzg3NTJdXSwgWydjY3VwcycsIFsxMDgyOF1dLCBbJ2NjdXBzc20nLCBbMTA4MzJdXSwgWydDZG90JywgWzI2Nl1dLCBbJ2Nkb3QnLCBbMjY3XV0sIFsnY2VkaWwnLCBbMTg0XV0sIFsnQ2VkaWxsYScsIFsxODRdXSwgWydjZW1wdHl2JywgWzEwNjc0XV0sIFsnY2VudCcsIFsxNjJdXSwgWydjZW50ZXJkb3QnLCBbMTgzXV0sIFsnQ2VudGVyRG90JywgWzE4M11dLCBbJ2NmcicsIFsxMjAwOTZdXSwgWydDZnInLCBbODQ5M11dLCBbJ0NIY3knLCBbMTA2M11dLCBbJ2NoY3knLCBbMTA5NV1dLCBbJ2NoZWNrJywgWzEwMDAzXV0sIFsnY2hlY2ttYXJrJywgWzEwMDAzXV0sIFsnQ2hpJywgWzkzNV1dLCBbJ2NoaScsIFs5NjddXSwgWydjaXJjJywgWzcxMF1dLCBbJ2NpcmNlcScsIFs4NzkxXV0sIFsnY2lyY2xlYXJyb3dsZWZ0JywgWzg2MzRdXSwgWydjaXJjbGVhcnJvd3JpZ2h0JywgWzg2MzVdXSwgWydjaXJjbGVkYXN0JywgWzg4NTldXSwgWydjaXJjbGVkY2lyYycsIFs4ODU4XV0sIFsnY2lyY2xlZGRhc2gnLCBbODg2MV1dLCBbJ0NpcmNsZURvdCcsIFs4ODU3XV0sIFsnY2lyY2xlZFInLCBbMTc0XV0sIFsnY2lyY2xlZFMnLCBbOTQxNl1dLCBbJ0NpcmNsZU1pbnVzJywgWzg4NTRdXSwgWydDaXJjbGVQbHVzJywgWzg4NTNdXSwgWydDaXJjbGVUaW1lcycsIFs4ODU1XV0sIFsnY2lyJywgWzk2NzVdXSwgWydjaXJFJywgWzEwNjkxXV0sIFsnY2lyZScsIFs4NzkxXV0sIFsnY2lyZm5pbnQnLCBbMTA3NjhdXSwgWydjaXJtaWQnLCBbMTA5OTFdXSwgWydjaXJzY2lyJywgWzEwNjkwXV0sIFsnQ2xvY2t3aXNlQ29udG91ckludGVncmFsJywgWzg3NTRdXSwgWydjbHVicycsIFs5ODI3XV0sIFsnY2x1YnN1aXQnLCBbOTgyN11dLCBbJ2NvbG9uJywgWzU4XV0sIFsnQ29sb24nLCBbODc1OV1dLCBbJ0NvbG9uZScsIFsxMDg2OF1dLCBbJ2NvbG9uZScsIFs4Nzg4XV0sIFsnY29sb25lcScsIFs4Nzg4XV0sIFsnY29tbWEnLCBbNDRdXSwgWydjb21tYXQnLCBbNjRdXSwgWydjb21wJywgWzg3MDVdXSwgWydjb21wZm4nLCBbODcyOF1dLCBbJ2NvbXBsZW1lbnQnLCBbODcwNV1dLCBbJ2NvbXBsZXhlcycsIFs4NDUwXV0sIFsnY29uZycsIFs4NzczXV0sIFsnY29uZ2RvdCcsIFsxMDg2MV1dLCBbJ0NvbmdydWVudCcsIFs4ODAxXV0sIFsnY29uaW50JywgWzg3NTBdXSwgWydDb25pbnQnLCBbODc1MV1dLCBbJ0NvbnRvdXJJbnRlZ3JhbCcsIFs4NzUwXV0sIFsnY29wZicsIFsxMjAxNDhdXSwgWydDb3BmJywgWzg0NTBdXSwgWydjb3Byb2QnLCBbODcyMF1dLCBbJ0NvcHJvZHVjdCcsIFs4NzIwXV0sIFsnY29weScsIFsxNjldXSwgWydDT1BZJywgWzE2OV1dLCBbJ2NvcHlzcicsIFs4NDcxXV0sIFsnQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzU1XV0sIFsnY3JhcnInLCBbODYyOV1dLCBbJ2Nyb3NzJywgWzEwMDA3XV0sIFsnQ3Jvc3MnLCBbMTA3OTldXSwgWydDc2NyJywgWzExOTk2Nl1dLCBbJ2NzY3InLCBbMTE5OTkyXV0sIFsnY3N1YicsIFsxMDk1OV1dLCBbJ2NzdWJlJywgWzEwOTYxXV0sIFsnY3N1cCcsIFsxMDk2MF1dLCBbJ2NzdXBlJywgWzEwOTYyXV0sIFsnY3Rkb3QnLCBbODk0M11dLCBbJ2N1ZGFycmwnLCBbMTA1NTJdXSwgWydjdWRhcnJyJywgWzEwNTQ5XV0sIFsnY3VlcHInLCBbODkyNl1dLCBbJ2N1ZXNjJywgWzg5MjddXSwgWydjdWxhcnInLCBbODYzMF1dLCBbJ2N1bGFycnAnLCBbMTA1NTddXSwgWydjdXBicmNhcCcsIFsxMDgyNF1dLCBbJ2N1cGNhcCcsIFsxMDgyMl1dLCBbJ0N1cENhcCcsIFs4NzgxXV0sIFsnY3VwJywgWzg3NDZdXSwgWydDdXAnLCBbODkxNV1dLCBbJ2N1cGN1cCcsIFsxMDgyNl1dLCBbJ2N1cGRvdCcsIFs4ODQ1XV0sIFsnY3Vwb3InLCBbMTA4MjFdXSwgWydjdXBzJywgWzg3NDYsIDY1MDI0XV0sIFsnY3VyYXJyJywgWzg2MzFdXSwgWydjdXJhcnJtJywgWzEwNTU2XV0sIFsnY3VybHllcXByZWMnLCBbODkyNl1dLCBbJ2N1cmx5ZXFzdWNjJywgWzg5MjddXSwgWydjdXJseXZlZScsIFs4OTEwXV0sIFsnY3VybHl3ZWRnZScsIFs4OTExXV0sIFsnY3VycmVuJywgWzE2NF1dLCBbJ2N1cnZlYXJyb3dsZWZ0JywgWzg2MzBdXSwgWydjdXJ2ZWFycm93cmlnaHQnLCBbODYzMV1dLCBbJ2N1dmVlJywgWzg5MTBdXSwgWydjdXdlZCcsIFs4OTExXV0sIFsnY3djb25pbnQnLCBbODc1NF1dLCBbJ2N3aW50JywgWzg3NTNdXSwgWydjeWxjdHknLCBbOTAwNV1dLCBbJ2RhZ2dlcicsIFs4MjI0XV0sIFsnRGFnZ2VyJywgWzgyMjVdXSwgWydkYWxldGgnLCBbODUwNF1dLCBbJ2RhcnInLCBbODU5NV1dLCBbJ0RhcnInLCBbODYwOV1dLCBbJ2RBcnInLCBbODY1OV1dLCBbJ2Rhc2gnLCBbODIwOF1dLCBbJ0Rhc2h2JywgWzEwOTgwXV0sIFsnZGFzaHYnLCBbODg2N11dLCBbJ2Ria2Fyb3cnLCBbMTA1MTFdXSwgWydkYmxhYycsIFs3MzNdXSwgWydEY2Fyb24nLCBbMjcwXV0sIFsnZGNhcm9uJywgWzI3MV1dLCBbJ0RjeScsIFsxMDQ0XV0sIFsnZGN5JywgWzEwNzZdXSwgWydkZGFnZ2VyJywgWzgyMjVdXSwgWydkZGFycicsIFs4NjUwXV0sIFsnREQnLCBbODUxN11dLCBbJ2RkJywgWzg1MThdXSwgWydERG90cmFoZCcsIFsxMDUxM11dLCBbJ2Rkb3RzZXEnLCBbMTA4NzFdXSwgWydkZWcnLCBbMTc2XV0sIFsnRGVsJywgWzg3MTFdXSwgWydEZWx0YScsIFs5MTZdXSwgWydkZWx0YScsIFs5NDhdXSwgWydkZW1wdHl2JywgWzEwNjczXV0sIFsnZGZpc2h0JywgWzEwNjIzXV0sIFsnRGZyJywgWzEyMDA3MV1dLCBbJ2RmcicsIFsxMjAwOTddXSwgWydkSGFyJywgWzEwNTk3XV0sIFsnZGhhcmwnLCBbODY0M11dLCBbJ2RoYXJyJywgWzg2NDJdXSwgWydEaWFjcml0aWNhbEFjdXRlJywgWzE4MF1dLCBbJ0RpYWNyaXRpY2FsRG90JywgWzcyOV1dLCBbJ0RpYWNyaXRpY2FsRG91YmxlQWN1dGUnLCBbNzMzXV0sIFsnRGlhY3JpdGljYWxHcmF2ZScsIFs5Nl1dLCBbJ0RpYWNyaXRpY2FsVGlsZGUnLCBbNzMyXV0sIFsnZGlhbScsIFs4OTAwXV0sIFsnZGlhbW9uZCcsIFs4OTAwXV0sIFsnRGlhbW9uZCcsIFs4OTAwXV0sIFsnZGlhbW9uZHN1aXQnLCBbOTgzMF1dLCBbJ2RpYW1zJywgWzk4MzBdXSwgWydkaWUnLCBbMTY4XV0sIFsnRGlmZmVyZW50aWFsRCcsIFs4NTE4XV0sIFsnZGlnYW1tYScsIFs5ODldXSwgWydkaXNpbicsIFs4OTQ2XV0sIFsnZGl2JywgWzI0N11dLCBbJ2RpdmlkZScsIFsyNDddXSwgWydkaXZpZGVvbnRpbWVzJywgWzg5MDNdXSwgWydkaXZvbngnLCBbODkwM11dLCBbJ0RKY3knLCBbMTAyNl1dLCBbJ2RqY3knLCBbMTEwNl1dLCBbJ2RsY29ybicsIFs4OTkwXV0sIFsnZGxjcm9wJywgWzg5NzNdXSwgWydkb2xsYXInLCBbMzZdXSwgWydEb3BmJywgWzEyMDEyM11dLCBbJ2RvcGYnLCBbMTIwMTQ5XV0sIFsnRG90JywgWzE2OF1dLCBbJ2RvdCcsIFs3MjldXSwgWydEb3REb3QnLCBbODQxMl1dLCBbJ2RvdGVxJywgWzg3ODRdXSwgWydkb3RlcWRvdCcsIFs4Nzg1XV0sIFsnRG90RXF1YWwnLCBbODc4NF1dLCBbJ2RvdG1pbnVzJywgWzg3NjBdXSwgWydkb3RwbHVzJywgWzg3MjRdXSwgWydkb3RzcXVhcmUnLCBbODg2NV1dLCBbJ2RvdWJsZWJhcndlZGdlJywgWzg5NjZdXSwgWydEb3VibGVDb250b3VySW50ZWdyYWwnLCBbODc1MV1dLCBbJ0RvdWJsZURvdCcsIFsxNjhdXSwgWydEb3VibGVEb3duQXJyb3cnLCBbODY1OV1dLCBbJ0RvdWJsZUxlZnRBcnJvdycsIFs4NjU2XV0sIFsnRG91YmxlTGVmdFJpZ2h0QXJyb3cnLCBbODY2MF1dLCBbJ0RvdWJsZUxlZnRUZWUnLCBbMTA5ODBdXSwgWydEb3VibGVMb25nTGVmdEFycm93JywgWzEwMjMyXV0sIFsnRG91YmxlTG9uZ0xlZnRSaWdodEFycm93JywgWzEwMjM0XV0sIFsnRG91YmxlTG9uZ1JpZ2h0QXJyb3cnLCBbMTAyMzNdXSwgWydEb3VibGVSaWdodEFycm93JywgWzg2NThdXSwgWydEb3VibGVSaWdodFRlZScsIFs4ODcyXV0sIFsnRG91YmxlVXBBcnJvdycsIFs4NjU3XV0sIFsnRG91YmxlVXBEb3duQXJyb3cnLCBbODY2MV1dLCBbJ0RvdWJsZVZlcnRpY2FsQmFyJywgWzg3NDFdXSwgWydEb3duQXJyb3dCYXInLCBbMTA1MTVdXSwgWydkb3duYXJyb3cnLCBbODU5NV1dLCBbJ0Rvd25BcnJvdycsIFs4NTk1XV0sIFsnRG93bmFycm93JywgWzg2NTldXSwgWydEb3duQXJyb3dVcEFycm93JywgWzg2OTNdXSwgWydEb3duQnJldmUnLCBbNzg1XV0sIFsnZG93bmRvd25hcnJvd3MnLCBbODY1MF1dLCBbJ2Rvd25oYXJwb29ubGVmdCcsIFs4NjQzXV0sIFsnZG93bmhhcnBvb25yaWdodCcsIFs4NjQyXV0sIFsnRG93bkxlZnRSaWdodFZlY3RvcicsIFsxMDU3Nl1dLCBbJ0Rvd25MZWZ0VGVlVmVjdG9yJywgWzEwNTkwXV0sIFsnRG93bkxlZnRWZWN0b3JCYXInLCBbMTA1ODJdXSwgWydEb3duTGVmdFZlY3RvcicsIFs4NjM3XV0sIFsnRG93blJpZ2h0VGVlVmVjdG9yJywgWzEwNTkxXV0sIFsnRG93blJpZ2h0VmVjdG9yQmFyJywgWzEwNTgzXV0sIFsnRG93blJpZ2h0VmVjdG9yJywgWzg2NDFdXSwgWydEb3duVGVlQXJyb3cnLCBbODYxNV1dLCBbJ0Rvd25UZWUnLCBbODg2OF1dLCBbJ2RyYmthcm93JywgWzEwNTEyXV0sIFsnZHJjb3JuJywgWzg5OTFdXSwgWydkcmNyb3AnLCBbODk3Ml1dLCBbJ0RzY3InLCBbMTE5OTY3XV0sIFsnZHNjcicsIFsxMTk5OTNdXSwgWydEU2N5JywgWzEwMjldXSwgWydkc2N5JywgWzExMDldXSwgWydkc29sJywgWzEwNzQyXV0sIFsnRHN0cm9rJywgWzI3Ml1dLCBbJ2RzdHJvaycsIFsyNzNdXSwgWydkdGRvdCcsIFs4OTQ1XV0sIFsnZHRyaScsIFs5NjYzXV0sIFsnZHRyaWYnLCBbOTY2Ml1dLCBbJ2R1YXJyJywgWzg2OTNdXSwgWydkdWhhcicsIFsxMDYwN11dLCBbJ2R3YW5nbGUnLCBbMTA2NjJdXSwgWydEWmN5JywgWzEwMzldXSwgWydkemN5JywgWzExMTldXSwgWydkemlncmFycicsIFsxMDIzOV1dLCBbJ0VhY3V0ZScsIFsyMDFdXSwgWydlYWN1dGUnLCBbMjMzXV0sIFsnZWFzdGVyJywgWzEwODYyXV0sIFsnRWNhcm9uJywgWzI4Ml1dLCBbJ2VjYXJvbicsIFsyODNdXSwgWydFY2lyYycsIFsyMDJdXSwgWydlY2lyYycsIFsyMzRdXSwgWydlY2lyJywgWzg3OTBdXSwgWydlY29sb24nLCBbODc4OV1dLCBbJ0VjeScsIFsxMDY5XV0sIFsnZWN5JywgWzExMDFdXSwgWydlRERvdCcsIFsxMDg3MV1dLCBbJ0Vkb3QnLCBbMjc4XV0sIFsnZWRvdCcsIFsyNzldXSwgWydlRG90JywgWzg3ODVdXSwgWydlZScsIFs4NTE5XV0sIFsnZWZEb3QnLCBbODc4Nl1dLCBbJ0VmcicsIFsxMjAwNzJdXSwgWydlZnInLCBbMTIwMDk4XV0sIFsnZWcnLCBbMTA5MDZdXSwgWydFZ3JhdmUnLCBbMjAwXV0sIFsnZWdyYXZlJywgWzIzMl1dLCBbJ2VncycsIFsxMDkwMl1dLCBbJ2Vnc2RvdCcsIFsxMDkwNF1dLCBbJ2VsJywgWzEwOTA1XV0sIFsnRWxlbWVudCcsIFs4NzEyXV0sIFsnZWxpbnRlcnMnLCBbOTE5MV1dLCBbJ2VsbCcsIFs4NDY3XV0sIFsnZWxzJywgWzEwOTAxXV0sIFsnZWxzZG90JywgWzEwOTAzXV0sIFsnRW1hY3InLCBbMjc0XV0sIFsnZW1hY3InLCBbMjc1XV0sIFsnZW1wdHknLCBbODcwOV1dLCBbJ2VtcHR5c2V0JywgWzg3MDldXSwgWydFbXB0eVNtYWxsU3F1YXJlJywgWzk3MjNdXSwgWydlbXB0eXYnLCBbODcwOV1dLCBbJ0VtcHR5VmVyeVNtYWxsU3F1YXJlJywgWzk2NDNdXSwgWydlbXNwMTMnLCBbODE5Nl1dLCBbJ2Vtc3AxNCcsIFs4MTk3XV0sIFsnZW1zcCcsIFs4MTk1XV0sIFsnRU5HJywgWzMzMF1dLCBbJ2VuZycsIFszMzFdXSwgWydlbnNwJywgWzgxOTRdXSwgWydFb2dvbicsIFsyODBdXSwgWydlb2dvbicsIFsyODFdXSwgWydFb3BmJywgWzEyMDEyNF1dLCBbJ2VvcGYnLCBbMTIwMTUwXV0sIFsnZXBhcicsIFs4OTE3XV0sIFsnZXBhcnNsJywgWzEwNzIzXV0sIFsnZXBsdXMnLCBbMTA4NjVdXSwgWydlcHNpJywgWzk0OV1dLCBbJ0Vwc2lsb24nLCBbOTE3XV0sIFsnZXBzaWxvbicsIFs5NDldXSwgWydlcHNpdicsIFsxMDEzXV0sIFsnZXFjaXJjJywgWzg3OTBdXSwgWydlcWNvbG9uJywgWzg3ODldXSwgWydlcXNpbScsIFs4NzcwXV0sIFsnZXFzbGFudGd0cicsIFsxMDkwMl1dLCBbJ2Vxc2xhbnRsZXNzJywgWzEwOTAxXV0sIFsnRXF1YWwnLCBbMTA4NjldXSwgWydlcXVhbHMnLCBbNjFdXSwgWydFcXVhbFRpbGRlJywgWzg3NzBdXSwgWydlcXVlc3QnLCBbODc5OV1dLCBbJ0VxdWlsaWJyaXVtJywgWzg2NTJdXSwgWydlcXVpdicsIFs4ODAxXV0sIFsnZXF1aXZERCcsIFsxMDg3Ml1dLCBbJ2VxdnBhcnNsJywgWzEwNzI1XV0sIFsnZXJhcnInLCBbMTA2MDldXSwgWydlckRvdCcsIFs4Nzg3XV0sIFsnZXNjcicsIFs4NDk1XV0sIFsnRXNjcicsIFs4NDk2XV0sIFsnZXNkb3QnLCBbODc4NF1dLCBbJ0VzaW0nLCBbMTA4NjddXSwgWydlc2ltJywgWzg3NzBdXSwgWydFdGEnLCBbOTE5XV0sIFsnZXRhJywgWzk1MV1dLCBbJ0VUSCcsIFsyMDhdXSwgWydldGgnLCBbMjQwXV0sIFsnRXVtbCcsIFsyMDNdXSwgWydldW1sJywgWzIzNV1dLCBbJ2V1cm8nLCBbODM2NF1dLCBbJ2V4Y2wnLCBbMzNdXSwgWydleGlzdCcsIFs4NzA3XV0sIFsnRXhpc3RzJywgWzg3MDddXSwgWydleHBlY3RhdGlvbicsIFs4NDk2XV0sIFsnZXhwb25lbnRpYWxlJywgWzg1MTldXSwgWydFeHBvbmVudGlhbEUnLCBbODUxOV1dLCBbJ2ZhbGxpbmdkb3RzZXEnLCBbODc4Nl1dLCBbJ0ZjeScsIFsxMDYwXV0sIFsnZmN5JywgWzEwOTJdXSwgWydmZW1hbGUnLCBbOTc5Ml1dLCBbJ2ZmaWxpZycsIFs2NDI1OV1dLCBbJ2ZmbGlnJywgWzY0MjU2XV0sIFsnZmZsbGlnJywgWzY0MjYwXV0sIFsnRmZyJywgWzEyMDA3M11dLCBbJ2ZmcicsIFsxMjAwOTldXSwgWydmaWxpZycsIFs2NDI1N11dLCBbJ0ZpbGxlZFNtYWxsU3F1YXJlJywgWzk3MjRdXSwgWydGaWxsZWRWZXJ5U21hbGxTcXVhcmUnLCBbOTY0Ml1dLCBbJ2ZqbGlnJywgWzEwMiwgMTA2XV0sIFsnZmxhdCcsIFs5ODM3XV0sIFsnZmxsaWcnLCBbNjQyNThdXSwgWydmbHRucycsIFs5NjQ5XV0sIFsnZm5vZicsIFs0MDJdXSwgWydGb3BmJywgWzEyMDEyNV1dLCBbJ2ZvcGYnLCBbMTIwMTUxXV0sIFsnZm9yYWxsJywgWzg3MDRdXSwgWydGb3JBbGwnLCBbODcwNF1dLCBbJ2ZvcmsnLCBbODkxNl1dLCBbJ2Zvcmt2JywgWzEwOTY5XV0sIFsnRm91cmllcnRyZicsIFs4NDk3XV0sIFsnZnBhcnRpbnQnLCBbMTA3NjVdXSwgWydmcmFjMTInLCBbMTg5XV0sIFsnZnJhYzEzJywgWzg1MzFdXSwgWydmcmFjMTQnLCBbMTg4XV0sIFsnZnJhYzE1JywgWzg1MzNdXSwgWydmcmFjMTYnLCBbODUzN11dLCBbJ2ZyYWMxOCcsIFs4NTM5XV0sIFsnZnJhYzIzJywgWzg1MzJdXSwgWydmcmFjMjUnLCBbODUzNF1dLCBbJ2ZyYWMzNCcsIFsxOTBdXSwgWydmcmFjMzUnLCBbODUzNV1dLCBbJ2ZyYWMzOCcsIFs4NTQwXV0sIFsnZnJhYzQ1JywgWzg1MzZdXSwgWydmcmFjNTYnLCBbODUzOF1dLCBbJ2ZyYWM1OCcsIFs4NTQxXV0sIFsnZnJhYzc4JywgWzg1NDJdXSwgWydmcmFzbCcsIFs4MjYwXV0sIFsnZnJvd24nLCBbODk5NF1dLCBbJ2ZzY3InLCBbMTE5OTk1XV0sIFsnRnNjcicsIFs4NDk3XV0sIFsnZ2FjdXRlJywgWzUwMV1dLCBbJ0dhbW1hJywgWzkxNV1dLCBbJ2dhbW1hJywgWzk0N11dLCBbJ0dhbW1hZCcsIFs5ODhdXSwgWydnYW1tYWQnLCBbOTg5XV0sIFsnZ2FwJywgWzEwODg2XV0sIFsnR2JyZXZlJywgWzI4Nl1dLCBbJ2dicmV2ZScsIFsyODddXSwgWydHY2VkaWwnLCBbMjkwXV0sIFsnR2NpcmMnLCBbMjg0XV0sIFsnZ2NpcmMnLCBbMjg1XV0sIFsnR2N5JywgWzEwNDNdXSwgWydnY3knLCBbMTA3NV1dLCBbJ0dkb3QnLCBbMjg4XV0sIFsnZ2RvdCcsIFsyODldXSwgWydnZScsIFs4ODA1XV0sIFsnZ0UnLCBbODgwN11dLCBbJ2dFbCcsIFsxMDg5Ml1dLCBbJ2dlbCcsIFs4OTIzXV0sIFsnZ2VxJywgWzg4MDVdXSwgWydnZXFxJywgWzg4MDddXSwgWydnZXFzbGFudCcsIFsxMDg3OF1dLCBbJ2dlc2NjJywgWzEwOTIxXV0sIFsnZ2VzJywgWzEwODc4XV0sIFsnZ2VzZG90JywgWzEwODgwXV0sIFsnZ2VzZG90bycsIFsxMDg4Ml1dLCBbJ2dlc2RvdG9sJywgWzEwODg0XV0sIFsnZ2VzbCcsIFs4OTIzLCA2NTAyNF1dLCBbJ2dlc2xlcycsIFsxMDkwMF1dLCBbJ0dmcicsIFsxMjAwNzRdXSwgWydnZnInLCBbMTIwMTAwXV0sIFsnZ2cnLCBbODgxMV1dLCBbJ0dnJywgWzg5MjFdXSwgWydnZ2cnLCBbODkyMV1dLCBbJ2dpbWVsJywgWzg1MDNdXSwgWydHSmN5JywgWzEwMjddXSwgWydnamN5JywgWzExMDddXSwgWydnbGEnLCBbMTA5MTddXSwgWydnbCcsIFs4ODIzXV0sIFsnZ2xFJywgWzEwODk4XV0sIFsnZ2xqJywgWzEwOTE2XV0sIFsnZ25hcCcsIFsxMDg5MF1dLCBbJ2duYXBwcm94JywgWzEwODkwXV0sIFsnZ25lJywgWzEwODg4XV0sIFsnZ25FJywgWzg4MDldXSwgWydnbmVxJywgWzEwODg4XV0sIFsnZ25lcXEnLCBbODgwOV1dLCBbJ2duc2ltJywgWzg5MzVdXSwgWydHb3BmJywgWzEyMDEyNl1dLCBbJ2dvcGYnLCBbMTIwMTUyXV0sIFsnZ3JhdmUnLCBbOTZdXSwgWydHcmVhdGVyRXF1YWwnLCBbODgwNV1dLCBbJ0dyZWF0ZXJFcXVhbExlc3MnLCBbODkyM11dLCBbJ0dyZWF0ZXJGdWxsRXF1YWwnLCBbODgwN11dLCBbJ0dyZWF0ZXJHcmVhdGVyJywgWzEwOTE0XV0sIFsnR3JlYXRlckxlc3MnLCBbODgyM11dLCBbJ0dyZWF0ZXJTbGFudEVxdWFsJywgWzEwODc4XV0sIFsnR3JlYXRlclRpbGRlJywgWzg4MTldXSwgWydHc2NyJywgWzExOTk3MF1dLCBbJ2dzY3InLCBbODQ1OF1dLCBbJ2dzaW0nLCBbODgxOV1dLCBbJ2dzaW1lJywgWzEwODk0XV0sIFsnZ3NpbWwnLCBbMTA4OTZdXSwgWydndGNjJywgWzEwOTE5XV0sIFsnZ3RjaXInLCBbMTA4NzRdXSwgWydndCcsIFs2Ml1dLCBbJ0dUJywgWzYyXV0sIFsnR3QnLCBbODgxMV1dLCBbJ2d0ZG90JywgWzg5MTldXSwgWydndGxQYXInLCBbMTA2NDVdXSwgWydndHF1ZXN0JywgWzEwODc2XV0sIFsnZ3RyYXBwcm94JywgWzEwODg2XV0sIFsnZ3RyYXJyJywgWzEwNjE2XV0sIFsnZ3RyZG90JywgWzg5MTldXSwgWydndHJlcWxlc3MnLCBbODkyM11dLCBbJ2d0cmVxcWxlc3MnLCBbMTA4OTJdXSwgWydndHJsZXNzJywgWzg4MjNdXSwgWydndHJzaW0nLCBbODgxOV1dLCBbJ2d2ZXJ0bmVxcScsIFs4ODA5LCA2NTAyNF1dLCBbJ2d2bkUnLCBbODgwOSwgNjUwMjRdXSwgWydIYWNlaycsIFs3MTFdXSwgWydoYWlyc3AnLCBbODIwMl1dLCBbJ2hhbGYnLCBbMTg5XV0sIFsnaGFtaWx0JywgWzg0NTldXSwgWydIQVJEY3knLCBbMTA2Nl1dLCBbJ2hhcmRjeScsIFsxMDk4XV0sIFsnaGFycmNpcicsIFsxMDU2OF1dLCBbJ2hhcnInLCBbODU5Nl1dLCBbJ2hBcnInLCBbODY2MF1dLCBbJ2hhcnJ3JywgWzg2MjFdXSwgWydIYXQnLCBbOTRdXSwgWydoYmFyJywgWzg0NjNdXSwgWydIY2lyYycsIFsyOTJdXSwgWydoY2lyYycsIFsyOTNdXSwgWydoZWFydHMnLCBbOTgyOV1dLCBbJ2hlYXJ0c3VpdCcsIFs5ODI5XV0sIFsnaGVsbGlwJywgWzgyMzBdXSwgWydoZXJjb24nLCBbODg4OV1dLCBbJ2hmcicsIFsxMjAxMDFdXSwgWydIZnInLCBbODQ2MF1dLCBbJ0hpbGJlcnRTcGFjZScsIFs4NDU5XV0sIFsnaGtzZWFyb3cnLCBbMTA1MzNdXSwgWydoa3N3YXJvdycsIFsxMDUzNF1dLCBbJ2hvYXJyJywgWzg3MDNdXSwgWydob210aHQnLCBbODc2M11dLCBbJ2hvb2tsZWZ0YXJyb3cnLCBbODYxN11dLCBbJ2hvb2tyaWdodGFycm93JywgWzg2MThdXSwgWydob3BmJywgWzEyMDE1M11dLCBbJ0hvcGYnLCBbODQ2MV1dLCBbJ2hvcmJhcicsIFs4MjEzXV0sIFsnSG9yaXpvbnRhbExpbmUnLCBbOTQ3Ml1dLCBbJ2hzY3InLCBbMTE5OTk3XV0sIFsnSHNjcicsIFs4NDU5XV0sIFsnaHNsYXNoJywgWzg0NjNdXSwgWydIc3Ryb2snLCBbMjk0XV0sIFsnaHN0cm9rJywgWzI5NV1dLCBbJ0h1bXBEb3duSHVtcCcsIFs4NzgyXV0sIFsnSHVtcEVxdWFsJywgWzg3ODNdXSwgWydoeWJ1bGwnLCBbODI1OV1dLCBbJ2h5cGhlbicsIFs4MjA4XV0sIFsnSWFjdXRlJywgWzIwNV1dLCBbJ2lhY3V0ZScsIFsyMzddXSwgWydpYycsIFs4MjkxXV0sIFsnSWNpcmMnLCBbMjA2XV0sIFsnaWNpcmMnLCBbMjM4XV0sIFsnSWN5JywgWzEwNDhdXSwgWydpY3knLCBbMTA4MF1dLCBbJ0lkb3QnLCBbMzA0XV0sIFsnSUVjeScsIFsxMDQ1XV0sIFsnaWVjeScsIFsxMDc3XV0sIFsnaWV4Y2wnLCBbMTYxXV0sIFsnaWZmJywgWzg2NjBdXSwgWydpZnInLCBbMTIwMTAyXV0sIFsnSWZyJywgWzg0NjVdXSwgWydJZ3JhdmUnLCBbMjA0XV0sIFsnaWdyYXZlJywgWzIzNl1dLCBbJ2lpJywgWzg1MjBdXSwgWydpaWlpbnQnLCBbMTA3NjRdXSwgWydpaWludCcsIFs4NzQ5XV0sIFsnaWluZmluJywgWzEwNzE2XV0sIFsnaWlvdGEnLCBbODQ4OV1dLCBbJ0lKbGlnJywgWzMwNl1dLCBbJ2lqbGlnJywgWzMwN11dLCBbJ0ltYWNyJywgWzI5OF1dLCBbJ2ltYWNyJywgWzI5OV1dLCBbJ2ltYWdlJywgWzg0NjVdXSwgWydJbWFnaW5hcnlJJywgWzg1MjBdXSwgWydpbWFnbGluZScsIFs4NDY0XV0sIFsnaW1hZ3BhcnQnLCBbODQ2NV1dLCBbJ2ltYXRoJywgWzMwNV1dLCBbJ0ltJywgWzg0NjVdXSwgWydpbW9mJywgWzg4ODddXSwgWydpbXBlZCcsIFs0MzddXSwgWydJbXBsaWVzJywgWzg2NThdXSwgWydpbmNhcmUnLCBbODQ1M11dLCBbJ2luJywgWzg3MTJdXSwgWydpbmZpbicsIFs4NzM0XV0sIFsnaW5maW50aWUnLCBbMTA3MTddXSwgWydpbm9kb3QnLCBbMzA1XV0sIFsnaW50Y2FsJywgWzg4OTBdXSwgWydpbnQnLCBbODc0N11dLCBbJ0ludCcsIFs4NzQ4XV0sIFsnaW50ZWdlcnMnLCBbODQ4NF1dLCBbJ0ludGVncmFsJywgWzg3NDddXSwgWydpbnRlcmNhbCcsIFs4ODkwXV0sIFsnSW50ZXJzZWN0aW9uJywgWzg4OThdXSwgWydpbnRsYXJoaycsIFsxMDc3NV1dLCBbJ2ludHByb2QnLCBbMTA4MTJdXSwgWydJbnZpc2libGVDb21tYScsIFs4MjkxXV0sIFsnSW52aXNpYmxlVGltZXMnLCBbODI5MF1dLCBbJ0lPY3knLCBbMTAyNV1dLCBbJ2lvY3knLCBbMTEwNV1dLCBbJ0lvZ29uJywgWzMwMl1dLCBbJ2lvZ29uJywgWzMwM11dLCBbJ0lvcGYnLCBbMTIwMTI4XV0sIFsnaW9wZicsIFsxMjAxNTRdXSwgWydJb3RhJywgWzkyMV1dLCBbJ2lvdGEnLCBbOTUzXV0sIFsnaXByb2QnLCBbMTA4MTJdXSwgWydpcXVlc3QnLCBbMTkxXV0sIFsnaXNjcicsIFsxMTk5OThdXSwgWydJc2NyJywgWzg0NjRdXSwgWydpc2luJywgWzg3MTJdXSwgWydpc2luZG90JywgWzg5NDldXSwgWydpc2luRScsIFs4OTUzXV0sIFsnaXNpbnMnLCBbODk0OF1dLCBbJ2lzaW5zdicsIFs4OTQ3XV0sIFsnaXNpbnYnLCBbODcxMl1dLCBbJ2l0JywgWzgyOTBdXSwgWydJdGlsZGUnLCBbMjk2XV0sIFsnaXRpbGRlJywgWzI5N11dLCBbJ0l1a2N5JywgWzEwMzBdXSwgWydpdWtjeScsIFsxMTEwXV0sIFsnSXVtbCcsIFsyMDddXSwgWydpdW1sJywgWzIzOV1dLCBbJ0pjaXJjJywgWzMwOF1dLCBbJ2pjaXJjJywgWzMwOV1dLCBbJ0pjeScsIFsxMDQ5XV0sIFsnamN5JywgWzEwODFdXSwgWydKZnInLCBbMTIwMDc3XV0sIFsnamZyJywgWzEyMDEwM11dLCBbJ2ptYXRoJywgWzU2N11dLCBbJ0pvcGYnLCBbMTIwMTI5XV0sIFsnam9wZicsIFsxMjAxNTVdXSwgWydKc2NyJywgWzExOTk3M11dLCBbJ2pzY3InLCBbMTE5OTk5XV0sIFsnSnNlcmN5JywgWzEwMzJdXSwgWydqc2VyY3knLCBbMTExMl1dLCBbJ0p1a2N5JywgWzEwMjhdXSwgWydqdWtjeScsIFsxMTA4XV0sIFsnS2FwcGEnLCBbOTIyXV0sIFsna2FwcGEnLCBbOTU0XV0sIFsna2FwcGF2JywgWzEwMDhdXSwgWydLY2VkaWwnLCBbMzEwXV0sIFsna2NlZGlsJywgWzMxMV1dLCBbJ0tjeScsIFsxMDUwXV0sIFsna2N5JywgWzEwODJdXSwgWydLZnInLCBbMTIwMDc4XV0sIFsna2ZyJywgWzEyMDEwNF1dLCBbJ2tncmVlbicsIFszMTJdXSwgWydLSGN5JywgWzEwNjFdXSwgWydraGN5JywgWzEwOTNdXSwgWydLSmN5JywgWzEwMzZdXSwgWydramN5JywgWzExMTZdXSwgWydLb3BmJywgWzEyMDEzMF1dLCBbJ2tvcGYnLCBbMTIwMTU2XV0sIFsnS3NjcicsIFsxMTk5NzRdXSwgWydrc2NyJywgWzEyMDAwMF1dLCBbJ2xBYXJyJywgWzg2NjZdXSwgWydMYWN1dGUnLCBbMzEzXV0sIFsnbGFjdXRlJywgWzMxNF1dLCBbJ2xhZW1wdHl2JywgWzEwNjc2XV0sIFsnbGFncmFuJywgWzg0NjZdXSwgWydMYW1iZGEnLCBbOTIzXV0sIFsnbGFtYmRhJywgWzk1NV1dLCBbJ2xhbmcnLCBbMTAyMTZdXSwgWydMYW5nJywgWzEwMjE4XV0sIFsnbGFuZ2QnLCBbMTA2NDFdXSwgWydsYW5nbGUnLCBbMTAyMTZdXSwgWydsYXAnLCBbMTA4ODVdXSwgWydMYXBsYWNldHJmJywgWzg0NjZdXSwgWydsYXF1bycsIFsxNzFdXSwgWydsYXJyYicsIFs4Njc2XV0sIFsnbGFycmJmcycsIFsxMDUyN11dLCBbJ2xhcnInLCBbODU5Ml1dLCBbJ0xhcnInLCBbODYwNl1dLCBbJ2xBcnInLCBbODY1Nl1dLCBbJ2xhcnJmcycsIFsxMDUyNV1dLCBbJ2xhcnJoaycsIFs4NjE3XV0sIFsnbGFycmxwJywgWzg2MTldXSwgWydsYXJycGwnLCBbMTA1NTNdXSwgWydsYXJyc2ltJywgWzEwNjExXV0sIFsnbGFycnRsJywgWzg2MTBdXSwgWydsYXRhaWwnLCBbMTA1MjFdXSwgWydsQXRhaWwnLCBbMTA1MjNdXSwgWydsYXQnLCBbMTA5MjNdXSwgWydsYXRlJywgWzEwOTI1XV0sIFsnbGF0ZXMnLCBbMTA5MjUsIDY1MDI0XV0sIFsnbGJhcnInLCBbMTA1MDhdXSwgWydsQmFycicsIFsxMDUxMF1dLCBbJ2xiYnJrJywgWzEwMDk4XV0sIFsnbGJyYWNlJywgWzEyM11dLCBbJ2xicmFjaycsIFs5MV1dLCBbJ2xicmtlJywgWzEwNjM1XV0sIFsnbGJya3NsZCcsIFsxMDYzOV1dLCBbJ2xicmtzbHUnLCBbMTA2MzddXSwgWydMY2Fyb24nLCBbMzE3XV0sIFsnbGNhcm9uJywgWzMxOF1dLCBbJ0xjZWRpbCcsIFszMTVdXSwgWydsY2VkaWwnLCBbMzE2XV0sIFsnbGNlaWwnLCBbODk2OF1dLCBbJ2xjdWInLCBbMTIzXV0sIFsnTGN5JywgWzEwNTFdXSwgWydsY3knLCBbMTA4M11dLCBbJ2xkY2EnLCBbMTA1NTBdXSwgWydsZHF1bycsIFs4MjIwXV0sIFsnbGRxdW9yJywgWzgyMjJdXSwgWydsZHJkaGFyJywgWzEwNTk5XV0sIFsnbGRydXNoYXInLCBbMTA1NzFdXSwgWydsZHNoJywgWzg2MjZdXSwgWydsZScsIFs4ODA0XV0sIFsnbEUnLCBbODgwNl1dLCBbJ0xlZnRBbmdsZUJyYWNrZXQnLCBbMTAyMTZdXSwgWydMZWZ0QXJyb3dCYXInLCBbODY3Nl1dLCBbJ2xlZnRhcnJvdycsIFs4NTkyXV0sIFsnTGVmdEFycm93JywgWzg1OTJdXSwgWydMZWZ0YXJyb3cnLCBbODY1Nl1dLCBbJ0xlZnRBcnJvd1JpZ2h0QXJyb3cnLCBbODY0Nl1dLCBbJ2xlZnRhcnJvd3RhaWwnLCBbODYxMF1dLCBbJ0xlZnRDZWlsaW5nJywgWzg5NjhdXSwgWydMZWZ0RG91YmxlQnJhY2tldCcsIFsxMDIxNF1dLCBbJ0xlZnREb3duVGVlVmVjdG9yJywgWzEwNTkzXV0sIFsnTGVmdERvd25WZWN0b3JCYXInLCBbMTA1ODVdXSwgWydMZWZ0RG93blZlY3RvcicsIFs4NjQzXV0sIFsnTGVmdEZsb29yJywgWzg5NzBdXSwgWydsZWZ0aGFycG9vbmRvd24nLCBbODYzN11dLCBbJ2xlZnRoYXJwb29udXAnLCBbODYzNl1dLCBbJ2xlZnRsZWZ0YXJyb3dzJywgWzg2NDddXSwgWydsZWZ0cmlnaHRhcnJvdycsIFs4NTk2XV0sIFsnTGVmdFJpZ2h0QXJyb3cnLCBbODU5Nl1dLCBbJ0xlZnRyaWdodGFycm93JywgWzg2NjBdXSwgWydsZWZ0cmlnaHRhcnJvd3MnLCBbODY0Nl1dLCBbJ2xlZnRyaWdodGhhcnBvb25zJywgWzg2NTFdXSwgWydsZWZ0cmlnaHRzcXVpZ2Fycm93JywgWzg2MjFdXSwgWydMZWZ0UmlnaHRWZWN0b3InLCBbMTA1NzRdXSwgWydMZWZ0VGVlQXJyb3cnLCBbODYxMl1dLCBbJ0xlZnRUZWUnLCBbODg2N11dLCBbJ0xlZnRUZWVWZWN0b3InLCBbMTA1ODZdXSwgWydsZWZ0dGhyZWV0aW1lcycsIFs4OTA3XV0sIFsnTGVmdFRyaWFuZ2xlQmFyJywgWzEwNzAzXV0sIFsnTGVmdFRyaWFuZ2xlJywgWzg4ODJdXSwgWydMZWZ0VHJpYW5nbGVFcXVhbCcsIFs4ODg0XV0sIFsnTGVmdFVwRG93blZlY3RvcicsIFsxMDU3N11dLCBbJ0xlZnRVcFRlZVZlY3RvcicsIFsxMDU5Ml1dLCBbJ0xlZnRVcFZlY3RvckJhcicsIFsxMDU4NF1dLCBbJ0xlZnRVcFZlY3RvcicsIFs4NjM5XV0sIFsnTGVmdFZlY3RvckJhcicsIFsxMDU3OF1dLCBbJ0xlZnRWZWN0b3InLCBbODYzNl1dLCBbJ2xFZycsIFsxMDg5MV1dLCBbJ2xlZycsIFs4OTIyXV0sIFsnbGVxJywgWzg4MDRdXSwgWydsZXFxJywgWzg4MDZdXSwgWydsZXFzbGFudCcsIFsxMDg3N11dLCBbJ2xlc2NjJywgWzEwOTIwXV0sIFsnbGVzJywgWzEwODc3XV0sIFsnbGVzZG90JywgWzEwODc5XV0sIFsnbGVzZG90bycsIFsxMDg4MV1dLCBbJ2xlc2RvdG9yJywgWzEwODgzXV0sIFsnbGVzZycsIFs4OTIyLCA2NTAyNF1dLCBbJ2xlc2dlcycsIFsxMDg5OV1dLCBbJ2xlc3NhcHByb3gnLCBbMTA4ODVdXSwgWydsZXNzZG90JywgWzg5MThdXSwgWydsZXNzZXFndHInLCBbODkyMl1dLCBbJ2xlc3NlcXFndHInLCBbMTA4OTFdXSwgWydMZXNzRXF1YWxHcmVhdGVyJywgWzg5MjJdXSwgWydMZXNzRnVsbEVxdWFsJywgWzg4MDZdXSwgWydMZXNzR3JlYXRlcicsIFs4ODIyXV0sIFsnbGVzc2d0cicsIFs4ODIyXV0sIFsnTGVzc0xlc3MnLCBbMTA5MTNdXSwgWydsZXNzc2ltJywgWzg4MThdXSwgWydMZXNzU2xhbnRFcXVhbCcsIFsxMDg3N11dLCBbJ0xlc3NUaWxkZScsIFs4ODE4XV0sIFsnbGZpc2h0JywgWzEwNjIwXV0sIFsnbGZsb29yJywgWzg5NzBdXSwgWydMZnInLCBbMTIwMDc5XV0sIFsnbGZyJywgWzEyMDEwNV1dLCBbJ2xnJywgWzg4MjJdXSwgWydsZ0UnLCBbMTA4OTddXSwgWydsSGFyJywgWzEwNTk0XV0sIFsnbGhhcmQnLCBbODYzN11dLCBbJ2xoYXJ1JywgWzg2MzZdXSwgWydsaGFydWwnLCBbMTA2MDJdXSwgWydsaGJsaycsIFs5NjA0XV0sIFsnTEpjeScsIFsxMDMzXV0sIFsnbGpjeScsIFsxMTEzXV0sIFsnbGxhcnInLCBbODY0N11dLCBbJ2xsJywgWzg4MTBdXSwgWydMbCcsIFs4OTIwXV0sIFsnbGxjb3JuZXInLCBbODk5MF1dLCBbJ0xsZWZ0YXJyb3cnLCBbODY2Nl1dLCBbJ2xsaGFyZCcsIFsxMDYwM11dLCBbJ2xsdHJpJywgWzk3MjJdXSwgWydMbWlkb3QnLCBbMzE5XV0sIFsnbG1pZG90JywgWzMyMF1dLCBbJ2xtb3VzdGFjaGUnLCBbOTEzNl1dLCBbJ2xtb3VzdCcsIFs5MTM2XV0sIFsnbG5hcCcsIFsxMDg4OV1dLCBbJ2xuYXBwcm94JywgWzEwODg5XV0sIFsnbG5lJywgWzEwODg3XV0sIFsnbG5FJywgWzg4MDhdXSwgWydsbmVxJywgWzEwODg3XV0sIFsnbG5lcXEnLCBbODgwOF1dLCBbJ2xuc2ltJywgWzg5MzRdXSwgWydsb2FuZycsIFsxMDIyMF1dLCBbJ2xvYXJyJywgWzg3MDFdXSwgWydsb2JyaycsIFsxMDIxNF1dLCBbJ2xvbmdsZWZ0YXJyb3cnLCBbMTAyMjldXSwgWydMb25nTGVmdEFycm93JywgWzEwMjI5XV0sIFsnTG9uZ2xlZnRhcnJvdycsIFsxMDIzMl1dLCBbJ2xvbmdsZWZ0cmlnaHRhcnJvdycsIFsxMDIzMV1dLCBbJ0xvbmdMZWZ0UmlnaHRBcnJvdycsIFsxMDIzMV1dLCBbJ0xvbmdsZWZ0cmlnaHRhcnJvdycsIFsxMDIzNF1dLCBbJ2xvbmdtYXBzdG8nLCBbMTAyMzZdXSwgWydsb25ncmlnaHRhcnJvdycsIFsxMDIzMF1dLCBbJ0xvbmdSaWdodEFycm93JywgWzEwMjMwXV0sIFsnTG9uZ3JpZ2h0YXJyb3cnLCBbMTAyMzNdXSwgWydsb29wYXJyb3dsZWZ0JywgWzg2MTldXSwgWydsb29wYXJyb3dyaWdodCcsIFs4NjIwXV0sIFsnbG9wYXInLCBbMTA2MjldXSwgWydMb3BmJywgWzEyMDEzMV1dLCBbJ2xvcGYnLCBbMTIwMTU3XV0sIFsnbG9wbHVzJywgWzEwNzk3XV0sIFsnbG90aW1lcycsIFsxMDgwNF1dLCBbJ2xvd2FzdCcsIFs4NzI3XV0sIFsnbG93YmFyJywgWzk1XV0sIFsnTG93ZXJMZWZ0QXJyb3cnLCBbODYwMV1dLCBbJ0xvd2VyUmlnaHRBcnJvdycsIFs4NjAwXV0sIFsnbG96JywgWzk2NzRdXSwgWydsb3plbmdlJywgWzk2NzRdXSwgWydsb3pmJywgWzEwNzMxXV0sIFsnbHBhcicsIFs0MF1dLCBbJ2xwYXJsdCcsIFsxMDY0M11dLCBbJ2xyYXJyJywgWzg2NDZdXSwgWydscmNvcm5lcicsIFs4OTkxXV0sIFsnbHJoYXInLCBbODY1MV1dLCBbJ2xyaGFyZCcsIFsxMDYwNV1dLCBbJ2xybScsIFs4MjA2XV0sIFsnbHJ0cmknLCBbODg5NV1dLCBbJ2xzYXF1bycsIFs4MjQ5XV0sIFsnbHNjcicsIFsxMjAwMDFdXSwgWydMc2NyJywgWzg0NjZdXSwgWydsc2gnLCBbODYyNF1dLCBbJ0xzaCcsIFs4NjI0XV0sIFsnbHNpbScsIFs4ODE4XV0sIFsnbHNpbWUnLCBbMTA4OTNdXSwgWydsc2ltZycsIFsxMDg5NV1dLCBbJ2xzcWInLCBbOTFdXSwgWydsc3F1bycsIFs4MjE2XV0sIFsnbHNxdW9yJywgWzgyMThdXSwgWydMc3Ryb2snLCBbMzIxXV0sIFsnbHN0cm9rJywgWzMyMl1dLCBbJ2x0Y2MnLCBbMTA5MThdXSwgWydsdGNpcicsIFsxMDg3M11dLCBbJ2x0JywgWzYwXV0sIFsnTFQnLCBbNjBdXSwgWydMdCcsIFs4ODEwXV0sIFsnbHRkb3QnLCBbODkxOF1dLCBbJ2x0aHJlZScsIFs4OTA3XV0sIFsnbHRpbWVzJywgWzg5MDVdXSwgWydsdGxhcnInLCBbMTA2MTRdXSwgWydsdHF1ZXN0JywgWzEwODc1XV0sIFsnbHRyaScsIFs5NjY3XV0sIFsnbHRyaWUnLCBbODg4NF1dLCBbJ2x0cmlmJywgWzk2NjZdXSwgWydsdHJQYXInLCBbMTA2NDZdXSwgWydsdXJkc2hhcicsIFsxMDU3MF1dLCBbJ2x1cnVoYXInLCBbMTA1OThdXSwgWydsdmVydG5lcXEnLCBbODgwOCwgNjUwMjRdXSwgWydsdm5FJywgWzg4MDgsIDY1MDI0XV0sIFsnbWFjcicsIFsxNzVdXSwgWydtYWxlJywgWzk3OTRdXSwgWydtYWx0JywgWzEwMDE2XV0sIFsnbWFsdGVzZScsIFsxMDAxNl1dLCBbJ01hcCcsIFsxMDUwMV1dLCBbJ21hcCcsIFs4NjE0XV0sIFsnbWFwc3RvJywgWzg2MTRdXSwgWydtYXBzdG9kb3duJywgWzg2MTVdXSwgWydtYXBzdG9sZWZ0JywgWzg2MTJdXSwgWydtYXBzdG91cCcsIFs4NjEzXV0sIFsnbWFya2VyJywgWzk2NDZdXSwgWydtY29tbWEnLCBbMTA3OTNdXSwgWydNY3knLCBbMTA1Ml1dLCBbJ21jeScsIFsxMDg0XV0sIFsnbWRhc2gnLCBbODIxMl1dLCBbJ21ERG90JywgWzg3NjJdXSwgWydtZWFzdXJlZGFuZ2xlJywgWzg3MzddXSwgWydNZWRpdW1TcGFjZScsIFs4Mjg3XV0sIFsnTWVsbGludHJmJywgWzg0OTldXSwgWydNZnInLCBbMTIwMDgwXV0sIFsnbWZyJywgWzEyMDEwNl1dLCBbJ21obycsIFs4NDg3XV0sIFsnbWljcm8nLCBbMTgxXV0sIFsnbWlkYXN0JywgWzQyXV0sIFsnbWlkY2lyJywgWzEwOTkyXV0sIFsnbWlkJywgWzg3MzldXSwgWydtaWRkb3QnLCBbMTgzXV0sIFsnbWludXNiJywgWzg4NjNdXSwgWydtaW51cycsIFs4NzIyXV0sIFsnbWludXNkJywgWzg3NjBdXSwgWydtaW51c2R1JywgWzEwNzk0XV0sIFsnTWludXNQbHVzJywgWzg3MjNdXSwgWydtbGNwJywgWzEwOTcxXV0sIFsnbWxkcicsIFs4MjMwXV0sIFsnbW5wbHVzJywgWzg3MjNdXSwgWydtb2RlbHMnLCBbODg3MV1dLCBbJ01vcGYnLCBbMTIwMTMyXV0sIFsnbW9wZicsIFsxMjAxNThdXSwgWydtcCcsIFs4NzIzXV0sIFsnbXNjcicsIFsxMjAwMDJdXSwgWydNc2NyJywgWzg0OTldXSwgWydtc3Rwb3MnLCBbODc2Nl1dLCBbJ011JywgWzkyNF1dLCBbJ211JywgWzk1Nl1dLCBbJ211bHRpbWFwJywgWzg4ODhdXSwgWydtdW1hcCcsIFs4ODg4XV0sIFsnbmFibGEnLCBbODcxMV1dLCBbJ05hY3V0ZScsIFszMjNdXSwgWyduYWN1dGUnLCBbMzI0XV0sIFsnbmFuZycsIFs4NzM2LCA4NDAyXV0sIFsnbmFwJywgWzg3NzddXSwgWyduYXBFJywgWzEwODY0LCA4MjRdXSwgWyduYXBpZCcsIFs4Nzc5LCA4MjRdXSwgWyduYXBvcycsIFszMjldXSwgWyduYXBwcm94JywgWzg3NzddXSwgWyduYXR1cmFsJywgWzk4MzhdXSwgWyduYXR1cmFscycsIFs4NDY5XV0sIFsnbmF0dXInLCBbOTgzOF1dLCBbJ25ic3AnLCBbMTYwXV0sIFsnbmJ1bXAnLCBbODc4MiwgODI0XV0sIFsnbmJ1bXBlJywgWzg3ODMsIDgyNF1dLCBbJ25jYXAnLCBbMTA4MTldXSwgWydOY2Fyb24nLCBbMzI3XV0sIFsnbmNhcm9uJywgWzMyOF1dLCBbJ05jZWRpbCcsIFszMjVdXSwgWyduY2VkaWwnLCBbMzI2XV0sIFsnbmNvbmcnLCBbODc3NV1dLCBbJ25jb25nZG90JywgWzEwODYxLCA4MjRdXSwgWyduY3VwJywgWzEwODE4XV0sIFsnTmN5JywgWzEwNTNdXSwgWyduY3knLCBbMTA4NV1dLCBbJ25kYXNoJywgWzgyMTFdXSwgWyduZWFyaGsnLCBbMTA1MzJdXSwgWyduZWFycicsIFs4NTk5XV0sIFsnbmVBcnInLCBbODY2M11dLCBbJ25lYXJyb3cnLCBbODU5OV1dLCBbJ25lJywgWzg4MDBdXSwgWyduZWRvdCcsIFs4Nzg0LCA4MjRdXSwgWydOZWdhdGl2ZU1lZGl1bVNwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVRoaWNrU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVGhpblNwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVZlcnlUaGluU3BhY2UnLCBbODIwM11dLCBbJ25lcXVpdicsIFs4ODAyXV0sIFsnbmVzZWFyJywgWzEwNTM2XV0sIFsnbmVzaW0nLCBbODc3MCwgODI0XV0sIFsnTmVzdGVkR3JlYXRlckdyZWF0ZXInLCBbODgxMV1dLCBbJ05lc3RlZExlc3NMZXNzJywgWzg4MTBdXSwgWyduZXhpc3QnLCBbODcwOF1dLCBbJ25leGlzdHMnLCBbODcwOF1dLCBbJ05mcicsIFsxMjAwODFdXSwgWyduZnInLCBbMTIwMTA3XV0sIFsnbmdFJywgWzg4MDcsIDgyNF1dLCBbJ25nZScsIFs4ODE3XV0sIFsnbmdlcScsIFs4ODE3XV0sIFsnbmdlcXEnLCBbODgwNywgODI0XV0sIFsnbmdlcXNsYW50JywgWzEwODc4LCA4MjRdXSwgWyduZ2VzJywgWzEwODc4LCA4MjRdXSwgWyduR2cnLCBbODkyMSwgODI0XV0sIFsnbmdzaW0nLCBbODgyMV1dLCBbJ25HdCcsIFs4ODExLCA4NDAyXV0sIFsnbmd0JywgWzg4MTVdXSwgWyduZ3RyJywgWzg4MTVdXSwgWyduR3R2JywgWzg4MTEsIDgyNF1dLCBbJ25oYXJyJywgWzg2MjJdXSwgWyduaEFycicsIFs4NjU0XV0sIFsnbmhwYXInLCBbMTA5OTRdXSwgWyduaScsIFs4NzE1XV0sIFsnbmlzJywgWzg5NTZdXSwgWyduaXNkJywgWzg5NTRdXSwgWyduaXYnLCBbODcxNV1dLCBbJ05KY3knLCBbMTAzNF1dLCBbJ25qY3knLCBbMTExNF1dLCBbJ25sYXJyJywgWzg2MDJdXSwgWydubEFycicsIFs4NjUzXV0sIFsnbmxkcicsIFs4MjI5XV0sIFsnbmxFJywgWzg4MDYsIDgyNF1dLCBbJ25sZScsIFs4ODE2XV0sIFsnbmxlZnRhcnJvdycsIFs4NjAyXV0sIFsnbkxlZnRhcnJvdycsIFs4NjUzXV0sIFsnbmxlZnRyaWdodGFycm93JywgWzg2MjJdXSwgWyduTGVmdHJpZ2h0YXJyb3cnLCBbODY1NF1dLCBbJ25sZXEnLCBbODgxNl1dLCBbJ25sZXFxJywgWzg4MDYsIDgyNF1dLCBbJ25sZXFzbGFudCcsIFsxMDg3NywgODI0XV0sIFsnbmxlcycsIFsxMDg3NywgODI0XV0sIFsnbmxlc3MnLCBbODgxNF1dLCBbJ25MbCcsIFs4OTIwLCA4MjRdXSwgWydubHNpbScsIFs4ODIwXV0sIFsnbkx0JywgWzg4MTAsIDg0MDJdXSwgWydubHQnLCBbODgxNF1dLCBbJ25sdHJpJywgWzg5MzhdXSwgWydubHRyaWUnLCBbODk0MF1dLCBbJ25MdHYnLCBbODgxMCwgODI0XV0sIFsnbm1pZCcsIFs4NzQwXV0sIFsnTm9CcmVhaycsIFs4Mjg4XV0sIFsnTm9uQnJlYWtpbmdTcGFjZScsIFsxNjBdXSwgWydub3BmJywgWzEyMDE1OV1dLCBbJ05vcGYnLCBbODQ2OV1dLCBbJ05vdCcsIFsxMDk4OF1dLCBbJ25vdCcsIFsxNzJdXSwgWydOb3RDb25ncnVlbnQnLCBbODgwMl1dLCBbJ05vdEN1cENhcCcsIFs4ODEzXV0sIFsnTm90RG91YmxlVmVydGljYWxCYXInLCBbODc0Ml1dLCBbJ05vdEVsZW1lbnQnLCBbODcxM11dLCBbJ05vdEVxdWFsJywgWzg4MDBdXSwgWydOb3RFcXVhbFRpbGRlJywgWzg3NzAsIDgyNF1dLCBbJ05vdEV4aXN0cycsIFs4NzA4XV0sIFsnTm90R3JlYXRlcicsIFs4ODE1XV0sIFsnTm90R3JlYXRlckVxdWFsJywgWzg4MTddXSwgWydOb3RHcmVhdGVyRnVsbEVxdWFsJywgWzg4MDcsIDgyNF1dLCBbJ05vdEdyZWF0ZXJHcmVhdGVyJywgWzg4MTEsIDgyNF1dLCBbJ05vdEdyZWF0ZXJMZXNzJywgWzg4MjVdXSwgWydOb3RHcmVhdGVyU2xhbnRFcXVhbCcsIFsxMDg3OCwgODI0XV0sIFsnTm90R3JlYXRlclRpbGRlJywgWzg4MjFdXSwgWydOb3RIdW1wRG93bkh1bXAnLCBbODc4MiwgODI0XV0sIFsnTm90SHVtcEVxdWFsJywgWzg3ODMsIDgyNF1dLCBbJ25vdGluJywgWzg3MTNdXSwgWydub3RpbmRvdCcsIFs4OTQ5LCA4MjRdXSwgWydub3RpbkUnLCBbODk1MywgODI0XV0sIFsnbm90aW52YScsIFs4NzEzXV0sIFsnbm90aW52YicsIFs4OTUxXV0sIFsnbm90aW52YycsIFs4OTUwXV0sIFsnTm90TGVmdFRyaWFuZ2xlQmFyJywgWzEwNzAzLCA4MjRdXSwgWydOb3RMZWZ0VHJpYW5nbGUnLCBbODkzOF1dLCBbJ05vdExlZnRUcmlhbmdsZUVxdWFsJywgWzg5NDBdXSwgWydOb3RMZXNzJywgWzg4MTRdXSwgWydOb3RMZXNzRXF1YWwnLCBbODgxNl1dLCBbJ05vdExlc3NHcmVhdGVyJywgWzg4MjRdXSwgWydOb3RMZXNzTGVzcycsIFs4ODEwLCA4MjRdXSwgWydOb3RMZXNzU2xhbnRFcXVhbCcsIFsxMDg3NywgODI0XV0sIFsnTm90TGVzc1RpbGRlJywgWzg4MjBdXSwgWydOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcicsIFsxMDkxNCwgODI0XV0sIFsnTm90TmVzdGVkTGVzc0xlc3MnLCBbMTA5MTMsIDgyNF1dLCBbJ25vdG5pJywgWzg3MTZdXSwgWydub3RuaXZhJywgWzg3MTZdXSwgWydub3RuaXZiJywgWzg5NThdXSwgWydub3RuaXZjJywgWzg5NTddXSwgWydOb3RQcmVjZWRlcycsIFs4ODMyXV0sIFsnTm90UHJlY2VkZXNFcXVhbCcsIFsxMDkyNywgODI0XV0sIFsnTm90UHJlY2VkZXNTbGFudEVxdWFsJywgWzg5MjhdXSwgWydOb3RSZXZlcnNlRWxlbWVudCcsIFs4NzE2XV0sIFsnTm90UmlnaHRUcmlhbmdsZUJhcicsIFsxMDcwNCwgODI0XV0sIFsnTm90UmlnaHRUcmlhbmdsZScsIFs4OTM5XV0sIFsnTm90UmlnaHRUcmlhbmdsZUVxdWFsJywgWzg5NDFdXSwgWydOb3RTcXVhcmVTdWJzZXQnLCBbODg0NywgODI0XV0sIFsnTm90U3F1YXJlU3Vic2V0RXF1YWwnLCBbODkzMF1dLCBbJ05vdFNxdWFyZVN1cGVyc2V0JywgWzg4NDgsIDgyNF1dLCBbJ05vdFNxdWFyZVN1cGVyc2V0RXF1YWwnLCBbODkzMV1dLCBbJ05vdFN1YnNldCcsIFs4ODM0LCA4NDAyXV0sIFsnTm90U3Vic2V0RXF1YWwnLCBbODg0MF1dLCBbJ05vdFN1Y2NlZWRzJywgWzg4MzNdXSwgWydOb3RTdWNjZWVkc0VxdWFsJywgWzEwOTI4LCA4MjRdXSwgWydOb3RTdWNjZWVkc1NsYW50RXF1YWwnLCBbODkyOV1dLCBbJ05vdFN1Y2NlZWRzVGlsZGUnLCBbODgzMSwgODI0XV0sIFsnTm90U3VwZXJzZXQnLCBbODgzNSwgODQwMl1dLCBbJ05vdFN1cGVyc2V0RXF1YWwnLCBbODg0MV1dLCBbJ05vdFRpbGRlJywgWzg3NjldXSwgWydOb3RUaWxkZUVxdWFsJywgWzg3NzJdXSwgWydOb3RUaWxkZUZ1bGxFcXVhbCcsIFs4Nzc1XV0sIFsnTm90VGlsZGVUaWxkZScsIFs4Nzc3XV0sIFsnTm90VmVydGljYWxCYXInLCBbODc0MF1dLCBbJ25wYXJhbGxlbCcsIFs4NzQyXV0sIFsnbnBhcicsIFs4NzQyXV0sIFsnbnBhcnNsJywgWzExMDA1LCA4NDIxXV0sIFsnbnBhcnQnLCBbODcwNiwgODI0XV0sIFsnbnBvbGludCcsIFsxMDc3Ml1dLCBbJ25wcicsIFs4ODMyXV0sIFsnbnByY3VlJywgWzg5MjhdXSwgWyducHJlYycsIFs4ODMyXV0sIFsnbnByZWNlcScsIFsxMDkyNywgODI0XV0sIFsnbnByZScsIFsxMDkyNywgODI0XV0sIFsnbnJhcnJjJywgWzEwNTQ3LCA4MjRdXSwgWyducmFycicsIFs4NjAzXV0sIFsnbnJBcnInLCBbODY1NV1dLCBbJ25yYXJydycsIFs4NjA1LCA4MjRdXSwgWyducmlnaHRhcnJvdycsIFs4NjAzXV0sIFsnblJpZ2h0YXJyb3cnLCBbODY1NV1dLCBbJ25ydHJpJywgWzg5MzldXSwgWyducnRyaWUnLCBbODk0MV1dLCBbJ25zYycsIFs4ODMzXV0sIFsnbnNjY3VlJywgWzg5MjldXSwgWyduc2NlJywgWzEwOTI4LCA4MjRdXSwgWydOc2NyJywgWzExOTk3N11dLCBbJ25zY3InLCBbMTIwMDAzXV0sIFsnbnNob3J0bWlkJywgWzg3NDBdXSwgWyduc2hvcnRwYXJhbGxlbCcsIFs4NzQyXV0sIFsnbnNpbScsIFs4NzY5XV0sIFsnbnNpbWUnLCBbODc3Ml1dLCBbJ25zaW1lcScsIFs4NzcyXV0sIFsnbnNtaWQnLCBbODc0MF1dLCBbJ25zcGFyJywgWzg3NDJdXSwgWyduc3FzdWJlJywgWzg5MzBdXSwgWyduc3FzdXBlJywgWzg5MzFdXSwgWyduc3ViJywgWzg4MzZdXSwgWyduc3ViRScsIFsxMDk0OSwgODI0XV0sIFsnbnN1YmUnLCBbODg0MF1dLCBbJ25zdWJzZXQnLCBbODgzNCwgODQwMl1dLCBbJ25zdWJzZXRlcScsIFs4ODQwXV0sIFsnbnN1YnNldGVxcScsIFsxMDk0OSwgODI0XV0sIFsnbnN1Y2MnLCBbODgzM11dLCBbJ25zdWNjZXEnLCBbMTA5MjgsIDgyNF1dLCBbJ25zdXAnLCBbODgzN11dLCBbJ25zdXBFJywgWzEwOTUwLCA4MjRdXSwgWyduc3VwZScsIFs4ODQxXV0sIFsnbnN1cHNldCcsIFs4ODM1LCA4NDAyXV0sIFsnbnN1cHNldGVxJywgWzg4NDFdXSwgWyduc3Vwc2V0ZXFxJywgWzEwOTUwLCA4MjRdXSwgWydudGdsJywgWzg4MjVdXSwgWydOdGlsZGUnLCBbMjA5XV0sIFsnbnRpbGRlJywgWzI0MV1dLCBbJ250bGcnLCBbODgyNF1dLCBbJ250cmlhbmdsZWxlZnQnLCBbODkzOF1dLCBbJ250cmlhbmdsZWxlZnRlcScsIFs4OTQwXV0sIFsnbnRyaWFuZ2xlcmlnaHQnLCBbODkzOV1dLCBbJ250cmlhbmdsZXJpZ2h0ZXEnLCBbODk0MV1dLCBbJ051JywgWzkyNV1dLCBbJ251JywgWzk1N11dLCBbJ251bScsIFszNV1dLCBbJ251bWVybycsIFs4NDcwXV0sIFsnbnVtc3AnLCBbODE5OV1dLCBbJ252YXAnLCBbODc4MSwgODQwMl1dLCBbJ252ZGFzaCcsIFs4ODc2XV0sIFsnbnZEYXNoJywgWzg4NzddXSwgWyduVmRhc2gnLCBbODg3OF1dLCBbJ25WRGFzaCcsIFs4ODc5XV0sIFsnbnZnZScsIFs4ODA1LCA4NDAyXV0sIFsnbnZndCcsIFs2MiwgODQwMl1dLCBbJ252SGFycicsIFsxMDUwMF1dLCBbJ252aW5maW4nLCBbMTA3MThdXSwgWydudmxBcnInLCBbMTA0OThdXSwgWydudmxlJywgWzg4MDQsIDg0MDJdXSwgWydudmx0JywgWzYwLCA4NDAyXV0sIFsnbnZsdHJpZScsIFs4ODg0LCA4NDAyXV0sIFsnbnZyQXJyJywgWzEwNDk5XV0sIFsnbnZydHJpZScsIFs4ODg1LCA4NDAyXV0sIFsnbnZzaW0nLCBbODc2NCwgODQwMl1dLCBbJ253YXJoaycsIFsxMDUzMV1dLCBbJ253YXJyJywgWzg1OThdXSwgWydud0FycicsIFs4NjYyXV0sIFsnbndhcnJvdycsIFs4NTk4XV0sIFsnbnduZWFyJywgWzEwNTM1XV0sIFsnT2FjdXRlJywgWzIxMV1dLCBbJ29hY3V0ZScsIFsyNDNdXSwgWydvYXN0JywgWzg4NTldXSwgWydPY2lyYycsIFsyMTJdXSwgWydvY2lyYycsIFsyNDRdXSwgWydvY2lyJywgWzg4NThdXSwgWydPY3knLCBbMTA1NF1dLCBbJ29jeScsIFsxMDg2XV0sIFsnb2Rhc2gnLCBbODg2MV1dLCBbJ09kYmxhYycsIFszMzZdXSwgWydvZGJsYWMnLCBbMzM3XV0sIFsnb2RpdicsIFsxMDgwOF1dLCBbJ29kb3QnLCBbODg1N11dLCBbJ29kc29sZCcsIFsxMDY4NF1dLCBbJ09FbGlnJywgWzMzOF1dLCBbJ29lbGlnJywgWzMzOV1dLCBbJ29mY2lyJywgWzEwNjg3XV0sIFsnT2ZyJywgWzEyMDA4Ml1dLCBbJ29mcicsIFsxMjAxMDhdXSwgWydvZ29uJywgWzczMV1dLCBbJ09ncmF2ZScsIFsyMTBdXSwgWydvZ3JhdmUnLCBbMjQyXV0sIFsnb2d0JywgWzEwNjg5XV0sIFsnb2hiYXInLCBbMTA2NzddXSwgWydvaG0nLCBbOTM3XV0sIFsnb2ludCcsIFs4NzUwXV0sIFsnb2xhcnInLCBbODYzNF1dLCBbJ29sY2lyJywgWzEwNjg2XV0sIFsnb2xjcm9zcycsIFsxMDY4M11dLCBbJ29saW5lJywgWzgyNTRdXSwgWydvbHQnLCBbMTA2ODhdXSwgWydPbWFjcicsIFszMzJdXSwgWydvbWFjcicsIFszMzNdXSwgWydPbWVnYScsIFs5MzddXSwgWydvbWVnYScsIFs5NjldXSwgWydPbWljcm9uJywgWzkyN11dLCBbJ29taWNyb24nLCBbOTU5XV0sIFsnb21pZCcsIFsxMDY3OF1dLCBbJ29taW51cycsIFs4ODU0XV0sIFsnT29wZicsIFsxMjAxMzRdXSwgWydvb3BmJywgWzEyMDE2MF1dLCBbJ29wYXInLCBbMTA2NzldXSwgWydPcGVuQ3VybHlEb3VibGVRdW90ZScsIFs4MjIwXV0sIFsnT3BlbkN1cmx5UXVvdGUnLCBbODIxNl1dLCBbJ29wZXJwJywgWzEwNjgxXV0sIFsnb3BsdXMnLCBbODg1M11dLCBbJ29yYXJyJywgWzg2MzVdXSwgWydPcicsIFsxMDgzNl1dLCBbJ29yJywgWzg3NDRdXSwgWydvcmQnLCBbMTA4NDVdXSwgWydvcmRlcicsIFs4NTAwXV0sIFsnb3JkZXJvZicsIFs4NTAwXV0sIFsnb3JkZicsIFsxNzBdXSwgWydvcmRtJywgWzE4Nl1dLCBbJ29yaWdvZicsIFs4ODg2XV0sIFsnb3JvcicsIFsxMDgzOF1dLCBbJ29yc2xvcGUnLCBbMTA4MzldXSwgWydvcnYnLCBbMTA4NDNdXSwgWydvUycsIFs5NDE2XV0sIFsnT3NjcicsIFsxMTk5NzhdXSwgWydvc2NyJywgWzg1MDBdXSwgWydPc2xhc2gnLCBbMjE2XV0sIFsnb3NsYXNoJywgWzI0OF1dLCBbJ29zb2wnLCBbODg1Nl1dLCBbJ090aWxkZScsIFsyMTNdXSwgWydvdGlsZGUnLCBbMjQ1XV0sIFsnb3RpbWVzYXMnLCBbMTA4MDZdXSwgWydPdGltZXMnLCBbMTA4MDddXSwgWydvdGltZXMnLCBbODg1NV1dLCBbJ091bWwnLCBbMjE0XV0sIFsnb3VtbCcsIFsyNDZdXSwgWydvdmJhcicsIFs5MDIxXV0sIFsnT3ZlckJhcicsIFs4MjU0XV0sIFsnT3ZlckJyYWNlJywgWzkxODJdXSwgWydPdmVyQnJhY2tldCcsIFs5MTQwXV0sIFsnT3ZlclBhcmVudGhlc2lzJywgWzkxODBdXSwgWydwYXJhJywgWzE4Ml1dLCBbJ3BhcmFsbGVsJywgWzg3NDFdXSwgWydwYXInLCBbODc0MV1dLCBbJ3BhcnNpbScsIFsxMDk5NV1dLCBbJ3BhcnNsJywgWzExMDA1XV0sIFsncGFydCcsIFs4NzA2XV0sIFsnUGFydGlhbEQnLCBbODcwNl1dLCBbJ1BjeScsIFsxMDU1XV0sIFsncGN5JywgWzEwODddXSwgWydwZXJjbnQnLCBbMzddXSwgWydwZXJpb2QnLCBbNDZdXSwgWydwZXJtaWwnLCBbODI0MF1dLCBbJ3BlcnAnLCBbODg2OV1dLCBbJ3BlcnRlbmsnLCBbODI0MV1dLCBbJ1BmcicsIFsxMjAwODNdXSwgWydwZnInLCBbMTIwMTA5XV0sIFsnUGhpJywgWzkzNF1dLCBbJ3BoaScsIFs5NjZdXSwgWydwaGl2JywgWzk4MV1dLCBbJ3BobW1hdCcsIFs4NDk5XV0sIFsncGhvbmUnLCBbOTc0Ml1dLCBbJ1BpJywgWzkyOF1dLCBbJ3BpJywgWzk2MF1dLCBbJ3BpdGNoZm9yaycsIFs4OTE2XV0sIFsncGl2JywgWzk4Ml1dLCBbJ3BsYW5jaycsIFs4NDYzXV0sIFsncGxhbmNraCcsIFs4NDYyXV0sIFsncGxhbmt2JywgWzg0NjNdXSwgWydwbHVzYWNpcicsIFsxMDc4N11dLCBbJ3BsdXNiJywgWzg4NjJdXSwgWydwbHVzY2lyJywgWzEwNzg2XV0sIFsncGx1cycsIFs0M11dLCBbJ3BsdXNkbycsIFs4NzI0XV0sIFsncGx1c2R1JywgWzEwNzg5XV0sIFsncGx1c2UnLCBbMTA4NjZdXSwgWydQbHVzTWludXMnLCBbMTc3XV0sIFsncGx1c21uJywgWzE3N11dLCBbJ3BsdXNzaW0nLCBbMTA3OTBdXSwgWydwbHVzdHdvJywgWzEwNzkxXV0sIFsncG0nLCBbMTc3XV0sIFsnUG9pbmNhcmVwbGFuZScsIFs4NDYwXV0sIFsncG9pbnRpbnQnLCBbMTA3NzNdXSwgWydwb3BmJywgWzEyMDE2MV1dLCBbJ1BvcGYnLCBbODQ3M11dLCBbJ3BvdW5kJywgWzE2M11dLCBbJ3ByYXAnLCBbMTA5MzVdXSwgWydQcicsIFsxMDkzOV1dLCBbJ3ByJywgWzg4MjZdXSwgWydwcmN1ZScsIFs4ODI4XV0sIFsncHJlY2FwcHJveCcsIFsxMDkzNV1dLCBbJ3ByZWMnLCBbODgyNl1dLCBbJ3ByZWNjdXJseWVxJywgWzg4MjhdXSwgWydQcmVjZWRlcycsIFs4ODI2XV0sIFsnUHJlY2VkZXNFcXVhbCcsIFsxMDkyN11dLCBbJ1ByZWNlZGVzU2xhbnRFcXVhbCcsIFs4ODI4XV0sIFsnUHJlY2VkZXNUaWxkZScsIFs4ODMwXV0sIFsncHJlY2VxJywgWzEwOTI3XV0sIFsncHJlY25hcHByb3gnLCBbMTA5MzddXSwgWydwcmVjbmVxcScsIFsxMDkzM11dLCBbJ3ByZWNuc2ltJywgWzg5MzZdXSwgWydwcmUnLCBbMTA5MjddXSwgWydwckUnLCBbMTA5MzFdXSwgWydwcmVjc2ltJywgWzg4MzBdXSwgWydwcmltZScsIFs4MjQyXV0sIFsnUHJpbWUnLCBbODI0M11dLCBbJ3ByaW1lcycsIFs4NDczXV0sIFsncHJuYXAnLCBbMTA5MzddXSwgWydwcm5FJywgWzEwOTMzXV0sIFsncHJuc2ltJywgWzg5MzZdXSwgWydwcm9kJywgWzg3MTldXSwgWydQcm9kdWN0JywgWzg3MTldXSwgWydwcm9mYWxhcicsIFs5MDA2XV0sIFsncHJvZmxpbmUnLCBbODk3OF1dLCBbJ3Byb2ZzdXJmJywgWzg5NzldXSwgWydwcm9wJywgWzg3MzNdXSwgWydQcm9wb3J0aW9uYWwnLCBbODczM11dLCBbJ1Byb3BvcnRpb24nLCBbODc1OV1dLCBbJ3Byb3B0bycsIFs4NzMzXV0sIFsncHJzaW0nLCBbODgzMF1dLCBbJ3BydXJlbCcsIFs4ODgwXV0sIFsnUHNjcicsIFsxMTk5NzldXSwgWydwc2NyJywgWzEyMDAwNV1dLCBbJ1BzaScsIFs5MzZdXSwgWydwc2knLCBbOTY4XV0sIFsncHVuY3NwJywgWzgyMDBdXSwgWydRZnInLCBbMTIwMDg0XV0sIFsncWZyJywgWzEyMDExMF1dLCBbJ3FpbnQnLCBbMTA3NjRdXSwgWydxb3BmJywgWzEyMDE2Ml1dLCBbJ1FvcGYnLCBbODQ3NF1dLCBbJ3FwcmltZScsIFs4Mjc5XV0sIFsnUXNjcicsIFsxMTk5ODBdXSwgWydxc2NyJywgWzEyMDAwNl1dLCBbJ3F1YXRlcm5pb25zJywgWzg0NjFdXSwgWydxdWF0aW50JywgWzEwNzc0XV0sIFsncXVlc3QnLCBbNjNdXSwgWydxdWVzdGVxJywgWzg3OTldXSwgWydxdW90JywgWzM0XV0sIFsnUVVPVCcsIFszNF1dLCBbJ3JBYXJyJywgWzg2NjddXSwgWydyYWNlJywgWzg3NjUsIDgxN11dLCBbJ1JhY3V0ZScsIFszNDBdXSwgWydyYWN1dGUnLCBbMzQxXV0sIFsncmFkaWMnLCBbODczMF1dLCBbJ3JhZW1wdHl2JywgWzEwNjc1XV0sIFsncmFuZycsIFsxMDIxN11dLCBbJ1JhbmcnLCBbMTAyMTldXSwgWydyYW5nZCcsIFsxMDY0Ml1dLCBbJ3JhbmdlJywgWzEwNjYxXV0sIFsncmFuZ2xlJywgWzEwMjE3XV0sIFsncmFxdW8nLCBbMTg3XV0sIFsncmFycmFwJywgWzEwNjEzXV0sIFsncmFycmInLCBbODY3N11dLCBbJ3JhcnJiZnMnLCBbMTA1MjhdXSwgWydyYXJyYycsIFsxMDU0N11dLCBbJ3JhcnInLCBbODU5NF1dLCBbJ1JhcnInLCBbODYwOF1dLCBbJ3JBcnInLCBbODY1OF1dLCBbJ3JhcnJmcycsIFsxMDUyNl1dLCBbJ3JhcnJoaycsIFs4NjE4XV0sIFsncmFycmxwJywgWzg2MjBdXSwgWydyYXJycGwnLCBbMTA1NjVdXSwgWydyYXJyc2ltJywgWzEwNjEyXV0sIFsnUmFycnRsJywgWzEwNTE4XV0sIFsncmFycnRsJywgWzg2MTFdXSwgWydyYXJydycsIFs4NjA1XV0sIFsncmF0YWlsJywgWzEwNTIyXV0sIFsnckF0YWlsJywgWzEwNTI0XV0sIFsncmF0aW8nLCBbODc1OF1dLCBbJ3JhdGlvbmFscycsIFs4NDc0XV0sIFsncmJhcnInLCBbMTA1MDldXSwgWydyQmFycicsIFsxMDUxMV1dLCBbJ1JCYXJyJywgWzEwNTEyXV0sIFsncmJicmsnLCBbMTAwOTldXSwgWydyYnJhY2UnLCBbMTI1XV0sIFsncmJyYWNrJywgWzkzXV0sIFsncmJya2UnLCBbMTA2MzZdXSwgWydyYnJrc2xkJywgWzEwNjM4XV0sIFsncmJya3NsdScsIFsxMDY0MF1dLCBbJ1JjYXJvbicsIFszNDRdXSwgWydyY2Fyb24nLCBbMzQ1XV0sIFsnUmNlZGlsJywgWzM0Ml1dLCBbJ3JjZWRpbCcsIFszNDNdXSwgWydyY2VpbCcsIFs4OTY5XV0sIFsncmN1YicsIFsxMjVdXSwgWydSY3knLCBbMTA1Nl1dLCBbJ3JjeScsIFsxMDg4XV0sIFsncmRjYScsIFsxMDU1MV1dLCBbJ3JkbGRoYXInLCBbMTA2MDFdXSwgWydyZHF1bycsIFs4MjIxXV0sIFsncmRxdW9yJywgWzgyMjFdXSwgWydDbG9zZUN1cmx5RG91YmxlUXVvdGUnLCBbODIyMV1dLCBbJ3Jkc2gnLCBbODYyN11dLCBbJ3JlYWwnLCBbODQ3Nl1dLCBbJ3JlYWxpbmUnLCBbODQ3NV1dLCBbJ3JlYWxwYXJ0JywgWzg0NzZdXSwgWydyZWFscycsIFs4NDc3XV0sIFsnUmUnLCBbODQ3Nl1dLCBbJ3JlY3QnLCBbOTY0NV1dLCBbJ3JlZycsIFsxNzRdXSwgWydSRUcnLCBbMTc0XV0sIFsnUmV2ZXJzZUVsZW1lbnQnLCBbODcxNV1dLCBbJ1JldmVyc2VFcXVpbGlicml1bScsIFs4NjUxXV0sIFsnUmV2ZXJzZVVwRXF1aWxpYnJpdW0nLCBbMTA2MDddXSwgWydyZmlzaHQnLCBbMTA2MjFdXSwgWydyZmxvb3InLCBbODk3MV1dLCBbJ3JmcicsIFsxMjAxMTFdXSwgWydSZnInLCBbODQ3Nl1dLCBbJ3JIYXInLCBbMTA1OTZdXSwgWydyaGFyZCcsIFs4NjQxXV0sIFsncmhhcnUnLCBbODY0MF1dLCBbJ3JoYXJ1bCcsIFsxMDYwNF1dLCBbJ1JobycsIFs5MjldXSwgWydyaG8nLCBbOTYxXV0sIFsncmhvdicsIFsxMDA5XV0sIFsnUmlnaHRBbmdsZUJyYWNrZXQnLCBbMTAyMTddXSwgWydSaWdodEFycm93QmFyJywgWzg2NzddXSwgWydyaWdodGFycm93JywgWzg1OTRdXSwgWydSaWdodEFycm93JywgWzg1OTRdXSwgWydSaWdodGFycm93JywgWzg2NThdXSwgWydSaWdodEFycm93TGVmdEFycm93JywgWzg2NDRdXSwgWydyaWdodGFycm93dGFpbCcsIFs4NjExXV0sIFsnUmlnaHRDZWlsaW5nJywgWzg5NjldXSwgWydSaWdodERvdWJsZUJyYWNrZXQnLCBbMTAyMTVdXSwgWydSaWdodERvd25UZWVWZWN0b3InLCBbMTA1ODldXSwgWydSaWdodERvd25WZWN0b3JCYXInLCBbMTA1ODFdXSwgWydSaWdodERvd25WZWN0b3InLCBbODY0Ml1dLCBbJ1JpZ2h0Rmxvb3InLCBbODk3MV1dLCBbJ3JpZ2h0aGFycG9vbmRvd24nLCBbODY0MV1dLCBbJ3JpZ2h0aGFycG9vbnVwJywgWzg2NDBdXSwgWydyaWdodGxlZnRhcnJvd3MnLCBbODY0NF1dLCBbJ3JpZ2h0bGVmdGhhcnBvb25zJywgWzg2NTJdXSwgWydyaWdodHJpZ2h0YXJyb3dzJywgWzg2NDldXSwgWydyaWdodHNxdWlnYXJyb3cnLCBbODYwNV1dLCBbJ1JpZ2h0VGVlQXJyb3cnLCBbODYxNF1dLCBbJ1JpZ2h0VGVlJywgWzg4NjZdXSwgWydSaWdodFRlZVZlY3RvcicsIFsxMDU4N11dLCBbJ3JpZ2h0dGhyZWV0aW1lcycsIFs4OTA4XV0sIFsnUmlnaHRUcmlhbmdsZUJhcicsIFsxMDcwNF1dLCBbJ1JpZ2h0VHJpYW5nbGUnLCBbODg4M11dLCBbJ1JpZ2h0VHJpYW5nbGVFcXVhbCcsIFs4ODg1XV0sIFsnUmlnaHRVcERvd25WZWN0b3InLCBbMTA1NzVdXSwgWydSaWdodFVwVGVlVmVjdG9yJywgWzEwNTg4XV0sIFsnUmlnaHRVcFZlY3RvckJhcicsIFsxMDU4MF1dLCBbJ1JpZ2h0VXBWZWN0b3InLCBbODYzOF1dLCBbJ1JpZ2h0VmVjdG9yQmFyJywgWzEwNTc5XV0sIFsnUmlnaHRWZWN0b3InLCBbODY0MF1dLCBbJ3JpbmcnLCBbNzMwXV0sIFsncmlzaW5nZG90c2VxJywgWzg3ODddXSwgWydybGFycicsIFs4NjQ0XV0sIFsncmxoYXInLCBbODY1Ml1dLCBbJ3JsbScsIFs4MjA3XV0sIFsncm1vdXN0YWNoZScsIFs5MTM3XV0sIFsncm1vdXN0JywgWzkxMzddXSwgWydybm1pZCcsIFsxMDk5MF1dLCBbJ3JvYW5nJywgWzEwMjIxXV0sIFsncm9hcnInLCBbODcwMl1dLCBbJ3JvYnJrJywgWzEwMjE1XV0sIFsncm9wYXInLCBbMTA2MzBdXSwgWydyb3BmJywgWzEyMDE2M11dLCBbJ1JvcGYnLCBbODQ3N11dLCBbJ3JvcGx1cycsIFsxMDc5OF1dLCBbJ3JvdGltZXMnLCBbMTA4MDVdXSwgWydSb3VuZEltcGxpZXMnLCBbMTA2MDhdXSwgWydycGFyJywgWzQxXV0sIFsncnBhcmd0JywgWzEwNjQ0XV0sIFsncnBwb2xpbnQnLCBbMTA3NzBdXSwgWydycmFycicsIFs4NjQ5XV0sIFsnUnJpZ2h0YXJyb3cnLCBbODY2N11dLCBbJ3JzYXF1bycsIFs4MjUwXV0sIFsncnNjcicsIFsxMjAwMDddXSwgWydSc2NyJywgWzg0NzVdXSwgWydyc2gnLCBbODYyNV1dLCBbJ1JzaCcsIFs4NjI1XV0sIFsncnNxYicsIFs5M11dLCBbJ3JzcXVvJywgWzgyMTddXSwgWydyc3F1b3InLCBbODIxN11dLCBbJ0Nsb3NlQ3VybHlRdW90ZScsIFs4MjE3XV0sIFsncnRocmVlJywgWzg5MDhdXSwgWydydGltZXMnLCBbODkwNl1dLCBbJ3J0cmknLCBbOTY1N11dLCBbJ3J0cmllJywgWzg4ODVdXSwgWydydHJpZicsIFs5NjU2XV0sIFsncnRyaWx0cmknLCBbMTA3MDJdXSwgWydSdWxlRGVsYXllZCcsIFsxMDc0MF1dLCBbJ3J1bHVoYXInLCBbMTA2MDBdXSwgWydyeCcsIFs4NDc4XV0sIFsnU2FjdXRlJywgWzM0Nl1dLCBbJ3NhY3V0ZScsIFszNDddXSwgWydzYnF1bycsIFs4MjE4XV0sIFsnc2NhcCcsIFsxMDkzNl1dLCBbJ1NjYXJvbicsIFszNTJdXSwgWydzY2Fyb24nLCBbMzUzXV0sIFsnU2MnLCBbMTA5NDBdXSwgWydzYycsIFs4ODI3XV0sIFsnc2NjdWUnLCBbODgyOV1dLCBbJ3NjZScsIFsxMDkyOF1dLCBbJ3NjRScsIFsxMDkzMl1dLCBbJ1NjZWRpbCcsIFszNTBdXSwgWydzY2VkaWwnLCBbMzUxXV0sIFsnU2NpcmMnLCBbMzQ4XV0sIFsnc2NpcmMnLCBbMzQ5XV0sIFsnc2NuYXAnLCBbMTA5MzhdXSwgWydzY25FJywgWzEwOTM0XV0sIFsnc2Nuc2ltJywgWzg5MzddXSwgWydzY3BvbGludCcsIFsxMDc3MV1dLCBbJ3Njc2ltJywgWzg4MzFdXSwgWydTY3knLCBbMTA1N11dLCBbJ3NjeScsIFsxMDg5XV0sIFsnc2RvdGInLCBbODg2NV1dLCBbJ3Nkb3QnLCBbODkwMV1dLCBbJ3Nkb3RlJywgWzEwODU0XV0sIFsnc2VhcmhrJywgWzEwNTMzXV0sIFsnc2VhcnInLCBbODYwMF1dLCBbJ3NlQXJyJywgWzg2NjRdXSwgWydzZWFycm93JywgWzg2MDBdXSwgWydzZWN0JywgWzE2N11dLCBbJ3NlbWknLCBbNTldXSwgWydzZXN3YXInLCBbMTA1MzddXSwgWydzZXRtaW51cycsIFs4NzI2XV0sIFsnc2V0bW4nLCBbODcyNl1dLCBbJ3NleHQnLCBbMTAwMzhdXSwgWydTZnInLCBbMTIwMDg2XV0sIFsnc2ZyJywgWzEyMDExMl1dLCBbJ3Nmcm93bicsIFs4OTk0XV0sIFsnc2hhcnAnLCBbOTgzOV1dLCBbJ1NIQ0hjeScsIFsxMDY1XV0sIFsnc2hjaGN5JywgWzEwOTddXSwgWydTSGN5JywgWzEwNjRdXSwgWydzaGN5JywgWzEwOTZdXSwgWydTaG9ydERvd25BcnJvdycsIFs4NTk1XV0sIFsnU2hvcnRMZWZ0QXJyb3cnLCBbODU5Ml1dLCBbJ3Nob3J0bWlkJywgWzg3MzldXSwgWydzaG9ydHBhcmFsbGVsJywgWzg3NDFdXSwgWydTaG9ydFJpZ2h0QXJyb3cnLCBbODU5NF1dLCBbJ1Nob3J0VXBBcnJvdycsIFs4NTkzXV0sIFsnc2h5JywgWzE3M11dLCBbJ1NpZ21hJywgWzkzMV1dLCBbJ3NpZ21hJywgWzk2M11dLCBbJ3NpZ21hZicsIFs5NjJdXSwgWydzaWdtYXYnLCBbOTYyXV0sIFsnc2ltJywgWzg3NjRdXSwgWydzaW1kb3QnLCBbMTA4NThdXSwgWydzaW1lJywgWzg3NzFdXSwgWydzaW1lcScsIFs4NzcxXV0sIFsnc2ltZycsIFsxMDkxMF1dLCBbJ3NpbWdFJywgWzEwOTEyXV0sIFsnc2ltbCcsIFsxMDkwOV1dLCBbJ3NpbWxFJywgWzEwOTExXV0sIFsnc2ltbmUnLCBbODc3NF1dLCBbJ3NpbXBsdXMnLCBbMTA3ODhdXSwgWydzaW1yYXJyJywgWzEwNjEwXV0sIFsnc2xhcnInLCBbODU5Ml1dLCBbJ1NtYWxsQ2lyY2xlJywgWzg3MjhdXSwgWydzbWFsbHNldG1pbnVzJywgWzg3MjZdXSwgWydzbWFzaHAnLCBbMTA4MDNdXSwgWydzbWVwYXJzbCcsIFsxMDcyNF1dLCBbJ3NtaWQnLCBbODczOV1dLCBbJ3NtaWxlJywgWzg5OTVdXSwgWydzbXQnLCBbMTA5MjJdXSwgWydzbXRlJywgWzEwOTI0XV0sIFsnc210ZXMnLCBbMTA5MjQsIDY1MDI0XV0sIFsnU09GVGN5JywgWzEwNjhdXSwgWydzb2Z0Y3knLCBbMTEwMF1dLCBbJ3NvbGJhcicsIFs5MDIzXV0sIFsnc29sYicsIFsxMDY5Ml1dLCBbJ3NvbCcsIFs0N11dLCBbJ1NvcGYnLCBbMTIwMTM4XV0sIFsnc29wZicsIFsxMjAxNjRdXSwgWydzcGFkZXMnLCBbOTgyNF1dLCBbJ3NwYWRlc3VpdCcsIFs5ODI0XV0sIFsnc3BhcicsIFs4NzQxXV0sIFsnc3FjYXAnLCBbODg1MV1dLCBbJ3NxY2FwcycsIFs4ODUxLCA2NTAyNF1dLCBbJ3NxY3VwJywgWzg4NTJdXSwgWydzcWN1cHMnLCBbODg1MiwgNjUwMjRdXSwgWydTcXJ0JywgWzg3MzBdXSwgWydzcXN1YicsIFs4ODQ3XV0sIFsnc3FzdWJlJywgWzg4NDldXSwgWydzcXN1YnNldCcsIFs4ODQ3XV0sIFsnc3FzdWJzZXRlcScsIFs4ODQ5XV0sIFsnc3FzdXAnLCBbODg0OF1dLCBbJ3Nxc3VwZScsIFs4ODUwXV0sIFsnc3FzdXBzZXQnLCBbODg0OF1dLCBbJ3Nxc3Vwc2V0ZXEnLCBbODg1MF1dLCBbJ3NxdWFyZScsIFs5NjMzXV0sIFsnU3F1YXJlJywgWzk2MzNdXSwgWydTcXVhcmVJbnRlcnNlY3Rpb24nLCBbODg1MV1dLCBbJ1NxdWFyZVN1YnNldCcsIFs4ODQ3XV0sIFsnU3F1YXJlU3Vic2V0RXF1YWwnLCBbODg0OV1dLCBbJ1NxdWFyZVN1cGVyc2V0JywgWzg4NDhdXSwgWydTcXVhcmVTdXBlcnNldEVxdWFsJywgWzg4NTBdXSwgWydTcXVhcmVVbmlvbicsIFs4ODUyXV0sIFsnc3F1YXJmJywgWzk2NDJdXSwgWydzcXUnLCBbOTYzM11dLCBbJ3NxdWYnLCBbOTY0Ml1dLCBbJ3NyYXJyJywgWzg1OTRdXSwgWydTc2NyJywgWzExOTk4Ml1dLCBbJ3NzY3InLCBbMTIwMDA4XV0sIFsnc3NldG1uJywgWzg3MjZdXSwgWydzc21pbGUnLCBbODk5NV1dLCBbJ3NzdGFyZicsIFs4OTAyXV0sIFsnU3RhcicsIFs4OTAyXV0sIFsnc3RhcicsIFs5NzM0XV0sIFsnc3RhcmYnLCBbOTczM11dLCBbJ3N0cmFpZ2h0ZXBzaWxvbicsIFsxMDEzXV0sIFsnc3RyYWlnaHRwaGknLCBbOTgxXV0sIFsnc3RybnMnLCBbMTc1XV0sIFsnc3ViJywgWzg4MzRdXSwgWydTdWInLCBbODkxMl1dLCBbJ3N1YmRvdCcsIFsxMDk0MV1dLCBbJ3N1YkUnLCBbMTA5NDldXSwgWydzdWJlJywgWzg4MzhdXSwgWydzdWJlZG90JywgWzEwOTQ3XV0sIFsnc3VibXVsdCcsIFsxMDk0NV1dLCBbJ3N1Ym5FJywgWzEwOTU1XV0sIFsnc3VibmUnLCBbODg0Ml1dLCBbJ3N1YnBsdXMnLCBbMTA5NDNdXSwgWydzdWJyYXJyJywgWzEwNjE3XV0sIFsnc3Vic2V0JywgWzg4MzRdXSwgWydTdWJzZXQnLCBbODkxMl1dLCBbJ3N1YnNldGVxJywgWzg4MzhdXSwgWydzdWJzZXRlcXEnLCBbMTA5NDldXSwgWydTdWJzZXRFcXVhbCcsIFs4ODM4XV0sIFsnc3Vic2V0bmVxJywgWzg4NDJdXSwgWydzdWJzZXRuZXFxJywgWzEwOTU1XV0sIFsnc3Vic2ltJywgWzEwOTUxXV0sIFsnc3Vic3ViJywgWzEwOTY1XV0sIFsnc3Vic3VwJywgWzEwOTYzXV0sIFsnc3VjY2FwcHJveCcsIFsxMDkzNl1dLCBbJ3N1Y2MnLCBbODgyN11dLCBbJ3N1Y2NjdXJseWVxJywgWzg4MjldXSwgWydTdWNjZWVkcycsIFs4ODI3XV0sIFsnU3VjY2VlZHNFcXVhbCcsIFsxMDkyOF1dLCBbJ1N1Y2NlZWRzU2xhbnRFcXVhbCcsIFs4ODI5XV0sIFsnU3VjY2VlZHNUaWxkZScsIFs4ODMxXV0sIFsnc3VjY2VxJywgWzEwOTI4XV0sIFsnc3VjY25hcHByb3gnLCBbMTA5MzhdXSwgWydzdWNjbmVxcScsIFsxMDkzNF1dLCBbJ3N1Y2Nuc2ltJywgWzg5MzddXSwgWydzdWNjc2ltJywgWzg4MzFdXSwgWydTdWNoVGhhdCcsIFs4NzE1XV0sIFsnc3VtJywgWzg3MjFdXSwgWydTdW0nLCBbODcyMV1dLCBbJ3N1bmcnLCBbOTgzNF1dLCBbJ3N1cDEnLCBbMTg1XV0sIFsnc3VwMicsIFsxNzhdXSwgWydzdXAzJywgWzE3OV1dLCBbJ3N1cCcsIFs4ODM1XV0sIFsnU3VwJywgWzg5MTNdXSwgWydzdXBkb3QnLCBbMTA5NDJdXSwgWydzdXBkc3ViJywgWzEwOTY4XV0sIFsnc3VwRScsIFsxMDk1MF1dLCBbJ3N1cGUnLCBbODgzOV1dLCBbJ3N1cGVkb3QnLCBbMTA5NDhdXSwgWydTdXBlcnNldCcsIFs4ODM1XV0sIFsnU3VwZXJzZXRFcXVhbCcsIFs4ODM5XV0sIFsnc3VwaHNvbCcsIFsxMDE4NV1dLCBbJ3N1cGhzdWInLCBbMTA5NjddXSwgWydzdXBsYXJyJywgWzEwNjE5XV0sIFsnc3VwbXVsdCcsIFsxMDk0Nl1dLCBbJ3N1cG5FJywgWzEwOTU2XV0sIFsnc3VwbmUnLCBbODg0M11dLCBbJ3N1cHBsdXMnLCBbMTA5NDRdXSwgWydzdXBzZXQnLCBbODgzNV1dLCBbJ1N1cHNldCcsIFs4OTEzXV0sIFsnc3Vwc2V0ZXEnLCBbODgzOV1dLCBbJ3N1cHNldGVxcScsIFsxMDk1MF1dLCBbJ3N1cHNldG5lcScsIFs4ODQzXV0sIFsnc3Vwc2V0bmVxcScsIFsxMDk1Nl1dLCBbJ3N1cHNpbScsIFsxMDk1Ml1dLCBbJ3N1cHN1YicsIFsxMDk2NF1dLCBbJ3N1cHN1cCcsIFsxMDk2Nl1dLCBbJ3N3YXJoaycsIFsxMDUzNF1dLCBbJ3N3YXJyJywgWzg2MDFdXSwgWydzd0FycicsIFs4NjY1XV0sIFsnc3dhcnJvdycsIFs4NjAxXV0sIFsnc3dud2FyJywgWzEwNTM4XV0sIFsnc3psaWcnLCBbMjIzXV0sIFsnVGFiJywgWzldXSwgWyd0YXJnZXQnLCBbODk4Ml1dLCBbJ1RhdScsIFs5MzJdXSwgWyd0YXUnLCBbOTY0XV0sIFsndGJyaycsIFs5MTQwXV0sIFsnVGNhcm9uJywgWzM1Nl1dLCBbJ3RjYXJvbicsIFszNTddXSwgWydUY2VkaWwnLCBbMzU0XV0sIFsndGNlZGlsJywgWzM1NV1dLCBbJ1RjeScsIFsxMDU4XV0sIFsndGN5JywgWzEwOTBdXSwgWyd0ZG90JywgWzg0MTFdXSwgWyd0ZWxyZWMnLCBbODk4MV1dLCBbJ1RmcicsIFsxMjAwODddXSwgWyd0ZnInLCBbMTIwMTEzXV0sIFsndGhlcmU0JywgWzg3NTZdXSwgWyd0aGVyZWZvcmUnLCBbODc1Nl1dLCBbJ1RoZXJlZm9yZScsIFs4NzU2XV0sIFsnVGhldGEnLCBbOTIwXV0sIFsndGhldGEnLCBbOTUyXV0sIFsndGhldGFzeW0nLCBbOTc3XV0sIFsndGhldGF2JywgWzk3N11dLCBbJ3RoaWNrYXBwcm94JywgWzg3NzZdXSwgWyd0aGlja3NpbScsIFs4NzY0XV0sIFsnVGhpY2tTcGFjZScsIFs4Mjg3LCA4MjAyXV0sIFsnVGhpblNwYWNlJywgWzgyMDFdXSwgWyd0aGluc3AnLCBbODIwMV1dLCBbJ3Roa2FwJywgWzg3NzZdXSwgWyd0aGtzaW0nLCBbODc2NF1dLCBbJ1RIT1JOJywgWzIyMl1dLCBbJ3Rob3JuJywgWzI1NF1dLCBbJ3RpbGRlJywgWzczMl1dLCBbJ1RpbGRlJywgWzg3NjRdXSwgWydUaWxkZUVxdWFsJywgWzg3NzFdXSwgWydUaWxkZUZ1bGxFcXVhbCcsIFs4NzczXV0sIFsnVGlsZGVUaWxkZScsIFs4Nzc2XV0sIFsndGltZXNiYXInLCBbMTA4MDFdXSwgWyd0aW1lc2InLCBbODg2NF1dLCBbJ3RpbWVzJywgWzIxNV1dLCBbJ3RpbWVzZCcsIFsxMDgwMF1dLCBbJ3RpbnQnLCBbODc0OV1dLCBbJ3RvZWEnLCBbMTA1MzZdXSwgWyd0b3Bib3QnLCBbOTAxNF1dLCBbJ3RvcGNpcicsIFsxMDk5M11dLCBbJ3RvcCcsIFs4ODY4XV0sIFsnVG9wZicsIFsxMjAxMzldXSwgWyd0b3BmJywgWzEyMDE2NV1dLCBbJ3RvcGZvcmsnLCBbMTA5NzBdXSwgWyd0b3NhJywgWzEwNTM3XV0sIFsndHByaW1lJywgWzgyNDRdXSwgWyd0cmFkZScsIFs4NDgyXV0sIFsnVFJBREUnLCBbODQ4Ml1dLCBbJ3RyaWFuZ2xlJywgWzk2NTNdXSwgWyd0cmlhbmdsZWRvd24nLCBbOTY2M11dLCBbJ3RyaWFuZ2xlbGVmdCcsIFs5NjY3XV0sIFsndHJpYW5nbGVsZWZ0ZXEnLCBbODg4NF1dLCBbJ3RyaWFuZ2xlcScsIFs4Nzk2XV0sIFsndHJpYW5nbGVyaWdodCcsIFs5NjU3XV0sIFsndHJpYW5nbGVyaWdodGVxJywgWzg4ODVdXSwgWyd0cmlkb3QnLCBbOTcwOF1dLCBbJ3RyaWUnLCBbODc5Nl1dLCBbJ3RyaW1pbnVzJywgWzEwODEwXV0sIFsnVHJpcGxlRG90JywgWzg0MTFdXSwgWyd0cmlwbHVzJywgWzEwODA5XV0sIFsndHJpc2InLCBbMTA3MDFdXSwgWyd0cml0aW1lJywgWzEwODExXV0sIFsndHJwZXppdW0nLCBbOTE4Nl1dLCBbJ1RzY3InLCBbMTE5OTgzXV0sIFsndHNjcicsIFsxMjAwMDldXSwgWydUU2N5JywgWzEwNjJdXSwgWyd0c2N5JywgWzEwOTRdXSwgWydUU0hjeScsIFsxMDM1XV0sIFsndHNoY3knLCBbMTExNV1dLCBbJ1RzdHJvaycsIFszNThdXSwgWyd0c3Ryb2snLCBbMzU5XV0sIFsndHdpeHQnLCBbODgxMl1dLCBbJ3R3b2hlYWRsZWZ0YXJyb3cnLCBbODYwNl1dLCBbJ3R3b2hlYWRyaWdodGFycm93JywgWzg2MDhdXSwgWydVYWN1dGUnLCBbMjE4XV0sIFsndWFjdXRlJywgWzI1MF1dLCBbJ3VhcnInLCBbODU5M11dLCBbJ1VhcnInLCBbODYwN11dLCBbJ3VBcnInLCBbODY1N11dLCBbJ1VhcnJvY2lyJywgWzEwNTY5XV0sIFsnVWJyY3knLCBbMTAzOF1dLCBbJ3VicmN5JywgWzExMThdXSwgWydVYnJldmUnLCBbMzY0XV0sIFsndWJyZXZlJywgWzM2NV1dLCBbJ1VjaXJjJywgWzIxOV1dLCBbJ3VjaXJjJywgWzI1MV1dLCBbJ1VjeScsIFsxMDU5XV0sIFsndWN5JywgWzEwOTFdXSwgWyd1ZGFycicsIFs4NjQ1XV0sIFsnVWRibGFjJywgWzM2OF1dLCBbJ3VkYmxhYycsIFszNjldXSwgWyd1ZGhhcicsIFsxMDYwNl1dLCBbJ3VmaXNodCcsIFsxMDYyMl1dLCBbJ1VmcicsIFsxMjAwODhdXSwgWyd1ZnInLCBbMTIwMTE0XV0sIFsnVWdyYXZlJywgWzIxN11dLCBbJ3VncmF2ZScsIFsyNDldXSwgWyd1SGFyJywgWzEwNTk1XV0sIFsndWhhcmwnLCBbODYzOV1dLCBbJ3VoYXJyJywgWzg2MzhdXSwgWyd1aGJsaycsIFs5NjAwXV0sIFsndWxjb3JuJywgWzg5ODhdXSwgWyd1bGNvcm5lcicsIFs4OTg4XV0sIFsndWxjcm9wJywgWzg5NzVdXSwgWyd1bHRyaScsIFs5NzIwXV0sIFsnVW1hY3InLCBbMzYyXV0sIFsndW1hY3InLCBbMzYzXV0sIFsndW1sJywgWzE2OF1dLCBbJ1VuZGVyQmFyJywgWzk1XV0sIFsnVW5kZXJCcmFjZScsIFs5MTgzXV0sIFsnVW5kZXJCcmFja2V0JywgWzkxNDFdXSwgWydVbmRlclBhcmVudGhlc2lzJywgWzkxODFdXSwgWydVbmlvbicsIFs4ODk5XV0sIFsnVW5pb25QbHVzJywgWzg4NDZdXSwgWydVb2dvbicsIFszNzBdXSwgWyd1b2dvbicsIFszNzFdXSwgWydVb3BmJywgWzEyMDE0MF1dLCBbJ3VvcGYnLCBbMTIwMTY2XV0sIFsnVXBBcnJvd0JhcicsIFsxMDUxNF1dLCBbJ3VwYXJyb3cnLCBbODU5M11dLCBbJ1VwQXJyb3cnLCBbODU5M11dLCBbJ1VwYXJyb3cnLCBbODY1N11dLCBbJ1VwQXJyb3dEb3duQXJyb3cnLCBbODY0NV1dLCBbJ3VwZG93bmFycm93JywgWzg1OTddXSwgWydVcERvd25BcnJvdycsIFs4NTk3XV0sIFsnVXBkb3duYXJyb3cnLCBbODY2MV1dLCBbJ1VwRXF1aWxpYnJpdW0nLCBbMTA2MDZdXSwgWyd1cGhhcnBvb25sZWZ0JywgWzg2MzldXSwgWyd1cGhhcnBvb25yaWdodCcsIFs4NjM4XV0sIFsndXBsdXMnLCBbODg0Nl1dLCBbJ1VwcGVyTGVmdEFycm93JywgWzg1OThdXSwgWydVcHBlclJpZ2h0QXJyb3cnLCBbODU5OV1dLCBbJ3Vwc2knLCBbOTY1XV0sIFsnVXBzaScsIFs5NzhdXSwgWyd1cHNpaCcsIFs5NzhdXSwgWydVcHNpbG9uJywgWzkzM11dLCBbJ3Vwc2lsb24nLCBbOTY1XV0sIFsnVXBUZWVBcnJvdycsIFs4NjEzXV0sIFsnVXBUZWUnLCBbODg2OV1dLCBbJ3VwdXBhcnJvd3MnLCBbODY0OF1dLCBbJ3VyY29ybicsIFs4OTg5XV0sIFsndXJjb3JuZXInLCBbODk4OV1dLCBbJ3VyY3JvcCcsIFs4OTc0XV0sIFsnVXJpbmcnLCBbMzY2XV0sIFsndXJpbmcnLCBbMzY3XV0sIFsndXJ0cmknLCBbOTcyMV1dLCBbJ1VzY3InLCBbMTE5OTg0XV0sIFsndXNjcicsIFsxMjAwMTBdXSwgWyd1dGRvdCcsIFs4OTQ0XV0sIFsnVXRpbGRlJywgWzM2MF1dLCBbJ3V0aWxkZScsIFszNjFdXSwgWyd1dHJpJywgWzk2NTNdXSwgWyd1dHJpZicsIFs5NjUyXV0sIFsndXVhcnInLCBbODY0OF1dLCBbJ1V1bWwnLCBbMjIwXV0sIFsndXVtbCcsIFsyNTJdXSwgWyd1d2FuZ2xlJywgWzEwNjYzXV0sIFsndmFuZ3J0JywgWzEwNjUyXV0sIFsndmFyZXBzaWxvbicsIFsxMDEzXV0sIFsndmFya2FwcGEnLCBbMTAwOF1dLCBbJ3Zhcm5vdGhpbmcnLCBbODcwOV1dLCBbJ3ZhcnBoaScsIFs5ODFdXSwgWyd2YXJwaScsIFs5ODJdXSwgWyd2YXJwcm9wdG8nLCBbODczM11dLCBbJ3ZhcnInLCBbODU5N11dLCBbJ3ZBcnInLCBbODY2MV1dLCBbJ3ZhcnJobycsIFsxMDA5XV0sIFsndmFyc2lnbWEnLCBbOTYyXV0sIFsndmFyc3Vic2V0bmVxJywgWzg4NDIsIDY1MDI0XV0sIFsndmFyc3Vic2V0bmVxcScsIFsxMDk1NSwgNjUwMjRdXSwgWyd2YXJzdXBzZXRuZXEnLCBbODg0MywgNjUwMjRdXSwgWyd2YXJzdXBzZXRuZXFxJywgWzEwOTU2LCA2NTAyNF1dLCBbJ3ZhcnRoZXRhJywgWzk3N11dLCBbJ3ZhcnRyaWFuZ2xlbGVmdCcsIFs4ODgyXV0sIFsndmFydHJpYW5nbGVyaWdodCcsIFs4ODgzXV0sIFsndkJhcicsIFsxMDk4NF1dLCBbJ1ZiYXInLCBbMTA5ODddXSwgWyd2QmFydicsIFsxMDk4NV1dLCBbJ1ZjeScsIFsxMDQyXV0sIFsndmN5JywgWzEwNzRdXSwgWyd2ZGFzaCcsIFs4ODY2XV0sIFsndkRhc2gnLCBbODg3Ml1dLCBbJ1ZkYXNoJywgWzg4NzNdXSwgWydWRGFzaCcsIFs4ODc1XV0sIFsnVmRhc2hsJywgWzEwOTgyXV0sIFsndmVlYmFyJywgWzg4OTFdXSwgWyd2ZWUnLCBbODc0NF1dLCBbJ1ZlZScsIFs4ODk3XV0sIFsndmVlZXEnLCBbODc5NF1dLCBbJ3ZlbGxpcCcsIFs4OTQyXV0sIFsndmVyYmFyJywgWzEyNF1dLCBbJ1ZlcmJhcicsIFs4MjE0XV0sIFsndmVydCcsIFsxMjRdXSwgWydWZXJ0JywgWzgyMTRdXSwgWydWZXJ0aWNhbEJhcicsIFs4NzM5XV0sIFsnVmVydGljYWxMaW5lJywgWzEyNF1dLCBbJ1ZlcnRpY2FsU2VwYXJhdG9yJywgWzEwMDcyXV0sIFsnVmVydGljYWxUaWxkZScsIFs4NzY4XV0sIFsnVmVyeVRoaW5TcGFjZScsIFs4MjAyXV0sIFsnVmZyJywgWzEyMDA4OV1dLCBbJ3ZmcicsIFsxMjAxMTVdXSwgWyd2bHRyaScsIFs4ODgyXV0sIFsndm5zdWInLCBbODgzNCwgODQwMl1dLCBbJ3Zuc3VwJywgWzg4MzUsIDg0MDJdXSwgWydWb3BmJywgWzEyMDE0MV1dLCBbJ3ZvcGYnLCBbMTIwMTY3XV0sIFsndnByb3AnLCBbODczM11dLCBbJ3ZydHJpJywgWzg4ODNdXSwgWydWc2NyJywgWzExOTk4NV1dLCBbJ3ZzY3InLCBbMTIwMDExXV0sIFsndnN1Ym5FJywgWzEwOTU1LCA2NTAyNF1dLCBbJ3ZzdWJuZScsIFs4ODQyLCA2NTAyNF1dLCBbJ3ZzdXBuRScsIFsxMDk1NiwgNjUwMjRdXSwgWyd2c3VwbmUnLCBbODg0MywgNjUwMjRdXSwgWydWdmRhc2gnLCBbODg3NF1dLCBbJ3Z6aWd6YWcnLCBbMTA2NTBdXSwgWydXY2lyYycsIFszNzJdXSwgWyd3Y2lyYycsIFszNzNdXSwgWyd3ZWRiYXInLCBbMTA4NDddXSwgWyd3ZWRnZScsIFs4NzQzXV0sIFsnV2VkZ2UnLCBbODg5Nl1dLCBbJ3dlZGdlcScsIFs4NzkzXV0sIFsnd2VpZXJwJywgWzg0NzJdXSwgWydXZnInLCBbMTIwMDkwXV0sIFsnd2ZyJywgWzEyMDExNl1dLCBbJ1dvcGYnLCBbMTIwMTQyXV0sIFsnd29wZicsIFsxMjAxNjhdXSwgWyd3cCcsIFs4NDcyXV0sIFsnd3InLCBbODc2OF1dLCBbJ3dyZWF0aCcsIFs4NzY4XV0sIFsnV3NjcicsIFsxMTk5ODZdXSwgWyd3c2NyJywgWzEyMDAxMl1dLCBbJ3hjYXAnLCBbODg5OF1dLCBbJ3hjaXJjJywgWzk3MTFdXSwgWyd4Y3VwJywgWzg4OTldXSwgWyd4ZHRyaScsIFs5NjYxXV0sIFsnWGZyJywgWzEyMDA5MV1dLCBbJ3hmcicsIFsxMjAxMTddXSwgWyd4aGFycicsIFsxMDIzMV1dLCBbJ3hoQXJyJywgWzEwMjM0XV0sIFsnWGknLCBbOTI2XV0sIFsneGknLCBbOTU4XV0sIFsneGxhcnInLCBbMTAyMjldXSwgWyd4bEFycicsIFsxMDIzMl1dLCBbJ3htYXAnLCBbMTAyMzZdXSwgWyd4bmlzJywgWzg5NTVdXSwgWyd4b2RvdCcsIFsxMDc1Ml1dLCBbJ1hvcGYnLCBbMTIwMTQzXV0sIFsneG9wZicsIFsxMjAxNjldXSwgWyd4b3BsdXMnLCBbMTA3NTNdXSwgWyd4b3RpbWUnLCBbMTA3NTRdXSwgWyd4cmFycicsIFsxMDIzMF1dLCBbJ3hyQXJyJywgWzEwMjMzXV0sIFsnWHNjcicsIFsxMTk5ODddXSwgWyd4c2NyJywgWzEyMDAxM11dLCBbJ3hzcWN1cCcsIFsxMDc1OF1dLCBbJ3h1cGx1cycsIFsxMDc1Nl1dLCBbJ3h1dHJpJywgWzk2NTFdXSwgWyd4dmVlJywgWzg4OTddXSwgWyd4d2VkZ2UnLCBbODg5Nl1dLCBbJ1lhY3V0ZScsIFsyMjFdXSwgWyd5YWN1dGUnLCBbMjUzXV0sIFsnWUFjeScsIFsxMDcxXV0sIFsneWFjeScsIFsxMTAzXV0sIFsnWWNpcmMnLCBbMzc0XV0sIFsneWNpcmMnLCBbMzc1XV0sIFsnWWN5JywgWzEwNjddXSwgWyd5Y3knLCBbMTA5OV1dLCBbJ3llbicsIFsxNjVdXSwgWydZZnInLCBbMTIwMDkyXV0sIFsneWZyJywgWzEyMDExOF1dLCBbJ1lJY3knLCBbMTAzMV1dLCBbJ3lpY3knLCBbMTExMV1dLCBbJ1lvcGYnLCBbMTIwMTQ0XV0sIFsneW9wZicsIFsxMjAxNzBdXSwgWydZc2NyJywgWzExOTk4OF1dLCBbJ3lzY3InLCBbMTIwMDE0XV0sIFsnWVVjeScsIFsxMDcwXV0sIFsneXVjeScsIFsxMTAyXV0sIFsneXVtbCcsIFsyNTVdXSwgWydZdW1sJywgWzM3Nl1dLCBbJ1phY3V0ZScsIFszNzddXSwgWyd6YWN1dGUnLCBbMzc4XV0sIFsnWmNhcm9uJywgWzM4MV1dLCBbJ3pjYXJvbicsIFszODJdXSwgWydaY3knLCBbMTA0N11dLCBbJ3pjeScsIFsxMDc5XV0sIFsnWmRvdCcsIFszNzldXSwgWyd6ZG90JywgWzM4MF1dLCBbJ3plZXRyZicsIFs4NDg4XV0sIFsnWmVyb1dpZHRoU3BhY2UnLCBbODIwM11dLCBbJ1pldGEnLCBbOTE4XV0sIFsnemV0YScsIFs5NTBdXSwgWyd6ZnInLCBbMTIwMTE5XV0sIFsnWmZyJywgWzg0ODhdXSwgWydaSGN5JywgWzEwNDZdXSwgWyd6aGN5JywgWzEwNzhdXSwgWyd6aWdyYXJyJywgWzg2NjldXSwgWyd6b3BmJywgWzEyMDE3MV1dLCBbJ1pvcGYnLCBbODQ4NF1dLCBbJ1pzY3InLCBbMTE5OTg5XV0sIFsnenNjcicsIFsxMjAwMTVdXSwgWyd6d2onLCBbODIwNV1dLCBbJ3p3bmonLCBbODIwNF1dXTtcblxudmFyIGFscGhhSW5kZXggPSB7fTtcbnZhciBjaGFySW5kZXggPSB7fTtcblxuY3JlYXRlSW5kZXhlcyhhbHBoYUluZGV4LCBjaGFySW5kZXgpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIdG1sNUVudGl0aWVzKCkge31cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJigjP1tcXHdcXGRdKyk7Py9nLCBmdW5jdGlvbihzLCBlbnRpdHkpIHtcbiAgICAgICAgdmFyIGNocjtcbiAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGVudGl0eS5jaGFyQXQoMSkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigyKS50b0xvd2VyQ2FzZSgpLCAxNikgOlxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMSkpO1xuXG4gICAgICAgICAgICBpZiAoIShpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkpIHtcbiAgICAgICAgICAgICAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyID0gYWxwaGFJbmRleFtlbnRpdHldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHIgfHwgcztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoYXJJbmZvID0gY2hhckluZGV4W3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgaWYgKGNoYXJJbmZvKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBjaGFySW5mb1tzdHIuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbHBoYSA9IGNoYXJJbmZvWycnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBjaGFySW5mbyA9IGNoYXJJbmRleFtjXTtcbiAgICAgICAgaWYgKGNoYXJJbmZvKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBjaGFySW5mb1tzdHIuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbHBoYSA9IGNoYXJJbmZvWycnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMzIgfHwgYyA+IDEyNikge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICBpKytcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGFscGhhSW5kZXggUGFzc2VkIGJ5IHJlZmVyZW5jZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjaGFySW5kZXggUGFzc2VkIGJ5IHJlZmVyZW5jZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5kZXhlcyhhbHBoYUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICB2YXIgaSA9IEVOVElUSUVTLmxlbmd0aDtcbiAgICB2YXIgX3Jlc3VsdHMgPSBbXTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciBlID0gRU5USVRJRVNbaV07XG4gICAgICAgIHZhciBhbHBoYSA9IGVbMF07XG4gICAgICAgIHZhciBjaGFycyA9IGVbMV07XG4gICAgICAgIHZhciBjaHIgPSBjaGFyc1swXTtcbiAgICAgICAgdmFyIGFkZENoYXIgPSAoY2hyIDwgMzIgfHwgY2hyID4gMTI2KSB8fCBjaHIgPT09IDYyIHx8IGNociA9PT0gNjAgfHwgY2hyID09PSAzOCB8fCBjaHIgPT09IDM0IHx8IGNociA9PT0gMzk7XG4gICAgICAgIHZhciBjaGFySW5mbztcbiAgICAgICAgaWYgKGFkZENoYXIpIHtcbiAgICAgICAgICAgIGNoYXJJbmZvID0gY2hhckluZGV4W2Nocl0gPSBjaGFySW5kZXhbY2hyXSB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcnNbMV0pIHtcbiAgICAgICAgICAgIHZhciBjaHIyID0gY2hhcnNbMV07XG4gICAgICAgICAgICBhbHBoYUluZGV4W2FscGhhXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMik7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGFkZENoYXIgJiYgKGNoYXJJbmZvW2NocjJdID0gYWxwaGEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFscGhhSW5kZXhbYWxwaGFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChhZGRDaGFyICYmIChjaGFySW5mb1snJ10gPSBhbHBoYSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWw1RW50aXRpZXM7XG4iLCJ2YXIgbWFwID0ge1xuXHRcIi4vbG9nXCI6IDIyXG59O1xuXG5cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHR2YXIgaWQgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKTtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oaWQpO1xufVxuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHR2YXIgaWQgPSBtYXBbcmVxXTtcblx0aWYoIShpZCArIDEpKSB7IC8vIGNoZWNrIGZvciBudW1iZXIgb3Igc3RyaW5nXG5cdFx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiBpZDtcbn1cbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSAyMTsiLCJ2YXIgbG9nTGV2ZWwgPSBcImluZm9cIjtcblxuZnVuY3Rpb24gZHVtbXkoKSB7fVxuXG5mdW5jdGlvbiBzaG91bGRMb2cobGV2ZWwpIHtcblx0dmFyIHNob3VsZExvZyA9XG5cdFx0KGxvZ0xldmVsID09PSBcImluZm9cIiAmJiBsZXZlbCA9PT0gXCJpbmZvXCIpIHx8XG5cdFx0KFtcImluZm9cIiwgXCJ3YXJuaW5nXCJdLmluZGV4T2YobG9nTGV2ZWwpID49IDAgJiYgbGV2ZWwgPT09IFwid2FybmluZ1wiKSB8fFxuXHRcdChbXCJpbmZvXCIsIFwid2FybmluZ1wiLCBcImVycm9yXCJdLmluZGV4T2YobG9nTGV2ZWwpID49IDAgJiYgbGV2ZWwgPT09IFwiZXJyb3JcIik7XG5cdHJldHVybiBzaG91bGRMb2c7XG59XG5cbmZ1bmN0aW9uIGxvZ0dyb3VwKGxvZ0ZuKSB7XG5cdHJldHVybiBmdW5jdGlvbihsZXZlbCwgbXNnKSB7XG5cdFx0aWYgKHNob3VsZExvZyhsZXZlbCkpIHtcblx0XHRcdGxvZ0ZuKG1zZyk7XG5cdFx0fVxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxldmVsLCBtc2cpIHtcblx0aWYgKHNob3VsZExvZyhsZXZlbCkpIHtcblx0XHRpZiAobGV2ZWwgPT09IFwiaW5mb1wiKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhtc2cpO1xuXHRcdH0gZWxzZSBpZiAobGV2ZWwgPT09IFwid2FybmluZ1wiKSB7XG5cdFx0XHRjb25zb2xlLndhcm4obXNnKTtcblx0XHR9IGVsc2UgaWYgKGxldmVsID09PSBcImVycm9yXCIpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IobXNnKTtcblx0XHR9XG5cdH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGlucyAqL1xudmFyIGdyb3VwID0gY29uc29sZS5ncm91cCB8fCBkdW1teTtcbnZhciBncm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQgfHwgZHVtbXk7XG52YXIgZ3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kIHx8IGR1bW15O1xuLyogZXNsaW50LWVuYWJsZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnMgKi9cblxubW9kdWxlLmV4cG9ydHMuZ3JvdXAgPSBsb2dHcm91cChncm91cCk7XG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwQ29sbGFwc2VkID0gbG9nR3JvdXAoZ3JvdXBDb2xsYXBzZWQpO1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cEVuZCA9IGxvZ0dyb3VwKGdyb3VwRW5kKTtcblxubW9kdWxlLmV4cG9ydHMuc2V0TG9nTGV2ZWwgPSBmdW5jdGlvbihsZXZlbCkge1xuXHRsb2dMZXZlbCA9IGxldmVsO1xufTtcbiIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCIvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RlZmFucGVubmVyL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIHY0LjIuNSs3ZjJiNTI2ZFxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5FUzZQcm9taXNlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgeDtcbiAgcmV0dXJuIHggIT09IG51bGwgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5cblxudmFyIF9pc0FycmF5ID0gdm9pZCAwO1xuaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xufSBlbHNlIHtcbiAgX2lzQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG59XG5cbnZhciBpc0FycmF5ID0gX2lzQXJyYXk7XG5cbnZhciBsZW4gPSAwO1xudmFyIHZlcnR4TmV4dCA9IHZvaWQgMDtcbnZhciBjdXN0b21TY2hlZHVsZXJGbiA9IHZvaWQgMDtcblxudmFyIGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgcXVldWVbbGVuXSA9IGNhbGxiYWNrO1xuICBxdWV1ZVtsZW4gKyAxXSA9IGFyZztcbiAgbGVuICs9IDI7XG4gIGlmIChsZW4gPT09IDIpIHtcbiAgICAvLyBJZiBsZW4gaXMgMiwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgaWYgKGN1c3RvbVNjaGVkdWxlckZuKSB7XG4gICAgICBjdXN0b21TY2hlZHVsZXJGbihmbHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG4gIGN1c3RvbVNjaGVkdWxlckZuID0gc2NoZWR1bGVGbjtcbn1cblxuZnVuY3Rpb24gc2V0QXNhcChhc2FwRm4pIHtcbiAgYXNhcCA9IGFzYXBGbjtcbn1cblxudmFyIGJyb3dzZXJXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbnZhciBicm93c2VyR2xvYmFsID0gYnJvd3NlcldpbmRvdyB8fCB7fTtcbnZhciBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgaXNOb2RlID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbi8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBub2RlXG5mdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcbiAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbn1cblxuLy8gdmVydHhcbmZ1bmN0aW9uIHVzZVZlcnR4VGltZXIoKSB7XG4gIGlmICh0eXBlb2YgdmVydHhOZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2ZXJ0eE5leHQoZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIG5vZGUuZGF0YSA9IGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyO1xuICB9O1xufVxuXG4vLyB3ZWIgd29ya2VyXG5mdW5jdGlvbiB1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU2V0VGltZW91dCgpIHtcbiAgLy8gU3RvcmUgc2V0VGltZW91dCByZWZlcmVuY2Ugc28gZXM2LXByb21pc2Ugd2lsbCBiZSB1bmFmZmVjdGVkIGJ5XG4gIC8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxuICB2YXIgZ2xvYmFsU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbFNldFRpbWVvdXQoZmx1c2gsIDEpO1xuICB9O1xufVxuXG52YXIgcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgIHZhciBhcmcgPSBxdWV1ZVtpICsgMV07XG5cbiAgICBjYWxsYmFjayhhcmcpO1xuXG4gICAgcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgcXVldWVbaSArIDFdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFZlcnR4KCkge1xuICB0cnkge1xuICAgIHZhciB2ZXJ0eCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCkucmVxdWlyZSgndmVydHgnKTtcbiAgICB2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgIHJldHVybiB1c2VWZXJ0eFRpbWVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xuICB9XG59XG5cbnZhciBzY2hlZHVsZUZsdXNoID0gdm9pZCAwO1xuLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbmlmIChpc05vZGUpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG59IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG59IGVsc2UgaWYgKGlzV29ya2VyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNZXNzYWdlQ2hhbm5lbCgpO1xufSBlbHNlIGlmIChicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgcGFyZW50ID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgfVxuXG4gIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG5cbiAgaWYgKF9zdGF0ZSkge1xuICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1tfc3RhdGUgLSAxXTtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjayhfc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcGFyZW50Ll9yZXN1bHQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gIH1cblxuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZXNvbHZlYCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIHJlc29sdmVkIHdpdGggdGhlXG4gIHBhc3NlZCBgdmFsdWVgLiBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVzb2x2ZSgxKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoMSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZXNvbHZlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgZnVsZmlsbGVkIHdpdGggdGhlIGdpdmVuXG4gIGB2YWx1ZWBcbiovXG5mdW5jdGlvbiByZXNvbHZlJDEob2JqZWN0KSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBQRU5ESU5HID0gdm9pZCAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xuXG52YXIgVFJZX0NBVENIX0VSUk9SID0geyBlcnJvcjogbnVsbCB9O1xuXG5mdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKHByb21pc2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGVycm9yO1xuICAgIHJldHVybiBUUllfQ0FUQ0hfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VGhlbih0aGVuJCQxLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gIHRyeSB7XG4gICAgdGhlbiQkMS5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGFzYXAoZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gdHJ5VGhlbih0aGVuJCQxLCB0aGVuYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH1cbiAgfSwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQxID09PSB0aGVuICYmIG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoZW4kJDEgPT09IFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIFRSWV9DQVRDSF9FUlJPUi5lcnJvcik7XG4gICAgICBUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodGhlbiQkMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGVuJCQxKSkge1xuICAgICAgaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBzZWxmRnVsZmlsbG1lbnQoKSk7XG4gIH0gZWxzZSBpZiAob2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlLCBnZXRUaGVuKHZhbHVlKSk7XG4gIH0gZWxzZSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICB9XG5cbiAgcHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cbiAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzYXAocHVibGlzaCwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cblxuICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gIF9zdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSA9IG9uUmVqZWN0aW9uO1xuXG4gIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMCxcbiAgICAgIGNhbGxiYWNrID0gdm9pZCAwLFxuICAgICAgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgVFJZX0NBVENIX0VSUk9SLmVycm9yID0gZTtcbiAgICByZXR1cm4gVFJZX0NBVENIX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdmFyIGhhc0NhbGxiYWNrID0gaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICB2YWx1ZSA9IHZvaWQgMCxcbiAgICAgIGVycm9yID0gdm9pZCAwLFxuICAgICAgc3VjY2VlZGVkID0gdm9pZCAwLFxuICAgICAgZmFpbGVkID0gdm9pZCAwO1xuXG4gIGlmIChoYXNDYWxsYmFjaykge1xuICAgIHZhbHVlID0gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCk7XG5cbiAgICBpZiAodmFsdWUgPT09IFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgIGVycm9yID0gdmFsdWUuZXJyb3I7XG4gICAgICB2YWx1ZS5lcnJvciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gbm9vcFxuICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gIHRyeSB7XG4gICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcbiAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBlKTtcbiAgfVxufVxuXG52YXIgaWQgPSAwO1xuZnVuY3Rpb24gbmV4dElkKCkge1xuICByZXR1cm4gaWQrKztcbn1cblxuZnVuY3Rpb24gbWFrZVByb21pc2UocHJvbWlzZSkge1xuICBwcm9taXNlW1BST01JU0VfSURdID0gaWQrKztcbiAgcHJvbWlzZS5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbn1cblxudmFyIEVudW1lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gICAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcblxuICAgIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG4gICAgICBtYWtlUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgICAgdGhpcy5fZW51bWVyYXRlKGlucHV0KTtcbiAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcbiAgICB9XG4gIH1cblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24gX2VudW1lcmF0ZShpbnB1dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gUEVORElORyAmJiBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2VhY2hFbnRyeShpbnB1dFtpXSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbiBfZWFjaEVudHJ5KGVudHJ5LCBpKSB7XG4gICAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuICAgIHZhciByZXNvbHZlJCQxID0gYy5yZXNvbHZlO1xuXG5cbiAgICBpZiAocmVzb2x2ZSQkMSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgICB2YXIgX3RoZW4gPSBnZXRUaGVuKGVudHJ5KTtcblxuICAgICAgaWYgKF90aGVuID09PSB0aGVuICYmIGVudHJ5Ll9zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSQxKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIF90aGVuKTtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHByb21pc2UsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KG5ldyBjKGZ1bmN0aW9uIChyZXNvbHZlJCQxKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUkJDEoZW50cnkpO1xuICAgICAgICB9KSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChyZXNvbHZlJCQxKGVudHJ5KSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbiBfc2V0dGxlZEF0KHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG5cbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgICBpZiAoc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiBfd2lsbFNldHRsZUF0KHByb21pc2UsIGkpIHtcbiAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICBzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRW51bWVyYXRvcjtcbn0oKTtcblxuLyoqXG4gIGBQcm9taXNlLmFsbGAgYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9taXNlcywgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaFxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXMgZm9yIHRoZSBwYXNzZWQgcHJvbWlzZXMsIG9yXG4gIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuICBlbGVtZW50cyBvZiB0aGUgcGFzc2VkIGl0ZXJhYmxlIHRvIHByb21pc2VzIGFzIGl0IHJ1bnMgdGhpcyBhbGdvcml0aG0uXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlc29sdmUoMik7XG4gIGxldCBwcm9taXNlMyA9IHJlc29sdmUoMyk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgfSk7XG4gIGBgYFxuXG4gIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgbGV0IHByb21pc2UzID0gcmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gZW50cmllcyBhcnJheSBvZiBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICBAc3RhdGljXG4qL1xuZnVuY3Rpb24gYWxsKGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yYWNlYCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2ggaXMgc2V0dGxlZCBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlXG4gIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMicpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFByb21pc2UucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdFxuICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG4gIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IHNldHRsZWQgcHJvbWlzZSBoYXNcbiAgYmVjb21lIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvbWlzZSAyJykpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICB9KTtcbiAgYGBgXG5cbiAgQW4gZXhhbXBsZSByZWFsLXdvcmxkIHVzZSBjYXNlIGlzIGltcGxlbWVudGluZyB0aW1lb3V0czpcblxuICBgYGBqYXZhc2NyaXB0XG4gIFByb21pc2UucmFjZShbYWpheCgnZm9vLmpzb24nKSwgdGltZW91dCg1MDAwKV0pXG4gIGBgYFxuXG4gIEBtZXRob2QgcmFjZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuICBwcm9taXNlIHRvIHNldHRsZS5cbiovXG5mdW5jdGlvbiByYWNlKGVudHJpZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkoZW50cmllcykpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5mdW5jdGlvbiByZWplY3QkMShyZWFzb24pIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbmVlZHNSZXNvbHZlcigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xufVxuXG5mdW5jdGlvbiBuZWVkc05ldygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbn1cblxuLyoqXG4gIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gIFRlcm1pbm9sb2d5XG4gIC0tLS0tLS0tLS0tXG5cbiAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgQmFzaWMgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLVxuXG4gIGBgYGpzXG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gb24gc3VjY2Vzc1xuICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgLy8gb24gZmFpbHVyZVxuICAgIHJlamVjdChyZWFzb24pO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIEFkdmFuY2VkIFVzYWdlOlxuICAtLS0tLS0tLS0tLS0tLS1cblxuICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICBgYGBqc1xuICBQcm9taXNlLmFsbChbXG4gICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KTtcbiAgYGBgXG5cbiAgQGNsYXNzIFByb21pc2VcbiAgQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZXJcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAY29uc3RydWN0b3JcbiovXG5cbnZhciBQcm9taXNlJDEgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICB0aGlzW1BST01JU0VfSURdID0gbmV4dElkKCk7XG4gICAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgIGlmIChub29wICE9PSByZXNvbHZlcikge1xuICAgICAgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nICYmIG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gIH0pO1xuICBgYGBcbiAgIENoYWluaW5nXG4gIC0tLS0tLS0tXG4gICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gIH0pO1xuICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgfSk7XG4gIGBgYFxuICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgQXNzaW1pbGF0aW9uXG4gIC0tLS0tLS0tLS0tLVxuICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gIH0pO1xuICBgYGBcbiAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgU2ltcGxlIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IHJlc3VsdDtcbiAgIHRyeSB7XG4gICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyBmYWlsdXJlXG4gIH0pO1xuICBgYGBcbiAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IGF1dGhvciwgYm9va3M7XG4gICB0cnkge1xuICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG4gICB9XG4gICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuICAgfVxuICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgaWYgKGVycikge1xuICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICB9XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfVxuICB9KTtcbiAgYGBgXG4gICBQcm9taXNlIEV4YW1wbGU7XG4gICBgYGBqYXZhc2NyaXB0XG4gIGZpbmRBdXRob3IoKS5cbiAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgIC8vIGZvdW5kIGJvb2tzXG4gIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfSk7XG4gIGBgYFxuICAgQG1ldGhvZCB0aGVuXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG4gIC8qKlxuICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gIH1cbiAgLy8gc3luY2hyb25vdXNcbiAgdHJ5IHtcbiAgZmluZEF1dGhvcigpO1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9XG4gIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgQG1ldGhvZCBjYXRjaFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgIGBmaW5hbGx5YCB3aWxsIGJlIGludm9rZWQgcmVnYXJkbGVzcyBvZiB0aGUgcHJvbWlzZSdzIGZhdGUganVzdCBhcyBuYXRpdmVcbiAgICB0cnkvY2F0Y2gvZmluYWxseSBiZWhhdmVzXG4gIFxuICAgIFN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpIHtcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBdXRob3IoKTtcbiAgICB9XG4gIFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZmluZEF1dGhvcigpOyAvLyBzdWNjZWVkIG9yIGZhaWxcbiAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIGFsd2F5cyBydW5zXG4gICAgICAvLyBkb2Vzbid0IGFmZmVjdCB0aGUgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBBc3luY2hyb25vdXMgZXhhbXBsZTpcbiAgXG4gICAgYGBganNcbiAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIHJldHVybiBmaW5kT3RoZXJBdXRoZXIoKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCl7XG4gICAgICAvLyBhdXRob3Igd2FzIGVpdGhlciBmb3VuZCwgb3Igbm90XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgZmluYWxseVxuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuXG4gIFByb21pc2UucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbiBfZmluYWxseShjYWxsYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwcm9taXNlLmNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihjYWxsYmFjaywgY2FsbGJhY2spO1xuICB9O1xuXG4gIHJldHVybiBQcm9taXNlO1xufSgpO1xuXG5Qcm9taXNlJDEucHJvdG90eXBlLnRoZW4gPSB0aGVuO1xuUHJvbWlzZSQxLmFsbCA9IGFsbDtcblByb21pc2UkMS5yYWNlID0gcmFjZTtcblByb21pc2UkMS5yZXNvbHZlID0gcmVzb2x2ZSQxO1xuUHJvbWlzZSQxLnJlamVjdCA9IHJlamVjdCQxO1xuUHJvbWlzZSQxLl9zZXRTY2hlZHVsZXIgPSBzZXRTY2hlZHVsZXI7XG5Qcm9taXNlJDEuX3NldEFzYXAgPSBzZXRBc2FwO1xuUHJvbWlzZSQxLl9hc2FwID0gYXNhcDtcblxuLypnbG9iYWwgc2VsZiovXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgdmFyIGxvY2FsID0gdm9pZCAwO1xuXG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsID0gc2VsZjtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgbG9jYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXG4gIGlmIChQKSB7XG4gICAgdmFyIHByb21pc2VUb1N0cmluZyA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2VUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gc2lsZW50bHkgaWdub3JlZFxuICAgIH1cblxuICAgIGlmIChwcm9taXNlVG9TdHJpbmcgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbG9jYWwuUHJvbWlzZSA9IFByb21pc2UkMTtcbn1cblxuLy8gU3RyYW5nZSBjb21wYXQuLlxuUHJvbWlzZSQxLnBvbHlmaWxsID0gcG9seWZpbGw7XG5Qcm9taXNlJDEuUHJvbWlzZSA9IFByb21pc2UkMTtcblxucmV0dXJuIFByb21pc2UkMTtcblxufSkpKTtcblxuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzNi1wcm9taXNlLm1hcFxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMjhfXzsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7d2luZG93IGFzIHdpbiwgZG9jdW1lbnQgYXMgZG9jfSBmcm9tIFwiLi9icm93c2VyXCI7XG5cbndpbi5GbG9hdDMyQXJyYXkgPSAodHlwZW9mIHdpbi5GbG9hdDMyQXJyYXkgIT09IFwidW5kZWZpbmVkXCIpID8gd2luLkZsb2F0MzJBcnJheSA6IHdpbi5BcnJheTtcblxuY29uc3QgRmxvYXQzMkFycmF5ID0gd2luLkZsb2F0MzJBcnJheTtcbmNvbnN0IGdldENvbXB1dGVkU3R5bGUgPSB3aW4uZ2V0Q29tcHV0ZWRTdHlsZTtcbmNvbnN0IHVzZXJBZ2VudCA9IHdpbi5uYXZpZ2F0b3IudXNlckFnZW50O1xuY29uc3QgU1VQUE9SVF9UT1VDSCA9IFwib250b3VjaHN0YXJ0XCIgaW4gd2luO1xuY29uc3QgU1VQUE9SVF9ERVZJQ0VNT1RJT04gPSBcIm9uZGV2aWNlbW90aW9uXCIgaW4gd2luO1xuY29uc3QgRGV2aWNlTW90aW9uRXZlbnQgPSB3aW4uRGV2aWNlTW90aW9uRXZlbnQ7XG5jb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gd2luLmRldmljZVBpeGVsUmF0aW87XG5cbmNvbnN0IFRSQU5TRk9STSA9IChmdW5jdGlvbigpIHtcblx0Y29uc3QgZG9jU3R5bGUgPSBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuXHRjb25zdCB0YXJnZXQgPSBbXCJ0cmFuc2Zvcm1cIiwgXCJ3ZWJraXRUcmFuc2Zvcm1cIiwgXCJtc1RyYW5zZm9ybVwiLCBcIm1velRyYW5zZm9ybVwiXTtcblxuXHRmb3IgKGxldCBpID0gMCwgbGVuID0gdGFyZ2V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0aWYgKHRhcmdldFtpXSBpbiBkb2NTdHlsZSkge1xuXHRcdFx0cmV0dXJuIHRhcmdldFtpXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIFwiXCI7XG59KSgpO1xuXG4vLyBjaGVjayBmb3Igd2lsbC1jaGFuZ2Ugc3VwcG9ydFxuY29uc3QgU1VQUE9SVF9XSUxMQ0hBTkdFID0gd2luLkNTUyAmJiB3aW4uQ1NTLnN1cHBvcnRzICYmXG5cdHdpbi5DU1Muc3VwcG9ydHMoXCJ3aWxsLWNoYW5nZVwiLCBcInRyYW5zZm9ybVwiKTtcblxuZXhwb3J0IHtcblx0RmxvYXQzMkFycmF5LFxuXHRnZXRDb21wdXRlZFN0eWxlLFxuXHR1c2VyQWdlbnQsXG5cdFRSQU5TRk9STSxcblx0U1VQUE9SVF9UT1VDSCxcblx0U1VQUE9SVF9ERVZJQ0VNT1RJT04sXG5cdFNVUFBPUlRfV0lMTENIQU5HRSxcblx0RGV2aWNlTW90aW9uRXZlbnQsXG5cdGRldmljZVBpeGVsUmF0aW9cbn07XG5cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IE5BVkVSIENvcnAuXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMsIG5vLW5lc3RlZC10ZXJuYXJ5ICovXG5jb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5NYXRoID09PSBNYXRoID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5NYXRoID09PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbi8qIGVzbGludC1lbmFibGUgbm8tbmV3LWZ1bmMsIG5vLW5lc3RlZC10ZXJuYXJ5ICovXG5cbmNvbnN0IGRvYyA9IHdpbi5kb2N1bWVudDtcbmNvbnN0IHVzZXJBZ2VudCA9IHdpbi5uYXZpZ2F0b3IudXNlckFnZW50O1xuY29uc3QgSVNfU0FGQVJJX09OX0RFU0tUT1AgPVxuXHR1c2VyQWdlbnQuaW5kZXhPZihcIlNhZmFyaVwiKSAhPT0gLTEgJiZcblx0dXNlckFnZW50LmluZGV4T2YoXCJDaHJvbWVcIikgPT09IC0xICYmXG5cdHVzZXJBZ2VudC5pbmRleE9mKFwiTWFjIE9TIFhcIikgIT09IC0xO1xuXG5leHBvcnQge1xuXHR3aW4gYXMgd2luZG93LFxuXHRkb2MgYXMgZG9jdW1lbnQsXG5cdElTX1NBRkFSSV9PTl9ERVNLVE9QXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zMV9fOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgTWF0aFV0aWwgPSByZXF1aXJlKCcuLi9tYXRoLXV0aWwnKTtcbnZhciBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG4vKipcbiAqIEdpdmVuIGFuIG9yaWVudGF0aW9uIGFuZCB0aGUgZ3lyb3Njb3BlIGRhdGEsIHByZWRpY3RzIHRoZSBmdXR1cmUgb3JpZW50YXRpb25cbiAqIG9mIHRoZSBoZWFkLiBUaGlzIG1ha2VzIHJlbmRlcmluZyBhcHBlYXIgZmFzdGVyLlxuICpcbiAqIEFsc28gc2VlOiBodHRwOi8vbXNsLmNzLnVpdWMuZWR1L35sYXZhbGxlL3BhcGVycy9MYXZZZXJLYXRBbnQxNC5wZGZcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gcHJlZGljdGlvblRpbWVTIHRpbWUgZnJvbSBoZWFkIG1vdmVtZW50IHRvIHRoZSBhcHBlYXJhbmNlIG9mXG4gKiB0aGUgY29ycmVzcG9uZGluZyBpbWFnZS5cbiAqL1xuZnVuY3Rpb24gUG9zZVByZWRpY3RvcihwcmVkaWN0aW9uVGltZVMpIHtcbiAgdGhpcy5wcmVkaWN0aW9uVGltZVMgPSBwcmVkaWN0aW9uVGltZVM7XG5cbiAgLy8gVGhlIHF1YXRlcm5pb24gY29ycmVzcG9uZGluZyB0byB0aGUgcHJldmlvdXMgc3RhdGUuXG4gIHRoaXMucHJldmlvdXNRID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcbiAgLy8gUHJldmlvdXMgdGltZSBhIHByZWRpY3Rpb24gb2NjdXJyZWQuXG4gIHRoaXMucHJldmlvdXNUaW1lc3RhbXBTID0gbnVsbDtcblxuICAvLyBUaGUgZGVsdGEgcXVhdGVybmlvbiB0aGF0IGFkanVzdHMgdGhlIGN1cnJlbnQgcG9zZS5cbiAgdGhpcy5kZWx0YVEgPSBuZXcgTWF0aFV0aWwuUXVhdGVybmlvbigpO1xuICAvLyBUaGUgb3V0cHV0IHF1YXRlcm5pb24uXG4gIHRoaXMub3V0USA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG59XG5cblBvc2VQcmVkaWN0b3IucHJvdG90eXBlLmdldFByZWRpY3Rpb24gPSBmdW5jdGlvbihjdXJyZW50USwgZ3lybywgdGltZXN0YW1wUykge1xuICBpZiAoIXRoaXMucHJldmlvdXNUaW1lc3RhbXBTKSB7XG4gICAgdGhpcy5wcmV2aW91c1EuY29weShjdXJyZW50USk7XG4gICAgdGhpcy5wcmV2aW91c1RpbWVzdGFtcFMgPSB0aW1lc3RhbXBTO1xuICAgIHJldHVybiBjdXJyZW50UTtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBheGlzIGFuZCBhbmdsZSBiYXNlZCBvbiBneXJvc2NvcGUgcm90YXRpb24gcmF0ZSBkYXRhLlxuICB2YXIgYXhpcyA9IG5ldyBNYXRoVXRpbC5WZWN0b3IzKCk7XG4gIGF4aXMuY29weShneXJvKTtcbiAgYXhpcy5ub3JtYWxpemUoKTtcblxuICB2YXIgYW5ndWxhclNwZWVkID0gZ3lyby5sZW5ndGgoKTtcblxuICAvLyBJZiB3ZSdyZSByb3RhdGluZyBzbG93bHksIGRvbid0IGRvIHByZWRpY3Rpb24uXG4gIGlmIChhbmd1bGFyU3BlZWQgPCBNYXRoVXRpbC5kZWdUb1JhZCAqIDIwKSB7XG4gICAgaWYgKFV0aWwuaXNEZWJ1ZygpKSB7XG4gICAgICBjb25zb2xlLmxvZygnTW92aW5nIHNsb3dseSwgYXQgJXMgZGVnL3M6IG5vIHByZWRpY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgKE1hdGhVdGlsLnJhZFRvRGVnICogYW5ndWxhclNwZWVkKS50b0ZpeGVkKDEpKTtcbiAgICB9XG4gICAgdGhpcy5vdXRRLmNvcHkoY3VycmVudFEpO1xuICAgIHRoaXMucHJldmlvdXNRLmNvcHkoY3VycmVudFEpO1xuICAgIHJldHVybiB0aGlzLm91dFE7XG4gIH1cblxuICAvLyBHZXQgdGhlIHByZWRpY3RlZCBhbmdsZSBiYXNlZCBvbiB0aGUgdGltZSBkZWx0YSBhbmQgbGF0ZW5jeS5cbiAgdmFyIGRlbHRhVCA9IHRpbWVzdGFtcFMgLSB0aGlzLnByZXZpb3VzVGltZXN0YW1wUztcbiAgdmFyIHByZWRpY3RBbmdsZSA9IGFuZ3VsYXJTcGVlZCAqIHRoaXMucHJlZGljdGlvblRpbWVTO1xuXG4gIHRoaXMuZGVsdGFRLnNldEZyb21BeGlzQW5nbGUoYXhpcywgcHJlZGljdEFuZ2xlKTtcbiAgdGhpcy5vdXRRLmNvcHkodGhpcy5wcmV2aW91c1EpO1xuICB0aGlzLm91dFEubXVsdGlwbHkodGhpcy5kZWx0YVEpO1xuXG4gIHRoaXMucHJldmlvdXNRLmNvcHkoY3VycmVudFEpO1xuICB0aGlzLnByZXZpb3VzVGltZXN0YW1wUyA9IHRpbWVzdGFtcFM7XG5cbiAgcmV0dXJuIHRoaXMub3V0UTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQb3NlUHJlZGljdG9yO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIE1hdGhVdGlsID0gd2luZG93Lk1hdGhVdGlsIHx8IHt9O1xuXG5NYXRoVXRpbC5kZWdUb1JhZCA9IE1hdGguUEkgLyAxODA7XG5NYXRoVXRpbC5yYWRUb0RlZyA9IDE4MCAvIE1hdGguUEk7XG5cbi8vIFNvbWUgbWluaW1hbCBtYXRoIGZ1bmN0aW9uYWxpdHkgYm9ycm93ZWQgZnJvbSBUSFJFRS5NYXRoIGFuZCBzdHJpcHBlZCBkb3duXG4vLyBmb3IgdGhlIHB1cnBvc2VzIG9mIHRoaXMgbGlicmFyeS5cblxuXG5NYXRoVXRpbC5WZWN0b3IyID0gZnVuY3Rpb24gKCB4LCB5ICkge1xuICB0aGlzLnggPSB4IHx8IDA7XG4gIHRoaXMueSA9IHkgfHwgMDtcbn07XG5cbk1hdGhVdGlsLlZlY3RvcjIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTWF0aFV0aWwuVmVjdG9yMixcblxuICBzZXQ6IGZ1bmN0aW9uICggeCwgeSApIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG4gICAgdGhpcy54ID0gdi54O1xuICAgIHRoaXMueSA9IHYueTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcbiAgICB0aGlzLnggPSBhLnggLSBiLng7XG4gICAgdGhpcy55ID0gYS55IC0gYi55O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG59O1xuXG5NYXRoVXRpbC5WZWN0b3IzID0gZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuICB0aGlzLnggPSB4IHx8IDA7XG4gIHRoaXMueSA9IHkgfHwgMDtcbiAgdGhpcy56ID0geiB8fCAwO1xufTtcblxuTWF0aFV0aWwuVmVjdG9yMy5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBNYXRoVXRpbC5WZWN0b3IzLFxuXG4gIHNldDogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnogPSB6O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCB2ICkge1xuICAgIHRoaXMueCA9IHYueDtcbiAgICB0aGlzLnkgPSB2Lnk7XG4gICAgdGhpcy56ID0gdi56O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XG4gIH0sXG5cbiAgbm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjYWxhciA9IHRoaXMubGVuZ3RoKCk7XG5cbiAgICBpZiAoIHNjYWxhciAhPT0gMCApIHtcbiAgICAgIHZhciBpbnZTY2FsYXIgPSAxIC8gc2NhbGFyO1xuXG4gICAgICB0aGlzLm11bHRpcGx5U2NhbGFyKGludlNjYWxhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueCA9IDA7XG4gICAgICB0aGlzLnkgPSAwO1xuICAgICAgdGhpcy56ID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG4gICAgdGhpcy54ICo9IHNjYWxhcjtcbiAgICB0aGlzLnkgKj0gc2NhbGFyO1xuICAgIHRoaXMueiAqPSBzY2FsYXI7XG4gIH0sXG5cbiAgYXBwbHlRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHogPSB0aGlzLno7XG5cbiAgICB2YXIgcXggPSBxLng7XG4gICAgdmFyIHF5ID0gcS55O1xuICAgIHZhciBxeiA9IHEuejtcbiAgICB2YXIgcXcgPSBxLnc7XG5cbiAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY3RvclxuICAgIHZhciBpeCA9ICBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG4gICAgdmFyIGl5ID0gIHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcbiAgICB2YXIgaXogPSAgcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICAgIHZhciBpdyA9IC0gcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC0gcXggKyBpeSAqIC0gcXogLSBpeiAqIC0gcXk7XG4gICAgdGhpcy55ID0gaXkgKiBxdyArIGl3ICogLSBxeSArIGl6ICogLSBxeCAtIGl4ICogLSBxejtcbiAgICB0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtIHF6ICsgaXggKiAtIHF5IC0gaXkgKiAtIHF4O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZG90OiBmdW5jdGlvbiAoIHYgKSB7XG4gICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcbiAgfSxcblxuICBjcm9zc1ZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcbiAgICB2YXIgYXggPSBhLngsIGF5ID0gYS55LCBheiA9IGEuejtcbiAgICB2YXIgYnggPSBiLngsIGJ5ID0gYi55LCBieiA9IGIuejtcblxuICAgIHRoaXMueCA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgIHRoaXMueSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICAgIHRoaXMueiA9IGF4ICogYnkgLSBheSAqIGJ4O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG59O1xuXG5NYXRoVXRpbC5RdWF0ZXJuaW9uID0gZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuICB0aGlzLnggPSB4IHx8IDA7XG4gIHRoaXMueSA9IHkgfHwgMDtcbiAgdGhpcy56ID0geiB8fCAwO1xuICB0aGlzLncgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XG59O1xuXG5NYXRoVXRpbC5RdWF0ZXJuaW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IE1hdGhVdGlsLlF1YXRlcm5pb24sXG5cbiAgc2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueiA9IHo7XG4gICAgdGhpcy53ID0gdztcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcbiAgICB0aGlzLnggPSBxdWF0ZXJuaW9uLng7XG4gICAgdGhpcy55ID0gcXVhdGVybmlvbi55O1xuICAgIHRoaXMueiA9IHF1YXRlcm5pb24uejtcbiAgICB0aGlzLncgPSBxdWF0ZXJuaW9uLnc7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzZXRGcm9tRXVsZXJYWVo6IGZ1bmN0aW9uKCB4LCB5LCB6ICkge1xuICAgIHZhciBjMSA9IE1hdGguY29zKCB4IC8gMiApO1xuICAgIHZhciBjMiA9IE1hdGguY29zKCB5IC8gMiApO1xuICAgIHZhciBjMyA9IE1hdGguY29zKCB6IC8gMiApO1xuICAgIHZhciBzMSA9IE1hdGguc2luKCB4IC8gMiApO1xuICAgIHZhciBzMiA9IE1hdGguc2luKCB5IC8gMiApO1xuICAgIHZhciBzMyA9IE1hdGguc2luKCB6IC8gMiApO1xuXG4gICAgdGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgIHRoaXMueSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICB0aGlzLnogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc2V0RnJvbUV1bGVyWVhaOiBmdW5jdGlvbiggeCwgeSwgeiApIHtcbiAgICB2YXIgYzEgPSBNYXRoLmNvcyggeCAvIDIgKTtcbiAgICB2YXIgYzIgPSBNYXRoLmNvcyggeSAvIDIgKTtcbiAgICB2YXIgYzMgPSBNYXRoLmNvcyggeiAvIDIgKTtcbiAgICB2YXIgczEgPSBNYXRoLnNpbiggeCAvIDIgKTtcbiAgICB2YXIgczIgPSBNYXRoLnNpbiggeSAvIDIgKTtcbiAgICB2YXIgczMgPSBNYXRoLnNpbiggeiAvIDIgKTtcblxuICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHNldEZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG4gICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuICAgIC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXG5cbiAgICB2YXIgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLCBzID0gTWF0aC5zaW4oIGhhbGZBbmdsZSApO1xuXG4gICAgdGhpcy54ID0gYXhpcy54ICogcztcbiAgICB0aGlzLnkgPSBheGlzLnkgKiBzO1xuICAgIHRoaXMueiA9IGF4aXMueiAqIHM7XG4gICAgdGhpcy53ID0gTWF0aC5jb3MoIGhhbGZBbmdsZSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgbXVsdGlwbHk6IGZ1bmN0aW9uICggcSApIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XG4gIH0sXG5cbiAgbXVsdGlwbHlRdWF0ZXJuaW9uczogZnVuY3Rpb24gKCBhLCBiICkge1xuICAgIC8vIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9jb2RlL2luZGV4Lmh0bVxuXG4gICAgdmFyIHFheCA9IGEueCwgcWF5ID0gYS55LCBxYXogPSBhLnosIHFhdyA9IGEudztcbiAgICB2YXIgcWJ4ID0gYi54LCBxYnkgPSBiLnksIHFieiA9IGIueiwgcWJ3ID0gYi53O1xuXG4gICAgdGhpcy54ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xuICAgIHRoaXMueSA9IHFheSAqIHFidyArIHFhdyAqIHFieSArIHFheiAqIHFieCAtIHFheCAqIHFiejtcbiAgICB0aGlzLnogPSBxYXogKiBxYncgKyBxYXcgKiBxYnogKyBxYXggKiBxYnkgLSBxYXkgKiBxYng7XG4gICAgdGhpcy53ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgaW52ZXJzZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMueCAqPSAtMTtcbiAgICB0aGlzLnkgKj0gLTE7XG4gICAgdGhpcy56ICo9IC0xO1xuXG4gICAgdGhpcy5ub3JtYWxpemUoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBsID0gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncgKTtcblxuICAgIGlmICggbCA9PT0gMCApIHtcbiAgICAgIHRoaXMueCA9IDA7XG4gICAgICB0aGlzLnkgPSAwO1xuICAgICAgdGhpcy56ID0gMDtcbiAgICAgIHRoaXMudyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSAxIC8gbDtcblxuICAgICAgdGhpcy54ID0gdGhpcy54ICogbDtcbiAgICAgIHRoaXMueSA9IHRoaXMueSAqIGw7XG4gICAgICB0aGlzLnogPSB0aGlzLnogKiBsO1xuICAgICAgdGhpcy53ID0gdGhpcy53ICogbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzbGVycDogZnVuY3Rpb24gKCBxYiwgdCApIHtcbiAgICBpZiAoIHQgPT09IDAgKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIHQgPT09IDEgKSByZXR1cm4gdGhpcy5jb3B5KCBxYiApO1xuXG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLnosIHcgPSB0aGlzLnc7XG5cbiAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL3NsZXJwL1xuXG4gICAgdmFyIGNvc0hhbGZUaGV0YSA9IHcgKiBxYi53ICsgeCAqIHFiLnggKyB5ICogcWIueSArIHogKiBxYi56O1xuXG4gICAgaWYgKCBjb3NIYWxmVGhldGEgPCAwICkge1xuICAgICAgdGhpcy53ID0gLSBxYi53O1xuICAgICAgdGhpcy54ID0gLSBxYi54O1xuICAgICAgdGhpcy55ID0gLSBxYi55O1xuICAgICAgdGhpcy56ID0gLSBxYi56O1xuXG4gICAgICBjb3NIYWxmVGhldGEgPSAtIGNvc0hhbGZUaGV0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb3B5KCBxYiApO1xuICAgIH1cblxuICAgIGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcbiAgICAgIHRoaXMudyA9IHc7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHRoaXMueiA9IHo7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBoYWxmVGhldGEgPSBNYXRoLmFjb3MoIGNvc0hhbGZUaGV0YSApO1xuICAgIHZhciBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIDEuMCAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YSApO1xuXG4gICAgaWYgKCBNYXRoLmFicyggc2luSGFsZlRoZXRhICkgPCAwLjAwMSApIHtcbiAgICAgIHRoaXMudyA9IDAuNSAqICggdyArIHRoaXMudyApO1xuICAgICAgdGhpcy54ID0gMC41ICogKCB4ICsgdGhpcy54ICk7XG4gICAgICB0aGlzLnkgPSAwLjUgKiAoIHkgKyB0aGlzLnkgKTtcbiAgICAgIHRoaXMueiA9IDAuNSAqICggeiArIHRoaXMueiApO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxuICAgIHJhdGlvQiA9IE1hdGguc2luKCB0ICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGE7XG5cbiAgICB0aGlzLncgPSAoIHcgKiByYXRpb0EgKyB0aGlzLncgKiByYXRpb0IgKTtcbiAgICB0aGlzLnggPSAoIHggKiByYXRpb0EgKyB0aGlzLnggKiByYXRpb0IgKTtcbiAgICB0aGlzLnkgPSAoIHkgKiByYXRpb0EgKyB0aGlzLnkgKiByYXRpb0IgKTtcbiAgICB0aGlzLnogPSAoIHogKiByYXRpb0EgKyB0aGlzLnogKiByYXRpb0IgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHNldEZyb21Vbml0VmVjdG9yczogZnVuY3Rpb24gKCkge1xuICAgIC8vIGh0dHA6Ly9sb2xlbmdpbmUubmV0L2Jsb2cvMjAxNC8wMi8yNC9xdWF0ZXJuaW9uLWZyb20tdHdvLXZlY3RvcnMtZmluYWxcbiAgICAvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcblxuICAgIHZhciB2MSwgcjtcbiAgICB2YXIgRVBTID0gMC4wMDAwMDE7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCB2RnJvbSwgdlRvICkge1xuICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgTWF0aFV0aWwuVmVjdG9yMygpO1xuXG4gICAgICByID0gdkZyb20uZG90KCB2VG8gKSArIDE7XG5cbiAgICAgIGlmICggciA8IEVQUyApIHtcbiAgICAgICAgciA9IDA7XG5cbiAgICAgICAgaWYgKCBNYXRoLmFicyggdkZyb20ueCApID4gTWF0aC5hYnMoIHZGcm9tLnogKSApIHtcbiAgICAgICAgICB2MS5zZXQoIC0gdkZyb20ueSwgdkZyb20ueCwgMCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHYxLnNldCggMCwgLSB2RnJvbS56LCB2RnJvbS55ICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYxLmNyb3NzVmVjdG9ycyggdkZyb20sIHZUbyApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnggPSB2MS54O1xuICAgICAgdGhpcy55ID0gdjEueTtcbiAgICAgIHRoaXMueiA9IHYxLno7XG4gICAgICB0aGlzLncgPSByO1xuXG4gICAgICB0aGlzLm5vcm1hbGl6ZSgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0oKSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0aFV0aWw7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgVXRpbCA9IHdpbmRvdy5VdGlsIHx8IHt9O1xuXG5VdGlsLk1JTl9USU1FU1RFUCA9IDAuMDAxO1xuVXRpbC5NQVhfVElNRVNURVAgPSAxO1xuXG5VdGlsLmJhc2U2NCA9IGZ1bmN0aW9uKG1pbWVUeXBlLCBiYXNlNjQpIHtcbiAgcmV0dXJuICdkYXRhOicgKyBtaW1lVHlwZSArICc7YmFzZTY0LCcgKyBiYXNlNjQ7XG59O1xuXG5VdGlsLmNsYW1wID0gZnVuY3Rpb24odmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIHZhbHVlKSwgbWF4KTtcbn07XG5cblV0aWwubGVycCA9IGZ1bmN0aW9uKGEsIGIsIHQpIHtcbiAgcmV0dXJuIGEgKyAoKGIgLSBhKSAqIHQpO1xufTtcblxuLyoqXG4gKiBMaWdodCBwb2x5ZmlsbCBmb3IgYFByb21pc2UucmFjZWAuIFJldHVybnNcbiAqIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGZpcnN0IHByb21pc2VcbiAqIHByb3ZpZGVkIHJlc29sdmVzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8UHJvbWlzZT59IHByb21pc2VzXG4gKi9cblV0aWwucmFjZSA9IGZ1bmN0aW9uKHByb21pc2VzKSB7XG4gIGlmIChQcm9taXNlLnJhY2UpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKHByb21pc2VzKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvbWlzZXNbaV0udGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5VdGlsLmlzSU9TID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgaXNJT1MgPSAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzSU9TO1xuICB9O1xufSkoKTtcblxuVXRpbC5pc1dlYlZpZXdBbmRyb2lkID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgaXNXZWJWaWV3QW5kcm9pZCA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVmVyc2lvbicpICE9PSAtMSAmJlxuICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdBbmRyb2lkJykgIT09IC0xICYmXG4gICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpICE9PSAtMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc1dlYlZpZXdBbmRyb2lkO1xuICB9O1xufSkoKTtcblxuVXRpbC5pc1NhZmFyaSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGlzU2FmYXJpID0gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc1NhZmFyaTtcbiAgfTtcbn0pKCk7XG5cblV0aWwuaXNGaXJlZm94QW5kcm9pZCA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGlzRmlyZWZveEFuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSAhPT0gLTEgJiZcbiAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQW5kcm9pZCcpICE9PSAtMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc0ZpcmVmb3hBbmRyb2lkO1xuICB9O1xufSkoKTtcblxuVXRpbC5pc1I3ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgaXNSNyA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignUjcgQnVpbGQnKSAhPT0gLTE7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNSNztcbiAgfTtcbn0pKCk7XG5cblV0aWwuaXNMYW5kc2NhcGVNb2RlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydG4gPSAod2luZG93Lm9yaWVudGF0aW9uID09IDkwIHx8IHdpbmRvdy5vcmllbnRhdGlvbiA9PSAtOTApO1xuICByZXR1cm4gVXRpbC5pc1I3KCkgPyAhcnRuIDogcnRuO1xufTtcblxuLy8gSGVscGVyIG1ldGhvZCB0byB2YWxpZGF0ZSB0aGUgdGltZSBzdGVwcyBvZiBzZW5zb3IgdGltZXN0YW1wcy5cblV0aWwuaXNUaW1lc3RhbXBEZWx0YVZhbGlkID0gZnVuY3Rpb24odGltZXN0YW1wRGVsdGFTKSB7XG4gIGlmIChpc05hTih0aW1lc3RhbXBEZWx0YVMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aW1lc3RhbXBEZWx0YVMgPD0gVXRpbC5NSU5fVElNRVNURVApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRpbWVzdGFtcERlbHRhUyA+IFV0aWwuTUFYX1RJTUVTVEVQKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuVXRpbC5nZXRTY3JlZW5XaWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTWF0aC5tYXgod2luZG93LnNjcmVlbi53aWR0aCwgd2luZG93LnNjcmVlbi5oZWlnaHQpICpcbiAgICAgIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xufTtcblxuVXRpbC5nZXRTY3JlZW5IZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGgubWluKHdpbmRvdy5zY3JlZW4ud2lkdGgsIHdpbmRvdy5zY3JlZW4uaGVpZ2h0KSAqXG4gICAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbn07XG5cblV0aWwucmVxdWVzdEZ1bGxzY3JlZW4gPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIGlmIChVdGlsLmlzV2ViVmlld0FuZHJvaWQoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChlbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgZWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbigpO1xuICB9IGVsc2UgaWYgKGVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICBlbGVtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gIH0gZWxzZSBpZiAoZWxlbWVudC5tb3pSZXF1ZXN0RnVsbFNjcmVlbikge1xuICAgIGVsZW1lbnQubW96UmVxdWVzdEZ1bGxTY3JlZW4oKTtcbiAgfSBlbHNlIGlmIChlbGVtZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICBlbGVtZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblV0aWwuZXhpdEZ1bGxzY3JlZW4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKSB7XG4gICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbikge1xuICAgIGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKCk7XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbikge1xuICAgIGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4oKTtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuKSB7XG4gICAgZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbigpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuVXRpbC5nZXRGdWxsc2NyZWVuRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgfHxcbiAgICAgIGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fFxuICAgICAgZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudDtcbn07XG5cblV0aWwubGlua1Byb2dyYW0gPSBmdW5jdGlvbihnbCwgdmVydGV4U291cmNlLCBmcmFnbWVudFNvdXJjZSwgYXR0cmliTG9jYXRpb25NYXApIHtcbiAgLy8gTm8gZXJyb3IgY2hlY2tpbmcgZm9yIGJyZXZpdHkuXG4gIHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XG4gIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNvdXJjZSk7XG4gIGdsLmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyKTtcblxuICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNvdXJjZSk7XG4gIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuXG4gIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcblxuICBmb3IgKHZhciBhdHRyaWJOYW1lIGluIGF0dHJpYkxvY2F0aW9uTWFwKVxuICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJMb2NhdGlvbk1hcFthdHRyaWJOYW1lXSwgYXR0cmliTmFtZSk7XG5cbiAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG5cbiAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG5cbiAgcmV0dXJuIHByb2dyYW07XG59O1xuXG5VdGlsLmdldFByb2dyYW1Vbmlmb3JtcyA9IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gIHZhciB1bmlmb3JtcyA9IHt9O1xuICB2YXIgdW5pZm9ybUNvdW50ID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xuICB2YXIgdW5pZm9ybU5hbWUgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmlmb3JtQ291bnQ7IGkrKykge1xuICAgIHZhciB1bmlmb3JtSW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgaSk7XG4gICAgdW5pZm9ybU5hbWUgPSB1bmlmb3JtSW5mby5uYW1lLnJlcGxhY2UoJ1swXScsICcnKTtcbiAgICB1bmlmb3Jtc1t1bmlmb3JtTmFtZV0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgdW5pZm9ybU5hbWUpO1xuICB9XG4gIHJldHVybiB1bmlmb3Jtcztcbn07XG5cblV0aWwub3J0aG9NYXRyaXggPSBmdW5jdGlvbiAob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICB2YXIgbHIgPSAxIC8gKGxlZnQgLSByaWdodCksXG4gICAgICBidCA9IDEgLyAoYm90dG9tIC0gdG9wKSxcbiAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gLTIgKiBscjtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gLTIgKiBidDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDIgKiBuZjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn07XG5cblV0aWwuY29weUFycmF5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZGVzdCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICBkZXN0W2ldID0gc291cmNlW2ldO1xuICB9XG59O1xuXG5VdGlsLmlzTW9iaWxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjaGVjayA9IGZhbHNlO1xuICAoZnVuY3Rpb24oYSl7aWYoLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWluby9pLnRlc3QoYSl8fC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzXFwtKXxhaShrb3xybil8YWwoYXZ8Y2F8Y28pfGFtb2l8YW4oZXh8bnl8eXcpfGFwdHV8YXIoY2h8Z28pfGFzKHRlfHVzKXxhdHR3fGF1KGRpfFxcLW18ciB8cyApfGF2YW58YmUoY2t8bGx8bnEpfGJpKGxifHJkKXxibChhY3xheil8YnIoZXx2KXd8YnVtYnxid1xcLShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtXFwtfGNlbGx8Y2h0bXxjbGRjfGNtZFxcLXxjbyhtcHxuZCl8Y3Jhd3xkYShpdHxsbHxuZyl8ZGJ0ZXxkY1xcLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8XFwtZCl8ZWwoNDl8YWkpfGVtKGwyfHVsKXxlcihpY3xrMCl8ZXNsOHxleihbNC03XTB8b3N8d2F8emUpfGZldGN8Zmx5KFxcLXxfKXxnMSB1fGc1NjB8Z2VuZXxnZlxcLTV8Z1xcLW1vfGdvKFxcLnd8b2QpfGdyKGFkfHVuKXxoYWllfGhjaXR8aGRcXC0obXxwfHQpfGhlaVxcLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzXFwtY3xodChjKFxcLXwgfF98YXxnfHB8c3x0KXx0cCl8aHUoYXd8dGMpfGlcXC0oMjB8Z298bWEpfGkyMzB8aWFjKCB8XFwtfFxcLyl8aWJyb3xpZGVhfGlnMDF8aWtvbXxpbTFrfGlubm98aXBhcXxpcmlzfGphKHR8dilhfGpicm98amVtdXxqaWdzfGtkZGl8a2VqaXxrZ3QoIHxcXC8pfGtsb258a3B0IHxrd2NcXC18a3lvKGN8ayl8bGUobm98eGkpfGxnKCBnfFxcLyhrfGx8dSl8NTB8NTR8XFwtW2Etd10pfGxpYnd8bHlueHxtMVxcLXd8bTNnYXxtNTBcXC98bWEodGV8dWl8eG8pfG1jKDAxfDIxfGNhKXxtXFwtY3J8bWUocmN8cmkpfG1pKG84fG9hfHRzKXxtbWVmfG1vKDAxfDAyfGJpfGRlfGRvfHQoXFwtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSlcXC18b258dGZ8d2Z8d2d8d3QpfG5vayg2fGkpfG56cGh8bzJpbXxvcCh0aXx3dil8b3Jhbnxvd2cxfHA4MDB8cGFuKGF8ZHx0KXxwZHhnfHBnKDEzfFxcLShbMS04XXxjKSl8cGhpbHxwaXJlfHBsKGF5fHVjKXxwblxcLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdFxcLWd8cWFcXC1hfHFjKDA3fDEyfDIxfDMyfDYwfFxcLVsyLTddfGlcXC0pfHF0ZWt8cjM4MHxyNjAwfHJha3N8cmltOXxybyh2ZXx6byl8czU1XFwvfHNhKGdlfG1hfG1tfG1zfG55fHZhKXxzYygwMXxoXFwtfG9vfHBcXC0pfHNka1xcL3xzZShjKFxcLXwwfDEpfDQ3fG1jfG5kfHJpKXxzZ2hcXC18c2hhcnxzaWUoXFwtfG0pfHNrXFwtMHxzbCg0NXxpZCl8c20oYWx8YXJ8YjN8aXR8dDUpfHNvKGZ0fG55KXxzcCgwMXxoXFwtfHZcXC18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2xcXC18dGRnXFwtfHRlbChpfG0pfHRpbVxcLXx0XFwtbW98dG8ocGx8c2gpfHRzKDcwfG1cXC18bTN8bTUpfHR4XFwtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118XFwtdil8dm00MHx2b2RhfHZ1bGN8dngoNTJ8NTN8NjB8NjF8NzB8ODB8ODF8ODN8ODV8OTgpfHczYyhcXC18ICl8d2ViY3x3aGl0fHdpKGcgfG5jfG53KXx3bWxifHdvbnV8eDcwMHx5YXNcXC18eW91cnx6ZXRvfHp0ZVxcLS9pLnRlc3QoYS5zdWJzdHIoMCw0KSkpY2hlY2sgPSB0cnVlfSkobmF2aWdhdG9yLnVzZXJBZ2VudHx8bmF2aWdhdG9yLnZlbmRvcnx8d2luZG93Lm9wZXJhKTtcbiAgcmV0dXJuIGNoZWNrO1xufTtcblxuVXRpbC5leHRlbmQgPSBmdW5jdGlvbihkZXN0LCBzcmMpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgZGVzdFtrZXldID0gc3JjW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59XG5cblV0aWwuc2FmYXJpQ3NzU2l6ZVdvcmthcm91bmQgPSBmdW5jdGlvbihjYW52YXMpIHtcbiAgLy8gVE9ETyhzbXVzKTogUmVtb3ZlIHRoaXMgd29ya2Fyb3VuZCB3aGVuIFNhZmFyaSBmb3IgaU9TIGlzIGZpeGVkLlxuICAvLyBpT1Mgb25seSB3b3JrYXJvdW5kIChmb3IgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1MjU1NikuXG4gIC8vXG4gIC8vIFwiVG8gdGhlIGxhc3QgSSBncmFwcGxlIHdpdGggdGhlZTtcbiAgLy8gIGZyb20gaGVsbCdzIGhlYXJ0IEkgc3RhYiBhdCB0aGVlO1xuICAvLyAgZm9yIGhhdGUncyBzYWtlIEkgc3BpdCBteSBsYXN0IGJyZWF0aCBhdCB0aGVlLlwiXG4gIC8vIC0tIE1vYnkgRGljaywgYnkgSGVybWFuIE1lbHZpbGxlXG4gIGlmIChVdGlsLmlzSU9TKCkpIHtcbiAgICB2YXIgd2lkdGggPSBjYW52YXMuc3R5bGUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGNhbnZhcy5zdHlsZS5oZWlnaHQ7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gKHBhcnNlSW50KHdpZHRoKSArIDEpICsgJ3B4JztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gKHBhcnNlSW50KGhlaWdodCkpICsgJ3B4JztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH0sIDEwMCk7XG4gIH1cblxuICAvLyBEZWJ1ZyBvbmx5LlxuICB3aW5kb3cuVXRpbCA9IFV0aWw7XG4gIHdpbmRvdy5jYW52YXMgPSBjYW52YXM7XG59O1xuXG5VdGlsLmlzRGVidWcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFV0aWwuZ2V0UXVlcnlQYXJhbWV0ZXIoJ2RlYnVnJyk7XG59O1xuXG5VdGlsLmdldFF1ZXJ5UGFyYW1ldGVyID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgbmFtZSA9IG5hbWUucmVwbGFjZSgvW1xcW10vLCBcIlxcXFxbXCIpLnJlcGxhY2UoL1tcXF1dLywgXCJcXFxcXVwiKTtcbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChcIltcXFxcPyZdXCIgKyBuYW1lICsgXCI9KFteJiNdKilcIiksXG4gICAgICByZXN1bHRzID0gcmVnZXguZXhlYyhsb2NhdGlvbi5zZWFyY2gpO1xuICByZXR1cm4gcmVzdWx0cyA9PT0gbnVsbCA/IFwiXCIgOiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1sxXS5yZXBsYWNlKC9cXCsvZywgXCIgXCIpKTtcbn07XG5cblV0aWwuZnJhbWVEYXRhRnJvbVBvc2UgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBwaU92ZXIxODAgPSBNYXRoLlBJIC8gMTgwLjA7XG4gIHZhciByYWQ0NSA9IE1hdGguUEkgKiAwLjI1O1xuXG4gIC8vIEJvcnJvd2VkIGZyb20gZ2xNYXRyaXguXG4gIGZ1bmN0aW9uIG1hdDRfcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcob3V0LCBmb3YsIG5lYXIsIGZhcikge1xuICAgIHZhciB1cFRhbiA9IE1hdGgudGFuKGZvdiA/IChmb3YudXBEZWdyZWVzICogcGlPdmVyMTgwKSA6IHJhZDQ1KSxcbiAgICBkb3duVGFuID0gTWF0aC50YW4oZm92ID8gKGZvdi5kb3duRGVncmVlcyAqIHBpT3ZlcjE4MCkgOiByYWQ0NSksXG4gICAgbGVmdFRhbiA9IE1hdGgudGFuKGZvdiA/IChmb3YubGVmdERlZ3JlZXMgKiBwaU92ZXIxODApIDogcmFkNDUpLFxuICAgIHJpZ2h0VGFuID0gTWF0aC50YW4oZm92ID8gKGZvdi5yaWdodERlZ3JlZXMgKiBwaU92ZXIxODApIDogcmFkNDUpLFxuICAgIHhTY2FsZSA9IDIuMCAvIChsZWZ0VGFuICsgcmlnaHRUYW4pLFxuICAgIHlTY2FsZSA9IDIuMCAvICh1cFRhbiArIGRvd25UYW4pO1xuXG4gICAgb3V0WzBdID0geFNjYWxlO1xuICAgIG91dFsxXSA9IDAuMDtcbiAgICBvdXRbMl0gPSAwLjA7XG4gICAgb3V0WzNdID0gMC4wO1xuICAgIG91dFs0XSA9IDAuMDtcbiAgICBvdXRbNV0gPSB5U2NhbGU7XG4gICAgb3V0WzZdID0gMC4wO1xuICAgIG91dFs3XSA9IDAuMDtcbiAgICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgICBvdXRbOV0gPSAoKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjUpO1xuICAgIG91dFsxMF0gPSBmYXIgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzExXSA9IC0xLjA7XG4gICAgb3V0WzEyXSA9IDAuMDtcbiAgICBvdXRbMTNdID0gMC4wO1xuICAgIG91dFsxNF0gPSAoZmFyICogbmVhcikgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzE1XSA9IDAuMDtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0NF9mcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIHEsIHYpIHtcbiAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgICB4eiA9IHggKiB6MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gICAgb3V0WzFdID0geHkgKyB3ejtcbiAgICBvdXRbMl0gPSB4eiAtIHd5O1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geHkgLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICAgIG91dFs2XSA9IHl6ICsgd3g7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4eiArIHd5O1xuICAgIG91dFs5XSA9IHl6IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1hdDRfdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdLFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gICAgaWYgKGEgPT09IG91dCkge1xuICAgICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xuICAgICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgICBvdXRbMF0gPSBhMDA7IG91dFsxXSA9IGEwMTsgb3V0WzJdID0gYTAyOyBvdXRbM10gPSBhMDM7XG4gICAgICBvdXRbNF0gPSBhMTA7IG91dFs1XSA9IGExMTsgb3V0WzZdID0gYTEyOyBvdXRbN10gPSBhMTM7XG4gICAgICBvdXRbOF0gPSBhMjA7IG91dFs5XSA9IGEyMTsgb3V0WzEwXSA9IGEyMjsgb3V0WzExXSA9IGEyMztcblxuICAgICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWF0NF9pbnZlcnQob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIHZhciBkZWZhdWx0T3JpZW50YXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAxXSk7XG4gIHZhciBkZWZhdWx0UG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwXSk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlRXllTWF0cmljZXMocHJvamVjdGlvbiwgdmlldywgcG9zZSwgcGFyYW1ldGVycywgdnJEaXNwbGF5KSB7XG4gICAgbWF0NF9wZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyhwcm9qZWN0aW9uLCBwYXJhbWV0ZXJzID8gcGFyYW1ldGVycy5maWVsZE9mVmlldyA6IG51bGwsIHZyRGlzcGxheS5kZXB0aE5lYXIsIHZyRGlzcGxheS5kZXB0aEZhcik7XG5cbiAgICB2YXIgb3JpZW50YXRpb24gPSBwb3NlLm9yaWVudGF0aW9uIHx8IGRlZmF1bHRPcmllbnRhdGlvbjtcbiAgICB2YXIgcG9zaXRpb24gPSBwb3NlLnBvc2l0aW9uIHx8IGRlZmF1bHRQb3NpdGlvbjtcblxuICAgIG1hdDRfZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24odmlldywgb3JpZW50YXRpb24sIHBvc2l0aW9uKTtcbiAgICBpZiAocGFyYW1ldGVycylcbiAgICAgIG1hdDRfdHJhbnNsYXRlKHZpZXcsIHZpZXcsIHBhcmFtZXRlcnMub2Zmc2V0KTtcbiAgICBtYXQ0X2ludmVydCh2aWV3LCB2aWV3KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihmcmFtZURhdGEsIHBvc2UsIHZyRGlzcGxheSkge1xuICAgIGlmICghZnJhbWVEYXRhIHx8ICFwb3NlKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgZnJhbWVEYXRhLnBvc2UgPSBwb3NlO1xuICAgIGZyYW1lRGF0YS50aW1lc3RhbXAgPSBwb3NlLnRpbWVzdGFtcDtcblxuICAgIHVwZGF0ZUV5ZU1hdHJpY2VzKFxuICAgICAgICBmcmFtZURhdGEubGVmdFByb2plY3Rpb25NYXRyaXgsIGZyYW1lRGF0YS5sZWZ0Vmlld01hdHJpeCxcbiAgICAgICAgcG9zZSwgdnJEaXNwbGF5LmdldEV5ZVBhcmFtZXRlcnMoXCJsZWZ0XCIpLCB2ckRpc3BsYXkpO1xuICAgIHVwZGF0ZUV5ZU1hdHJpY2VzKFxuICAgICAgICBmcmFtZURhdGEucmlnaHRQcm9qZWN0aW9uTWF0cml4LCBmcmFtZURhdGEucmlnaHRWaWV3TWF0cml4LFxuICAgICAgICBwb3NlLCB2ckRpc3BsYXkuZ2V0RXllUGFyYW1ldGVycyhcInJpZ2h0XCIpLCB2ckRpc3BsYXkpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59KSgpO1xuXG5VdGlsLmlzSW5zaWRlQ3Jvc3NEb21haW5JRnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlzRnJhbWVkID0gKHdpbmRvdy5zZWxmICE9PSB3aW5kb3cudG9wKTtcbiAgdmFyIHJlZkRvbWFpbiA9IFV0aWwuZ2V0RG9tYWluRnJvbVVybChkb2N1bWVudC5yZWZlcnJlcik7XG4gIHZhciB0aGlzRG9tYWluID0gVXRpbC5nZXREb21haW5Gcm9tVXJsKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICByZXR1cm4gaXNGcmFtZWQgJiYgKHJlZkRvbWFpbiAhPT0gdGhpc0RvbWFpbik7XG59O1xuXG4vLyBGcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIzOTQ1MDI3LlxuVXRpbC5nZXREb21haW5Gcm9tVXJsID0gZnVuY3Rpb24odXJsKSB7XG4gIHZhciBkb21haW47XG4gIC8vIEZpbmQgJiByZW1vdmUgcHJvdG9jb2wgKGh0dHAsIGZ0cCwgZXRjLikgYW5kIGdldCBkb21haW4uXG4gIGlmICh1cmwuaW5kZXhPZihcIjovL1wiKSA+IC0xKSB7XG4gICAgZG9tYWluID0gdXJsLnNwbGl0KCcvJylbMl07XG4gIH1cbiAgZWxzZSB7XG4gICAgZG9tYWluID0gdXJsLnNwbGl0KCcvJylbMF07XG4gIH1cblxuICAvL2ZpbmQgJiByZW1vdmUgcG9ydCBudW1iZXJcbiAgZG9tYWluID0gZG9tYWluLnNwbGl0KCc6JylbMF07XG5cbiAgcmV0dXJuIGRvbWFpbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBVdGlsO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIFNlbnNvclNhbXBsZSA9IHJlcXVpcmUoJy4vc2Vuc29yLXNhbXBsZS5qcycpO1xudmFyIE1hdGhVdGlsID0gcmVxdWlyZSgnLi4vbWF0aC11dGlsLmpzJyk7XG52YXIgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwuanMnKTtcblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBhIHNpbXBsZSBjb21wbGVtZW50YXJ5IGZpbHRlciwgd2hpY2ggZnVzZXMgZ3lyb3Njb3BlIGFuZFxuICogYWNjZWxlcm9tZXRlciBkYXRhIGZyb20gdGhlICdkZXZpY2Vtb3Rpb24nIGV2ZW50LlxuICpcbiAqIEFjY2VsZXJvbWV0ZXIgZGF0YSBpcyB2ZXJ5IG5vaXN5LCBidXQgc3RhYmxlIG92ZXIgdGhlIGxvbmcgdGVybS5cbiAqIEd5cm9zY29wZSBkYXRhIGlzIHNtb290aCwgYnV0IHRlbmRzIHRvIGRyaWZ0IG92ZXIgdGhlIGxvbmcgdGVybS5cbiAqXG4gKiBUaGlzIGZ1c2lvbiBpcyByZWxhdGl2ZWx5IHNpbXBsZTpcbiAqIDEuIEdldCBvcmllbnRhdGlvbiBlc3RpbWF0ZXMgZnJvbSBhY2NlbGVyb21ldGVyIGJ5IGFwcGx5aW5nIGEgbG93LXBhc3MgZmlsdGVyXG4gKiAgICBvbiB0aGF0IGRhdGEuXG4gKiAyLiBHZXQgb3JpZW50YXRpb24gZXN0aW1hdGVzIGZyb20gZ3lyb3Njb3BlIGJ5IGludGVncmF0aW5nIG92ZXIgdGltZS5cbiAqIDMuIENvbWJpbmUgdGhlIHR3byBlc3RpbWF0ZXMsIHdlaWdoaW5nICgxKSBpbiB0aGUgbG9uZyB0ZXJtLCBidXQgKDIpIGZvciB0aGVcbiAqICAgIHNob3J0IHRlcm0uXG4gKi9cbmZ1bmN0aW9uIENvbXBsZW1lbnRhcnlGaWx0ZXIoa0ZpbHRlcikge1xuICB0aGlzLmtGaWx0ZXIgPSBrRmlsdGVyO1xuXG4gIC8vIFJhdyBzZW5zb3IgbWVhc3VyZW1lbnRzLlxuICB0aGlzLmN1cnJlbnRBY2NlbE1lYXN1cmVtZW50ID0gbmV3IFNlbnNvclNhbXBsZSgpO1xuICB0aGlzLmN1cnJlbnRHeXJvTWVhc3VyZW1lbnQgPSBuZXcgU2Vuc29yU2FtcGxlKCk7XG4gIHRoaXMucHJldmlvdXNHeXJvTWVhc3VyZW1lbnQgPSBuZXcgU2Vuc29yU2FtcGxlKCk7XG5cbiAgLy8gU2V0IGRlZmF1bHQgbG9vayBkaXJlY3Rpb24gdG8gYmUgaW4gdGhlIGNvcnJlY3QgZGlyZWN0aW9uLlxuICBpZiAoVXRpbC5pc0lPUygpKSB7XG4gICAgdGhpcy5maWx0ZXJRID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oLTEsIDAsIDAsIDEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmlsdGVyUSA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKDEsIDAsIDAsIDEpO1xuICB9XG4gIHRoaXMucHJldmlvdXNGaWx0ZXJRID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcbiAgdGhpcy5wcmV2aW91c0ZpbHRlclEuY29weSh0aGlzLmZpbHRlclEpO1xuXG4gIC8vIE9yaWVudGF0aW9uIGJhc2VkIG9uIHRoZSBhY2NlbGVyb21ldGVyLlxuICB0aGlzLmFjY2VsUSA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG4gIC8vIFdoZXRoZXIgb3Igbm90IHRoZSBvcmllbnRhdGlvbiBoYXMgYmVlbiBpbml0aWFsaXplZC5cbiAgdGhpcy5pc09yaWVudGF0aW9uSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgLy8gUnVubmluZyBlc3RpbWF0ZSBvZiBncmF2aXR5IGJhc2VkIG9uIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uLlxuICB0aGlzLmVzdGltYXRlZEdyYXZpdHkgPSBuZXcgTWF0aFV0aWwuVmVjdG9yMygpO1xuICAvLyBNZWFzdXJlZCBncmF2aXR5IGJhc2VkIG9uIGFjY2VsZXJvbWV0ZXIuXG4gIHRoaXMubWVhc3VyZWRHcmF2aXR5ID0gbmV3IE1hdGhVdGlsLlZlY3RvcjMoKTtcblxuICAvLyBEZWJ1ZyBvbmx5IHF1YXRlcm5pb24gb2YgZ3lyby1iYXNlZCBvcmllbnRhdGlvbi5cbiAgdGhpcy5neXJvSW50ZWdyYWxRID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcbn1cblxuQ29tcGxlbWVudGFyeUZpbHRlci5wcm90b3R5cGUuYWRkQWNjZWxNZWFzdXJlbWVudCA9IGZ1bmN0aW9uKHZlY3RvciwgdGltZXN0YW1wUykge1xuICB0aGlzLmN1cnJlbnRBY2NlbE1lYXN1cmVtZW50LnNldCh2ZWN0b3IsIHRpbWVzdGFtcFMpO1xufTtcblxuQ29tcGxlbWVudGFyeUZpbHRlci5wcm90b3R5cGUuYWRkR3lyb01lYXN1cmVtZW50ID0gZnVuY3Rpb24odmVjdG9yLCB0aW1lc3RhbXBTKSB7XG4gIHRoaXMuY3VycmVudEd5cm9NZWFzdXJlbWVudC5zZXQodmVjdG9yLCB0aW1lc3RhbXBTKTtcblxuICB2YXIgZGVsdGFUID0gdGltZXN0YW1wUyAtIHRoaXMucHJldmlvdXNHeXJvTWVhc3VyZW1lbnQudGltZXN0YW1wUztcbiAgaWYgKFV0aWwuaXNUaW1lc3RhbXBEZWx0YVZhbGlkKGRlbHRhVCkpIHtcbiAgICB0aGlzLnJ1bl8oKTtcbiAgfVxuXG4gIHRoaXMucHJldmlvdXNHeXJvTWVhc3VyZW1lbnQuY29weSh0aGlzLmN1cnJlbnRHeXJvTWVhc3VyZW1lbnQpO1xufTtcblxuQ29tcGxlbWVudGFyeUZpbHRlci5wcm90b3R5cGUucnVuXyA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICghdGhpcy5pc09yaWVudGF0aW9uSW5pdGlhbGl6ZWQpIHtcbiAgICB0aGlzLmFjY2VsUSA9IHRoaXMuYWNjZWxUb1F1YXRlcm5pb25fKHRoaXMuY3VycmVudEFjY2VsTWVhc3VyZW1lbnQuc2FtcGxlKTtcbiAgICB0aGlzLnByZXZpb3VzRmlsdGVyUS5jb3B5KHRoaXMuYWNjZWxRKTtcbiAgICB0aGlzLmlzT3JpZW50YXRpb25Jbml0aWFsaXplZCA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRlbHRhVCA9IHRoaXMuY3VycmVudEd5cm9NZWFzdXJlbWVudC50aW1lc3RhbXBTIC1cbiAgICAgIHRoaXMucHJldmlvdXNHeXJvTWVhc3VyZW1lbnQudGltZXN0YW1wUztcblxuICAvLyBDb252ZXJ0IGd5cm8gcm90YXRpb24gdmVjdG9yIHRvIGEgcXVhdGVybmlvbiBkZWx0YS5cbiAgdmFyIGd5cm9EZWx0YVEgPSB0aGlzLmd5cm9Ub1F1YXRlcm5pb25EZWx0YV8odGhpcy5jdXJyZW50R3lyb01lYXN1cmVtZW50LnNhbXBsZSwgZGVsdGFUKTtcbiAgdGhpcy5neXJvSW50ZWdyYWxRLm11bHRpcGx5KGd5cm9EZWx0YVEpO1xuXG4gIC8vIGZpbHRlcl8xID0gSyAqIChmaWx0ZXJfMCArIGd5cm8gKiBkVCkgKyAoMSAtIEspICogYWNjZWwuXG4gIHRoaXMuZmlsdGVyUS5jb3B5KHRoaXMucHJldmlvdXNGaWx0ZXJRKTtcbiAgdGhpcy5maWx0ZXJRLm11bHRpcGx5KGd5cm9EZWx0YVEpO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgZGVsdGEgYmV0d2VlbiB0aGUgY3VycmVudCBlc3RpbWF0ZWQgZ3Jhdml0eSBhbmQgdGhlIHJlYWxcbiAgLy8gZ3Jhdml0eSB2ZWN0b3IgZnJvbSBhY2NlbGVyb21ldGVyLlxuICB2YXIgaW52RmlsdGVyUSA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG4gIGludkZpbHRlclEuY29weSh0aGlzLmZpbHRlclEpO1xuICBpbnZGaWx0ZXJRLmludmVyc2UoKTtcblxuICB0aGlzLmVzdGltYXRlZEdyYXZpdHkuc2V0KDAsIDAsIC0xKTtcbiAgdGhpcy5lc3RpbWF0ZWRHcmF2aXR5LmFwcGx5UXVhdGVybmlvbihpbnZGaWx0ZXJRKTtcbiAgdGhpcy5lc3RpbWF0ZWRHcmF2aXR5Lm5vcm1hbGl6ZSgpO1xuXG4gIHRoaXMubWVhc3VyZWRHcmF2aXR5LmNvcHkodGhpcy5jdXJyZW50QWNjZWxNZWFzdXJlbWVudC5zYW1wbGUpO1xuICB0aGlzLm1lYXN1cmVkR3Jhdml0eS5ub3JtYWxpemUoKTtcblxuICAvLyBDb21wYXJlIGVzdGltYXRlZCBncmF2aXR5IHdpdGggbWVhc3VyZWQgZ3Jhdml0eSwgZ2V0IHRoZSBkZWx0YSBxdWF0ZXJuaW9uXG4gIC8vIGJldHdlZW4gdGhlIHR3by5cbiAgdmFyIGRlbHRhUSA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG4gIGRlbHRhUS5zZXRGcm9tVW5pdFZlY3RvcnModGhpcy5lc3RpbWF0ZWRHcmF2aXR5LCB0aGlzLm1lYXN1cmVkR3Jhdml0eSk7XG4gIGRlbHRhUS5pbnZlcnNlKCk7XG5cbiAgaWYgKFV0aWwuaXNEZWJ1ZygpKSB7XG4gICAgY29uc29sZS5sb2coJ0RlbHRhOiAlZCBkZWcsIEdfZXN0OiAoJXMsICVzLCAlcyksIEdfbWVhczogKCVzLCAlcywgJXMpJyxcbiAgICAgICAgICAgICAgICBNYXRoVXRpbC5yYWRUb0RlZyAqIFV0aWwuZ2V0UXVhdGVybmlvbkFuZ2xlKGRlbHRhUSksXG4gICAgICAgICAgICAgICAgKHRoaXMuZXN0aW1hdGVkR3Jhdml0eS54KS50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICAgICh0aGlzLmVzdGltYXRlZEdyYXZpdHkueSkudG9GaXhlZCgxKSxcbiAgICAgICAgICAgICAgICAodGhpcy5lc3RpbWF0ZWRHcmF2aXR5LnopLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgICAgKHRoaXMubWVhc3VyZWRHcmF2aXR5LngpLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgICAgKHRoaXMubWVhc3VyZWRHcmF2aXR5LnkpLnRvRml4ZWQoMSksXG4gICAgICAgICAgICAgICAgKHRoaXMubWVhc3VyZWRHcmF2aXR5LnopLnRvRml4ZWQoMSkpO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBTTEVSUCB0YXJnZXQ6IGN1cnJlbnQgb3JpZW50YXRpb24gcGx1cyB0aGUgbWVhc3VyZWQtZXN0aW1hdGVkXG4gIC8vIHF1YXRlcm5pb24gZGVsdGEuXG4gIHZhciB0YXJnZXRRID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcbiAgdGFyZ2V0US5jb3B5KHRoaXMuZmlsdGVyUSk7XG4gIHRhcmdldFEubXVsdGlwbHkoZGVsdGFRKTtcblxuICAvLyBTTEVSUCBmYWN0b3I6IDAgaXMgcHVyZSBneXJvLCAxIGlzIHB1cmUgYWNjZWwuXG4gIHRoaXMuZmlsdGVyUS5zbGVycCh0YXJnZXRRLCAxIC0gdGhpcy5rRmlsdGVyKTtcblxuICB0aGlzLnByZXZpb3VzRmlsdGVyUS5jb3B5KHRoaXMuZmlsdGVyUSk7XG59O1xuXG5Db21wbGVtZW50YXJ5RmlsdGVyLnByb3RvdHlwZS5nZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5maWx0ZXJRO1xufTtcblxuQ29tcGxlbWVudGFyeUZpbHRlci5wcm90b3R5cGUuYWNjZWxUb1F1YXRlcm5pb25fID0gZnVuY3Rpb24oYWNjZWwpIHtcbiAgdmFyIG5vcm1BY2NlbCA9IG5ldyBNYXRoVXRpbC5WZWN0b3IzKCk7XG4gIG5vcm1BY2NlbC5jb3B5KGFjY2VsKTtcbiAgbm9ybUFjY2VsLm5vcm1hbGl6ZSgpO1xuICB2YXIgcXVhdCA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG4gIHF1YXQuc2V0RnJvbVVuaXRWZWN0b3JzKG5ldyBNYXRoVXRpbC5WZWN0b3IzKDAsIDAsIC0xKSwgbm9ybUFjY2VsKTtcbiAgcXVhdC5pbnZlcnNlKCk7XG4gIHJldHVybiBxdWF0O1xufTtcblxuQ29tcGxlbWVudGFyeUZpbHRlci5wcm90b3R5cGUuZ3lyb1RvUXVhdGVybmlvbkRlbHRhXyA9IGZ1bmN0aW9uKGd5cm8sIGR0KSB7XG4gIC8vIEV4dHJhY3QgYXhpcyBhbmQgYW5nbGUgZnJvbSB0aGUgZ3lyb3Njb3BlIGRhdGEuXG4gIHZhciBxdWF0ID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcbiAgdmFyIGF4aXMgPSBuZXcgTWF0aFV0aWwuVmVjdG9yMygpO1xuICBheGlzLmNvcHkoZ3lybyk7XG4gIGF4aXMubm9ybWFsaXplKCk7XG4gIHF1YXQuc2V0RnJvbUF4aXNBbmdsZShheGlzLCBneXJvLmxlbmd0aCgpICogZHQpO1xuICByZXR1cm4gcXVhdDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wbGVtZW50YXJ5RmlsdGVyO1xuIiwiZnVuY3Rpb24gU2Vuc29yU2FtcGxlKHNhbXBsZSwgdGltZXN0YW1wUykge1xuICB0aGlzLnNldChzYW1wbGUsIHRpbWVzdGFtcFMpO1xufTtcblxuU2Vuc29yU2FtcGxlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihzYW1wbGUsIHRpbWVzdGFtcFMpIHtcbiAgdGhpcy5zYW1wbGUgPSBzYW1wbGU7XG4gIHRoaXMudGltZXN0YW1wUyA9IHRpbWVzdGFtcFM7XG59O1xuXG5TZW5zb3JTYW1wbGUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihzZW5zb3JTYW1wbGUpIHtcbiAgdGhpcy5zZXQoc2Vuc29yU2FtcGxlLnNhbXBsZSwgc2Vuc29yU2FtcGxlLnRpbWVzdGFtcFMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZW5zb3JTYW1wbGU7XG4iLCJjb25zdCBWRVJTSU9OID0gXCIzLjIuMS1zbmFwc2hvdFwiO1xuXG5leHBvcnQge1xuXHRWRVJTSU9OXG59O1xuIiwiaW1wb3J0IFBhbm9WaWV3ZXIgZnJvbSBcIi4vUGFub1ZpZXdlclwiO1xuaW1wb3J0IHtWRVJTSU9OfSBmcm9tIFwiLi4vdmVyc2lvblwiO1xuXG5leHBvcnQge1xuXHRQYW5vVmlld2VyLFxuXHRWRVJTSU9OXG59O1xuIiwiZXhwb3J0IGZ1bmN0aW9uIHRvQXhpcyhzb3VyY2UsIG9mZnNldCkge1xuXHRyZXR1cm4gb2Zmc2V0LnJlZHVjZSgoYWNjLCB2LCBpKSA9PiB7XG5cdFx0aWYgKHNvdXJjZVtpXSkge1xuXHRcdFx0YWNjW3NvdXJjZVtpXV0gPSB2O1xuXHRcdH1cblx0XHRyZXR1cm4gYWNjO1xuXHR9LCB7fSk7XG59XG4iLCIvKipcbiAqIE9yaWdpbmFsIENvZGVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL2dsLW1hdHJpeC9ibG9iL3YyLjMuMi9zcmMvZ2wtbWF0cml4L2NvbW1vbi5qc1xuICogQ29tbW9uIHV0aWxpdGllc1xuICogbW9kaWZpZWQgYnkgZWdqc1xuICovXG52YXIgZ2xNYXRyaXggPSB7fTtcblxuZ2xNYXRyaXguQVJSQVlfVFlQRSA9ICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJykgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcblxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG5cbmdsTWF0cml4LnRvUmFkaWFuID0gZnVuY3Rpb24oYSl7XG4gICAgIHJldHVybiBhICogZGVncmVlO1xufVxuXG5nbE1hdHJpeC50b0RlZ3JlZSA9IGZ1bmN0aW9uKGEpe1xuICAgICByZXR1cm4gYSAvIGRlZ3JlZTtcbn1cblxuLy8gZ2xNYXRyaXguRVBTSUxPTiA9IDAuMDAwMDAxO1xuZ2xNYXRyaXguRVBTSUxPTiA9IDAuMDAwMTtcblxuZXhwb3J0IGRlZmF1bHQgZ2xNYXRyaXg7XG4iLCIvKipcbiAqIE9yaWdpbmFsIENvZGVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL2dsLW1hdHJpeC9ibG9iL3YyLjMuMi9zcmMvZ2wtbWF0cml4L3ZlYzMuanNcbiAqIDMgRGltZW5zaW9uYWwgVmVjdG9yIFV0aWxcbiAqIG1vZGlmaWVkIGJ5IGVnanNcbiAqL1xuaW1wb3J0IGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuXG4vKipcbiAqIEBjbGFzcyAzIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjM1xuICovXG52YXIgdmVjMyA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcbiAqXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbnZlYzMuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5LCB6KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbnZlYzMuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMzLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqejtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMy5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXTtcblxuICAgIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybVF1YXQgPSBmdW5jdGlvbihvdXQsIGEsIHEpIHtcbiAgICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xuXG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXSxcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICAgICAgICBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcbiAgICAgICAgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG4gICAgICAgIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4LFxuICAgICAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMucm90YXRlWiA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG5cdHZhciBwID0gW10sIHI9W107XG5cdC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblx0cFswXSA9IGFbMF0gLSBiWzBdO1xuXHRwWzFdID0gYVsxXSAtIGJbMV07XG5cdHBbMl0gPSBhWzJdIC0gYlsyXTtcblxuXHQvL3BlcmZvcm0gcm90YXRpb25cblx0clswXSA9IHBbMF0qTWF0aC5jb3MoYykgLSBwWzFdKk1hdGguc2luKGMpO1xuXHRyWzFdID0gcFswXSpNYXRoLnNpbihjKSArIHBbMV0qTWF0aC5jb3MoYyk7XG5cdHJbMl0gPSBwWzJdO1xuXG5cdC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblx0b3V0WzBdID0gclswXSArIGJbMF07XG5cdG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuXHRvdXRbMl0gPSByWzJdICsgYlsyXTtcblxuXHRyZXR1cm4gb3V0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdmVjMztcbiIsIi8qKlxuICogT3JpZ2luYWwgQ29kZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3RvamkvZ2wtbWF0cml4L2Jsb2IvdjIuMy4yL3NyYy9nbC1tYXRyaXgvdmVjMi5qc1xuICogMiBEaW1lbnNpb25hbCBWZWN0b3IgVXRpbFxuICogbW9kaWZpZWQgYnkgZWdqc1xuICovXG5pbXBvcnQgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5cbi8qKlxuICogQGNsYXNzIDIgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWMyXG4gKi9cbnZhciB2ZWMyID0ge307XG5cbnZlYzIuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdmVjMjtcbiIsIi8qKlxuICogT3JpZ2luYWwgQ29kZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3RvamkvZ2wtbWF0cml4L2Jsb2IvdjIuMy4yL3NyYy9nbC1tYXRyaXgvcXVhdC5qc1xuICogUXVhdGVybmlvbiB1dGlsXG4gKiBtb2RpZmllZCBieSBlZ2pzXG4gKi9cbmltcG9ydCBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcblxuLyoqXG4gKiBAY2xhc3MgUXVhdGVybmlvblxuICogQG5hbWUgcXVhdFxuICovXG52YXIgcXVhdCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgcXVhdFxuICpcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKi9cbnF1YXQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHksIHosIHcpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgb3V0WzNdID0gdztcbiAgICByZXR1cm4gb3V0O1xufTs7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHF1YXQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0cyBhIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYW5kIHJvdGF0aW9uIGF4aXMsXG4gKiB0aGVuIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgYXJvdW5kIHdoaWNoIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICoqL1xucXVhdC5zZXRBeGlzQW5nbGUgPSBmdW5jdGlvbihvdXQsIGF4aXMsIHJhZCkge1xuICAgIHJhZCA9IHJhZCAqIDAuNTtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgb3V0WzBdID0gcyAqIGF4aXNbMF07XG4gICAgb3V0WzFdID0gcyAqIGF4aXNbMV07XG4gICAgb3V0WzJdID0gcyAqIGF4aXNbMl07XG4gICAgb3V0WzNdID0gTWF0aC5jb3MocmFkKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0Lm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXSwgYncgPSBiWzNdO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieTtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFggYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWCA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7XG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBheiAqIGJ4O1xuICAgIG91dFsyXSA9IGF6ICogYncgLSBheSAqIGJ4O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWSBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGVZID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTtcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ5ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnk7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF4ICogYnk7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF5ICogYnk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY29uanVnYXRlIG9mIGEgcXVhdFxuICogSWYgdGhlIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0LmludmVyc2UgYW5kIHByb2R1Y2VzIHRoZSBzYW1lIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5jb25qdWdhdGUgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0geCAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0geSAqIGxlbjtcbiAgICAgICAgb3V0WzJdID0geiAqIGxlbjtcbiAgICAgICAgb3V0WzNdID0gdyAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcXVhdGVybmlvbnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBUaGUgZmlyc3QgcXVhdGVybmlvbi5cbiAqIEBwYXJhbSB7cXVhdH0gYiBUaGUgc2Vjb25kIHF1YXRlcm5pb24uXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xucXVhdC5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gICAgbGV0IGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSk7XG4gIH1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBxdWF0ZXJuaW9ucyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIFRoZSBmaXJzdCBxdWF0ZXJuaW9uLlxuICogQHBhcmFtIHtxdWF0fSBiIFRoZSBzZWNvbmQgcXVhdGVybmlvbi5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5xdWF0LmV4YWN0RXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHF1YXQ7XG4iLCIvKipcbiAqIE9yaWdpbmFsIENvZGVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL2dsLW1hdHJpeC9ibG9iL3YyLjMuMi9zcmMvZ2wtbWF0cml4L21hdDQuanNcbiAqIDR4NCBNYXRyaXggdXRpbFxuICogbW9kaWZpZWQgYnkgZWdqc1xuICovXG5pbXBvcnQgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG5cbi8qKlxuICogQGNsYXNzIDR4NCBNYXRyaXhcbiAqIEBuYW1lIG1hdDRcbiAqL1xudmFyIG1hdDQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5tYXQ0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpcyBub3QgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlWCA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbMF0gID0gYVswXTtcbiAgICAgICAgb3V0WzFdICA9IGFbMV07XG4gICAgICAgIG91dFsyXSAgPSBhWzJdO1xuICAgICAgICBvdXRbM10gID0gYVszXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjICsgYTIxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjICsgYTIyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgICBvdXRbOF0gPSBhMjAgKiBjIC0gYTEwICogcztcbiAgICBvdXRbOV0gPSBhMjEgKiBjIC0gYTExICogcztcbiAgICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gICAgb3V0WzExXSA9IGEyMyAqIGMgLSBhMTMgKiBzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzIG5vdCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGVZID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXSxcbiAgICAgICAgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFs0XSAgPSBhWzRdO1xuICAgICAgICBvdXRbNV0gID0gYVs1XTtcbiAgICAgICAgb3V0WzZdICA9IGFbNl07XG4gICAgICAgIG91dFs3XSAgPSBhWzddO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGMgLSBhMjAgKiBzO1xuICAgIG91dFsxXSA9IGEwMSAqIGMgLSBhMjEgKiBzO1xuICAgIG91dFsyXSA9IGEwMiAqIGMgLSBhMjIgKiBzO1xuICAgIG91dFszXSA9IGEwMyAqIGMgLSBhMjMgKiBzO1xuICAgIG91dFs4XSA9IGEwMCAqIHMgKyBhMjAgKiBjO1xuICAgIG91dFs5XSA9IGEwMSAqIHMgKyBhMjEgKiBjO1xuICAgIG91dFsxMF0gPSBhMDIgKiBzICsgYTIyICogYztcbiAgICBvdXRbMTFdID0gYTAzICogcyArIGEyMyAqIGM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBhIDR4NCBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gcSBRdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUXVhdCA9IGZ1bmN0aW9uIChvdXQsIHEpIHtcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHl4ID0geSAqIHgyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgenggPSB6ICogeDIsXG4gICAgICAgIHp5ID0geiAqIHkyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICAgIG91dFsxXSA9IHl4ICsgd3o7XG4gICAgb3V0WzJdID0genggLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuXG4gICAgb3V0WzRdID0geXggLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgICBvdXRbNl0gPSB6eSArIHd4O1xuICAgIG91dFs3XSA9IDA7XG5cbiAgICBvdXRbOF0gPSB6eCArIHd5O1xuICAgIG91dFs5XSA9IHp5IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICAgIG91dFsxMV0gPSAwO1xuXG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgQXNwZWN0IHJhdGlvLiB0eXBpY2FsbHkgdmlld3BvcnQgd2lkdGgvaGVpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnBlcnNwZWN0aXZlID0gZnVuY3Rpb24gKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSBmO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKDIgKiBmYXIgKiBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBtYXQ0O1xuIiwiLyoqXG4gKiBPcmlnaW5hbCBDb2RlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdG9qaS9nbC1tYXRyaXgvYmxvYi92Mi4zLjIvc3JjL2dsLW1hdHJpeC5qc1xuICogTWF0aCBVdGlsXG4gKiBtb2RpZmllZCBieSBlZ2pzXG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBnbC1tYXRyaXggLSBIaWdoIHBlcmZvcm1hbmNlIG1hdHJpeCBhbmQgdmVjdG9yIG9wZXJhdGlvbnNcbiAqIEBhdXRob3IgQnJhbmRvbiBKb25lc1xuICogQGF1dGhvciBDb2xpbiBNYWNLZW56aWUgSVZcbiAqIEB2ZXJzaW9uIDIuMy4yXG4gKi9cblxuLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuLy8gU29tZSBtaW5pbWFsIG1hdGggZnVuY3Rpb25hbGl0eSBib3Jyb3dlZCBmcm9tIGdsLU1hdHJpeCBhbmQgc3RyaXBwZWQgZG93blxuLy8gZm9yIHRoZSBwdXJwb3NlcyBvZiB0aGlzIGxpYnJhcnkuXG5cbmltcG9ydCBnbE1hdHJpeCBmcm9tIFwiLi9tYXRoVXRpbC9jb21tb24uanNcIjtcbmltcG9ydCB2ZWMzIGZyb20gXCIuL21hdGhVdGlsL3ZlYzMuanNcIjtcbmltcG9ydCB2ZWMyIGZyb20gXCIuL21hdGhVdGlsL3ZlYzIuanNcIjtcbmltcG9ydCBxdWF0IGZyb20gXCIuL21hdGhVdGlsL3F1YXQuanNcIjtcbmltcG9ydCBtYXQ0IGZyb20gXCIuL21hdGhVdGlsL21hdDQuanNcIjtcblxuZnVuY3Rpb24gcXVhdFRvVmVjMyhxdWF0ZXJuaW9uKSB7XG5cdGNvbnN0IGJhc2VWID0gdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDEpO1xuXG5cdHZlYzMudHJhbnNmb3JtUXVhdChiYXNlViwgYmFzZVYsIHF1YXRlcm5pb24pO1xuXHRyZXR1cm4gYmFzZVY7XG59XG5cbmNvbnN0IHV0aWwgPSB7fTtcblxudXRpbC5pc1Bvd2VyT2ZUd28gPSBmdW5jdGlvbihuKSB7XG5cdHJldHVybiBuICYmIChuICYgKG4gLSAxKSkgPT09IDA7XG59O1xuXG51dGlsLmV4dHJhY3RQaXRjaEZyb21RdWF0ID0gZnVuY3Rpb24ocXVhdGVybmlvbikge1xuXHRjb25zdCBiYXNlViA9IHF1YXRUb1ZlYzMocXVhdGVybmlvbik7XG5cblx0cmV0dXJuIC0xICogTWF0aC5hdGFuMihcblx0XHRiYXNlVlsxXSxcblx0XHRNYXRoLnNxcnQoTWF0aC5wb3coYmFzZVZbMF0sIDIpICsgTWF0aC5wb3coYmFzZVZbMl0sIDIpKSk7XG59O1xuXG4vLyBpbXBsZW1lbnQgcmVmZXJlbmNlXG4vLyB0aGUgZ2VuZXJhbCBlcXVhdGlvbiBvZiBhIHBsYW5lIDogaHR0cDovL3d3dy5naXNkZXZlbG9wZXIuY28ua3IvZW50cnkv7Y+J66m07J2YLeqzteyLnVxuLy8gY2FsY3VsYXRpbmcgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9ycyA6IGh0dHA6Ly9kYXJrcGdtci50aXN0b3J5LmNvbS8xMjFcbmNvbnN0IFJPVEFURV9DT05TVEFOVCA9IHtcblx0UElUQ0hfREVMVEE6IDEsXG5cdFlBV19ERUxUQV9CWV9ST0xMOiAyLFxuXHRZQVdfREVMVEFfQllfWUFXOiAzLFxufTtcblxuUk9UQVRFX0NPTlNUQU5UW1JPVEFURV9DT05TVEFOVC5QSVRDSF9ERUxUQV0gPSB7XG5cdHRhcmdldEF4aXM6IFswLCAxLCAwXSxcblx0bWVzaFBvaW50OiBbMCwgMCwgMV0sXG59O1xuUk9UQVRFX0NPTlNUQU5UW1JPVEFURV9DT05TVEFOVC5ZQVdfREVMVEFfQllfUk9MTF0gPSB7XG5cdHRhcmdldEF4aXM6IFswLCAxLCAwXSxcblx0bWVzaFBvaW50OiBbMSwgMCwgMF0sXG59O1xuUk9UQVRFX0NPTlNUQU5UW1JPVEFURV9DT05TVEFOVC5ZQVdfREVMVEFfQllfWUFXXSA9IHtcblx0dGFyZ2V0QXhpczogWzEsIDAsIDBdLFxuXHRtZXNoUG9pbnQ6IFswLCAwLCAxXSxcbn07XG5cbmZ1bmN0aW9uIGdldFJvdGF0aW9uRGVsdGEocHJldlEsIGN1clEsIHJvdGF0ZUtpbmQpIHtcblx0Y29uc3QgdGFyZ2V0QXhpcyA9IHZlYzMuZnJvbVZhbHVlcyhcblx0XHRST1RBVEVfQ09OU1RBTlRbcm90YXRlS2luZF0udGFyZ2V0QXhpc1swXSxcblx0XHRST1RBVEVfQ09OU1RBTlRbcm90YXRlS2luZF0udGFyZ2V0QXhpc1sxXSxcblx0XHRST1RBVEVfQ09OU1RBTlRbcm90YXRlS2luZF0udGFyZ2V0QXhpc1syXVxuXHQpO1xuXHRjb25zdCBtZXNoUG9pbnQgPSBST1RBVEVfQ09OU1RBTlRbcm90YXRlS2luZF0ubWVzaFBvaW50O1xuXG5cdGNvbnN0IHByZXZRdWF0ZXJuaW9uID0gcXVhdC5jbG9uZShwcmV2USk7XG5cdGNvbnN0IGN1clF1YXRlcm5pb24gPSBxdWF0LmNsb25lKGN1clEpO1xuXG5cdHF1YXQubm9ybWFsaXplKHByZXZRdWF0ZXJuaW9uLCBwcmV2UXVhdGVybmlvbik7XG5cdHF1YXQubm9ybWFsaXplKGN1clF1YXRlcm5pb24sIGN1clF1YXRlcm5pb24pO1xuXG5cdGxldCBwcmV2UG9pbnQgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMSk7XG5cdGxldCBjdXJQb2ludCA9IHZlYzMuZnJvbVZhbHVlcygwLCAwLCAxKTtcblxuXHR2ZWMzLnRyYW5zZm9ybVF1YXQocHJldlBvaW50LCBwcmV2UG9pbnQsIHByZXZRdWF0ZXJuaW9uKTtcblx0dmVjMy50cmFuc2Zvcm1RdWF0KGN1clBvaW50LCBjdXJQb2ludCwgY3VyUXVhdGVybmlvbik7XG5cdHZlYzMudHJhbnNmb3JtUXVhdCh0YXJnZXRBeGlzLCB0YXJnZXRBeGlzLCBjdXJRdWF0ZXJuaW9uKTtcblxuXHRjb25zdCByb3RhdGVEaXN0YW5jZSA9IHZlYzMuZG90KHRhcmdldEF4aXMsIHZlYzMuY3Jvc3ModmVjMy5jcmVhdGUoKSwgcHJldlBvaW50LCBjdXJQb2ludCkpO1xuXHRjb25zdCByb3RhdGVEaXJlY3Rpb24gPSByb3RhdGVEaXN0YW5jZSA+IDAgPyAxIDogLTE7XG5cblx0Ly8gd2hlbiBjb3VudGVyIGNsb2NrIHdpc2UsIHVzZSB2ZWMzLmZyb21WYWx1ZXMoMCwxLDApXG5cdC8vIHdoZW4gY2xvY2sgd2lzZSwgdXNlIHZlYzMuZnJvbVZhbHVlcygwLC0xLDApXG5cdC8vIGNvbnN0IG1lc2hQb2ludDEgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMCk7XG5cdGNvbnN0IG1lc2hQb2ludDIgPSB2ZWMzLmZyb21WYWx1ZXMobWVzaFBvaW50WzBdLCBtZXNoUG9pbnRbMV0sIG1lc2hQb2ludFsyXSk7XG5cblx0bGV0IG1lc2hQb2ludDM7XG5cblx0aWYgKHJvdGF0ZUtpbmQgIT09IFJPVEFURV9DT05TVEFOVC5ZQVdfREVMVEFfQllfWUFXKSB7XG5cdFx0bWVzaFBvaW50MyA9IHZlYzMuZnJvbVZhbHVlcygwLCByb3RhdGVEaXJlY3Rpb24sIDApO1xuXHR9IGVsc2Uge1xuXHRcdG1lc2hQb2ludDMgPSB2ZWMzLmZyb21WYWx1ZXMocm90YXRlRGlyZWN0aW9uLCAwLCAwKTtcblx0fVxuXG5cdHZlYzMudHJhbnNmb3JtUXVhdChtZXNoUG9pbnQyLCBtZXNoUG9pbnQyLCBjdXJRdWF0ZXJuaW9uKTtcblx0dmVjMy50cmFuc2Zvcm1RdWF0KG1lc2hQb2ludDMsIG1lc2hQb2ludDMsIGN1clF1YXRlcm5pb24pO1xuXG5cdGNvbnN0IHZlY1UgPSBtZXNoUG9pbnQyO1xuXHRjb25zdCB2ZWNWID0gbWVzaFBvaW50Mztcblx0Y29uc3QgdmVjTiA9IHZlYzMuY3JlYXRlKCk7XG5cblx0dmVjMy5jcm9zcyh2ZWNOLCB2ZWNVLCB2ZWNWKTtcblx0dmVjMy5ub3JtYWxpemUodmVjTiwgdmVjTik7XG5cblx0Y29uc3QgY29lZmZpY2llbnRBID0gdmVjTlswXTtcblx0Y29uc3QgY29lZmZpY2llbnRCID0gdmVjTlsxXTtcblx0Y29uc3QgY29lZmZpY2llbnRDID0gdmVjTlsyXTtcbi8vXHRjb25zdCBjb2VmZmljaWVudEQgPSAtMSAqIHZlYzMuZG90KHZlY04sIG1lc2hQb2ludDEpO1xuXG5cdC8vIGEgcG9pbnQgb24gdGhlIHBsYW5lXG5cdGN1clBvaW50ID0gdmVjMy5mcm9tVmFsdWVzKG1lc2hQb2ludFswXSwgbWVzaFBvaW50WzFdLCBtZXNoUG9pbnRbMl0pO1xuXHR2ZWMzLnRyYW5zZm9ybVF1YXQoY3VyUG9pbnQsIGN1clBvaW50LCBjdXJRdWF0ZXJuaW9uKTtcblxuXHQvLyBhIHBvaW50IHNob3VsZCBwcm9qZWN0IG9uIHRoZSBwbGFuZVxuXHRwcmV2UG9pbnQgPSB2ZWMzLmZyb21WYWx1ZXMobWVzaFBvaW50WzBdLCBtZXNoUG9pbnRbMV0sIG1lc2hQb2ludFsyXSk7XG5cdHZlYzMudHJhbnNmb3JtUXVhdChwcmV2UG9pbnQsIHByZXZQb2ludCwgcHJldlF1YXRlcm5pb24pO1xuXG5cdC8vIGRpc3RhbmNlIGJldHdlZW4gcHJldlBvaW50IGFuZCB0aGUgcGxhbmVcblx0bGV0IGRpc3RhbmNlID0gTWF0aC5hYnMoXG5cdFx0cHJldlBvaW50WzBdICogY29lZmZpY2llbnRBICtcblx0XHRwcmV2UG9pbnRbMV0gKiBjb2VmZmljaWVudEIgK1xuXHRcdHByZXZQb2ludFsyXSAqIGNvZWZmaWNpZW50Q1xuXHQpO1xuXG5cdGNvbnN0IHByb2plY3RlZFByZXZQb2ludCA9IHZlYzMuY3JlYXRlKCk7XG5cblx0dmVjMy5zdWJ0cmFjdChwcm9qZWN0ZWRQcmV2UG9pbnQsIHByZXZQb2ludCwgdmVjMy5zY2FsZSh2ZWMzLmNyZWF0ZSgpLCB2ZWNOLCBkaXN0YW5jZSkpO1xuXG5cdGxldCB0cmlnb25vbWV0cmljUmF0aW8gPVxuXHRcdChwcm9qZWN0ZWRQcmV2UG9pbnRbMF0gKiBjdXJQb2ludFswXSArXG5cdFx0cHJvamVjdGVkUHJldlBvaW50WzFdICogY3VyUG9pbnRbMV0gK1xuXHRcdHByb2plY3RlZFByZXZQb2ludFsyXSAqIGN1clBvaW50WzJdKSAvXG5cdFx0KHZlYzMubGVuZ3RoKHByb2plY3RlZFByZXZQb2ludCkgKiB2ZWMzLmxlbmd0aChjdXJQb2ludCkpO1xuXG5cdC8vIGRlZmVuc2l2ZSBibG9ja1xuXHR0cmlnb25vbWV0cmljUmF0aW8gPiAxICYmICh0cmlnb25vbWV0cmljUmF0aW8gPSAxKTtcblxuXHRjb25zdCB0aGV0YSA9IE1hdGguYWNvcyh0cmlnb25vbWV0cmljUmF0aW8pO1xuXG5cdGNvbnN0IGNyb3NzVmVjID0gdmVjMy5jcm9zcyh2ZWMzLmNyZWF0ZSgpLCBjdXJQb2ludCwgcHJvamVjdGVkUHJldlBvaW50KTtcblxuXHRkaXN0YW5jZSA9XG5cdFx0Y29lZmZpY2llbnRBICogY3Jvc3NWZWNbMF0gK1xuXHRcdGNvZWZmaWNpZW50QiAqIGNyb3NzVmVjWzFdICtcblx0XHRjb2VmZmljaWVudEMgKiBjcm9zc1ZlY1syXTtcblxuXHRsZXQgdGhldGFEaXJlY3Rpb247XG5cblx0aWYgKHJvdGF0ZUtpbmQgIT09IFJPVEFURV9DT05TVEFOVC5ZQVdfREVMVEFfQllfWUFXKSB7XG5cdFx0dGhldGFEaXJlY3Rpb24gPSBkaXN0YW5jZSA+IDAgPyAxIDogLTE7XG5cdH0gZWxzZSB7XG5cdFx0dGhldGFEaXJlY3Rpb24gPSBkaXN0YW5jZSA8IDAgPyAxIDogLTE7XG5cdH1cblxuXHRjb25zdCBkZWx0YVJhZGlhbiA9IHRoZXRhICogdGhldGFEaXJlY3Rpb24gKiByb3RhdGVEaXJlY3Rpb247XG5cblx0cmV0dXJuIGdsTWF0cml4LnRvRGVncmVlKGRlbHRhUmFkaWFuKTtcbn1cblxudXRpbC5nZXRSb3RhdGlvbkRlbHRhID0gZ2V0Um90YXRpb25EZWx0YTtcblxuZXhwb3J0IHtcblx0dXRpbCxcblx0Z2xNYXRyaXgsXG5cdG1hdDQsXG5cdHF1YXQsXG5cdHZlYzIsXG5cdHZlYzMsXG5cdFJPVEFURV9DT05TVEFOVCxcbn07XG4iLCJpbXBvcnQge3VzZXJBZ2VudH0gZnJvbSBcIi4uL3V0aWxzL2Jyb3dzZXJGZWF0dXJlXCI7XG4vKipcbiAqIFJldHVybnMgYSBudW1iZXIgdmFsdWUgaW5kaWNpYXRpbmcgdGhlIHZlcnNpb24gb2YgQ2hyb21lIGJlaW5nIHVzZWQsXG4gKiBvciBvdGhlcndpc2UgYG51bGxgIGlmIG5vdCBvbiBDaHJvbWUuXG4gKlxuICogUmVmOiBodHRwczovL2dpdGh1Yi5jb20vaW1tZXJzaXZlLXdlYi9jYXJkYm9hcmQtdnItZGlzcGxheS9wdWxsLzE5XG4gKi9cbi8qKlxuICogSW4gQ2hyb21lIG02NSwgYGRldmljZW1vdGlvbmAgZXZlbnRzIGFyZSBicm9rZW4gYnV0IHN1YnNlcXVlbnRseSBmaXhlZFxuICogaW4gNjUuMC4zMzI1LjE0OC4gU2luY2UgbWFueSBicm93c2VycyB1c2UgQ2hyb21pdW0sIGVuc3VyZSB0aGF0XG4gKiB3ZSBzY29wZSB0aGlzIGRldGVjdGlvbiBieSBicmFuY2ggYW5kIGJ1aWxkIG51bWJlcnMgdG8gcHJvdmlkZVxuICogYSBwcm9wZXIgZmFsbGJhY2suXG4gKiBodHRwczovL2dpdGh1Yi5jb20vaW1tZXJzaXZlLXdlYi93ZWJ2ci1wb2x5ZmlsbC9pc3N1ZXMvMzA3XG4gKi9cbmxldCB2ZXJzaW9uID0gLTE7IC8vIEl0IHNob3VsZCBub3QgYmUgbnVsbCBiZWNhdXNlIGl0IHdpbGwgYmUgY29tcGFyZWQgd2l0aCBudW1iZXJcbmxldCBicmFuY2ggPSBudWxsO1xubGV0IGJ1aWxkID0gbnVsbDtcblxuY29uc3QgbWF0Y2ggPSAvQ2hyb21lXFwvKFswLTldKylcXC4oPzpbMC05XSopXFwuKFswLTldKilcXC4oWzAtOV0qKS9pLmV4ZWModXNlckFnZW50KTtcblxuaWYgKG1hdGNoKSB7XG5cdHZlcnNpb24gPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuXHRicmFuY2ggPSBtYXRjaFsyXTtcblx0YnVpbGQgPSBtYXRjaFszXTtcbn1cblxuY29uc3QgQ0hST01FX1ZFUlNJT04gPSB2ZXJzaW9uO1xuY29uc3QgSVNfQ0hST01FX1dJVEhPVVRfREVWSUNFX01PVElPTiA9IHZlcnNpb24gPT09IDY1ICYmIGJyYW5jaCA9PT0gXCIzMzI1XCIgJiYgcGFyc2VJbnQoYnVpbGQsIDEwKSA8IDE0ODtcbmNvbnN0IElTX0FORFJPSUQgPSAvQW5kcm9pZC9pLnRlc3QodXNlckFnZW50KTtcblxuY29uc3QgQ09OVFJPTF9NT0RFX1ZSID0gMTtcbmNvbnN0IENPTlRST0xfTU9ERV9ZQVdQSVRDSCA9IDI7XG5cbmNvbnN0IFRPVUNIX0RJUkVDVElPTl9OT05FID0gMTtcbmNvbnN0IFRPVUNIX0RJUkVDVElPTl9ZQVcgPSAyO1xuY29uc3QgVE9VQ0hfRElSRUNUSU9OX1BJVENIID0gNDtcbmNvbnN0IFRPVUNIX0RJUkVDVElPTl9BTEwgPSBUT1VDSF9ESVJFQ1RJT05fWUFXIHwgVE9VQ0hfRElSRUNUSU9OX1BJVENIO1xuXG4vKiBDb25zdCBmb3IgTW92YWJsZUNvb3JkICovXG5jb25zdCBNQ19ERUNFTEVSQVRJT04gPSAwLjAwMTQ7XG5jb25zdCBNQ19NQVhJTVVNX0RVUkFUSU9OID0gMTAwMDtcbmNvbnN0IE1DX0JJTkRfU0NBTEUgPSBbMC4yMCwgMC4yMF07XG5cbmNvbnN0IE1JTl9GSUVMRF9PRl9WSUVXID0gMjA7XG5jb25zdCBNQVhfRklFTERfT0ZfVklFVyA9IDExMDtcbmNvbnN0IFBBTl9TQ0FMRSA9IDMyMDtcblxuLy8gY29uc3QgREVMVEFfVEhSRVNIT0xEID0gMC4wMTU7XG4vLyBjb25zdCBERUxUQV9USFJFU0hPTEQgPSAwLjA5OyAvLyBOb3RlNFxuLy8gY29uc3QgREVMVEFfVEhSRVNIT0xEID0gMC4wODI1O1xuLy8gY29uc3QgREVMVEFfVEhSRVNIT0xEID0gMC4wNzU7XG4vLyBjb25zdCBERUxUQV9USFJFU0hPTEQgPSAwLjA2O1xuLy8gY29uc3QgREVMVEFfVEhSRVNIT0xEID0gMC4wNDU7XG5jb25zdCBERUxUQV9USFJFU0hPTEQgPSAwLjAzNzU7IC8vIE5vdGUyXG5cbmNvbnN0IFlBV19SQU5HRV9IQUxGID0gMTgwO1xuY29uc3QgUElUQ0hfUkFOR0VfSEFMRiA9IDkwO1xuY29uc3QgQ0lSQ1VMQVJfUElUQ0hfUkFOR0VfSEFMRiA9IDE4MDtcbmNvbnN0IFBJTkNIX0VWRU5UUyA9IFwicGluY2hzdGFydCBwaW5jaG1vdmUgcGluY2hlbmRcIjtcblxuY29uc3QgS0VZTUFQID0ge1xuXHRMRUZUX0FSUk9XOiAzNyxcblx0QTogNjUsXG5cdFVQX0FSUk9XOiAzOCxcblx0VzogODcsXG5cdFJJR0hUX0FSUk9XOiAzOSxcblx0RDogNjgsXG5cdERPV05fQVJST1c6IDQwLFxuXHRTOiA4Myxcbn07XG5cbmNvbnN0IEdZUk9fTU9ERSA9IHtcblx0Tk9ORTogXCJub25lXCIsXG5cdFlBV1BJVENIOiBcInlhd1BpdGNoXCIsXG5cdFZSOiBcIlZSXCJcbn07XG5cbmV4cG9ydCB7XG5cdEdZUk9fTU9ERSxcblxuXHRDT05UUk9MX01PREVfVlIsXG5cdENPTlRST0xfTU9ERV9ZQVdQSVRDSCxcblxuXHRUT1VDSF9ESVJFQ1RJT05fTk9ORSxcblx0VE9VQ0hfRElSRUNUSU9OX1lBVyxcblx0VE9VQ0hfRElSRUNUSU9OX1BJVENILFxuXHRUT1VDSF9ESVJFQ1RJT05fQUxMLFxuXG5cdE1DX0RFQ0VMRVJBVElPTixcblx0TUNfTUFYSU1VTV9EVVJBVElPTixcblx0TUNfQklORF9TQ0FMRSxcblx0TUlOX0ZJRUxEX09GX1ZJRVcsXG5cdE1BWF9GSUVMRF9PRl9WSUVXLFxuXHRQQU5fU0NBTEUsXG5cdERFTFRBX1RIUkVTSE9MRCxcblx0WUFXX1JBTkdFX0hBTEYsXG5cdFBJVENIX1JBTkdFX0hBTEYsXG5cdENJUkNVTEFSX1BJVENIX1JBTkdFX0hBTEYsXG5cdFBJTkNIX0VWRU5UUyxcblx0S0VZTUFQLFxuXG5cdENIUk9NRV9WRVJTSU9OLFxuXHRJU19DSFJPTUVfV0lUSE9VVF9ERVZJQ0VfTU9USU9OLFxuXHRJU19BTkRST0lEXG59O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG5pbXBvcnQge3ZlYzN9IGZyb20gXCIuLi8uLi91dGlscy9tYXRoLXV0aWxcIjtcbmltcG9ydCB7d2luZG93fSBmcm9tIFwiLi4vLi4vdXRpbHMvYnJvd3NlclwiO1xuaW1wb3J0IHtJU19DSFJPTUVfV0lUSE9VVF9ERVZJQ0VfTU9USU9OLCBJU19BTkRST0lEfSBmcm9tIFwiLi4vY29uc3RzXCI7XG5cbmNvbnN0IFNUSUxMTkVTU19USFJFU0hPTEQgPSAyMDA7IC8vIG1pbGxpc2Vjb25kXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERldmljZU1vdGlvbiBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5fb25EZXZpY2VNb3Rpb24gPSB0aGlzLl9vbkRldmljZU1vdGlvbi5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuX29uRGV2aWNlT3JpZW50YXRpb24gPSB0aGlzLl9vbkRldmljZU9yaWVudGF0aW9uLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5fb25DaHJvbWVXaXRob3V0RGV2aWNlTW90aW9uID0gdGhpcy5fb25DaHJvbWVXaXRob3V0RGV2aWNlTW90aW9uLmJpbmQodGhpcyk7XG5cblx0XHR0aGlzLmlzV2l0aG91dERldmljZU1vdGlvbiA9IElTX0NIUk9NRV9XSVRIT1VUX0RFVklDRV9NT1RJT047XG5cdFx0dGhpcy5pc0FuZHJvaWQgPSBJU19BTkRST0lEO1xuXG5cdFx0dGhpcy5zdGlsbEd5cm9WZWMgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHRoaXMucmF3R3lyb1ZlYyA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0dGhpcy5hZGp1c3RlZEd5cm9WZWMgPSB2ZWMzLmNyZWF0ZSgpO1xuXG5cdFx0dGhpcy5fdGltZXIgPSBudWxsO1xuXG5cdFx0dGhpcy5sYXN0RGV2aWNlbW90aW9uVGltZXN0YW1wID0gMDtcblx0XHR0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcblx0XHR0aGlzLmVuYWJsZSgpO1xuXHR9XG5cdF9vbkNocm9tZVdpdGhvdXREZXZpY2VNb3Rpb24oZSkge1xuXHRcdGxldCB7YWxwaGEsIGJldGEsIGdhbW1hfSA9IGU7XG5cblx0XHQvLyBUaGVyZSBpcyBkZXZpY2VvcmllbnRhdGlvbiBldmVudCB0cmlnZ2VkIHdpdGggZW1wdHkgdmFsdWVzXG5cdFx0Ly8gb24gSGVhZGxlc3MgQ2hyb21lLlxuXHRcdGlmIChhbHBoYSA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdG8gcmFkaWFuXG5cdFx0YWxwaGEgPSAoYWxwaGEgfHwgMCkgKiBNYXRoLlBJIC8gMTgwO1xuXHRcdGJldGEgPSAoYmV0YSB8fCAwKSAqIE1hdGguUEkgLyAxODA7XG5cdFx0Z2FtbWEgPSAoZ2FtbWEgfHwgMCkgKiBNYXRoLlBJIC8gMTgwO1xuXG5cdFx0dGhpcy50cmlnZ2VyKFwiZGV2aWNlbW90aW9uXCIsIHtcblx0XHRcdGlucHV0RXZlbnQ6IHtcblx0XHRcdFx0ZGV2aWNlb3JpZW50YXRpb246IHtcblx0XHRcdFx0XHRhbHBoYSxcblx0XHRcdFx0XHRiZXRhLFxuXHRcdFx0XHRcdGdhbW1hOiAtZ2FtbWFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cdF9vbkRldmljZU9yaWVudGF0aW9uKCkge1xuXHRcdHRoaXMuX3RpbWVyICYmIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG5cdFx0dGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdGlmICgobmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3REZXZpY2Vtb3Rpb25UaW1lc3RhbXApIDwgU1RJTExORVNTX1RIUkVTSE9MRCkge1xuXHRcdFx0XHR2ZWMzLmNvcHkodGhpcy5zdGlsbEd5cm9WZWMsIHRoaXMucmF3R3lyb1ZlYyk7XG5cdFx0XHR9XG5cdFx0fSwgU1RJTExORVNTX1RIUkVTSE9MRCk7XG5cdH1cblx0X29uRGV2aWNlTW90aW9uKGUpIHtcblx0XHQvLyBkZXNrdG9wIGNocm9tZSB0cmlnZ2VycyBkZXZpY2Vtb3Rpb24gZXZlbnQgd2l0aCBlbXB0aHkgc2Vuc29yIHZhbHVlcy5cblx0XHQvLyBUaG9zZSBldmVudHMgc2hvdWxkIGlnbm9yZWQuXG5cdFx0Y29uc3QgaXNHeXJvU2Vuc29yQXZhaWxhYmxlID0gIShlLnJvdGF0aW9uUmF0ZS5hbHBoYSA9PSBudWxsKTtcblx0XHRjb25zdCBpc0dyYXZpdHlTZW5zb3JBdmFpbGFibGUgPSAhKGUuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eS54ID09IG51bGwpO1xuXG5cdFx0aWYgKGUuaW50ZXJ2YWwgPT09IDAgfHwgIShpc0d5cm9TZW5zb3JBdmFpbGFibGUgJiYgaXNHcmF2aXR5U2Vuc29yQXZhaWxhYmxlKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IGRldmljZW1vdGlvbkV2ZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgZSk7XG5cblx0XHRkZXZpY2Vtb3Rpb25FdmVudC5pbnRlcnZhbCA9IGUuaW50ZXJ2YWw7XG5cdFx0ZGV2aWNlbW90aW9uRXZlbnQudGltZVN0YW1wID0gZS50aW1lU3RhbXA7XG5cdFx0ZGV2aWNlbW90aW9uRXZlbnQudHlwZSA9IGUudHlwZTtcblx0XHRkZXZpY2Vtb3Rpb25FdmVudC5yb3RhdGlvblJhdGUgPSB7XG5cdFx0XHRhbHBoYTogZS5yb3RhdGlvblJhdGUuYWxwaGEsXG5cdFx0XHRiZXRhOiBlLnJvdGF0aW9uUmF0ZS5iZXRhLFxuXHRcdFx0Z2FtbWE6IGUucm90YXRpb25SYXRlLmdhbW1hLFxuXHRcdH07XG5cdFx0ZGV2aWNlbW90aW9uRXZlbnQuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eSA9IHtcblx0XHRcdHg6IGUuYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eS54LFxuXHRcdFx0eTogZS5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5LnksXG5cdFx0XHR6OiBlLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHkueixcblx0XHR9O1xuXHRcdGRldmljZW1vdGlvbkV2ZW50LmFjY2VsZXJhdGlvbiA9IHtcblx0XHRcdHg6IGUuYWNjZWxlcmF0aW9uLngsXG5cdFx0XHR5OiBlLmFjY2VsZXJhdGlvbi55LFxuXHRcdFx0ejogZS5hY2NlbGVyYXRpb24ueixcblx0XHR9O1xuXG5cdFx0aWYgKHRoaXMuaXNBbmRyb2lkKSB7XG5cdFx0XHR2ZWMzLnNldChcblx0XHRcdFx0dGhpcy5yYXdHeXJvVmVjLFxuXHRcdFx0XHRlLnJvdGF0aW9uUmF0ZS5hbHBoYSB8fCAwLFxuXHRcdFx0XHRlLnJvdGF0aW9uUmF0ZS5iZXRhIHx8IDAsXG5cdFx0XHRcdGUucm90YXRpb25SYXRlLmdhbW1hIHx8IDApO1xuXHRcdFx0dmVjMy5zdWJ0cmFjdCh0aGlzLmFkanVzdGVkR3lyb1ZlYywgdGhpcy5yYXdHeXJvVmVjLCB0aGlzLnN0aWxsR3lyb1ZlYyk7XG5cdFx0XHR0aGlzLmxhc3REZXZpY2Vtb3Rpb25UaW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuXHRcdFx0ZGV2aWNlbW90aW9uRXZlbnQuYWRqdXN0ZWRSb3RhdGlvblJhdGUgPSB7XG5cdFx0XHRcdGFscGhhOiB0aGlzLmFkanVzdGVkR3lyb1ZlY1swXSxcblx0XHRcdFx0YmV0YTogdGhpcy5hZGp1c3RlZEd5cm9WZWNbMV0sXG5cdFx0XHRcdGdhbW1hOiB0aGlzLmFkanVzdGVkR3lyb1ZlY1syXX07XG5cdFx0fVxuXG5cdFx0dGhpcy50cmlnZ2VyKFwiZGV2aWNlbW90aW9uXCIsIHtcblx0XHRcdGlucHV0RXZlbnQ6IGRldmljZW1vdGlvbkV2ZW50XG5cdFx0fSk7XG5cdH1cblx0ZW5hYmxlKCkge1xuXHRcdGlmICh0aGlzLmlzQW5kcm9pZCkge1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkZXZpY2VvcmllbnRhdGlvblwiLCB0aGlzLl9vbkRldmljZU9yaWVudGF0aW9uKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuaXNXaXRob3V0RGV2aWNlTW90aW9uKSB7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsIHRoaXMuX29uQ2hyb21lV2l0aG91dERldmljZU1vdGlvbik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZGV2aWNlbW90aW9uXCIsIHRoaXMuX29uRGV2aWNlTW90aW9uKTtcblx0XHR9XG5cdFx0dGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcblx0fVxuXHRkaXNhYmxlKCkge1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGV2aWNlb3JpZW50YXRpb25cIiwgdGhpcy5fb25EZXZpY2VPcmllbnRhdGlvbik7XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkZXZpY2VvcmllbnRhdGlvblwiLCB0aGlzLl9vbkNocm9tZVdpdGhvdXREZXZpY2VNb3Rpb24pO1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGV2aWNlbW90aW9uXCIsIHRoaXMuX29uRGV2aWNlTW90aW9uKTtcblx0XHR0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcblx0fVxufVxuIiwiaW1wb3J0IE1hdGhVdGlsIGZyb20gXCJ3ZWJ2ci1wb2x5ZmlsbC9zcmMvbWF0aC11dGlsXCI7XG5pbXBvcnQgQ29tcGxlbWVudGFyeUZpbHRlciBmcm9tIFwid2VidnItcG9seWZpbGwvc3JjL3NlbnNvci1mdXNpb24vY29tcGxlbWVudGFyeS1maWx0ZXJcIjtcblxuQ29tcGxlbWVudGFyeUZpbHRlci5wcm90b3R5cGUucnVuXyA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIXRoaXMuaXNPcmllbnRhdGlvbkluaXRpYWxpemVkKSB7XG5cdFx0dGhpcy5hY2NlbFEgPSB0aGlzLmFjY2VsVG9RdWF0ZXJuaW9uXyh0aGlzLmN1cnJlbnRBY2NlbE1lYXN1cmVtZW50LnNhbXBsZSk7XG5cdFx0dGhpcy5wcmV2aW91c0ZpbHRlclEuY29weSh0aGlzLmFjY2VsUSk7XG5cdFx0dGhpcy5pc09yaWVudGF0aW9uSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGRlbHRhVCA9IHRoaXMuY3VycmVudEd5cm9NZWFzdXJlbWVudC50aW1lc3RhbXBTIC1cblx0dGhpcy5wcmV2aW91c0d5cm9NZWFzdXJlbWVudC50aW1lc3RhbXBTO1xuXG5cdC8vIENvbnZlcnQgZ3lybyByb3RhdGlvbiB2ZWN0b3IgdG8gYSBxdWF0ZXJuaW9uIGRlbHRhLlxuXHRjb25zdCBneXJvRGVsdGFRID0gdGhpcy5neXJvVG9RdWF0ZXJuaW9uRGVsdGFfKHRoaXMuY3VycmVudEd5cm9NZWFzdXJlbWVudC5zYW1wbGUsIGRlbHRhVCk7XG5cblx0dGhpcy5neXJvSW50ZWdyYWxRLm11bHRpcGx5KGd5cm9EZWx0YVEpO1xuXG5cdC8vIGZpbHRlcl8xID0gSyAqIChmaWx0ZXJfMCArIGd5cm8gKiBkVCkgKyAoMSAtIEspICogYWNjZWwuXG5cdHRoaXMuZmlsdGVyUS5jb3B5KHRoaXMucHJldmlvdXNGaWx0ZXJRKTtcblx0dGhpcy5maWx0ZXJRLm11bHRpcGx5KGd5cm9EZWx0YVEpO1xuXG5cdC8vIENhbGN1bGF0ZSB0aGUgZGVsdGEgYmV0d2VlbiB0aGUgY3VycmVudCBlc3RpbWF0ZWQgZ3Jhdml0eSBhbmQgdGhlIHJlYWxcblx0Ly8gZ3Jhdml0eSB2ZWN0b3IgZnJvbSBhY2NlbGVyb21ldGVyLlxuXHRjb25zdCBpbnZGaWx0ZXJRID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcblxuXHRpbnZGaWx0ZXJRLmNvcHkodGhpcy5maWx0ZXJRKTtcblx0aW52RmlsdGVyUS5pbnZlcnNlKCk7XG5cblx0dGhpcy5lc3RpbWF0ZWRHcmF2aXR5LnNldCgwLCAwLCAtMSk7XG5cdHRoaXMuZXN0aW1hdGVkR3Jhdml0eS5hcHBseVF1YXRlcm5pb24oaW52RmlsdGVyUSk7XG5cdHRoaXMuZXN0aW1hdGVkR3Jhdml0eS5ub3JtYWxpemUoKTtcblxuXHR0aGlzLm1lYXN1cmVkR3Jhdml0eS5jb3B5KHRoaXMuY3VycmVudEFjY2VsTWVhc3VyZW1lbnQuc2FtcGxlKTtcblx0dGhpcy5tZWFzdXJlZEdyYXZpdHkubm9ybWFsaXplKCk7XG5cblx0Ly8gQ29tcGFyZSBlc3RpbWF0ZWQgZ3Jhdml0eSB3aXRoIG1lYXN1cmVkIGdyYXZpdHksIGdldCB0aGUgZGVsdGEgcXVhdGVybmlvblxuXHQvLyBiZXR3ZWVuIHRoZSB0d28uXG5cdGNvbnN0IGRlbHRhUSA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG5cblx0ZGVsdGFRLnNldEZyb21Vbml0VmVjdG9ycyh0aGlzLmVzdGltYXRlZEdyYXZpdHksIHRoaXMubWVhc3VyZWRHcmF2aXR5KTtcblx0ZGVsdGFRLmludmVyc2UoKTtcblxuXHQvLyBDYWxjdWxhdGUgdGhlIFNMRVJQIHRhcmdldDogY3VycmVudCBvcmllbnRhdGlvbiBwbHVzIHRoZSBtZWFzdXJlZC1lc3RpbWF0ZWRcblx0Ly8gcXVhdGVybmlvbiBkZWx0YS5cblx0Y29uc3QgdGFyZ2V0USA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG5cblx0dGFyZ2V0US5jb3B5KHRoaXMuZmlsdGVyUSk7XG5cdHRhcmdldFEubXVsdGlwbHkoZGVsdGFRKTtcblxuXHQvLyBTTEVSUCBmYWN0b3I6IDAgaXMgcHVyZSBneXJvLCAxIGlzIHB1cmUgYWNjZWwuXG5cdHRoaXMuZmlsdGVyUS5zbGVycCh0YXJnZXRRLCAxIC0gdGhpcy5rRmlsdGVyKTtcblxuXHR0aGlzLnByZXZpb3VzRmlsdGVyUS5jb3B5KHRoaXMuZmlsdGVyUSk7XG5cblx0aWYgKCF0aGlzLmlzRmlsdGVyUXVhdGVybmlvbkluaXRpYWxpemVkKSB7XG5cdFx0dGhpcy5pc0ZpbHRlclF1YXRlcm5pb25Jbml0aWFsaXplZCA9IHRydWU7XG5cdH1cbn07XG5cbkNvbXBsZW1lbnRhcnlGaWx0ZXIucHJvdG90eXBlLmdldE9yaWVudGF0aW9uID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLmlzRmlsdGVyUXVhdGVybmlvbkluaXRpYWxpemVkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyUTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQ29tcGxlbWVudGFyeUZpbHRlcjtcblxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG5pbXBvcnQgUG9zZVByZWRpY3RvciBmcm9tIFwid2VidnItcG9seWZpbGwvc3JjL3NlbnNvci1mdXNpb24vcG9zZS1wcmVkaWN0b3JcIjtcbmltcG9ydCBNYXRoVXRpbCBmcm9tIFwid2VidnItcG9seWZpbGwvc3JjL21hdGgtdXRpbFwiO1xuaW1wb3J0IFV0aWwgZnJvbSBcIndlYnZyLXBvbHlmaWxsL3NyYy91dGlsXCI7XG5pbXBvcnQge3dpbmRvd30gZnJvbSBcIi4uLy4uL3V0aWxzL2Jyb3dzZXJcIjtcbmltcG9ydCB7cXVhdH0gZnJvbSBcIi4uLy4uL3V0aWxzL21hdGgtdXRpbFwiO1xuaW1wb3J0IERldmljZU1vdGlvbiBmcm9tIFwiLi9EZXZpY2VNb3Rpb25cIjtcbmltcG9ydCBDb21wbGVtZW50YXJ5RmlsdGVyIGZyb20gXCIuL0NvbXBsZW1lbnRhcnlGaWx0ZXJcIjtcbmltcG9ydCB7Q0hST01FX1ZFUlNJT059IGZyb20gXCIuLi9jb25zdHNcIjtcblxuY29uc3QgS19GSUxURVIgPSAwLjk4O1xuY29uc3QgUFJFRElDVElPTl9USU1FX1MgPSAwLjA0MDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRnVzaW9uUG9zZVNlbnNvciBleHRlbmRzIENvbXBvbmVudCB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmRldmljZU1vdGlvbiA9IG5ldyBEZXZpY2VNb3Rpb24oKTtcblxuXHRcdHRoaXMuYWNjZWxlcm9tZXRlciA9IG5ldyBNYXRoVXRpbC5WZWN0b3IzKCk7XG5cdFx0dGhpcy5neXJvc2NvcGUgPSBuZXcgTWF0aFV0aWwuVmVjdG9yMygpO1xuXG5cdFx0dGhpcy5fb25EZXZpY2VNb3Rpb25DaGFuZ2UgPSB0aGlzLl9vbkRldmljZU1vdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuX29uU2NyZWVuT3JpZW50YXRpb25DaGFuZ2UgPSB0aGlzLl9vblNjcmVlbk9yaWVudGF0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG5cblx0XHR0aGlzLmZpbHRlciA9IG5ldyBDb21wbGVtZW50YXJ5RmlsdGVyKEtfRklMVEVSKTtcblx0XHR0aGlzLnBvc2VQcmVkaWN0b3IgPSBuZXcgUG9zZVByZWRpY3RvcihQUkVESUNUSU9OX1RJTUVfUyk7XG5cblx0XHR0aGlzLmZpbHRlclRvV29ybGRRID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcblxuXHRcdHRoaXMuaXNGaXJlZm94QW5kcm9pZCA9IFV0aWwuaXNGaXJlZm94QW5kcm9pZCgpO1xuXHRcdHRoaXMuaXNJT1MgPSBVdGlsLmlzSU9TKCk7XG5cblx0XHQvLyBSZWYgaHR0cHM6Ly9naXRodWIuY29tL2ltbWVyc2l2ZS13ZWIvY2FyZGJvYXJkLXZyLWRpc3BsYXkvaXNzdWVzLzE4XG5cdFx0dGhpcy5pc0Nocm9tZVVzaW5nRGVncmVlcyA9IENIUk9NRV9WRVJTSU9OID49IDY2O1xuXG5cdFx0dGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG5cblx0XHQvLyBTZXQgdGhlIGZpbHRlciB0byB3b3JsZCB0cmFuc2Zvcm0sIGRlcGVuZGluZyBvbiBPUy5cblx0XHRpZiAodGhpcy5pc0lPUykge1xuXHRcdFx0dGhpcy5maWx0ZXJUb1dvcmxkUS5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBNYXRoVXRpbC5WZWN0b3IzKDEsIDAsIDApLCBNYXRoLlBJIC8gMik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZmlsdGVyVG9Xb3JsZFEuc2V0RnJvbUF4aXNBbmdsZShuZXcgTWF0aFV0aWwuVmVjdG9yMygxLCAwLCAwKSwgLU1hdGguUEkgLyAyKTtcblx0XHR9XG5cblx0XHR0aGlzLmludmVyc2VXb3JsZFRvU2NyZWVuUSA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG5cdFx0dGhpcy53b3JsZFRvU2NyZWVuUSA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG5cdFx0dGhpcy5vcmlnaW5hbFBvc2VBZGp1c3RRID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcblx0XHR0aGlzLm9yaWdpbmFsUG9zZUFkanVzdFEuc2V0RnJvbUF4aXNBbmdsZShuZXcgTWF0aFV0aWwuVmVjdG9yMygwLCAwLCAxKSxcblx0XHRcdC13aW5kb3cub3JpZW50YXRpb24gKiBNYXRoLlBJIC8gMTgwKTtcblxuXHRcdHRoaXMuX3NldFNjcmVlblRyYW5zZm9ybSgpO1xuXHRcdC8vIEFkanVzdCB0aGlzIGZpbHRlciBmb3IgYmVpbmcgaW4gbGFuZHNjYXBlIG1vZGUuXG5cdFx0aWYgKFV0aWwuaXNMYW5kc2NhcGVNb2RlKCkpIHtcblx0XHRcdHRoaXMuZmlsdGVyVG9Xb3JsZFEubXVsdGlwbHkodGhpcy5pbnZlcnNlV29ybGRUb1NjcmVlblEpO1xuXHRcdH1cblxuXHRcdC8vIEtlZXAgdHJhY2sgb2YgYSByZXNldCB0cmFuc2Zvcm0gZm9yIHJlc2V0U2Vuc29yLlxuXHRcdHRoaXMucmVzZXRRID0gbmV3IE1hdGhVdGlsLlF1YXRlcm5pb24oKTtcblxuXHRcdHRoaXMuZGV2aWNlTW90aW9uLm9uKFwiZGV2aWNlbW90aW9uXCIsIHRoaXMuX29uRGV2aWNlTW90aW9uQ2hhbmdlKTtcblx0XHR0aGlzLmVuYWJsZSgpO1xuXHR9XG5cdGVuYWJsZSgpIHtcblx0XHRpZiAodGhpcy5pc0VuYWJsZWQoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLmRldmljZU1vdGlvbi5lbmFibGUoKTtcblx0XHR0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fb25TY3JlZW5PcmllbnRhdGlvbkNoYW5nZSk7XG5cdH1cblx0ZGlzYWJsZSgpIHtcblx0XHRpZiAoIXRoaXMuaXNFbmFibGVkKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5kZXZpY2VNb3Rpb24uZGlzYWJsZSgpO1xuXHRcdHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fb25TY3JlZW5PcmllbnRhdGlvbkNoYW5nZSk7XG5cdH1cblx0aXNFbmFibGVkKCkge1xuXHRcdHJldHVybiB0aGlzLl9pc0VuYWJsZWQ7XG5cdH1cblx0ZGVzdHJveSgpIHtcblx0XHR0aGlzLmRpc2FibGUoKTtcblx0XHR0aGlzLmRldmljZU1vdGlvbiA9IG51bGw7XG5cdH1cblx0X3RyaWdnZXJDaGFuZ2UoKSB7XG5cdFx0Y29uc3Qgb3JpZW50YXRpb24gPSB0aGlzLmdldE9yaWVudGF0aW9uKCk7XG5cblx0XHQvLyBpZiBvcmllbnRhdGlvbiBpcyBub3QgcHJlcGFyZWQuIGRvbid0IHRyaWdnZXIgY2hhbmdlIGV2ZW50XG5cdFx0aWYgKCFvcmllbnRhdGlvbikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fcHJldk9yaWVudGF0aW9uKSB7XG5cdFx0XHR0aGlzLl9wcmV2T3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAocXVhdC5lcXVhbHModGhpcy5fcHJldk9yaWVudGF0aW9uLCBvcmllbnRhdGlvbikpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnRyaWdnZXIoXCJjaGFuZ2VcIiwge3F1YXRlcm5pb246IG9yaWVudGF0aW9ufSk7XG5cdH1cblx0Z2V0T3JpZW50YXRpb24oKSB7XG5cdFx0bGV0IG9yaWVudGF0aW9uO1xuXG5cdFx0Ly8gSGFjayBhcm91bmQgdXNpbmcgZGV2aWNlb3JpZW50YXRpb24gaW5zdGVhZCBvZiBkZXZpY2Vtb3Rpb25cblx0XHRpZiAodGhpcy5kZXZpY2VNb3Rpb24uaXNXaXRob3V0RGV2aWNlTW90aW9uICYmIHRoaXMuX2RldmljZU9yaWVudGF0aW9uUSkge1xuXHRcdFx0dGhpcy5kZXZpY2VPcmllbnRhdGlvbkZpeFEgPSB0aGlzLmRldmljZU9yaWVudGF0aW9uRml4USB8fCAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvbnN0IHkgPVxuXHRcdFx0XHRcdG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCkuc2V0RnJvbUF4aXNBbmdsZShcblx0XHRcdFx0XHRcdG5ldyBNYXRoVXRpbC5WZWN0b3IzKDAsIDEsIDApLCAtdGhpcy5fYWxwaGEpO1xuXG5cdFx0XHRcdHJldHVybiB5O1xuXHRcdFx0fSkuYmluZCh0aGlzKSgpO1xuXG5cdFx0XHRvcmllbnRhdGlvbiA9IHRoaXMuX2RldmljZU9yaWVudGF0aW9uUTtcblx0XHRcdGNvbnN0IG91dCA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG5cblx0XHRcdG91dC5jb3B5KG9yaWVudGF0aW9uKTtcblx0XHRcdG91dC5tdWx0aXBseSh0aGlzLmZpbHRlclRvV29ybGRRKTtcblx0XHRcdG91dC5tdWx0aXBseSh0aGlzLnJlc2V0USk7XG5cdFx0XHRvdXQubXVsdGlwbHkodGhpcy53b3JsZFRvU2NyZWVuUSk7XG5cdFx0XHRvdXQubXVsdGlwbHlRdWF0ZXJuaW9ucyh0aGlzLmRldmljZU9yaWVudGF0aW9uRml4USwgb3V0KTtcblxuXHRcdFx0Ly8gcmV0dXJuIHF1YXRlcm5pb24gYXMgZ2xtYXRyaXggcXVhdGVybmlvbiBvYmplY3Rcblx0XHRcdGNvbnN0IG91dF8gPSBxdWF0LmZyb21WYWx1ZXMoXG5cdFx0XHRcdG91dC54LFxuXHRcdFx0XHRvdXQueSxcblx0XHRcdFx0b3V0LnosXG5cdFx0XHRcdG91dC53XG5cdFx0XHQpO1xuXG5cdFx0XHRyZXR1cm4gcXVhdC5ub3JtYWxpemUob3V0Xywgb3V0Xyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIENvbnZlcnQgZnJvbSBmaWx0ZXIgc3BhY2UgdG8gdGhlIHRoZSBzYW1lIHN5c3RlbSB1c2VkIGJ5IHRoZVxuXHRcdFx0Ly8gZGV2aWNlb3JpZW50YXRpb24gZXZlbnQuXG5cdFx0XHRvcmllbnRhdGlvbiA9IHRoaXMuZmlsdGVyLmdldE9yaWVudGF0aW9uKCk7XG5cblx0XHRcdGlmICghb3JpZW50YXRpb24pIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG91dCA9IHRoaXMuX2NvbnZlcnRGdXNpb25Ub1ByZWRpY3RlZChvcmllbnRhdGlvbik7XG5cblx0XHRcdC8vIHJldHVybiBxdWF0ZXJuaW9uIGFzIGdsbWF0cml4IHF1YXRlcm5pb24gb2JqZWN0XG5cdFx0XHRjb25zdCBvdXRfID0gcXVhdC5mcm9tVmFsdWVzKFxuXHRcdFx0XHRvdXQueCxcblx0XHRcdFx0b3V0LnksXG5cdFx0XHRcdG91dC56LFxuXHRcdFx0XHRvdXQud1xuXHRcdFx0KTtcblxuXHRcdFx0cmV0dXJuIHF1YXQubm9ybWFsaXplKG91dF8sIG91dF8pO1xuXHRcdH1cblx0fVxuXHRfY29udmVydEZ1c2lvblRvUHJlZGljdGVkKG9yaWVudGF0aW9uKSB7XG5cdFx0Ly8gUHJlZGljdCBvcmllbnRhdGlvbi5cblx0XHR0aGlzLnByZWRpY3RlZFEgPVxuXHRcdFx0dGhpcy5wb3NlUHJlZGljdG9yLmdldFByZWRpY3Rpb24ob3JpZW50YXRpb24sIHRoaXMuZ3lyb3Njb3BlLCB0aGlzLnByZXZpb3VzVGltZXN0YW1wUyk7XG5cblx0XHQvLyBDb252ZXJ0IHRvIFRIUkVFIGNvb3JkaW5hdGUgc3lzdGVtOiAtWiBmb3J3YXJkLCBZIHVwLCBYIHJpZ2h0LlxuXHRcdGNvbnN0IG91dCA9IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG5cblx0XHRvdXQuY29weSh0aGlzLmZpbHRlclRvV29ybGRRKTtcblx0XHRvdXQubXVsdGlwbHkodGhpcy5yZXNldFEpO1xuXHRcdG91dC5tdWx0aXBseSh0aGlzLnByZWRpY3RlZFEpO1xuXHRcdG91dC5tdWx0aXBseSh0aGlzLndvcmxkVG9TY3JlZW5RKTtcblxuXHRcdHJldHVybiBvdXQ7XG5cdH1cblx0X29uRGV2aWNlTW90aW9uQ2hhbmdlKHtpbnB1dEV2ZW50fSkge1xuXHRcdGNvbnN0IGRldmljZW9yaWVudGF0aW9uID0gaW5wdXRFdmVudC5kZXZpY2VvcmllbnRhdGlvbjtcblx0XHRjb25zdCBkZXZpY2VNb3Rpb24gPSBpbnB1dEV2ZW50O1xuXHRcdGNvbnN0IGFjY0dyYXZpdHkgPSBkZXZpY2VNb3Rpb24uYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eTtcblx0XHRjb25zdCByb3RSYXRlID0gZGV2aWNlTW90aW9uLmFkanVzdGVkUm90YXRpb25SYXRlIHx8IGRldmljZU1vdGlvbi5yb3RhdGlvblJhdGU7XG5cdFx0bGV0IHRpbWVzdGFtcFMgPSBkZXZpY2VNb3Rpb24udGltZVN0YW1wIC8gMTAwMDtcblxuXHRcdGlmIChkZXZpY2VvcmllbnRhdGlvbikge1xuXHRcdFx0aWYgKCF0aGlzLl9hbHBoYSkge1xuXHRcdFx0XHR0aGlzLl9hbHBoYSA9IGRldmljZW9yaWVudGF0aW9uLmFscGhhO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZGV2aWNlT3JpZW50YXRpb25RID0gdGhpcy5fZGV2aWNlT3JpZW50YXRpb25RIHx8IG5ldyBNYXRoVXRpbC5RdWF0ZXJuaW9uKCk7XG5cdFx0XHR0aGlzLl9kZXZpY2VPcmllbnRhdGlvblEuc2V0RnJvbUV1bGVyWVhaKFxuXHRcdFx0XHRkZXZpY2VvcmllbnRhdGlvbi5iZXRhLFxuXHRcdFx0XHRkZXZpY2VvcmllbnRhdGlvbi5hbHBoYSxcblx0XHRcdFx0ZGV2aWNlb3JpZW50YXRpb24uZ2FtbWFcblx0XHRcdCk7XG5cblx0XHRcdHRoaXMuX3RyaWdnZXJDaGFuZ2UoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRmlyZWZveCBBbmRyb2lkIHRpbWVTdGFtcCByZXR1cm5zIG9uZSB0aG91c2FuZHRoIG9mIGEgbWlsbGlzZWNvbmQuXG5cdFx0XHRpZiAodGhpcy5pc0ZpcmVmb3hBbmRyb2lkKSB7XG5cdFx0XHRcdHRpbWVzdGFtcFMgLz0gMTAwMDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5hY2NlbGVyb21ldGVyLnNldCgtYWNjR3Jhdml0eS54LCAtYWNjR3Jhdml0eS55LCAtYWNjR3Jhdml0eS56KTtcblx0XHRcdHRoaXMuZ3lyb3Njb3BlLnNldChyb3RSYXRlLmFscGhhLCByb3RSYXRlLmJldGEsIHJvdFJhdGUuZ2FtbWEpO1xuXG5cdFx0XHQvLyBCcm93c2VycyBvbiBpT1MsIEZpcmVmb3gvQW5kcm9pZCwgYW5kIENocm9tZSBtNjYvQW5kcm9pZCBgcm90YXRpb25SYXRlYFxuXHRcdFx0Ly8gaXMgcmVwb3J0ZWQgaW4gZGVncmVlcywgc28gd2UgZmlyc3QgY29udmVydCB0byByYWRpYW5zLlxuXHRcdFx0aWYgKHRoaXMuaXNJT1MgfHwgdGhpcy5pc0ZpcmVmb3hBbmRyb2lkIHx8IHRoaXMuaXNDaHJvbWVVc2luZ0RlZ3JlZXMpIHtcblx0XHRcdFx0dGhpcy5neXJvc2NvcGUubXVsdGlwbHlTY2FsYXIoTWF0aC5QSSAvIDE4MCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZmlsdGVyLmFkZEFjY2VsTWVhc3VyZW1lbnQodGhpcy5hY2NlbGVyb21ldGVyLCB0aW1lc3RhbXBTKTtcblx0XHRcdHRoaXMuZmlsdGVyLmFkZEd5cm9NZWFzdXJlbWVudCh0aGlzLmd5cm9zY29wZSwgdGltZXN0YW1wUyk7XG5cblx0XHRcdHRoaXMuX3RyaWdnZXJDaGFuZ2UoKTtcblxuXHRcdFx0dGhpcy5wcmV2aW91c1RpbWVzdGFtcFMgPSB0aW1lc3RhbXBTO1xuXHRcdH1cblx0fVxuXHRfb25TY3JlZW5PcmllbnRhdGlvbkNoYW5nZShzY3JlZW5PcmllbnRhdGlvbikge1xuXHRcdHRoaXMuX3NldFNjcmVlblRyYW5zZm9ybSh3aW5kb3cub3JpZW50YXRpb24pO1xuXHR9XG5cdF9zZXRTY3JlZW5UcmFuc2Zvcm0oKSB7XG5cdFx0dGhpcy53b3JsZFRvU2NyZWVuUS5zZXQoMCwgMCwgMCwgMSk7XG5cdFx0c3dpdGNoICh3aW5kb3cub3JpZW50YXRpb24pIHtcblx0XHRcdGNhc2UgMDpcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDkwOlxuXHRcdFx0XHR0aGlzLndvcmxkVG9TY3JlZW5RLnNldEZyb21BeGlzQW5nbGUobmV3IE1hdGhVdGlsLlZlY3RvcjMoMCwgMCwgMSksIDkwIC8gLTE4MCAqIE1hdGguUEkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgLTkwOlxuXHRcdFx0XHR0aGlzLndvcmxkVG9TY3JlZW5RLnNldEZyb21BeGlzQW5nbGUobmV3IE1hdGhVdGlsLlZlY3RvcjMoMCwgMCwgMSksIC05MCAvIC0xODAgKiBNYXRoLlBJKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDE4MDpcblx0XHRcdFx0dGhpcy53b3JsZFRvU2NyZWVuUS5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBNYXRoVXRpbC5WZWN0b3IzKDAsIDAsIDEpLCAxODAgLyAtMTgwICogTWF0aC5QSSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHRoaXMuaW52ZXJzZVdvcmxkVG9TY3JlZW5RLmNvcHkodGhpcy53b3JsZFRvU2NyZWVuUSk7XG5cdFx0dGhpcy5pbnZlcnNlV29ybGRUb1NjcmVlblEuaW52ZXJzZSgpO1xuXHR9XG59XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbmltcG9ydCB7dG9BeGlzfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCBGdXNpb25Qb3NlU2Vuc29yIGZyb20gXCIuL0Z1c2lvblBvc2VTZW5zb3JcIjtcbmltcG9ydCB7XG5cdHV0aWwsXG5cdHF1YXQsXG5cdFJPVEFURV9DT05TVEFOVCxcbn0gZnJvbSBcIi4uLy4uL3V0aWxzL21hdGgtdXRpbFwiO1xuXG5mdW5jdGlvbiBnZXREZWx0YVlhdyhwcnZRLCBjdXJRKSB7XG5cdGNvbnN0IHlhd0RlbHRhQnlZYXcgPSB1dGlsLmdldFJvdGF0aW9uRGVsdGEocHJ2USwgY3VyUSwgUk9UQVRFX0NPTlNUQU5ULllBV19ERUxUQV9CWV9ZQVcpO1xuXHRjb25zdCB5YXdEZWx0YUJ5Um9sbCA9IHV0aWwuZ2V0Um90YXRpb25EZWx0YShwcnZRLCBjdXJRLCBST1RBVEVfQ09OU1RBTlQuWUFXX0RFTFRBX0JZX1JPTEwpICpcblx0XHRNYXRoLnNpbih1dGlsLmV4dHJhY3RQaXRjaEZyb21RdWF0KGN1clEpKTtcblxuXHRyZXR1cm4geWF3RGVsdGFCeVJvbGwgKyB5YXdEZWx0YUJ5WWF3O1xufVxuXG5mdW5jdGlvbiBnZXREZWx0YVBpdGNoKHBydlEsIGN1clEpIHtcblx0Y29uc3QgcGl0Y2hEZWx0YSA9IHV0aWwuZ2V0Um90YXRpb25EZWx0YShwcnZRLCBjdXJRLCBST1RBVEVfQ09OU1RBTlQuUElUQ0hfREVMVEEpO1xuXG5cdHJldHVybiBwaXRjaERlbHRhO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWx0TW90aW9uSW5wdXQgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3RvcihlbCwgb3B0aW9ucykge1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5lbGVtZW50ID0gZWw7XG5cblx0XHR0aGlzLl9wcmV2UXVhdGVybmlvbiA9IG51bGw7XG5cdFx0dGhpcy5fcXVhdGVybmlvbiA9IG51bGw7XG5cblx0XHR0aGlzLmZ1c2lvblBvc2VTZW5zb3IgPSBudWxsO1xuXG5cdFx0dGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0XHRzY2FsZTogMSxcblx0XHRcdHRocmVzaG9sZDogMCxcblx0XHR9LCBvcHRpb25zKTtcblxuXHRcdHRoaXMuX29uUG9zZUNoYW5nZSA9IHRoaXMuX29uUG9zZUNoYW5nZS5iaW5kKHRoaXMpO1xuXHR9XG5cdG1hcEF4ZXMoYXhlcykge1xuXHRcdHRoaXMuYXhlcyA9IGF4ZXM7XG5cdH1cblx0Y29ubmVjdChvYnNlcnZlcikge1xuXHRcdGlmICh0aGlzLm9ic2VydmVyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0dGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuXHRcdHRoaXMuZnVzaW9uUG9zZVNlbnNvciA9IG5ldyBGdXNpb25Qb3NlU2Vuc29yKCk7XG5cdFx0dGhpcy5mdXNpb25Qb3NlU2Vuc29yLmVuYWJsZSgpO1xuXHRcdHRoaXMuX2F0dGFjaEV2ZW50KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0ZGlzY29ubmVjdCgpIHtcblx0XHRpZiAoIXRoaXMub2JzZXJ2ZXIpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RldHRhY2hFdmVudCgpO1xuXHRcdHRoaXMuZnVzaW9uUG9zZVNlbnNvci5kaXNhYmxlKCk7XG5cdFx0dGhpcy5mdXNpb25Qb3NlU2Vuc29yLmRlc3Ryb3koKTtcblx0XHR0aGlzLmZ1c2lvblBvc2VTZW5zb3IgPSBudWxsO1xuXHRcdHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGRlc3Ryb3koKSB7XG5cdFx0dGhpcy5kaXNjb25uZWN0KCk7XG5cdFx0dGhpcy5lbGVtZW50ID0gbnVsbDtcblx0XHR0aGlzLm9wdGlvbnMgPSBudWxsO1xuXHRcdHRoaXMuYXhlcyA9IG51bGw7XG5cdFx0dGhpcy5fcHJldlF1YXRlcm5pb24gPSBudWxsO1xuXHRcdHRoaXMuX3F1YXRlcm5pb24gPSBudWxsO1xuXHR9XG5cdF9vblBvc2VDaGFuZ2UoZXZlbnQpIHtcblx0XHRpZiAoIXRoaXMuX3ByZXZRdWF0ZXJuaW9uKSB7XG5cdFx0XHR0aGlzLl9wcmV2UXVhdGVybmlvbiA9IHF1YXQuY2xvbmUoZXZlbnQucXVhdGVybmlvbik7XG5cdFx0XHR0aGlzLl9xdWF0ZXJuaW9uID0gcXVhdC5jbG9uZShldmVudC5xdWF0ZXJuaW9uKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRxdWF0LmNvcHkodGhpcy5fcHJldlF1YXRlcm5pb24sIHRoaXMuX3F1YXRlcm5pb24pO1xuXHRcdHF1YXQuY29weSh0aGlzLl9xdWF0ZXJuaW9uLCBldmVudC5xdWF0ZXJuaW9uKTtcblxuXHRcdHRoaXMub2JzZXJ2ZXIuY2hhbmdlKHRoaXMsIGV2ZW50LCB0b0F4aXModGhpcy5heGVzLCBbXG5cdFx0XHRnZXREZWx0YVlhdyh0aGlzLl9wcmV2UXVhdGVybmlvbiwgdGhpcy5fcXVhdGVybmlvbiksXG5cdFx0XHRnZXREZWx0YVBpdGNoKHRoaXMuX3ByZXZRdWF0ZXJuaW9uLCB0aGlzLl9xdWF0ZXJuaW9uKVxuXHRcdF0pKTtcblx0fVxuXHRfYXR0YWNoRXZlbnQoKSB7XG5cdFx0dGhpcy5mdXNpb25Qb3NlU2Vuc29yLm9uKFwiY2hhbmdlXCIsIHRoaXMuX29uUG9zZUNoYW5nZSk7XG5cdH1cblx0X2RldHRhY2hFdmVudCgpIHtcblx0XHR0aGlzLmZ1c2lvblBvc2VTZW5zb3Iub2ZmKFwiY2hhbmdlXCIsIHRoaXMuX29uUG9zZUNoYW5nZSk7XG5cdH1cbn1cblxuIiwiaW1wb3J0IHt3aW5kb3d9IGZyb20gXCIuLi91dGlscy9icm93c2VyXCI7XG5pbXBvcnQge2dsTWF0cml4fSBmcm9tIFwiLi4vdXRpbHMvbWF0aC11dGlsXCI7XG5cbi8vIFNpbmdsZXRvblxubGV0IHNjcmVlblJvdGF0aW9uQW5nbGVJbnN0ID0gbnVsbDtcbmxldCByZWZDb3VudCA9IDA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjcmVlblJvdGF0aW9uQW5nbGUge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRyZWZDb3VudCsrO1xuXG5cdFx0aWYgKHNjcmVlblJvdGF0aW9uQW5nbGVJbnN0KSB7XG5cdFx0XHRyZXR1cm4gc2NyZWVuUm90YXRpb25BbmdsZUluc3Q7XG5cdFx0fVxuXHRcdC8qIGVzbGludC1kaXNhYmxlICovXG5cdFx0c2NyZWVuUm90YXRpb25BbmdsZUluc3QgPSB0aGlzO1xuXHRcdC8qIGVzbGludC1lbmFibGUgKi9cblx0XHR0aGlzLl9vbkRldmljZU9yaWVudGF0aW9uID0gdGhpcy5fb25EZXZpY2VPcmllbnRhdGlvbi5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UgPSB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG5cblx0XHR0aGlzLl9zcGluUiA9IDA7XG5cblx0XHR0aGlzLl9zY3JlZW5PcmllbnRhdGlvbkFuZ2xlID0gMDtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsIHRoaXMuX29uRGV2aWNlT3JpZW50YXRpb24pO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSk7XG5cdH1cblxuXHRfb25EZXZpY2VPcmllbnRhdGlvbihlKSB7XG5cdFx0aWYgKGUuYmV0YSA9PT0gbnVsbCB8fCBlLmdhbW1hID09PSBudWxsKSB7XG5cdFx0XHQvLyAoQ2hyb21lKSBkZXZpY2VvcmllbnRhdGlvbiBpcyBmaXJlZCB3aXRoIGludmFsaWQgaW5mb3JtYXRpb24ge2FscGhhPW51bGwsIGJldGE9bnVsbCwgLi4ufSBkZXNwaXRlIG9mIG5vdCBkaXNwYXRjaGluZyBpdC4gV2Ugc2tpcCBpdC5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSYWRpYW5cblx0XHRjb25zdCBiZXRhUiA9IGdsTWF0cml4LnRvUmFkaWFuKGUuYmV0YSk7XG5cdFx0Y29uc3QgZ2FtbWFSID0gZ2xNYXRyaXgudG9SYWRpYW4oZS5nYW1tYSk7XG5cblx0XHQvKiBzcGluUiByYW5nZSA9IFstMTgwLCAxODBdLCBsZWZ0IHNpZGU6IDAgfiAtMTgwKGRlZyksIHJpZ2h0IHNpZGU6IDAgfiAxODAoZGVnKSAqL1xuXHRcdHRoaXMuX3NwaW5SID0gTWF0aC5hdGFuMihNYXRoLmNvcyhiZXRhUikgKiBNYXRoLnNpbihnYW1tYVIpLCBNYXRoLnNpbihiZXRhUikpO1xuXHR9XG5cblx0X29uT3JpZW50YXRpb25DaGFuZ2UoZSkge1xuXHRcdGlmICh3aW5kb3cuc2NyZWVuICYmIHdpbmRvdy5zY3JlZW4ub3JpZW50YXRpb24gJiYgd2luZG93LnNjcmVlbi5vcmllbnRhdGlvbi5hbmdsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLl9zY3JlZW5PcmllbnRhdGlvbkFuZ2xlID0gc2NyZWVuLm9yaWVudGF0aW9uLmFuZ2xlO1xuXHRcdH0gZWxzZSBpZiAod2luZG93Lm9yaWVudGF0aW9uICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8qIGlPUyAqL1xuXHRcdFx0dGhpcy5fc2NyZWVuT3JpZW50YXRpb25BbmdsZSA9IHdpbmRvdy5vcmllbnRhdGlvbiA+PSAwID9cblx0XHRcdFx0d2luZG93Lm9yaWVudGF0aW9uIDogMzYwICsgd2luZG93Lm9yaWVudGF0aW9uO1xuXHRcdH1cblx0fVxuXG5cdGdldFJhZGlhbigpIHtcblx0XHQvLyBKb2luIHdpdGggc2NyZWVuIG9yaWVudGF0aW9uXG5cdFx0Ly8gdGhpcy5fdGVzdFZhbCA9IHRoaXMuX3NwaW5SICsgXCIsIFwiICsgdGhpcy5fc2NyZWVuT3JpZW50YXRpb25BbmdsZSArIFwiLCBcIiArIHdpbmRvdy5vcmllbnRhdGlvbjtcblx0XHRyZXR1cm4gdGhpcy5fc3BpblIgKyBnbE1hdHJpeC50b1JhZGlhbih0aGlzLl9zY3JlZW5PcmllbnRhdGlvbkFuZ2xlKTtcblx0fVxuXG5cdHVucmVmKCkge1xuXHRcdGlmICgtLXJlZkNvdW50ID4gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGV2aWNlb3JpZW50YXRpb25cIiwgdGhpcy5fb25EZXZpY2VPcmllbnRhdGlvbik7XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlKTtcblxuXHRcdHRoaXMuX3NwaW5SID0gMDtcblx0XHR0aGlzLl9zY3JlZW5PcmllbnRhdGlvbkFuZ2xlID0gMDtcblx0XHQvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXHRcdHNjcmVlblJvdGF0aW9uQW5nbGVJbnN0ID0gbnVsbDtcblx0XHQvKiBlc2xpbnQtZW5hYmxlICovXG5cdFx0cmVmQ291bnQgPSAwO1xuXHR9XG59XG5cbiIsImltcG9ydCBBeGVzLCB7UGFuSW5wdXR9IGZyb20gXCJAZWdqcy9heGVzXCI7XG5pbXBvcnQgU2NyZWVuUm90YXRpb25BbmdsZSBmcm9tIFwiLi4vU2NyZWVuUm90YXRpb25BbmdsZVwiO1xuXG4vKipcbiAqIFJvdGF0aW9uUGFuSW5wdXQgaXMgZXh0ZW5zaW9uIG9mIFBhbklucHV0IHRvIGNvbXBlbnNhdGUgY29vcmRpbmF0ZXMgYnkgc2NyZWVuIHJvdGF0aW9uIGFuZ2xlLlxuICpcbiAqIFRoZSByZWFzb24gZm9yIHVzaW5nIHRoaXMgZnVuY3Rpb24gaXMgdGhhdCBpbiBWUiBtb2RlLFxuICogdGhlIHJvbGwgYW5nbGUgaXMgYWRqdXN0ZWQgaW4gdGhlIGRpcmVjdGlvbiBvcHBvc2l0ZSB0byB0aGUgc2NyZWVuIHJvdGF0aW9uIGFuZ2xlLlxuICpcbiAqIFRoZXJlZm9yZSwgdGhlIGFuZ2xlIHRoYXQgdGhlIHVzZXIgdG91Y2hlcyBhbmQgbW92ZXMgZG9lcyBub3QgbWF0Y2ggdGhlIGFuZ2xlIGF0IHdoaWNoIHRoZSBhY3R1YWwgb2JqZWN0IHNob3VsZCBtb3ZlLlxuICogQGV4dGVuZHMgUGFuSW5wdXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm90YXRpb25QYW5JbnB1dCBleHRlbmRzIFBhbklucHV0IHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdG9yXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbiBvYmplY3Rcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VSb3RhdGlvbl0gIFdoZXRoZXIgdG8gdXNlIHJvdGF0aW9uKG9yIFZSKVxuXHQgKi9cblx0Y29uc3RydWN0b3IoZWwsIG9wdGlvbnMpIHtcblx0XHRzdXBlcihlbCwgb3B0aW9ucyk7XG5cblx0XHR0aGlzLl91c2VSb3RhdGlvbiA9IGZhbHNlO1xuXHRcdHRoaXMuX3NjcmVlblJvdGF0aW9uQW5nbGUgPSBudWxsO1xuXG5cdFx0dGhpcy5zZXRVc2VSb3RhdGlvbighIShvcHRpb25zICYmIG9wdGlvbnMudXNlUm90YXRpb24pKTtcblxuXHRcdHRoaXMuX3VzZXJEaXJlY3Rpb24gPSBBeGVzLkRJUkVDVElPTl9BTEw7XG5cdH1cblxuXHRzZXRVc2VSb3RhdGlvbih1c2VSb3RhdGlvbikge1xuXHRcdHRoaXMuX3VzZVJvdGF0aW9uID0gdXNlUm90YXRpb247XG5cblx0XHRpZiAodGhpcy5fc2NyZWVuUm90YXRpb25BbmdsZSkge1xuXHRcdFx0dGhpcy5fc2NyZWVuUm90YXRpb25BbmdsZS51bnJlZigpO1xuXHRcdFx0dGhpcy5fc2NyZWVuUm90YXRpb25BbmdsZSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3VzZVJvdGF0aW9uKSB7XG5cdFx0XHR0aGlzLl9zY3JlZW5Sb3RhdGlvbkFuZ2xlID0gbmV3IFNjcmVlblJvdGF0aW9uQW5nbGUoKTtcblx0XHR9XG5cdH1cblxuXHRjb25uZWN0KG9ic2VydmVyKSB7XG5cdFx0Ly8gVXNlciBpbnRldGVuZWQgZGlyZWN0aW9uXG5cdFx0dGhpcy5fdXNlckRpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbjtcblxuXHRcdC8vIEluIFZSIE1vZGUsIFVzZSBBTEwgZGlyZWN0aW9uIGlmIGRpcmVjdGlvbiBpcyBub3Qgbm9uZVxuXHRcdC8vIEJlY2F1c2UgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgaXMgY2hhbmdlZCBkeW5hbWljYWxseSBieSBzY3JlZW4gcm90YXRpb24uXG5cdFx0Ly8gdGhpcy5fZGlyZWN0aW9uIGlzIHVzZWQgdG8gaW5pdGlhbGl6ZSBoYW1tZXJqc1xuXHRcdGlmICh0aGlzLl91c2VSb3RhdGlvbiAmJiAodGhpcy5fZGlyZWN0aW9uICYgQXhlcy5ESVJFQ1RJT05fQUxMKSkge1xuXHRcdFx0dGhpcy5fZGlyZWN0aW9uID0gQXhlcy5ESVJFQ1RJT05fQUxMO1xuXHRcdH1cblxuXHRcdHN1cGVyLmNvbm5lY3Qob2JzZXJ2ZXIpO1xuXHR9XG5cblx0Z2V0T2Zmc2V0KHByb3BlcnRpZXMsIHVzZURpcmVjdGlvbikge1xuXHRcdGlmICh0aGlzLl91c2VSb3RhdGlvbiA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybiBzdXBlci5nZXRPZmZzZXQocHJvcGVydGllcywgdXNlRGlyZWN0aW9uKTtcblx0XHR9XG5cblx0XHRjb25zdCBvZmZzZXQgPSBzdXBlci5nZXRPZmZzZXQocHJvcGVydGllcywgW3RydWUsIHRydWVdKTtcblx0XHRjb25zdCBuZXdPZmZzZXQgPSBbMCwgMF07XG5cdFx0Y29uc3QgdGhldGEgPSB0aGlzLl9zY3JlZW5Sb3RhdGlvbkFuZ2xlLmdldFJhZGlhbigpO1xuXHRcdGNvbnN0IGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xuXHRcdGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuXG5cdFx0bmV3T2Zmc2V0WzBdID0gb2Zmc2V0WzBdICogY29zVGhldGEgLSBvZmZzZXRbMV0gKiBzaW5UaGV0YTtcblx0XHRuZXdPZmZzZXRbMV0gPSBvZmZzZXRbMV0gKiBjb3NUaGV0YSArIG9mZnNldFswXSAqIHNpblRoZXRhO1xuXG5cdFx0Ly8gVXNlIG9ubHkgdXNlciBhbGxvd2VkIGRpcmVjdGlvbi5cblx0XHRpZiAoISh0aGlzLl91c2VyRGlyZWN0aW9uICYgQXhlcy5ESVJFQ1RJT05fSE9SSVpPTlRBTCkpIHtcblx0XHRcdG5ld09mZnNldFswXSA9IDA7XG5cdFx0fSBlbHNlIGlmICghKHRoaXMuX3VzZXJEaXJlY3Rpb24gJiBBeGVzLkRJUkVDVElPTl9WRVJUSUNBTCkpIHtcblx0XHRcdG5ld09mZnNldFsxXSA9IDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ld09mZnNldDtcblx0fVxuXG5cdGRlc3Ryb3koKSB7XG5cdFx0aWYgKHRoaXMuX3VzZVJvdGF0aW9uKSB7XG5cdFx0XHR0aGlzLl9zY3JlZW5Sb3RhdGlvbkFuZ2xlICYmIHRoaXMuX3NjcmVlblJvdGF0aW9uQW5nbGUudW5yZWYoKTtcblx0XHR9XG5cblx0XHRzdXBlci5kZXN0cm95KCk7XG5cdH1cbn1cblxuLyoqXG4gKiBPdmVycmlkZSBnZXREaXJlY3Rpb25CeUFuZ2xlIHRvIHJldHVybiBESVJFQ1RJT05fQUxMXG4gKiBSZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWF4ZXMvaXNzdWVzLzk5XG4gKlxuICogQnV0IHdlIG9iZXkgYXhlcydzIHJ1bGUuIElmIGF4ZXMncyBydWxlIGlzIHByb2JsZW0sIGxldCdzIGFwcGx5IGZvbGxvd2luZyBjb2RlLlxuICovXG4vLyBQYW5JbnB1dC5nZXREaXJlY3Rpb25CeUFuZ2xlID0gZnVuY3Rpb24gKGFuZ2xlLCB0aHJlc2hvbGRBbmdsZSkge1xuLy8gXHRyZXR1cm4gRElSRUNUSU9OX0FMTDtcbi8vIH07XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbmltcG9ydCBGdXNpb25Qb3NlU2Vuc29yIGZyb20gXCIuL2lucHV0L0Z1c2lvblBvc2VTZW5zb3JcIjtcbmltcG9ydCBTY3JlZW5Sb3RhdGlvbkFuZ2xlIGZyb20gXCIuL1NjcmVlblJvdGF0aW9uQW5nbGVcIjtcbmltcG9ydCB7dmVjMywgZ2xNYXRyaXgsIHF1YXR9IGZyb20gXCIuLi91dGlscy9tYXRoLXV0aWxcIjtcblxuY29uc3QgT1JJR0lOX1ZFQ1RPUiA9IHZlYzMuZnJvbVZhbHVlcygwLCAwLCAwKTtcbmNvbnN0IFhfQVhJU19WRUNUT1IgPSB2ZWMzLmZyb21WYWx1ZXMoMSwgMCwgMCk7XG5jb25zdCBZX0FYSVNfVkVDVE9SID0gdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZXZpY2VRdWF0ZXJuaW9uIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuX3NjcmVlblJvdGF0aW9uQW5nbGUgPSBuZXcgU2NyZWVuUm90YXRpb25BbmdsZSgpO1xuXHRcdHRoaXMuX2Z1c2lvblBvc2VTZW5zb3IgPSBuZXcgRnVzaW9uUG9zZVNlbnNvcigpO1xuXHRcdHRoaXMuX3F1YXRlcm5pb24gPSBxdWF0LmNyZWF0ZSgpO1xuXG5cdFx0dGhpcy5fZnVzaW9uUG9zZVNlbnNvci5lbmFibGUoKTtcblx0XHR0aGlzLl9mdXNpb25Qb3NlU2Vuc29yLm9uKFwiY2hhbmdlXCIsIGUgPT4ge1xuXHRcdFx0dGhpcy5fcXVhdGVybmlvbiA9IGUucXVhdGVybmlvbjtcblxuXHRcdFx0dGhpcy50cmlnZ2VyKFwiY2hhbmdlXCIsIHtpc1RydXN0ZWQ6IHRydWV9KTtcblx0XHR9KTtcblx0fVxuXG5cdGdldENvbWJpbmVkUXVhdGVybmlvbih5YXcsIHBpdGNoKSB7XG5cdFx0Y29uc3QgZGV2aWNlUiA9IHRoaXMuX3NjcmVlblJvdGF0aW9uQW5nbGUuZ2V0UmFkaWFuKCk7XG5cblx0XHQvLyByb3RhdGUgeC1heGlzIGFyb3VuZCB6LWF4aXMgYWJvdXQgc2NyZWVuIHJvdGF0aW9uIGFuZ2xlLlxuXHRcdGNvbnN0IHBpdGNoQXhpcyA9IHZlYzMucm90YXRlWih2ZWMzLmNyZWF0ZSgpLCBYX0FYSVNfVkVDVE9SLCBPUklHSU5fVkVDVE9SLCBkZXZpY2VSKTtcblx0XHRjb25zdCB5YXdRID0gcXVhdC5zZXRBeGlzQW5nbGUocXVhdC5jcmVhdGUoKSwgWV9BWElTX1ZFQ1RPUiwgZ2xNYXRyaXgudG9SYWRpYW4oLXlhdykpO1xuXHRcdC8vIHJvdGF0ZSBxdWF0ZXJuaW9uIGFyb3VuZCBuZXcgeC1heGlzIGFib3V0IHBpdGNoIGFuZ2xlLlxuXHRcdGNvbnN0IHBpdGNoUSA9IHF1YXQuc2V0QXhpc0FuZ2xlKHF1YXQuY3JlYXRlKCksIHBpdGNoQXhpcywgZ2xNYXRyaXgudG9SYWRpYW4oLXBpdGNoKSk7XG5cdFx0Y29uc3QgY29uaiA9IHF1YXQuY29uanVnYXRlKHF1YXQuY3JlYXRlKCksIHRoaXMuX3F1YXRlcm5pb24pO1xuXHRcdC8vIE11bHRpcGx5IHBpdGNoIHF1YXRlcm5pb24gLT4gZGV2aWNlIHF1YXRlcm5pb24gLT4geWF3IHF1YXRlcm5pb25cblx0XHRjb25zdCBvdXRRID0gcXVhdC5tdWx0aXBseShxdWF0LmNyZWF0ZSgpLCBwaXRjaFEsIGNvbmopO1xuXG5cdFx0cXVhdC5tdWx0aXBseShvdXRRLCBvdXRRLCB5YXdRKTtcblx0XHRyZXR1cm4gb3V0UTtcblx0fVxuXG5cdGRlc3Ryb3koKSB7XG5cdFx0Ly8gZGV0YWNoIGFsbCBldmVudCBoYW5kbGVyXG5cdFx0dGhpcy5vZmYoKTtcblxuXHRcdGlmICh0aGlzLl9mdXNpb25Qb3NlU2Vuc29yKSB7XG5cdFx0XHR0aGlzLl9mdXNpb25Qb3NlU2Vuc29yLm9mZigpO1xuXHRcdFx0dGhpcy5fZnVzaW9uUG9zZVNlbnNvci5kZXN0cm95KCk7XG5cdFx0XHR0aGlzLl9mdXNpb25Qb3NlU2Vuc29yID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fc2NyZWVuUm90YXRpb25BbmdsZSkge1xuXHRcdFx0dGhpcy5fc2NyZWVuUm90YXRpb25BbmdsZS51bnJlZigpO1xuXHRcdFx0dGhpcy5fc2NyZWVuUm90YXRpb25BbmdsZSA9IG51bGw7XG5cdFx0fVxuXHR9XG59XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbmltcG9ydCBBeGVzLCB7UGluY2hJbnB1dCwgTW92ZUtleUlucHV0LCBXaGVlbElucHV0fSBmcm9tIFwiQGVnanMvYXhlc1wiO1xuaW1wb3J0IHtnZXRDb21wdXRlZFN0eWxlLCBTVVBQT1JUX1RPVUNILCBTVVBQT1JUX0RFVklDRU1PVElPTn0gZnJvbSBcIi4uL3V0aWxzL2Jyb3dzZXJGZWF0dXJlXCI7XG5pbXBvcnQgVGlsdE1vdGlvbklucHV0IGZyb20gXCIuL2lucHV0L1RpbHRNb3Rpb25JbnB1dFwiO1xuaW1wb3J0IFJvdGF0aW9uUGFuSW5wdXQgZnJvbSBcIi4vaW5wdXQvUm90YXRpb25QYW5JbnB1dFwiO1xuaW1wb3J0IERldmljZVF1YXRlcm5pb24gZnJvbSBcIi4vRGV2aWNlUXVhdGVybmlvblwiO1xuaW1wb3J0IHtcblx0dmVjMixcbn0gZnJvbSBcIi4uL3V0aWxzL21hdGgtdXRpbFwiO1xuaW1wb3J0IHtcblx0R1lST19NT0RFLFxuXHRUT1VDSF9ESVJFQ1RJT05fWUFXLFxuXHRUT1VDSF9ESVJFQ1RJT05fUElUQ0gsXG5cdFRPVUNIX0RJUkVDVElPTl9BTEwsXG5cdE1DX0RFQ0VMRVJBVElPTixcblx0TUNfTUFYSU1VTV9EVVJBVElPTixcblx0TUNfQklORF9TQ0FMRSxcblx0TUFYX0ZJRUxEX09GX1ZJRVcsXG5cdFBBTl9TQ0FMRSxcblx0WUFXX1JBTkdFX0hBTEYsXG5cdFBJVENIX1JBTkdFX0hBTEYsXG5cdENJUkNVTEFSX1BJVENIX1JBTkdFX0hBTEYsXG5cdENPTlRST0xfTU9ERV9WUixcblx0Q09OVFJPTF9NT0RFX1lBV1BJVENILFxuXHRUT1VDSF9ESVJFQ1RJT05fTk9ORSxcbn0gZnJvbSBcIi4vY29uc3RzXCI7XG5pbXBvcnQge1ZFUlNJT059IGZyb20gXCIuLi92ZXJzaW9uXCI7XG5cbmNvbnN0IERFRkFVTFRfWUFXX1JBTkdFID0gWy1ZQVdfUkFOR0VfSEFMRiwgWUFXX1JBTkdFX0hBTEZdO1xuY29uc3QgREVGQVVMVF9QSVRDSF9SQU5HRSA9IFstUElUQ0hfUkFOR0VfSEFMRiwgUElUQ0hfUkFOR0VfSEFMRl07XG5jb25zdCBDSVJDVUxBUl9QSVRDSF9SQU5HRSA9IFstQ0lSQ1VMQVJfUElUQ0hfUkFOR0VfSEFMRiwgQ0lSQ1VMQVJfUElUQ0hfUkFOR0VfSEFMRl07XG5cbi8qKlxuICogQSBtb2R1bGUgdXNlZCB0byBwcm92aWRlIGNvb3JkaW5hdGUgYmFzZWQgb24geWF3L3BpdGNoIG9yaWVudGF0aW9uLiBUaGlzIG1vZHVsZSByZWNlaXZlcyB1c2VyIHRvdWNoIGFjdGlvbiwga2V5Ym9hcmQsIG1vdXNlIGFuZCBkZXZpY2Ugb3JpZW50YXRpb24oaWYgaXQgZXhpc3RzKSBhcyBpbnB1dCwgdGhlbiBjb21iaW5lcyB0aGVtIGFuZCBjb252ZXJ0cyBpdCB0byB5YXcvcGl0Y2ggY29vcmRpbmF0ZXMuXG4gKlxuICogQGFsaWFzIGVnLllhd1BpdGNoQ29udHJvbFxuICogQGV4dGVuZHMgZWcuQ29tcG9uZW50XG4gKlxuICogQHN1cHBvcnQge1wiaWVcIjogXCIxMCtcIiwgXCJjaFwiIDogXCJsYXRlc3RcIiwgXCJmZlwiIDogXCJsYXRlc3RcIiwgIFwic2ZcIiA6IFwibGF0ZXN0XCIsIFwiZWRnZVwiIDogXCJsYXRlc3RcIiwgXCJpb3NcIiA6IFwiNytcIiwgXCJhblwiIDogXCIyLjMrIChleGNlcHQgMy54KVwifVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBZYXdQaXRjaENvbnRyb2wgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRzdGF0aWMgVkVSU0lPTiA9IFZFUlNJT047XG5cdC8vIEV4cG9zZSBEZXZpY2VPcmllbnRhdGlvbkNvbnRyb2xzIHN1YiBtb2R1bGUgZm9yIHRlc3QgcHVycG9zZVxuXHRzdGF0aWMgQ09OVFJPTF9NT0RFX1ZSID0gQ09OVFJPTF9NT0RFX1ZSO1xuXHRzdGF0aWMgQ09OVFJPTF9NT0RFX1lBV1BJVENIID0gQ09OVFJPTF9NT0RFX1lBV1BJVENIO1xuXHRzdGF0aWMgVE9VQ0hfRElSRUNUSU9OX0FMTCA9IFRPVUNIX0RJUkVDVElPTl9BTEw7XG5cdHN0YXRpYyBUT1VDSF9ESVJFQ1RJT05fWUFXID0gVE9VQ0hfRElSRUNUSU9OX1lBVztcblx0c3RhdGljIFRPVUNIX0RJUkVDVElPTl9QSVRDSCA9IFRPVUNIX0RJUkVDVElPTl9QSVRDSDtcblx0c3RhdGljIFRPVUNIX0RJUkVDVElPTl9OT05FID0gVE9VQ0hfRElSRUNUSU9OX05PTkU7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9uIG9iamVjdCBvZiB0aGUgZWcuWWF3UGl0Y2ggbW9kdWxlXG5cdCAqIEBwYXJhbSB7RWxlbWVudH1bb3B0aW9ucy5lbGVtZW50PW51bGxdIGVsZW1lbnQgQSBiYXNlIGVsZW1lbnQgZm9yIHRoZSBlZy5ZYXdQaXRjaCBtb2R1bGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnlhdz0wXSBpbml0aWFsIHlhdyAoZGVncmVlKVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGl0Y2g9MF0gaW5pdGlhbCBwaXRjaCAoZGVncmVlKVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm92PTY1XSBpbml0aWFsIGZpZWxkIG9mIHZpZXcgKGRlZ3JlZSlcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9zbi5zaG93UG9sZVBvaW50PXRydWVdIEluZGljYXRlcyB3aGV0aGVyIHBvbGUgaXMgc2hvd25cblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2Vab29tPXRydWVdIEluZGljYXRlcyB3aGV0aGVyIHpvb20gaXMgYXZhaWxhYmxlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlS2V5Ym9hcmQ9dHJ1ZV0gSW5kaWNhdGVzIHdoZXRoZXIga2V5Ym9hcmQgaXMgZW5hYmxlZFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5neXJvTW9kZT15YXdQaXRjaF0gRW5hYmxlcyBjb250cm9sIHRocm91Z2ggZGV2aWNlIG1vdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvdWNoRGlyZWN0aW9uPVRPVUNIX0RJUkVDVElPTl9BTExdIERpcmVjdGlvbiBvZiB0aGUgdG91Y2ggbW92ZW1lbnQgKFRPVUNIX0RJUkVDVElPTl9BTEw6IGFsbCwgIFRPVUNIX0RJUkVDVElPTl9ZQVc6IGhvcml6b250YWwsIFRPVUNIX0RJUkVDVElPTl9QSVRDSDogdmVydGljYWwsIFRPVUNIX0RJUkVDVElPTl9OT05FOiBubyBtb3ZlKVxuXHQgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy55YXdSYW5nZT1bLTE4MCwgMTgwXSBSYW5nZSBvZiB2aXNpYmxlIHlhd1xuXHQgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5waXRjaFJhbmdlPVstOTAsIDkwXSBSYW5nZSBvZiB2aXNpYmxlIHBpdGNoXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmZvdlJhbmdlPVszMCwgMTEwXSBSYW5nZSBvZiBGT1Zcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFzcGVjdFJhdGlvPTFdIEFzcGVjdCBSYXRpb1xuXHQgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdHN1cGVyKCk7XG5cblx0XHRjb25zdCBvcHQgPSBPYmplY3QuYXNzaWduKHtcblx0XHRcdGVsZW1lbnQ6IG51bGwsXG5cdFx0XHR5YXc6IDAsXG5cdFx0XHRwaXRjaDogMCxcblx0XHRcdGZvdjogNjUsXG5cdFx0XHRzaG93UG9sZVBvaW50OiBmYWxzZSxcblx0XHRcdHVzZVpvb206IHRydWUsXG5cdFx0XHR1c2VLZXlib2FyZDogdHJ1ZSxcblx0XHRcdGd5cm9Nb2RlOiBHWVJPX01PREUuWUFXUElUQ0gsXG5cdFx0XHR0b3VjaERpcmVjdGlvbjogVE9VQ0hfRElSRUNUSU9OX0FMTCxcblx0XHRcdHlhd1JhbmdlOiBERUZBVUxUX1lBV19SQU5HRSxcblx0XHRcdHBpdGNoUmFuZ2U6IERFRkFVTFRfUElUQ0hfUkFOR0UsXG5cdFx0XHRmb3ZSYW5nZTogWzMwLCAxMTBdLFxuXHRcdFx0YXNwZWN0UmF0aW86IDEsIC8qIFRPRE86IE5lZWQgTWFuZGF0b3J5PyAqL1xuXHRcdH0sIG9wdGlvbnMpO1xuXG5cdFx0dGhpcy5fZWxlbWVudCA9IG9wdC5lbGVtZW50O1xuXHRcdHRoaXMuX2luaXRpYWxGb3YgPSBvcHQuZm92O1xuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9pc0FuaW1hdGluZyA9IGZhbHNlO1xuXHRcdHRoaXMuX2RldmljZVF1YXRlcm5pb24gPSBudWxsO1xuXG5cdFx0dGhpcy5faW5pdEF4ZXMob3B0KTtcblx0XHR0aGlzLm9wdGlvbihvcHQpO1xuXHR9XG5cblx0X2luaXRBeGVzKG9wdCkge1xuXHRcdGNvbnN0IHlSYW5nZSA9IHRoaXMuX3VwZGF0ZVlhd1JhbmdlKG9wdC55YXdSYW5nZSwgb3B0LmZvdiwgb3B0LmFzcGVjdFJhdGlvKTtcblx0XHRjb25zdCBwUmFuZ2UgPSB0aGlzLl91cGRhdGVQaXRjaFJhbmdlKG9wdC5waXRjaFJhbmdlLCBvcHQuZm92LCBvcHQuc2hvd1BvbGVQb2ludCk7XG5cdFx0Y29uc3QgdXNlUm90YXRpb24gPSBvcHQuZ3lyb01vZGUgPT09IEdZUk9fTU9ERS5WUjtcblxuXHRcdHRoaXMuYXhlc1BhbklucHV0ID0gbmV3IFJvdGF0aW9uUGFuSW5wdXQodGhpcy5fZWxlbWVudCwge3VzZVJvdGF0aW9ufSk7XG5cdFx0dGhpcy5heGVzV2hlZWxJbnB1dCA9IG5ldyBXaGVlbElucHV0KHRoaXMuX2VsZW1lbnQsIHtzY2FsZTogLTR9KTtcblx0XHR0aGlzLmF4ZXNUaWx0TW90aW9uSW5wdXQgPSBudWxsO1xuXHRcdHRoaXMuYXhlc1BpbmNoSW5wdXQgPSBTVVBQT1JUX1RPVUNIID8gbmV3IFBpbmNoSW5wdXQodGhpcy5fZWxlbWVudCwge3NjYWxlOiAtMX0pIDogbnVsbDtcblx0XHR0aGlzLmF4ZXNNb3ZlS2V5SW5wdXQgPSBuZXcgTW92ZUtleUlucHV0KHRoaXMuX2VsZW1lbnQsIHtzY2FsZTogWy02LCA2XX0pO1xuXG5cdFx0dGhpcy5heGVzID0gbmV3IEF4ZXMoe1xuXHRcdFx0eWF3OiB7XG5cdFx0XHRcdHJhbmdlOiB5UmFuZ2UsXG5cdFx0XHRcdGNpcmN1bGFyOiBZYXdQaXRjaENvbnRyb2wuaXNDaXJjdWxhcih5UmFuZ2UpLFxuXHRcdFx0XHRib3VuY2U6IFswLCAwXVxuXHRcdFx0fSxcblx0XHRcdHBpdGNoOiB7XG5cdFx0XHRcdHJhbmdlOiBwUmFuZ2UsXG5cdFx0XHRcdGNpcmN1bGFyOiBZYXdQaXRjaENvbnRyb2wuaXNDaXJjdWxhcihwUmFuZ2UpLFxuXHRcdFx0XHRib3VuY2U6IFswLCAwXVxuXHRcdFx0fSxcblx0XHRcdGZvdjoge1xuXHRcdFx0XHRyYW5nZTogb3B0LmZvdlJhbmdlLFxuXHRcdFx0XHRjaXJjdWxhcjogW2ZhbHNlLCBmYWxzZV0sXG5cdFx0XHRcdGJvdW5jZTogWzAsIDBdXG5cdFx0XHR9LFxuXHRcdH0sIHtcblx0XHRcdGRlY2VsZXJhdGlvbjogTUNfREVDRUxFUkFUSU9OLFxuXHRcdFx0bWF4aW11bUR1cmF0aW9uOiBNQ19NQVhJTVVNX0RVUkFUSU9OLFxuXHRcdH0sIHtcblx0XHRcdHlhdzogb3B0Lnlhdyxcblx0XHRcdHBpdGNoOiBvcHQucGl0Y2gsXG5cdFx0XHRmb3Y6IG9wdC5mb3Zcblx0XHR9KS5vbih7XG5cdFx0XHRob2xkOiBldnQgPT4ge1xuXHRcdFx0XHQvLyBSZXN0b3JlIG1heGltdW1EdXJhdGlvbiBub3QgdG8gYmUgc3BpbiB0b28gbXVzaC5cblx0XHRcdFx0dGhpcy5heGVzLm9wdGlvbnMubWF4aW11bUR1cmF0aW9uID0gTUNfTUFYSU1VTV9EVVJBVElPTjtcblxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJob2xkXCIsIHtpc1RydXN0ZWQ6IGV2dC5pc1RydXN0ZWR9KTtcblx0XHRcdH0sXG5cdFx0XHRjaGFuZ2U6IGV2dCA9PiB7XG5cdFx0XHRcdGlmIChldnQuZGVsdGEuZm92ICE9PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlQ29udHJvbFNjYWxlKGV2dCk7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGVQYW5TY2FsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3RyaWdnZXJDaGFuZ2UoZXZ0KTtcblx0XHRcdH0sXG5cdFx0XHRyZWxlYXNlOiBldnQgPT4ge1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyQ2hhbmdlKGV2dCk7XG5cdFx0XHR9LFxuXHRcdFx0YW5pbWF0aW9uU3RhcnQ6IGV2dCA9PiB7XG5cdFx0XHR9LFxuXHRcdFx0YW5pbWF0aW9uRW5kOiBldnQgPT4ge1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJhbmltYXRpb25FbmRcIiwge2lzVHJ1c3RlZDogZXZ0LmlzVHJ1c3RlZH0pO1xuXHRcdFx0fSxcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgUGFuIFNjYWxlXG5cdCAqXG5cdCAqIFNjYWxlKFNlbnNpdGl2aXR5KSB2YWx1ZXMgb2YgcGFubmluZyBpcyByZWxhdGVkIHdpdGggZm92IGFuZCBoZWlnaHQuXG5cdCAqIElmIGF0IGxlYXN0IG9uZSBvZiB0aGVtIGlzIGNoYW5nZWQsIHRoaXMgZnVuY3Rpb24gbmVlZCB0byBiZSBjYWxsZWQuXG5cdCAqIEBwYXJhbSB7Kn0gcGFyYW1cblx0ICovXG5cdHVwZGF0ZVBhblNjYWxlKHBhcmFtID0ge30pIHtcblx0XHRjb25zdCBmb3YgPSB0aGlzLmF4ZXMuZ2V0KCkuZm92O1xuXHRcdGNvbnN0IGFyZWFIZWlnaHQgPSBwYXJhbS5oZWlnaHQgfHwgcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50KS5oZWlnaHQsIDEwKTtcblx0XHRjb25zdCBzY2FsZSA9IE1DX0JJTkRfU0NBTEVbMF0gKiBmb3YgLyB0aGlzLl9pbml0aWFsRm92ICogUEFOX1NDQUxFIC8gYXJlYUhlaWdodDtcblxuXHRcdHRoaXMuYXhlc1BhbklucHV0Lm9wdGlvbnMuc2NhbGUgPSBbc2NhbGUsIHNjYWxlXTtcblx0XHR0aGlzLmF4ZXMub3B0aW9ucy5kZWNlbGVyYXRpb24gPSBNQ19ERUNFTEVSQVRJT04gKiBmb3YgLyBNQVhfRklFTERfT0ZfVklFVztcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Lypcblx0ICogT3ZlcnJpZGUgY29tcG9uZW50J3Mgb3B0aW9uIG1ldGhvZFxuXHQgKiB0byBjYWxsIG1ldGhvZCBmb3IgdXBkYXRpbmcgdmFsdWVzIHdoaWNoIGlzIGFmZmVjdGVkIGJ5IG9wdGlvbiBjaGFuZ2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0gYXJnc1xuXHQgKi9cblx0b3B0aW9uKC4uLmFyZ3MpIHtcblx0XHRjb25zdCBhcmdMZW4gPSBhcmdzLmxlbmd0aDtcblxuXHRcdC8vIEdldHRlclxuXHRcdGlmIChhcmdMZW4gPT09IDApIHtcblx0XHRcdHJldHVybiB0aGlzLl9nZXRPcHRpb25zKCk7XG5cdFx0fSBlbHNlIGlmIChhcmdMZW4gPT09IDEgJiYgdHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHJldHVybiB0aGlzLl9nZXRPcHRpb25zKGFyZ3NbMF0pO1xuXHRcdH1cblxuXHRcdC8vIFNldHRlclxuXHRcdGNvbnN0IGJlZm9yZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpO1xuXHRcdGxldCBuZXdPcHRpb25zID0ge307XG5cdFx0bGV0IGNoYW5nZWRLZXlMaXN0ID0gW107IC8vIFRPRE86IGlmIHZhbHVlIGlzIG5vdCBjaGFuZ2VkLCB0aGVuIGRvIG5vdCBwdXNoIG9uIGNoYW5nZWRLZXlMaXN0LlxuXG5cdFx0aWYgKGFyZ0xlbiA9PT0gMSkge1xuXHRcdFx0Y2hhbmdlZEtleUxpc3QgPSBPYmplY3Qua2V5cyhhcmdzWzBdKTtcblx0XHRcdG5ld09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBhcmdzWzBdKTtcblx0XHR9IGVsc2UgaWYgKGFyZ0xlbiA+PSAyKSB7XG5cdFx0XHRjaGFuZ2VkS2V5TGlzdC5wdXNoKGFyZ3NbMF0pO1xuXHRcdFx0bmV3T3B0aW9uc1thcmdzWzBdXSA9IGFyZ3NbMV07XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2V0T3B0aW9ucyh0aGlzLl9nZXRWYWxpZGF0ZWRPcHRpb25zKG5ld09wdGlvbnMpKTtcblx0XHR0aGlzLl9hcHBseU9wdGlvbnMoY2hhbmdlZEtleUxpc3QsIGJlZm9yZU9wdGlvbnMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0X2dldFZhbGlkYXRlZE9wdGlvbnMobmV3T3B0aW9ucykge1xuXHRcdGlmIChuZXdPcHRpb25zLnlhd1JhbmdlKSB7XG5cdFx0XHRuZXdPcHRpb25zLnlhd1JhbmdlID1cblx0XHRcdFx0dGhpcy5fZ2V0VmFsaWRZYXdSYW5nZShuZXdPcHRpb25zLnlhd1JhbmdlLCBuZXdPcHRpb25zLmZvdiwgbmV3T3B0aW9ucy5hc3BlY3RSYXRpbyk7XG5cdFx0fVxuXHRcdGlmIChuZXdPcHRpb25zLnBpdGNoUmFuZ2UpIHtcblx0XHRcdG5ld09wdGlvbnMucGl0Y2hSYW5nZSA9IHRoaXMuX2dldFZhbGlkUGl0Y2hSYW5nZShuZXdPcHRpb25zLnBpdGNoUmFuZ2UsIG5ld09wdGlvbnMuZm92KTtcblx0XHR9XG5cdFx0cmV0dXJuIG5ld09wdGlvbnM7XG5cdH1cblxuXHRfZ2V0T3B0aW9ucyhrZXkpIHtcblx0XHRsZXQgdmFsdWU7XG5cblx0XHRpZiAodHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFsdWUgPSB0aGlzLm9wdGlvbnNba2V5XTtcblx0XHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcblx0XHRcdHZhbHVlID0gdGhpcy5vcHRpb25zO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHRfc2V0T3B0aW9ucyhvcHRpb25zKSB7XG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuXHRcdFx0dGhpcy5vcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG5cdFx0fVxuXHR9XG5cblx0X2FwcGx5T3B0aW9ucyhrZXlzLCBwcmV2T3B0aW9ucykge1xuXHRcdC8vIElmIG9uZSBvZiBiZWxvdyBpcyBjaGFuZ2VkLCBjYWxsIHVwZGF0ZUNvbnRyb2xTY2FsZSgpXG5cdFx0aWYgKGtleXMuc29tZShrZXkgPT5cblx0XHRcdGtleSA9PT0gXCJzaG93UG9sZVBvaW50XCIgfHwga2V5ID09PSBcImZvdlwiIHx8IGtleSA9PT0gXCJhc3BlY3RSYXRpb1wiIHx8XG5cdFx0XHRrZXkgPT09IFwieWF3UmFuZ2VcIiB8fCBrZXkgPT09IFwicGl0Y2hSYW5nZVwiXG5cdFx0KSkge1xuXHRcdFx0dGhpcy5fdXBkYXRlQ29udHJvbFNjYWxlKCk7XG5cblx0XHRcdC8vIElmIGZvdiBpcyBjaGFuZ2VkLCB1cGRhdGUgcGFuIHNjYWxlXG5cdFx0XHRpZiAoa2V5cy5pbmRleE9mKFwiZm92XCIpID49IDApIHtcblx0XHRcdFx0dGhpcy51cGRhdGVQYW5TY2FsZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChrZXlzLnNvbWUoa2V5ID0+IGtleSA9PT0gXCJmb3ZSYW5nZVwiKSkge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBUZW1wb3JhcnkgRml4IENvZGVcblx0XHRcdCAqIENoYW5nZWQgZmxvYXQgbnVtYmVyIGFzIHRvRml4ZWQoNSkgZm9ybWF0IGZvciB0ZW1wb3JhcnkuXG5cdFx0XHQgKlxuXHRcdFx0ICogVE9ETzogaXQgc2hvdWxkIG5vdCB1c2UgdG9GaXhlZCg1KSBhZnRlciBheGVzLmpzIGlzIGZpeGVkLlxuXHRcdFx0ICovXG5cdFx0XHRjb25zdCBmb3ZSYW5nZSA9IHRoaXMub3B0aW9ucy5mb3ZSYW5nZS5tYXAodiA9PiArdi50b0ZpeGVkKDUpKTtcblx0XHRcdGNvbnN0IHByZXZGb3YgPSB0aGlzLmF4ZXMuZ2V0KCkuZm92O1xuXHRcdFx0bGV0IG5leHRGb3YgPSB0aGlzLmF4ZXMuZ2V0KCkuZm92O1xuXG5cdFx0XHR2ZWMyLmNvcHkodGhpcy5heGVzLmF4aXMuZm92LnJhbmdlLCBmb3ZSYW5nZSk7XG5cblx0XHRcdGlmIChuZXh0Rm92IDwgZm92UmFuZ2VbMF0pIHtcblx0XHRcdFx0bmV4dEZvdiA9IGZvdlJhbmdlWzBdO1xuXHRcdFx0fSBlbHNlIGlmIChwcmV2Rm92ID4gZm92UmFuZ2VbMV0pIHtcblx0XHRcdFx0bmV4dEZvdiA9IGZvdlJhbmdlWzFdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocHJldkZvdiAhPT0gbmV4dEZvdikge1xuXHRcdFx0XHR0aGlzLmF4ZXMuc2V0VG8oe1xuXHRcdFx0XHRcdGZvdjogbmV4dEZvdlxuXHRcdFx0XHR9LCAwKTtcblx0XHRcdFx0dGhpcy5fdXBkYXRlQ29udHJvbFNjYWxlKCk7XG5cdFx0XHRcdHRoaXMudXBkYXRlUGFuU2NhbGUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoa2V5cy5zb21lKGtleSA9PiBrZXkgPT09IFwiZ3lyb01vZGVcIikgJiYgU1VQUE9SVF9ERVZJQ0VNT1RJT04pIHtcblx0XHRcdGNvbnN0IGlzVlIgPSB0aGlzLm9wdGlvbnMuZ3lyb01vZGUgPT09IEdZUk9fTU9ERS5WUjtcblx0XHRcdGNvbnN0IGlzWWF3UGl0Y2ggPSB0aGlzLm9wdGlvbnMuZ3lyb01vZGUgPT09IEdZUk9fTU9ERS5ZQVdQSVRDSDtcblxuXHRcdFx0Ly8gRGlzY29ubmVjdCBmaXJzdFxuXHRcdFx0aWYgKHRoaXMuYXhlc1RpbHRNb3Rpb25JbnB1dCkge1xuXHRcdFx0XHR0aGlzLmF4ZXMuZGlzY29ubmVjdCh0aGlzLmF4ZXNUaWx0TW90aW9uSW5wdXQpO1xuXHRcdFx0XHR0aGlzLmF4ZXNUaWx0TW90aW9uSW5wdXQuZGVzdHJveSgpO1xuXHRcdFx0XHR0aGlzLmF4ZXNUaWx0TW90aW9uSW5wdXQgPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fZGV2aWNlUXVhdGVybmlvbikge1xuXHRcdFx0XHR0aGlzLl9kZXZpY2VRdWF0ZXJuaW9uLmRlc3Ryb3koKTtcblx0XHRcdFx0dGhpcy5fZGV2aWNlUXVhdGVybmlvbiA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc1ZSKSB7XG5cdFx0XHRcdHRoaXMuX2luaXREZXZpY2VRdWF0ZXJuaW9uKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGlzWWF3UGl0Y2gpIHtcblx0XHRcdFx0dGhpcy5heGVzVGlsdE1vdGlvbklucHV0ID0gbmV3IFRpbHRNb3Rpb25JbnB1dCh0aGlzLl9lbGVtZW50KTtcblx0XHRcdFx0dGhpcy5heGVzLmNvbm5lY3QoW1wieWF3XCIsIFwicGl0Y2hcIl0sIHRoaXMuYXhlc1RpbHRNb3Rpb25JbnB1dCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYXhlc1BhbklucHV0LnNldFVzZVJvdGF0aW9uKGlzVlIpO1xuXHRcdH1cblxuXHRcdGlmIChrZXlzLnNvbWUoa2V5ID0+IGtleSA9PT0gXCJ1c2VLZXlib2FyZFwiKSkge1xuXHRcdFx0Y29uc3QgdXNlS2V5Ym9hcmQgPSB0aGlzLm9wdGlvbnMudXNlS2V5Ym9hcmQ7XG5cblx0XHRcdGlmICh1c2VLZXlib2FyZCkge1xuXHRcdFx0XHR0aGlzLmF4ZXMuY29ubmVjdChbXCJ5YXdcIiwgXCJwaXRjaFwiXSwgdGhpcy5heGVzTW92ZUtleUlucHV0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYXhlcy5kaXNjb25uZWN0KHRoaXMuYXhlc01vdmVLZXlJbnB1dCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGtleXMuc29tZShrZXkgPT4ga2V5ID09PSBcInVzZVpvb21cIikpIHtcblx0XHRcdGNvbnN0IHVzZVpvb20gPSB0aGlzLm9wdGlvbnMudXNlWm9vbTtcblxuXHRcdFx0Ly8gRGlzY29ubmVjdCBmaXJzdFxuXHRcdFx0dGhpcy5heGVzLmRpc2Nvbm5lY3QodGhpcy5heGVzV2hlZWxJbnB1dCk7XG5cdFx0XHRpZiAodXNlWm9vbSkge1xuXHRcdFx0XHR0aGlzLmF4ZXMuY29ubmVjdChbXCJmb3ZcIl0sIHRoaXMuYXhlc1doZWVsSW5wdXQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3RvZ2dsZVBpbmNoSW5wdXRCeU9wdGlvbih0aGlzLm9wdGlvbnMudG91Y2hEaXJlY3Rpb24sIHRoaXMub3B0aW9ucy51c2Vab29tKTtcblxuXHRcdGlmIChrZXlzLnNvbWUoa2V5ID0+IGtleSA9PT0gXCJ0b3VjaERpcmVjdGlvblwiKSkge1xuXHRcdFx0dGhpcy5fZW5hYmxlZCAmJiB0aGlzLl9lbmFibGVUb3VjaCh0aGlzLm9wdGlvbnMudG91Y2hEaXJlY3Rpb24pO1xuXHRcdH1cblx0fVxuXG5cdF90b2dnbGVQaW5jaElucHV0QnlPcHRpb24odG91Y2hEaXJlY3Rpb24sIHVzZVpvb20pIHtcblx0XHRpZiAodGhpcy5heGVzUGluY2hJbnB1dCkge1xuXHRcdFx0Ly8gZGlzY29ubmVjdCBmaXJzdFxuXHRcdFx0dGhpcy5heGVzLmRpc2Nvbm5lY3QodGhpcy5heGVzUGluY2hJbnB1dCk7XG5cblx0XHRcdC8vIElmIHRoZSB0b3VjaERpcmVjdGlvbiBvcHRpb24gaXMgbm90IEFMTCwgcGluY2hJbnB1dCBzaG91bGQgYmUgZGlzY29ubmVjdGVkIHRvIG1ha2UgdXNlIG9mIGEgbmF0aXZlIHNjcm9sbC5cblx0XHRcdGlmIChcblx0XHRcdFx0dXNlWm9vbSAmJlxuXHRcdFx0XHR0b3VjaERpcmVjdGlvbiA9PT0gVE9VQ0hfRElSRUNUSU9OX0FMTCAmJlxuXHRcdFx0XHQvLyBUT0RPOiBHZXQgcmlkIG9mIHVzaW5nIHByaXZhdGUgcHJvcGVydHkgb2YgYXhlcyBpbnN0YW5jZS5cblx0XHRcdFx0dGhpcy5heGVzLl9pbnB1dHMuaW5kZXhPZih0aGlzLmF4ZXNQaW5jaElucHV0KSA9PT0gLTFcblx0XHRcdCkge1xuXHRcdFx0XHR0aGlzLmF4ZXMuY29ubmVjdChbXCJmb3ZcIl0sIHRoaXMuYXhlc1BpbmNoSW5wdXQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdF9lbmFibGVUb3VjaChkaXJlY3Rpb24pIHtcblx0XHQvLyBEaXNjb25uZWN0IGZpcnN0XG5cdFx0dGhpcy5heGVzUGFuSW5wdXQgJiYgdGhpcy5heGVzLmRpc2Nvbm5lY3QodGhpcy5heGVzUGFuSW5wdXQpO1xuXG5cdFx0Y29uc3QgeWF3RW5hYmxlZCA9IGRpcmVjdGlvbiAmIFRPVUNIX0RJUkVDVElPTl9ZQVcgPyBcInlhd1wiIDogbnVsbDtcblx0XHRjb25zdCBwaXRjaEVuYWJsZWQgPSBkaXJlY3Rpb24gJiBUT1VDSF9ESVJFQ1RJT05fUElUQ0ggPyBcInBpdGNoXCIgOiBudWxsO1xuXG5cdFx0dGhpcy5heGVzLmNvbm5lY3QoW3lhd0VuYWJsZWQsIHBpdGNoRW5hYmxlZF0sIHRoaXMuYXhlc1BhbklucHV0KTtcblx0fVxuXG5cdF9pbml0RGV2aWNlUXVhdGVybmlvbigpIHtcblx0XHR0aGlzLl9kZXZpY2VRdWF0ZXJuaW9uID0gbmV3IERldmljZVF1YXRlcm5pb24oKTtcblx0XHR0aGlzLl9kZXZpY2VRdWF0ZXJuaW9uLm9uKFwiY2hhbmdlXCIsIGUgPT4ge1xuXHRcdFx0dGhpcy5fdHJpZ2dlckNoYW5nZShlKTtcblx0XHR9KTtcblx0fVxuXG5cdF9nZXRWYWxpZFlhd1JhbmdlKG5ld1lhd1JhbmdlLCBuZXdGb3YsIG5ld0FzcGVjdFJhdGlvKSB7XG5cdFx0Y29uc3QgcmF0aW8gPSBZYXdQaXRjaENvbnRyb2wuYWRqdXN0QXNwZWN0UmF0aW8obmV3QXNwZWN0UmF0aW8gfHwgdGhpcy5vcHRpb25zLmFzcGVjdFJhdGlvIHx8IDEpO1xuXHRcdGNvbnN0IGZvdiA9IG5ld0ZvdiB8fCB0aGlzLmF4ZXMuZ2V0KCkuZm92O1xuXHRcdGNvbnN0IGhvcml6b250YWxGb3YgPSBmb3YgKiByYXRpbztcblx0XHRjb25zdCBpc1ZhbGlkID0gbmV3WWF3UmFuZ2VbMV0gLSBuZXdZYXdSYW5nZVswXSA+PSBob3Jpem9udGFsRm92O1xuXG5cdFx0aWYgKGlzVmFsaWQpIHtcblx0XHRcdHJldHVybiBuZXdZYXdSYW5nZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9ucy55YXdSYW5nZSB8fCBERUZBVUxUX1lBV19SQU5HRTtcblx0XHR9XG5cdH1cblxuXHRfZ2V0VmFsaWRQaXRjaFJhbmdlKG5ld1BpdGNoUmFuZ2UsIG5ld0Zvdikge1xuXHRcdGNvbnN0IGZvdiA9IG5ld0ZvdiB8fCB0aGlzLmF4ZXMuZ2V0KCkuZm92O1xuXHRcdGNvbnN0IGlzVmFsaWQgPSBuZXdQaXRjaFJhbmdlWzFdIC0gbmV3UGl0Y2hSYW5nZVswXSA+PSBmb3Y7XG5cblx0XHRpZiAoaXNWYWxpZCkge1xuXHRcdFx0cmV0dXJuIG5ld1BpdGNoUmFuZ2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnMucGl0Y2hSYW5nZSB8fCBERUZBVUxUX1BJVENIX1JBTkdFO1xuXHRcdH1cblx0fVxuXG5cdHN0YXRpYyBpc0NpcmN1bGFyKHJhbmdlKSB7XG5cdFx0cmV0dXJuIHJhbmdlWzFdIC0gcmFuZ2VbMF0gPCAzNjAgPyBbZmFsc2UsIGZhbHNlXSA6IFt0cnVlLCB0cnVlXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgeWF3L3BpdGNoIG1pbi9tYXggYnkgNSBmYWN0b3Jcblx0ICpcblx0ICogMS4gc2hvd1BvbGVQb2ludFxuXHQgKiAyLiBmb3Zcblx0ICogMy4geWF3UmFuZ2Vcblx0ICogNC4gcGl0Y2hSYW5nZVxuXHQgKiA1LiBhc3BlY3RSYXRpb1xuXHQgKlxuXHQgKiBJZiBvbmUgb2YgYWJvdmUgaXMgY2hhbmdlZCwgY2FsbCB0aGlzIGZ1bmN0aW9uXG5cdCAqL1xuXHRfdXBkYXRlQ29udHJvbFNjYWxlKGNoYW5nZUV2dCkge1xuXHRcdGNvbnN0IG9wdCA9IHRoaXMub3B0aW9ucztcblx0XHRjb25zdCBmb3YgPSB0aGlzLmF4ZXMuZ2V0KCkuZm92O1xuXG5cdFx0Y29uc3QgcFJhbmdlID0gdGhpcy5fdXBkYXRlUGl0Y2hSYW5nZShvcHQucGl0Y2hSYW5nZSwgZm92LCBvcHQuc2hvd1BvbGVQb2ludCk7XG5cdFx0Y29uc3QgeVJhbmdlID0gdGhpcy5fdXBkYXRlWWF3UmFuZ2Uob3B0Lnlhd1JhbmdlLCBmb3YsIG9wdC5hc3BlY3RSYXRpbyk7XG5cblx0XHQvLyBUT0RPOiBJZiBub3QgY2hhbmdlZCE/XG5cdFx0Y29uc3QgcG9zID0gdGhpcy5heGVzLmdldCgpO1xuXHRcdGxldCB5ID0gcG9zLnlhdztcblx0XHRsZXQgcCA9IHBvcy5waXRjaDtcblxuXHRcdHZlYzIuY29weSh0aGlzLmF4ZXMuYXhpcy55YXcucmFuZ2UsIHlSYW5nZSk7XG5cdFx0dmVjMi5jb3B5KHRoaXMuYXhlcy5heGlzLnBpdGNoLnJhbmdlLCBwUmFuZ2UpO1xuXHRcdHRoaXMuYXhlcy5heGlzLnlhdy5jaXJjdWxhciA9IFlhd1BpdGNoQ29udHJvbC5pc0NpcmN1bGFyKHlSYW5nZSk7XG5cdFx0dGhpcy5heGVzLmF4aXMucGl0Y2guY2lyY3VsYXIgPSBZYXdQaXRjaENvbnRyb2wuaXNDaXJjdWxhcihwUmFuZ2UpO1xuXG5cdFx0LyoqXG5cdFx0ICogdXBkYXRlIHlhdy9waXRjaCBieSBpdCdzIHJhbmdlLlxuXHRcdCAqL1xuXHRcdGlmICh5IDwgeVJhbmdlWzBdKSB7XG5cdFx0XHR5ID0geVJhbmdlWzBdO1xuXHRcdH0gZWxzZSBpZiAoeSA+IHlSYW5nZVsxXSkge1xuXHRcdFx0eSA9IHlSYW5nZVsxXTtcblx0XHR9XG5cblx0XHRpZiAocCA8IHBSYW5nZVswXSkge1xuXHRcdFx0cCA9IHBSYW5nZVswXTtcblx0XHR9IGVsc2UgaWYgKHAgPiBwUmFuZ2VbMV0pIHtcblx0XHRcdHAgPSBwUmFuZ2VbMV07XG5cdFx0fVxuXG5cdFx0aWYgKGNoYW5nZUV2dCkge1xuXHRcdFx0Y2hhbmdlRXZ0LnNldCh7XG5cdFx0XHRcdHlhdzogeSxcblx0XHRcdFx0cGl0Y2g6IHAsXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLmF4ZXMuc2V0VG8oe1xuXHRcdFx0eWF3OiB5LFxuXHRcdFx0cGl0Y2g6IHAsXG5cdFx0fSwgMCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdF91cGRhdGVQaXRjaFJhbmdlKHBpdGNoUmFuZ2UsIGZvdiwgc2hvd1BvbGVQb2ludCkge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMuZ3lyb01vZGUgPT09IEdZUk9fTU9ERS5WUikge1xuXHRcdFx0Ly8gQ2lyY3VsYXIgcGl0Y2ggb24gVlJcblx0XHRcdHJldHVybiBDSVJDVUxBUl9QSVRDSF9SQU5HRTtcblx0XHR9XG5cblx0XHRjb25zdCB2ZXJ0aWNhbEFuZ2xlID0gcGl0Y2hSYW5nZVsxXSAtIHBpdGNoUmFuZ2VbMF07XG5cdFx0Y29uc3QgaGFsZkZvdiA9IGZvdiAvIDI7XG5cdFx0Y29uc3QgaXNQYW5vcmFtYSA9IHZlcnRpY2FsQW5nbGUgPCAxODA7XG5cblx0XHRpZiAoc2hvd1BvbGVQb2ludCAmJiAhaXNQYW5vcmFtYSkge1xuXHRcdFx0Ly8gVXNlIGZ1bGwgcGluY2ggcmFuZ2Vcblx0XHRcdHJldHVybiBwaXRjaFJhbmdlLm1hcCh2ID0+ICt2LnRvRml4ZWQoNSkpO1xuXHRcdH1cblxuXHRcdC8vIFJvdW5kIHZhbHVlIGFzIG1vdmFibGVDb29kIGRvLlxuXHRcdHJldHVybiBbcGl0Y2hSYW5nZVswXSArIGhhbGZGb3YsIHBpdGNoUmFuZ2VbMV0gLSBoYWxmRm92XS5tYXAodiA9PiArdi50b0ZpeGVkKDUpKTtcblx0fVxuXG5cdF91cGRhdGVZYXdSYW5nZSh5YXdSYW5nZSwgZm92LCBhc3BlY3RSYXRpbykge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMuZ3lyb01vZGUgPT09IEdZUk9fTU9ERS5WUikge1xuXHRcdFx0cmV0dXJuIERFRkFVTFRfWUFXX1JBTkdFO1xuXHRcdH1cblxuXHRcdGNvbnN0IGhvcml6b250YWxBbmdsZSA9IHlhd1JhbmdlWzFdIC0geWF3UmFuZ2VbMF07XG5cblx0XHQvKipcblx0XHQgKiBGdWxsIDM2MCBNb2RlXG5cdFx0ICovXG5cdFx0aWYgKGhvcml6b250YWxBbmdsZSA+PSAzNjApIHtcblx0XHRcdC8vIERvbid0IGxpbWl0IHlhdyByYW5nZSBvbiBGdWxsIDM2MCBtb2RlLlxuXHRcdFx0cmV0dXJuIHlhd1JhbmdlLm1hcCh2ID0+ICt2LnRvRml4ZWQoNSkpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFBhbm9yYW1hIG1vZGVcblx0XHQgKi9cblx0XHRsZXQgTUFHSUNfTlVNQkVSID0gMTtcblx0XHRjb25zdCByYXRpbyA9IFlhd1BpdGNoQ29udHJvbC5hZGp1c3RBc3BlY3RSYXRpbyhhc3BlY3RSYXRpbyk7XG5cdFx0Y29uc3QgaGFsZkhvcml6b250YWxGb3YgPSBmb3YgLyAyICogcmF0aW87XG5cblx0XHQvLyBUT0RPOiBNYWdpYyBOdW1iZXIgRml4IVxuXHRcdGlmIChob3Jpem9udGFsQW5nbGUgPiAyOTApIHtcblx0XHRcdE1BR0lDX05VTUJFUiA9IDAuNzk0Oy8vIGhvcml6b250YWxBbmdsZSA9IDI4Njtcblx0XHR9IGVsc2UgaWYgKGhvcml6b250YWxBbmdsZSA+IDEyNSkge1xuXHRcdFx0TUFHSUNfTlVNQkVSID0gMC45ODsgLy8gaG9yaXpvbnRhbEFuZ2xlICo9IDAuOTg7XG5cdFx0fVxuXG5cdFx0Ly8gUm91bmQgdmFsdWUgYXMgbW92YWJsZUNvb2QgZG8uXG5cdFx0cmV0dXJuIFtcblx0XHRcdCh5YXdSYW5nZVswXSAqIE1BR0lDX05VTUJFUikgKyBoYWxmSG9yaXpvbnRhbEZvdixcblx0XHRcdCh5YXdSYW5nZVsxXSAqIE1BR0lDX05VTUJFUikgLSBoYWxmSG9yaXpvbnRhbEZvdlxuXHRcdF0ubWFwKHYgPT4gK3YudG9GaXhlZCg1KSk7XG5cdH1cblxuXHRfdHJpZ2dlckNoYW5nZShldnQpIHtcblx0XHRjb25zdCBwb3MgPSB0aGlzLmF4ZXMuZ2V0KCk7XG5cdFx0Y29uc3Qgb3B0ID0gdGhpcy5vcHRpb25zO1xuXHRcdGNvbnN0IGV2ZW50ID0ge1xuXHRcdFx0dGFyZ2V0RWxlbWVudDogb3B0LmVsZW1lbnQsXG5cdFx0XHRpc1RydXN0ZWQ6IGV2dC5pc1RydXN0ZWQsXG5cdFx0fTtcblxuXHRcdGV2ZW50LnlhdyA9IHBvcy55YXc7XG5cdFx0ZXZlbnQucGl0Y2ggPSBwb3MucGl0Y2g7XG5cdFx0ZXZlbnQuZm92ID0gcG9zLmZvdjtcblxuXHRcdGlmIChvcHQuZ3lyb01vZGUgPT09IEdZUk9fTU9ERS5WUiAmJiB0aGlzLl9kZXZpY2VRdWF0ZXJuaW9uKSB7XG5cdFx0XHRldmVudC5xdWF0ZXJuaW9uID0gdGhpcy5fZGV2aWNlUXVhdGVybmlvbi5nZXRDb21iaW5lZFF1YXRlcm5pb24ocG9zLnlhdywgcG9zLnBpdGNoKTtcblx0XHR9XG5cdFx0dGhpcy50cmlnZ2VyKFwiY2hhbmdlXCIsIGV2ZW50KTtcblx0fVxuXG5cdC8vIFRPRE86IG1ha2VzIGNvbnN0YW50IHRvIGJlIGxvZ2ljXG5cdHN0YXRpYyBhZGp1c3RBc3BlY3RSYXRpbyhpbnB1dCkge1xuXHRcdGNvbnN0IGlucHV0UmFuZ2UgPSBbXG5cdFx0XHQwLjUyMCwgMC41NDAsIDAuNTYzLCAwLjU3MCwgMC41ODQsIDAuNTkwLCAwLjYwOSwgMC42NzAsXG5cdFx0XHQwLjcwMiwgMC43MjAsIDAuNzYwLCAwLjc4MCwgMC44MjAsIDAuOTIwLCAwLjk3MCwgMS4wMCwgMS4wNywgMS4xNCwgMS4xOSxcblx0XHRcdDEuMjUsIDEuMzIsIDEuMzgsIDEuNDAsIDEuNDMsIDEuNTMsIDEuNjIsIDEuNzYsIDEuNzcsIDEuODYsIDEuOTYsIDIuMjYsXG5cdFx0XHQyLjMwLCAyLjYwLCAzLjAwLCA1LjAwLCA2LjAwXG5cdFx0XTtcblx0XHRjb25zdCBvdXRwdXRSYW5nZSA9IFtcblx0XHRcdDAuNTEwLCAwLjU0MCwgMC42MDYsIDAuNTYwLCAwLjYyOCwgMC42MzAsIDAuNjQ3LCAwLjcxMCxcblx0XHRcdDAuNzM2LCAwLjc1NywgMC43ODAsIDAuNzcwLCAwLjgwMCwgMC44OTAsIDAuOTc1LCAxLjAwLCAxLjA3LCAxLjEwLCAxLjE1LFxuXHRcdFx0MS4xOCwgMS4yMiwgMS4yNywgMS4zMCwgMS4zMywgMS4zOSwgMS40NSwgMS41NCwgMS41NSwgMS41OCwgMS42MiwgMS43Mixcblx0XHRcdDEuODIsIDEuOTIsIDIuMDAsIDIuMjQsIDIuMzBcblx0XHRdO1xuXG5cdFx0bGV0IHJhbmdlSWR4ID0gLTE7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0UmFuZ2UubGVuZ3RoIC0gMTsgaSsrKSB7XG5cdFx0XHRpZiAoaW5wdXRSYW5nZVtpXSA8PSBpbnB1dCAmJiBpbnB1dFJhbmdlW2kgKyAxXSA+PSBpbnB1dCkge1xuXHRcdFx0XHRyYW5nZUlkeCA9IGk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChyYW5nZUlkeCA9PT0gLTEpIHtcblx0XHRcdGlmIChpbnB1dFJhbmdlWzBdID4gaW5wdXQpIHtcblx0XHRcdFx0cmV0dXJuIG91dHB1dFJhbmdlWzBdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIG91dHB1dFJhbmdlW291dHB1dFJhbmdlWzBdLmxlbmd0aCAtIDFdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IGlucHV0QSA9IGlucHV0UmFuZ2VbcmFuZ2VJZHhdO1xuXHRcdGNvbnN0IGlucHV0QiA9IGlucHV0UmFuZ2VbcmFuZ2VJZHggKyAxXTtcblx0XHRjb25zdCBvdXRwdXRBID0gb3V0cHV0UmFuZ2VbcmFuZ2VJZHhdO1xuXHRcdGNvbnN0IG91dHB1dEIgPSBvdXRwdXRSYW5nZVtyYW5nZUlkeCArIDFdO1xuXG5cdFx0cmV0dXJuIFlhd1BpdGNoQ29udHJvbC5sZXJwKG91dHB1dEEsIG91dHB1dEIsIChpbnB1dCAtIGlucHV0QSkgLyAoaW5wdXRCIC0gaW5wdXRBKSk7XG5cdH1cblxuXHRzdGF0aWMgbGVycChhLCBiLCBmcmFjdGlvbikge1xuXHRcdHJldHVybiBhICsgZnJhY3Rpb24gKiAoYiAtIGEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuYWJsZSBZYXdQaXRjaCBmdW5jdGlvbmFsaXR5XG5cdCAqXG5cdCAqIEBtZXRob2QgZWcuWWF3UGl0Y2gjZW5hYmxlXG5cdCAqL1xuXHRlbmFibGUoKSB7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXG5cdFx0Ly8gdG91Y2hEaXJlY3Rpb24gaXMgZGVjaWRlZCBieSBwYXJhbWV0ZXIgaXMgdmFsaWQgc3RyaW5nIChSZWYuIEF4ZXMuY29ubmVjdClcblx0XHR0aGlzLl9hcHBseU9wdGlvbnMoT2JqZWN0LmtleXModGhpcy5vcHRpb25zKSwgdGhpcy5vcHRpb25zKTtcblxuXHRcdC8vIFRPRE86IElzIHRoaXMgY29kZSBpcyBuZWVkZWQ/IENoZWNrIGxhdGVyLlxuXHRcdHRoaXMudXBkYXRlUGFuU2NhbGUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIERpc2FibGUgWWF3UGl0Y2ggZnVuY3Rpb25hbGl0eVxuXHQgKlxuXHQgKiBAbWV0aG9kIGVnLllhd1BpdGNoI2Rpc2FibGVcblx0ICovXG5cdGRpc2FibGUocGVyc2lzdE9yaWVudGF0aW9uKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBUT0RPOiBDaGVjayBwZXJpc3RPcmllbnRhdGlvbiBpcyBuZWVkZWQhXG5cdFx0aWYgKCFwZXJzaXN0T3JpZW50YXRpb24pIHtcblx0XHRcdHRoaXMuX3Jlc2V0T3JpZW50YXRpb24oKTtcblx0XHR9XG5cdFx0dGhpcy5heGVzLmRpc2Nvbm5lY3QoKTtcblx0XHR0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRfcmVzZXRPcmllbnRhdGlvbigpIHtcblx0XHRjb25zdCBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLmF4ZXMuc2V0VG8oe1xuXHRcdFx0eWF3OiBvcHQueWF3LFxuXHRcdFx0cGl0Y2g6IG9wdC5waXRjaCxcblx0XHRcdGZvdjogb3B0LmZvdixcblx0XHR9LCAwKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblxuXHQvKipcblx0ICogU2V0IG9uZSBvciBtb3JlIG9mIHlhdywgcGl0Y2gsIGZvdlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29vcmRpbmF0ZSB5YXcsIHBpdGNoLCBmb3Zcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIEFuaW1hdGlvbiBkdXJhdGlvbi4gaWYgaXQgaXMgYWJvdmUgMCB0aGVuIGl0J3MgYW5pbWF0ZWQuXG5cdCAqL1xuXHRsb29rQXQoe3lhdywgcGl0Y2gsIGZvdn0sIGR1cmF0aW9uKSB7XG5cdFx0Y29uc3QgcG9zID0gdGhpcy5heGVzLmdldCgpO1xuXG5cdFx0Y29uc3QgeSA9IHlhdyA9PT0gdW5kZWZpbmVkID8gMCA6IHlhdyAtIHBvcy55YXc7XG5cdFx0Y29uc3QgcCA9IHBpdGNoID09PSB1bmRlZmluZWQgPyAwIDogcGl0Y2ggLSBwb3MucGl0Y2g7XG5cdFx0Y29uc3QgZiA9IGZvdiA9PT0gdW5kZWZpbmVkID8gMCA6IGZvdiAtIHBvcy5mb3Y7XG5cblx0XHQvLyBBbGxvdyBkdXJhdGlvbiBvZiBhbmltYXRpb24gdG8gaGF2ZSBtb3JlIHRoYW4gTUNfTUFYSU1VTV9EVVJBVElPTi5cblx0XHR0aGlzLmF4ZXMub3B0aW9ucy5tYXhpbXVtRHVyYXRpb24gPSBJbmZpbml0eTtcblxuXHRcdHRoaXMuYXhlcy5zZXRCeSh7XG5cdFx0XHR5YXc6IHksXG5cdFx0XHRwaXRjaDogcCxcblx0XHRcdGZvdjogZlxuXHRcdH0sIGR1cmF0aW9uKTtcblx0fVxuXG5cdGdldCgpIHtcblx0XHRyZXR1cm4gdGhpcy5heGVzLmdldCgpO1xuXHR9XG5cblx0Z2V0WWF3KCkge1xuXHRcdHJldHVybiB0aGlzLmF4ZXMuZ2V0KCkueWF3O1xuXHR9XG5cblx0Z2V0UGl0Y2goKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXhlcy5nZXQoKS5waXRjaDtcblx0fVxuXG5cdGdldEZvdigpIHtcblx0XHRyZXR1cm4gdGhpcy5heGVzLmdldCgpLmZvdjtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXN0cm95cyBvYmplY3RzXG5cdCAqL1xuXHRkZXN0cm95KCkge1xuXHRcdHRoaXMuYXhlcyAmJiB0aGlzLmF4ZXMuZGVzdHJveSgpO1xuXHRcdHRoaXMuYXhpc1BhbklucHV0ICYmIHRoaXMuYXhpc1BhbklucHV0LmRlc3Ryb3koKTtcblx0XHR0aGlzLmF4ZXNXaGVlbElucHV0ICYmIHRoaXMuYXhlc1doZWVsSW5wdXQuZGVzdHJveSgpO1xuXHRcdHRoaXMuYXhlc1RpbHRNb3Rpb25JbnB1dCAmJiB0aGlzLmF4ZXNUaWx0TW90aW9uSW5wdXQuZGVzdHJveSgpO1xuXHRcdHRoaXMuYXhlc0RldmljZU9yaWVudGF0aW9uSW5wdXQgJiYgdGhpcy5heGVzRGV2aWNlT3JpZW50YXRpb25JbnB1dC5kZXN0cm95KCk7XG5cdFx0dGhpcy5heGVzUGluY2hJbnB1dCAmJiB0aGlzLmF4ZXNQaW5jaElucHV0LmRlc3Ryb3koKTtcblx0XHR0aGlzLmF4ZXNNb3ZlS2V5SW5wdXQgJiYgdGhpcy5heGVzTW92ZUtleUlucHV0LmRlc3Ryb3koKTtcblx0XHR0aGlzLl9kZXZpY2VRdWF0ZXJuaW9uICYmIHRoaXMuX2RldmljZVF1YXRlcm5pb24uZGVzdHJveSgpO1xuXHR9XG59XG4iLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcblxuY29uc3QgU1RBVFVTID0ge1xuXHRcIk5PTkVcIjogMCxcblx0XCJMT0FESU5HXCI6IDEsXG5cdFwiTE9BREVEXCI6IDIsXG5cdFwiRVJST1JcIjogM1xufTtcblxuY29uc3QgRVZFTlQgPSB7XG5cdFwiUkVBRFlTVEFURUNIQU5HRVwiOiBcInJlYWR5c3RhdGVjaGFuZ2VcIlxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW1hZ2VMb2FkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRzdGF0aWMgU1RBVFVTID0gU1RBVFVTO1xuXHRjb25zdHJ1Y3RvcihpbWFnZSkge1xuXHRcdC8vIFN1cGVyIGNvbnN0cnVjdG9yXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuX2ltYWdlID0gbnVsbDtcblx0XHR0aGlzLl9vbmNlSGFuZGxlcnMgPSBbXTtcblx0XHR0aGlzLl9sb2FkU3RhdHVzID0gU1RBVFVTLk5PTkU7XG5cblx0XHRpbWFnZSAmJiB0aGlzLnNldChpbWFnZSk7XG5cdH1cblxuXHRnZXQoKSB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXHRcdFx0aWYgKCF0aGlzLl9pbWFnZSkge1xuXHRcdFx0XHRyZWooXCJJbWFnZUxvYWRlcjogaW1hZ2UgaXMgbm90IGRlZmllbmRcIik7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2xvYWRTdGF0dXMgPT09IFNUQVRVUy5MT0FERUQpIHtcblx0XHRcdFx0cmVzKHRoaXMuZ2V0RWxlbWVudCgpKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fbG9hZFN0YXR1cyA9PT0gU1RBVFVTLkxPQURJTkcpIHtcblx0XHRcdFx0LyogQ2hlY2sgaXNNYXliZUxvYWRlZCgpIGZpcnN0IGJlY2F1c2UgdGhlcmUgbWF5IGhhdmVcblx0XHRcdFx0XHRwb3NpYmlsaXRpZXMgdGhhdCBpbWFnZSBhbHJlYWR5IGxvYWRlZCBiZWZvcmUgZ2V0IGlzIGNhbGxlZC5cblx0XHRcdFx0XHRmb3IgZXhhbXBsZSBjYWxsaW5nIGdldCBvbiBleHRlcm5hbCBpbWFnZSBvbmxvYWQgY2FsbGJhY2suKi9cblx0XHRcdFx0aWYgKEltYWdlTG9hZGVyLmlzTWF5YmVMb2FkZWQodGhpcy5faW1hZ2UpKSB7XG5cdFx0XHRcdFx0dGhpcy5fbG9hZFN0YXR1cyA9IFNUQVRVUy5MT0FERUQ7XG5cdFx0XHRcdFx0cmVzKHRoaXMuZ2V0RWxlbWVudCgpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLm9uKEVWRU5ULlJFQURZU1RBVEVDSEFOR0UsIGUgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKGUudHlwZSA9PT0gU1RBVFVTLkxPQURFRCkge1xuXHRcdFx0XHRcdFx0XHRyZXModGhpcy5nZXRFbGVtZW50KCkpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmVqKFwiSW1hZ2VMb2FkZXI6IGZhaWxlZCB0byBsb2FkIGltYWdlcy5cIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlaihcIkltYWdlTG9hZGVyOiBmYWlsZWQgdG8gbG9hZCBpbWFnZXNcIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIGltYWdlIGltZyBlbGVtZW50IG9yIGltZyB1cmwgb3IgYXJyYXkgb2YgaW1nIGVsZW1lbnQgb3IgYXJyYXkgb2YgaW1nIHVybFxuXHQgKi9cblx0c2V0KGltYWdlKSB7XG5cdFx0dGhpcy5fbG9hZFN0YXR1cyA9IFNUQVRVUy5MT0FESU5HO1xuXG5cdFx0dGhpcy5faW1hZ2UgPSBJbWFnZUxvYWRlci5jcmVhdGVFbGVtZW50KGltYWdlKTtcblxuXHRcdGlmIChJbWFnZUxvYWRlci5pc01heWJlTG9hZGVkKHRoaXMuX2ltYWdlKSkge1xuXHRcdFx0dGhpcy5fbG9hZFN0YXR1cyA9IFNUQVRVUy5MT0FERUQ7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5vbmNlTG9hZGVkKFxuXHRcdFx0dGhpcy5faW1hZ2UsXG5cdFx0XHQoKSA9PiB7XG5cdFx0XHRcdHRoaXMuX2xvYWRTdGF0dXMgPSBTVEFUVVMuTE9BREVEO1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoRVZFTlQuUkVBRFlTVEFURUNIQU5HRSwge1xuXHRcdFx0XHRcdHR5cGU6IFNUQVRVUy5MT0FERURcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0KCkgPT4ge1xuXHRcdFx0XHR0aGlzLl9sb2FkU3RhdHVzID0gU1RBVFVTLkVSUk9SO1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoRVZFTlQuUkVBRFlTVEFURUNIQU5HRSwge1xuXHRcdFx0XHRcdHR5cGU6IFNUQVRVUy5FUlJPUlxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHQpO1xuXHR9XG5cblx0c3RhdGljIGNyZWF0ZUVsZW1lbnQoaW1hZ2UpIHtcblx0XHRjb25zdCBpbWFnZXMgPSBpbWFnZSBpbnN0YW5jZW9mIEFycmF5ID8gaW1hZ2UgOiBbaW1hZ2VdO1xuXG5cdFx0cmV0dXJuIGltYWdlcy5tYXAoaW1nID0+IHtcblx0XHRcdGxldCBfaW1nID0gaW1nO1xuXG5cdFx0XHRpZiAodHlwZW9mIGltZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRfaW1nID0gbmV3IEltYWdlKCk7XG5cdFx0XHRcdF9pbWcuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuXHRcdFx0XHRfaW1nLnNyYyA9IGltZztcblx0XHRcdH1cblx0XHRcdHJldHVybiBfaW1nO1xuXHRcdH0pO1xuXHR9XG5cblx0Z2V0RWxlbWVudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2UubGVuZ3RoID09PSAxID8gdGhpcy5faW1hZ2VbMF0gOiB0aGlzLl9pbWFnZTtcblx0fVxuXG5cdHN0YXRpYyBpc01heWJlTG9hZGVkKGltYWdlKSB7XG5cdFx0bGV0IHJlc3VsdCA9IGZhbHNlO1xuXG5cdFx0aWYgKGltYWdlIGluc3RhbmNlb2YgSW1hZ2UpIHtcblx0XHRcdHJlc3VsdCA9IGltYWdlLmNvbXBsZXRlICYmIGltYWdlLm5hdHVyYWxXaWR0aCAhPT0gMDtcblx0XHR9IGVsc2UgaWYgKGltYWdlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdHJlc3VsdCA9ICFpbWFnZS5zb21lKGltZyA9PiAhaW1nLmNvbXBsZXRlIHx8IGltZy5uYXR1cmFsV2lkdGggPT09IDApO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRvbmNlTG9hZGVkKHRhcmdldCwgb25sb2FkLCBvbmVycm9yKSB7XG5cdFx0Y29uc3QgdGFyZ2V0cyA9IHRhcmdldCBpbnN0YW5jZW9mIEFycmF5ID8gdGFyZ2V0IDogW3RhcmdldF07XG5cdFx0Y29uc3QgdGFyZ2V0c05vdExvYWRlZCA9IHRhcmdldHMuZmlsdGVyKGltZyA9PiAhSW1hZ2VMb2FkZXIuaXNNYXliZUxvYWRlZChpbWcpKTtcblx0XHRjb25zdCBsb2FkUHJvbWlzZXMgPSB0YXJnZXRzTm90TG9hZGVkLm1hcChpbWcgPT4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cdFx0XHR0aGlzLl9vbmNlKGltZywgXCJsb2FkXCIsICgpID0+IChyZXMoaW1nKSkpO1xuXHRcdFx0dGhpcy5fb25jZShpbWcsIFwiZXJyb3JcIiwgKCkgPT4gKHJlaihpbWcpKSk7XG5cdFx0fSkpO1xuXG5cdFx0UHJvbWlzZS5hbGwobG9hZFByb21pc2VzKS50aGVuKFxuXHRcdFx0cmVzdWx0ID0+IChvbmxvYWQodGFyZ2V0cy5sZW5ndGggPT09IDEgPyB0YXJnZXRzWzBdIDogdGFyZ2V0cykpLFxuXHRcdFx0cmVhc29uID0+IChvbmVycm9yKHJlYXNvbikpXG5cdFx0KTtcblx0fVxuXG5cdF9vbmNlKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcblx0XHRjb25zdCBmbiA9IGV2ZW50ID0+IHtcblx0XHRcdHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuKTtcblx0XHRcdGxpc3RlbmVyKGV2ZW50KTtcblx0XHR9O1xuXG5cdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4pO1xuXHRcdHRoaXMuX29uY2VIYW5kbGVycy5wdXNoKHt0YXJnZXQsIHR5cGUsIGZufSk7XG5cdH1cblxuXHRnZXRTdGF0dXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRTdGF0dXM7XG5cdH1cblxuXHRkZXN0cm95KCkge1xuXHRcdHRoaXMuX29uY2VIYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4ge1xuXHRcdFx0aGFuZGxlci50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihoYW5kbGVyLnR5cGUsIGhhbmRsZXIuZm4pO1xuXHRcdH0pO1xuXHRcdHRoaXMuX29uY2VIYW5kbGVycyA9IFtdO1xuXHRcdHRoaXMuX2ltYWdlLnNyYyA9IFwiXCI7XG5cdFx0dGhpcy5faW1hZ2UgPSBudWxsO1xuXHRcdHRoaXMuX2xvYWRTdGF0dXMgPSBTVEFUVVMuTk9ORTtcblx0fVxufVxuIiwiLy8gaW1wb3J0IEFnZW50IGZyb20gXCJAZWdqcy9hZ2VudFwiO1xuXG4vKiBSZWYgaHR0cHM6Ly93d3cudzNzY2hvb2xzLmNvbS90YWdzL2F2X3Byb3BfcmVhZHlzdGF0ZS5hc3AgKi9cbmNvbnN0IFJFQURZX1NUQVRVUyA9IHtcblx0SEFWRV9OT1RISU5HOiAwLCAvLyBubyBpbmZvcm1hdGlvbiB3aGV0aGVyIG9yIG5vdCB0aGUgYXVkaW8vdmlkZW8gaXMgcmVhZHlcblx0SEFWRV9NRVRBREFUQTogMSwgLy8gSEFWRV9NRVRBREFUQSAtIG1ldGFkYXRhIGZvciB0aGUgYXVkaW8vdmlkZW8gaXMgcmVhZHlcblx0SEFWRV9DVVJSRU5UX0RBVEE6IDIsIC8vIGRhdGEgZm9yIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGlzIGF2YWlsYWJsZSwgYnV0IG5vdCBlbm91Z2ggZGF0YSB0byBwbGF5IG5leHQgZnJhbWUvbWlsbGlzZWNvbmRcblx0SEFWRV9GVVRVUkVfREFUQTogMywgLy8gZGF0YSBmb3IgdGhlIGN1cnJlbnQgYW5kIGF0IGxlYXN0IHRoZSBuZXh0IGZyYW1lIGlzIGF2YWlsYWJsZVxuXHRIQVZFX0VOT1VHSF9EQVRBOiA0LCAvLyBlbm91Z2ggZGF0YSBhdmFpbGFibGUgdG8gc3RhcnQgcGxheWluZ1xuXHQvLyBiZWxvdyBpcyBjdXN0b20gc3RhdHVzIGZvciBmYWlsZWQgdG8gbG9hZCBzdGF0dXNcblx0TE9BRElOR19GQUlMRUQ6IC0xXG59O1xuXG5jb25zdCBSRUFEWVNUQVRFQ0hBTkdFX0VWRU5UX05BTUUgPSB7fTtcblxuUkVBRFlTVEFURUNIQU5HRV9FVkVOVF9OQU1FW1JFQURZX1NUQVRVUy5IQVZFX01FVEFEQVRBXSA9IFwibG9hZGVkbWV0YWRhdGFcIjtcblJFQURZU1RBVEVDSEFOR0VfRVZFTlRfTkFNRVtSRUFEWV9TVEFUVVMuSEFWRV9DVVJSRU5UX0RBVEFdID0gXCJsb2FkZWRkYXRhXCI7XG5SRUFEWVNUQVRFQ0hBTkdFX0VWRU5UX05BTUVbUkVBRFlfU1RBVFVTLkhBVkVfRlVUVVJFX0RBVEFdID0gXCJjYW5wbGF5XCI7XG5SRUFEWVNUQVRFQ0hBTkdFX0VWRU5UX05BTUVbUkVBRFlfU1RBVFVTLkhBVkVfRU5PVUdIX0RBVEFdID0gXCJjYW5wbGF5dGhyb3VnaFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWRlb0xvYWRlciB7XG5cdGNvbnN0cnVjdG9yKHZpZGVvKSB7XG5cdFx0dGhpcy5faGFuZGxlcnMgPSBbXTtcblx0XHR0aGlzLl9zb3VyY2VDb3VudCA9IDA7XG5cblx0XHQvLyBvbiBpT1Mgc2FmYXJpLCAnbG9hZGVkZGF0YScgd2lsbCBub3QgdHJpZ2dlcmVkIHVubGVzcyB0aGUgdXNlciBoaXRzIHBsYXksXG5cdFx0Ly8gc28gdXNlZCAnbG9hZGVkbWV0YWRhdGEnIGluc3RlYWQuXG5cdFx0dGhpcy5fdGhyZXNob2xkUmVhZHlTdGF0ZSA9IFJFQURZX1NUQVRVUy5IQVZFX01FVEFEQVRBO1xuXHRcdHRoaXMuX3RocmVzaG9sZEV2ZW50TmFtZSA9IFJFQURZU1RBVEVDSEFOR0VfRVZFTlRfTkFNRVt0aGlzLl90aHJlc2hvbGRSZWFkeVN0YXRlXTtcblxuXHRcdHRoaXMuX2xvYWRTdGF0dXMgPSAodmlkZW8gJiYgdmlkZW8ucmVhZHlTdGF0ZSkgfHwgUkVBRFlfU1RBVFVTLkhBVkVfTk9USElORztcblxuXHRcdHRoaXMuX29uZXJyb3IgPSB0aGlzLl9vbmVycm9yLmJpbmQodGhpcyk7XG5cblx0XHR2aWRlbyAmJiB0aGlzLnNldCh2aWRlbyk7XG5cdH1cblxuXHRfb25lcnJvcigpIHtcblx0XHR0aGlzLl9lcnJvckNvdW50Kys7XG5cdFx0aWYgKHRoaXMuX2Vycm9yQ291bnQgPj0gdGhpcy5fc291cmNlQ291bnQpIHtcblx0XHRcdHRoaXMuX2xvYWRTdGF0dXMgPSBSRUFEWV9TVEFUVVMuTE9BRElOR19GQUlMRUQ7XG5cdFx0XHR0aGlzLl9kZXRhY2hFcnJvckhhbmRsZXIodGhpcy5fb25lcnJvcik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0IHwgU3RyaW5nfSB2aWRlbyBPYmplY3Qgb3IgU3RyaW5nIGNvbnRhaW5pbmcgVmlkZW8gU291cmNlIFVSTDxrbz7ruYTrlJTsmKQgVVJMIOygleuztOulvCDri7Tqs6Ag7J6I64qUIOusuOyekOyXtOydtOuCmCDqsJ3ssrQge3R5cGUsIHNyY308L2tvPlxuXHQgKi9cblx0X2FwcGVuZFNvdXJjZUVsZW1lbnQodmlkZW9VcmwpIHtcblx0XHRsZXQgdmlkZW9TcmM7XG5cdFx0bGV0IHZpZGVvVHlwZTtcblxuXHRcdGlmICh0eXBlb2YgdmlkZW9VcmwgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdHZpZGVvU3JjID0gdmlkZW9Vcmwuc3JjO1xuXHRcdFx0dmlkZW9UeXBlID0gdmlkZW9VcmwudHlwZTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2aWRlb1VybCA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmlkZW9TcmMgPSB2aWRlb1VybDtcblx0XHR9XG5cblx0XHRpZiAoIXZpZGVvU3JjKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc291cmNlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzb3VyY2VcIik7XG5cblx0XHRzb3VyY2VFbGVtZW50LnNyYyA9IHZpZGVvU3JjO1xuXHRcdHZpZGVvVHlwZSAmJiAoc291cmNlRWxlbWVudC50eXBlID0gdmlkZW9UeXBlKTtcblxuXHRcdHRoaXMuX3ZpZGVvLmFwcGVuZENoaWxkKHNvdXJjZUVsZW1lbnQpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0c2V0KHZpZGVvKSB7XG5cdFx0dGhpcy5fcmVzZXQoKTsgLy8gcmVzZXQgcmVzb3VyY2VzLlxuXG5cdFx0aWYgKCF2aWRlbykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh2aWRlbyBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcblx0XHRcdC8vIHZpZGVvIHRhZ1xuXHRcdFx0dGhpcy5fdmlkZW8gPSB2aWRlbztcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2aWRlbyA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmlkZW8gPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdC8vIHVybFxuXHRcdFx0dGhpcy5fdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG5cdFx0XHR0aGlzLl92aWRlby5zZXRBdHRyaWJ1dGUoXCJjcm9zc29yaWdpblwiLCBcImFub255bW91c1wiKTtcblx0XHRcdHRoaXMuX3ZpZGVvLnNldEF0dHJpYnV0ZShcIndlYmtpdC1wbGF5c2lubGluZVwiLCBcIlwiKTtcblx0XHRcdHRoaXMuX3ZpZGVvLnNldEF0dHJpYnV0ZShcInBsYXlzaW5saW5lXCIsIFwiXCIpO1xuXG5cdFx0XHRpZiAodmlkZW8gaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHR2aWRlby5mb3JFYWNoKHYgPT4gdGhpcy5fYXBwZW5kU291cmNlRWxlbWVudCh2KSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9hcHBlbmRTb3VyY2VFbGVtZW50KHZpZGVvKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc291cmNlQ291bnQgPSB0aGlzLl92aWRlby5xdWVyeVNlbGVjdG9yQWxsKFwic291cmNlXCIpLmxlbmd0aDtcblxuXHRcdFx0aWYgKHRoaXMuX3NvdXJjZUNvdW50ID4gMCkge1xuXHRcdFx0XHRpZiAodGhpcy5fdmlkZW8ucmVhZHlTdGF0ZSA8IHRoaXMuX3RocmVzaG9sZFJlYWR5U3RhdGUpIHtcblx0XHRcdFx0XHR0aGlzLl92aWRlby5sb2FkKCk7XG5cdFx0XHRcdFx0Ly8gYXR0YWNoIGxvYWRpbmcgZXJyb3IgbGlzdGVuZXJcblx0XHRcdFx0XHR0aGlzLl9hdHRhY2hFcnJvckhhbmRsZXIodGhpcy5fb25lcnJvcik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3ZpZGVvID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRfYXR0YWNoRXJyb3JIYW5kbGVyKGhhbmRsZXIpIHtcblx0XHR0aGlzLl92aWRlby5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgaGFuZGxlcik7XG5cdFx0dGhpcy5fc291cmNlcyA9IHRoaXMuX3ZpZGVvLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzb3VyY2VcIik7XG5cdFx0W10uZm9yRWFjaC5jYWxsKHRoaXMuX3NvdXJjZXMsIHNvdXJjZSA9PiB7XG5cdFx0XHRzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGhhbmRsZXIpO1xuXHRcdH0pO1xuXHR9XG5cblx0X2RldGFjaEVycm9ySGFuZGxlcihoYW5kbGVyKSB7XG5cdFx0dGhpcy5fdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGhhbmRsZXIpO1xuXHRcdFtdLmZvckVhY2guY2FsbCh0aGlzLl9zb3VyY2VzLCBzb3VyY2UgPT4ge1xuXHRcdFx0c291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBoYW5kbGVyKTtcblx0XHR9KTtcblx0fVxuXG5cdGdldCgpIHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cdFx0XHRpZiAoIXRoaXMuX3ZpZGVvKSB7XG5cdFx0XHRcdHJlaihcIlZpZGVvTG9hZGVyOiB2aWRlbyBpcyB1bmRlZmluZWRcIik7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2xvYWRTdGF0dXMgPT09IFJFQURZX1NUQVRVUy5MT0FESU5HX0ZBSUxFRCkge1xuXHRcdFx0XHRyZWooXCJWaWRlb0xvYWRlcjogdmlkZW8gc291cmNlIGlzIGludmFsaWRcIik7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3ZpZGVvLnJlYWR5U3RhdGUgPj0gdGhpcy5fdGhyZXNob2xkUmVhZHlTdGF0ZSkge1xuXHRcdFx0XHRyZXModGhpcy5fdmlkZW8pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gY2hlY2sgZXJyb3JDbnQgYW5kIHJlamVjdFxuXHRcdFx0XHRjb25zdCByZWplY3RvciA9ICgpID0+IHtcblx0XHRcdFx0XHRpZiAodGhpcy5fbG9hZFN0YXR1cyA9PT0gUkVBRFlfU1RBVFVTLkxPQURJTkdfRkFJTEVEKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kZXRhY2hFcnJvckhhbmRsZXIocmVqZWN0b3IpO1xuXHRcdFx0XHRcdFx0cmVqKFwiVmlkZW9Mb2FkZXI6IHZpZGVvIHNvdXJjZSBpcyBpbnZhbGlkXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLl9hdHRhY2hFcnJvckhhbmRsZXIocmVqZWN0b3IpO1xuXHRcdFx0XHR0aGlzLl9vbmNlKHRoaXMuX3RocmVzaG9sZEV2ZW50TmFtZSwgKCkgPT4gcmVzKHRoaXMuX3ZpZGVvKSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRnZXRFbGVtZW50KCkge1xuXHRcdHJldHVybiB0aGlzLl92aWRlbztcblx0fVxuXG5cdGRlc3Ryb3koKSB7XG5cdFx0dGhpcy5fcmVzZXQoKTtcblx0fVxuXG5cdF9yZXNldCgpIHtcblx0XHR0aGlzLl9oYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4ge1xuXHRcdFx0dGhpcy5fdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihoYW5kbGVyLnR5cGUsIGhhbmRsZXIuZm4pO1xuXHRcdH0pO1xuXHRcdHRoaXMuX2hhbmRsZXJzID0gW107XG5cdFx0dGhpcy5fdmlkZW8gPSBudWxsO1xuXG5cdFx0dGhpcy5fc291cmNlQ291bnQgPSAwO1xuXHRcdHRoaXMuX2Vycm9yQ291bnQgPSAwO1xuXHR9XG5cblx0X29uY2UodHlwZSwgbGlzdGVuZXIpIHtcblx0XHRjb25zdCB0YXJnZXQgPSB0aGlzLl92aWRlbztcblxuXHRcdGNvbnN0IGZuID0gZXZlbnQgPT4ge1xuXHRcdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4pO1xuXHRcdFx0bGlzdGVuZXIoZXZlbnQpO1xuXHRcdH07XG5cblx0XHQvKiBCeSB1c2VDYXB0dXJlIG1vZGUgZW5hYmxlZCwgeW91IGNhbiBjYXB0dXJlIHRoZSBlcnJvciBldmVudCBiZWluZyBmaXJlZCBvbiBzb3VyY2UoY2hpbGQpKi9cblx0XHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgdHJ1ZSk7XG5cdFx0dGhpcy5faGFuZGxlcnMucHVzaCh7dHlwZSwgZm59KTtcblx0fVxufVxuIiwiLypcbkNvcHlyaWdodCAoYykgMjAxNyBOQVZFUiBDb3JwLlxyXG5AZWdqcy9hZ2VudCBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG5cclxuQGVnanMvYWdlbnQgSmF2YVNjcmlwdCBsaWJyYXJ5XHJcblxyXG5cclxuQHZlcnNpb24gMi4xLjVcbiovXG52YXIgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgfHwge307XG52YXIgUmVnRXhwJDEgPSB3aW4uUmVnRXhwO1xudmFyIG5hdmlnYXRvciA9IHdpbi5uYXZpZ2F0b3I7XG5cbnZhciBwYXJzZVJ1bGVzID0ge1xuXHRicm93c2VyOiBbe1xuXHRcdGNyaXRlcmlhOiBcIlBoYW50b21KU1wiLFxuXHRcdGlkZW50aXR5OiBcIlBoYW50b21KU1wiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogL1doYWxlLyxcblx0XHRpZGVudGl0eTogXCJXaGFsZVwiLFxuXHRcdHZlcnNpb25TZWFyY2g6IFwiV2hhbGVcIlxuXHR9LCB7XG5cdFx0Y3JpdGVyaWE6IC9FZGdlLyxcblx0XHRpZGVudGl0eTogXCJFZGdlXCIsXG5cdFx0dmVyc2lvblNlYXJjaDogXCJFZGdlXCJcblx0fSwge1xuXHRcdGNyaXRlcmlhOiAvTVNJRXxUcmlkZW50fFdpbmRvd3MgUGhvbmUvLFxuXHRcdGlkZW50aXR5OiBcIklFXCIsXG5cdFx0dmVyc2lvblNlYXJjaDogXCJJRU1vYmlsZXxNU0lFfHJ2XCJcblx0fSwge1xuXHRcdGNyaXRlcmlhOiAvTWl1aUJyb3dzZXIvLFxuXHRcdGlkZW50aXR5OiBcIk1JVUkgQnJvd3NlclwiLFxuXHRcdHZlcnNpb25TZWFyY2g6IFwiTWl1aUJyb3dzZXJcIlxuXHR9LCB7XG5cdFx0Y3JpdGVyaWE6IC9TYW1zdW5nQnJvd3Nlci8sXG5cdFx0aWRlbnRpdHk6IFwiU2Ftc3VuZyBJbnRlcm5ldFwiLFxuXHRcdHZlcnNpb25TZWFyY2g6IFwiU2Ftc3VuZ0Jyb3dzZXJcIlxuXHR9LCB7XG5cdFx0Y3JpdGVyaWE6IC9TQU1TVU5HIC8sXG5cdFx0aWRlbnRpdHk6IFwiU2Ftc3VuZyBJbnRlcm5ldFwiLFxuXHRcdHZlcnNpb25TZWFyY2g6IFwiVmVyc2lvblwiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogL0Nocm9tZXxDcmlPUy8sXG5cdFx0aWRlbnRpdHk6IFwiQ2hyb21lXCJcblx0fSwge1xuXHRcdGNyaXRlcmlhOiAvQW5kcm9pZC8sXG5cdFx0aWRlbnRpdHk6IFwiQW5kcm9pZCBCcm93c2VyXCIsXG5cdFx0dmVyc2lvblNlYXJjaDogXCJWZXJzaW9uXCJcblx0fSwge1xuXHRcdGNyaXRlcmlhOiAvaVBob25lfGlQYWQvLFxuXHRcdGlkZW50aXR5OiBcIlNhZmFyaVwiLFxuXHRcdHZlcnNpb25TZWFyY2g6IFwiVmVyc2lvblwiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogXCJBcHBsZVwiLFxuXHRcdGlkZW50aXR5OiBcIlNhZmFyaVwiLFxuXHRcdHZlcnNpb25TZWFyY2g6IFwiVmVyc2lvblwiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogXCJGaXJlZm94XCIsXG5cdFx0aWRlbnRpdHk6IFwiRmlyZWZveFwiXG5cdH1dLFxuXHRvczogW3tcblx0XHRjcml0ZXJpYTogL1dpbmRvd3MgUGhvbmUvLFxuXHRcdGlkZW50aXR5OiBcIldpbmRvd3MgUGhvbmVcIixcblx0XHR2ZXJzaW9uU2VhcmNoOiBcIldpbmRvd3MgUGhvbmVcIlxuXHR9LCB7XG5cdFx0Y3JpdGVyaWE6IFwiV2luZG93cyAyMDAwXCIsXG5cdFx0aWRlbnRpdHk6IFwiV2luZG93XCIsXG5cdFx0dmVyc2lvbkFsaWFzOiBcIjUuMFwiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogL1dpbmRvd3MgTlQvLFxuXHRcdGlkZW50aXR5OiBcIldpbmRvd1wiLFxuXHRcdHZlcnNpb25TZWFyY2g6IFwiV2luZG93cyBOVFwiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogL2lQaG9uZXxpUGFkLyxcblx0XHRpZGVudGl0eTogXCJpT1NcIixcblx0XHR2ZXJzaW9uU2VhcmNoOiBcImlQaG9uZSBPU3xDUFUgT1NcIlxuXHR9LCB7XG5cdFx0Y3JpdGVyaWE6IFwiTWFjXCIsXG5cdFx0dmVyc2lvblNlYXJjaDogXCJPUyBYXCIsXG5cdFx0aWRlbnRpdHk6IFwiTUFDXCJcblx0fSwge1xuXHRcdGNyaXRlcmlhOiAvQW5kcm9pZC8sXG5cdFx0aWRlbnRpdHk6IFwiQW5kcm9pZFwiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogL1RpemVuLyxcblx0XHRpZGVudGl0eTogXCJUaXplblwiXG5cdH0sIHtcblx0XHRjcml0ZXJpYTogL1dlYjBTLyxcblx0XHRpZGVudGl0eTogXCJXZWJPU1wiXG5cdH1dLFxuXG5cdC8vIFdlYnZpZXcgY2hlY2sgY29uZGl0aW9uXG5cdC8vIGlvczogSWYgaGFzIG5vIHZlcnNpb24gaW5mb3JtYXRpb25cblx0Ly8gQW5kcm9pZCA1LjAgJiYgY2hyb21lIDQwKzogUHJlc2VuY2Ugb2YgXCI7IHd2XCIgaW4gdXNlckFnZW50XG5cdC8vIFVuZGVyIGFuZHJvaWQgNS4wOiBQcmVzZW5jZSBvZiBcIk5BVkVSXCIgb3IgXCJEYXVtXCIgaW4gdXNlckFnZW50XG5cdHdlYnZpZXc6IFt7XG5cdFx0Y3JpdGVyaWE6IC9pUGhvbmV8aVBhZC8sXG5cdFx0YnJvd3NlclZlcnNpb25TZWFyY2g6IFwiVmVyc2lvblwiLFxuXHRcdHdlYnZpZXdCcm93c2VyVmVyc2lvbjogLy0xL1xuXHR9LCB7XG5cdFx0Y3JpdGVyaWE6IC9pUGhvbmV8aVBhZHxBbmRyb2lkLyxcblx0XHR3ZWJ2aWV3VG9rZW46IC9OQVZFUnxEQVVNfDsgd3YvXG5cblx0fV0sXG5cdGRlZmF1bHRTdHJpbmc6IHtcblx0XHRicm93c2VyOiB7XG5cdFx0XHR2ZXJzaW9uOiBcIi0xXCIsXG5cdFx0XHRuYW1lOiBcInVua25vd25cIlxuXHRcdH0sXG5cdFx0b3M6IHtcblx0XHRcdHZlcnNpb246IFwiLTFcIixcblx0XHRcdG5hbWU6IFwidW5rbm93blwiXG5cdFx0fVxuXHR9XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIoYXJyLCBjb21wYXJlKSB7XG5cdHZhciByZXN1bHQgPSBbXTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdGNvbXBhcmUoYXJyW2ldKSAmJiByZXN1bHQucHVzaChhcnJbaV0pO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHNvbWUoYXJyLCBjb21wYXJlKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKGNvbXBhcmUoYXJyW2ldKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxudmFyIFVBID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBzZXRVYSh1YSkge1xuXHRVQSA9IHVhO1xufVxuXG5mdW5jdGlvbiBpc01hdGNoZWQoYmFzZSwgdGFyZ2V0KSB7XG5cdHJldHVybiB0YXJnZXQgJiYgdGFyZ2V0LnRlc3QgPyAhIXRhcmdldC50ZXN0KGJhc2UpIDogYmFzZS5pbmRleE9mKHRhcmdldCkgPiAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0SWRlbnRpdHlTdHJpbmdGcm9tQXJyYXkocnVsZXMsIGRlZmF1bHRTdHJpbmdzKSB7XG5cdHZhciBtYXRjaGVkUnVsZSA9IGZpbHRlcihydWxlcywgZnVuY3Rpb24gKHJ1bGUpIHtcblx0XHRyZXR1cm4gaXNNYXRjaGVkKFVBLCBydWxlLmNyaXRlcmlhKTtcblx0fSlbMF07XG5cblx0cmV0dXJuIG1hdGNoZWRSdWxlICYmIG1hdGNoZWRSdWxlLmlkZW50aXR5IHx8IGRlZmF1bHRTdHJpbmdzLm5hbWU7XG59XG5cbmZ1bmN0aW9uIGdldFJ1bGUocnVsZXMsIHRhcmdldElkZW50aXR5KSB7XG5cdHJldHVybiBmaWx0ZXIocnVsZXMsIGZ1bmN0aW9uIChydWxlKSB7XG5cdFx0dmFyIGNyaXRlcmlhID0gcnVsZS5jcml0ZXJpYTtcblx0XHR2YXIgaWRlbnRpdHlNYXRjaGVkID0gbmV3IFJlZ0V4cChydWxlLmlkZW50aXR5LCBcImlcIikudGVzdCh0YXJnZXRJZGVudGl0eSk7XG5cblx0XHRpZiAoY3JpdGVyaWEgPyBpZGVudGl0eU1hdGNoZWQgJiYgaXNNYXRjaGVkKFVBLCBjcml0ZXJpYSkgOiBpZGVudGl0eU1hdGNoZWQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9KVswXTtcbn1cblxuZnVuY3Rpb24gZ2V0QnJvd3Nlck5hbWUoKSB7XG5cdHJldHVybiBnZXRJZGVudGl0eVN0cmluZ0Zyb21BcnJheShwYXJzZVJ1bGVzLmJyb3dzZXIsIHBhcnNlUnVsZXMuZGVmYXVsdFN0cmluZy5icm93c2VyKTtcbn1cblxuZnVuY3Rpb24gZ2V0QnJvd3NlclJ1bGUoYnJvd3Nlck5hbWUpIHtcblx0dmFyIHJ1bGUgPSBnZXRSdWxlKHBhcnNlUnVsZXMuYnJvd3NlciwgYnJvd3Nlck5hbWUpO1xuXG5cdGlmICghcnVsZSkge1xuXHRcdHJ1bGUgPSB7XG5cdFx0XHRjcml0ZXJpYTogYnJvd3Nlck5hbWUsXG5cdFx0XHR2ZXJzaW9uU2VhcmNoOiBicm93c2VyTmFtZSxcblx0XHRcdGlkZW50aXR5OiBicm93c2VyTmFtZVxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gcnVsZTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEJyb3dzZXJWZXJzaW9uKHZlcnNpb25Ub2tlbiwgdWEpIHtcblx0dmFyIGJyb3dzZXJWZXJzaW9uID0gcGFyc2VSdWxlcy5kZWZhdWx0U3RyaW5nLmJyb3dzZXIudmVyc2lvbjtcblx0dmFyIHZlcnNpb25SZWdleFJlc3VsdCA9IG5ldyBSZWdFeHAoXCIoXCIgKyB2ZXJzaW9uVG9rZW4gKyBcIilcIiwgXCJpXCIpLmV4ZWModWEpO1xuXG5cdGlmICghdmVyc2lvblJlZ2V4UmVzdWx0KSB7XG5cdFx0cmV0dXJuIGJyb3dzZXJWZXJzaW9uO1xuXHR9XG5cblx0dmFyIHZlcnNpb25Ub2tlbkluZGV4ID0gdmVyc2lvblJlZ2V4UmVzdWx0LmluZGV4O1xuXHR2YXIgdmVyVGtuID0gdmVyc2lvblJlZ2V4UmVzdWx0WzBdO1xuXG5cdGlmICh2ZXJzaW9uVG9rZW5JbmRleCA+IC0xKSB7XG5cdFx0dmFyIHZlcnNpb25JbmRleCA9IHZlcnNpb25Ub2tlbkluZGV4ICsgdmVyVGtuLmxlbmd0aCArIDE7XG5cblx0XHRicm93c2VyVmVyc2lvbiA9IHVhLnN1YnN0cmluZyh2ZXJzaW9uSW5kZXgpLnNwbGl0KFwiIFwiKVswXS5yZXBsYWNlKC9fL2csIFwiLlwiKS5yZXBsYWNlKC87fFxcKS9nLCBcIlwiKTtcblx0fVxuXHRyZXR1cm4gYnJvd3NlclZlcnNpb247XG59XG5cbmZ1bmN0aW9uIGdldEJyb3dzZXJWZXJzaW9uKGJyb3dzZXJOYW1lKSB7XG5cdGlmICghYnJvd3Nlck5hbWUpIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gY29uc29sZS5sb2coYnJvd3NlclJ1bGUpO1xuXHQvLyBjb25zdCB2ZXJzaW9uVG9rZW4gPSBicm93c2VyUnVsZSA/IGJyb3dzZXJSdWxlLnZlcnNpb25TZWFyY2ggOiBicm93c2VyTmFtZTtcblx0dmFyIGJyb3dzZXJSdWxlID0gZ2V0QnJvd3NlclJ1bGUoYnJvd3Nlck5hbWUpO1xuXHR2YXIgdmVyc2lvblRva2VuID0gYnJvd3NlclJ1bGUudmVyc2lvblNlYXJjaCB8fCBicm93c2VyTmFtZTtcblx0dmFyIGJyb3dzZXJWZXJzaW9uID0gZXh0cmFjdEJyb3dzZXJWZXJzaW9uKHZlcnNpb25Ub2tlbiwgVUEpO1xuXG5cdHJldHVybiBicm93c2VyVmVyc2lvbjtcbn1cblxuZnVuY3Rpb24gaXNXZWJ2aWV3KCkge1xuXHR2YXIgd2Vidmlld1J1bGVzID0gcGFyc2VSdWxlcy53ZWJ2aWV3O1xuXHR2YXIgYnJvd3NlclZlcnNpb24gPSB2b2lkIDA7XG5cblx0cmV0dXJuIHNvbWUoZmlsdGVyKHdlYnZpZXdSdWxlcywgZnVuY3Rpb24gKHJ1bGUpIHtcblx0XHRyZXR1cm4gaXNNYXRjaGVkKFVBLCBydWxlLmNyaXRlcmlhKTtcblx0fSksIGZ1bmN0aW9uIChydWxlKSB7XG5cdFx0YnJvd3NlclZlcnNpb24gPSBleHRyYWN0QnJvd3NlclZlcnNpb24ocnVsZS5icm93c2VyVmVyc2lvblNlYXJjaCwgVUEpO1xuXHRcdGlmIChpc01hdGNoZWQoVUEsIHJ1bGUud2Vidmlld1Rva2VuKSB8fCBpc01hdGNoZWQoYnJvd3NlclZlcnNpb24sIHJ1bGUud2Vidmlld0Jyb3dzZXJWZXJzaW9uKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBnZXRPU1J1bGUob3NOYW1lKSB7XG5cdHJldHVybiBnZXRSdWxlKHBhcnNlUnVsZXMub3MsIG9zTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldE9zTmFtZSgpIHtcblx0cmV0dXJuIGdldElkZW50aXR5U3RyaW5nRnJvbUFycmF5KHBhcnNlUnVsZXMub3MsIHBhcnNlUnVsZXMuZGVmYXVsdFN0cmluZy5vcyk7XG59XG5cbmZ1bmN0aW9uIGdldE9zVmVyc2lvbihvc05hbWUpIHtcblx0dmFyIG9zUnVsZSA9IGdldE9TUnVsZShvc05hbWUpIHx8IHt9O1xuXHR2YXIgZGVmYXVsdE9TVmVyc2lvbiA9IHBhcnNlUnVsZXMuZGVmYXVsdFN0cmluZy5vcy52ZXJzaW9uO1xuXHR2YXIgb3NWZXJzaW9uID0gdm9pZCAwO1xuXG5cdGlmICghb3NOYW1lKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXHRpZiAob3NSdWxlLnZlcnNpb25BbGlhcykge1xuXHRcdHJldHVybiBvc1J1bGUudmVyc2lvbkFsaWFzO1xuXHR9XG5cdHZhciBvc1ZlcnNpb25Ub2tlbiA9IG9zUnVsZS52ZXJzaW9uU2VhcmNoIHx8IG9zTmFtZTtcblx0dmFyIG9zVmVyc2lvblJlZ2V4ID0gbmV3IFJlZ0V4cChcIihcIiArIG9zVmVyc2lvblRva2VuICsgXCIpXFxcXHMoW1xcXFxkX1xcXFwuXSt8XFxcXGRfMClcIiwgXCJpXCIpO1xuXHR2YXIgb3NWZXJzaW9uUmVnZXhSZXN1bHQgPSBvc1ZlcnNpb25SZWdleC5leGVjKFVBKTtcblxuXHRpZiAob3NWZXJzaW9uUmVnZXhSZXN1bHQpIHtcblx0XHRvc1ZlcnNpb24gPSBvc1ZlcnNpb25SZWdleC5leGVjKFVBKVsyXS5yZXBsYWNlKC9fL2csIFwiLlwiKS5yZXBsYWNlKC87fFxcKS9nLCBcIlwiKTtcblx0fVxuXHRyZXR1cm4gb3NWZXJzaW9uIHx8IGRlZmF1bHRPU1ZlcnNpb247XG59XG5cbmZ1bmN0aW9uIGdldE9zKCkge1xuXHR2YXIgbmFtZSA9IGdldE9zTmFtZSgpO1xuXHR2YXIgdmVyc2lvbiA9IGdldE9zVmVyc2lvbihuYW1lKTtcblxuXHRyZXR1cm4geyBuYW1lOiBuYW1lLCB2ZXJzaW9uOiB2ZXJzaW9uIH07XG59XG5cbmZ1bmN0aW9uIGdldEJyb3dzZXIoKSB7XG5cdHZhciBuYW1lID0gZ2V0QnJvd3Nlck5hbWUoKTtcblx0dmFyIHZlcnNpb24gPSBnZXRCcm93c2VyVmVyc2lvbihuYW1lKTtcblxuXHRyZXR1cm4geyBuYW1lOiBuYW1lLCB2ZXJzaW9uOiB2ZXJzaW9uLCB3ZWJ2aWV3OiBpc1dlYnZpZXcoKSB9O1xufVxuXG5mdW5jdGlvbiBnZXRJc01vYmlsZSgpIHtcblx0cmV0dXJuIFVBLmluZGV4T2YoXCJNb2JpXCIpICE9PSAtMTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE5BVkVSIENvcnAuXG4gKiBlZ2pzLWFnZW50IHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgZWcuYWdlbnRcbiAqL1xuLyoqXG4gKiBFeHRyYWN0cyBicm93c2VyIGFuZCBvcGVyYXRpbmcgc3lzdGVtIGluZm9ybWF0aW9uIGZyb20gdGhlIHVzZXIgYWdlbnQgc3RyaW5nLlxuICogQGtvIOycoOyggCDsl5DsnbTsoITtirgg66y47J6Q7Je07JeQ7IScIOu4jOudvOyasOyggOyZgCDsmrTsmIHssrTsoJwg7KCV67O066W8IOy2lOy2nO2VnOuLpC5cbiAqIEBmdW5jdGlvbiBlZy5hZ2VudCNhZ2VudFxuICogQHBhcmFtIHtTdHJpbmd9IFt1c2VyQWdlbnQ9bmF2aWdhdG9yLnVzZXJBZ2VudF0gdXNlciBhZ2VudCBzdHJpbmcgdG8gcGFyc2UgPGtvPu2MjOyLse2VoCDsnKDsoIDsl5DsnbTsoITtirgg66y47J6Q7Je0PC9rbz5cbiAqIEByZXR1cm4ge09iamVjdH0gYWdlbnRJbmZvXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFnZW50SW5mby5vcyBvcyBPcGVyYXRpbmcgc3lzdGVtIGluZm9ybWF0aW9uIDxrbz7smrTsmIHssrTsoJwg7KCV67O0PC9rbz5cbiAqIEByZXR1cm4ge1N0cmluZ30gYWdlbnRJbmZvLm9zLm5hbWUgT3BlcmF0aW5nIHN5c3RlbSBuYW1lIChhbmRyb2lkLCBpb3MsIHdpbmRvdywgbWFjLCB1bmtub3duKSA8a28+7Jq07JiB7LK07KCcIOydtOumhCAoYW5kcm9pZCwgaW9zLCB3aW5kb3csIG1hYywgdW5rbm93bik8L2tvPlxuICogQHJldHVybiB7U3RyaW5nfSBhZ2VudEluZm8ub3MudmVyc2lvbiBPcGVyYXRpbmcgc3lzdGVtIHZlcnNpb24gPGtvPuyatOyYgeyytOygnCDrsoTsoIQ8L2tvPlxuICogQHJldHVybiB7U3RyaW5nfSBhZ2VudEluZm8uYnJvd3NlciBCcm93c2VyIGluZm9ybWF0aW9uIDxrbz7ruIzrnbzsmrDsoIAg7KCV67O0PC9rbz5cbiAqIEByZXR1cm4ge1N0cmluZ30gYWdlbnRJbmZvLmJyb3dzZXIubmFtZSBCcm93c2VyIG5hbWUgKHNhZmFyaSwgY2hyb21lLCBzYnJvd3NlciwgaWUsIGZpcmVmb3gsIHVua25vd24pIDxrbz7ruIzrnbzsmrDsoIAg7J2066aEIChzYWZhcmksIGNocm9tZSwgc2Jyb3dzZXIsIGllLCBmaXJlZm94LCB1bmtub3duKTwva28+XG4gKiBAcmV0dXJuIHtTdHJpbmd9IGFnZW50SW5mby5icm93c2VyLnZlcnNpb24gQnJvd3NlciB2ZXJzaW9uIDxrbz7ruIzrnbzsmrDsoIAg67KE7KCEIDwva28+XG4gKiBAcmV0dXJuIHtCb29sZWFufSBhZ2VudEluZm8uYnJvd3Nlci53ZWJ2aWV3IEluZGljYXRlcyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIGluYXBwPGtvPuybueu3sCDruIzrnbzsmrDsoIAg7Jes67aAPC9rbz5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGFnZW50SW5mby5pc01vYmlsZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBmb3IgbW9iaWxlPGtvPuuqqOuwlOydvCDruIzrnbzsmrDsoIAg7Jes67aAPC9rbz5cbiAqIEBleGFtcGxlXG5pbXBvcnQgYWdlbnQgZnJvbSBcIkBlZ2pzL2FnZW50XCI7XG5cbmNvbnN0IHtvcywgYnJvd3NlciwgaXNNb2JpbGV9ID0gYWdlbnQoKTtcbiAqL1xuZnVuY3Rpb24gYWdlbnQoKSB7XG4gIHZhciB1YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBzZXRVYSh1YSk7XG5cbiAgdmFyIGFnZW50SW5mbyA9IHtcbiAgICBvczogZ2V0T3MoKSxcbiAgICBicm93c2VyOiBnZXRCcm93c2VyKCksXG4gICAgaXNNb2JpbGU6IGdldElzTW9iaWxlKClcbiAgfTtcblxuICBhZ2VudEluZm8uYnJvd3Nlci5uYW1lID0gYWdlbnRJbmZvLmJyb3dzZXIubmFtZS50b0xvd2VyQ2FzZSgpO1xuICBhZ2VudEluZm8ub3MubmFtZSA9IGFnZW50SW5mby5vcy5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGFnZW50SW5mby5vcy52ZXJzaW9uID0gYWdlbnRJbmZvLm9zLnZlcnNpb24udG9Mb3dlckNhc2UoKTtcblxuICBpZiAoYWdlbnRJbmZvLm9zLm5hbWUgPT09IFwiaW9zXCIgJiYgYWdlbnRJbmZvLmJyb3dzZXIud2Vidmlldykge1xuICAgIGFnZW50SW5mby5icm93c2VyLnZlcnNpb24gPSBcIi0xXCI7XG4gIH1cblxuICByZXR1cm4gYWdlbnRJbmZvO1xufVxuLyoqXG4gKiBWZXJzaW9uIGluZm8gc3RyaW5nXG4gKiBAa28g67KE7KCE7KCV67O0IOusuOyekOyXtFxuICogQG5hbWUgVkVSU0lPTlxuICogQHN0YXRpY1xuICogQHR5cGUge1N0cmluZ31cbiAqIEBleGFtcGxlXG4gKiBlZy5hZ2VudC5WRVJTSU9OOyAgLy8gZXgpIDIuMi4wXG4gKiBAbWVtYmVyb2YgZWcuYWdlbnRcbiAqL1xuYWdlbnQuVkVSU0lPTiA9IFwiMi4xLjVcIjtcblxuZXhwb3J0IGRlZmF1bHQgYWdlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZ2VudC5lc20uanMubWFwXG4iLCJpbXBvcnQgYWdlbnQgZnJvbSBcIkBlZ2pzL2FnZW50XCI7XG5cbmNvbnN0IFdFQkdMX0VSUk9SX0NPREUgPSB7XG5cdFwiMFwiOiBcIk5PX0VSUk9SXCIsXG5cdFwiMTI4MFwiOiBcIklOVkFMSURfRU5VTVwiLFxuXHRcIjEyODFcIjogXCJJTlZBTElEX1ZBTFVFXCIsXG5cdFwiMTI4MlwiOiBcIklOVkFMSURfT1BFUkFUSU9OXCIsXG5cdFwiMTI4NVwiOiBcIk9VVF9PRl9NRU1PUllcIixcblx0XCIxMjg2XCI6IFwiSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT05cIixcblx0XCIzNzQ0MlwiOiBcIkNPTlRFWFRfTE9TVF9XRUJHTFwiXG59O1xuXG5sZXQgd2ViZ2xBdmFpbGFiaWxpdHkgPSBudWxsO1xubGV0IE1BWF9URVhUVVJFX1NJWkVfRk9SX1RFU1QgPSBudWxsO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTFV0aWxzIHtcblx0c3RhdGljIGNyZWF0ZVNoYWRlcihnbCwgdHlwZSwgc291cmNlKSB7XG5cdFx0Y29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuXG5cdFx0Z2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcblx0XHRnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG5cdFx0Y29uc3Qgc3VjY2VzcyA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKTtcblxuXHRcdGlmIChzdWNjZXNzKSB7XG5cdFx0XHRyZXR1cm4gc2hhZGVyO1xuXHRcdH1cblxuXHRcdGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0c3RhdGljIGNyZWF0ZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpIHtcblx0XHRjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG5cdFx0Z2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG5cdFx0Z2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcblx0XHRnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblx0XHRjb25zdCBzdWNjZXNzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyk7XG5cblx0XHRpZiAoc3VjY2Vzcykge1xuXHRcdFx0cmV0dXJuIHByb2dyYW07XG5cdFx0fVxuXG5cdFx0Z2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHN0YXRpYyBpbml0QnVmZmVyKGdsLCB0YXJnZXQgLyogYmluZCBwb2ludCAqLywgZGF0YSwgaXRlbVNpemUsIGF0dHIpIHtcblx0XHRjb25zdCBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdGdsLmJpbmRCdWZmZXIodGFyZ2V0LCBidWZmZXIpO1xuXHRcdGdsLmJ1ZmZlckRhdGEodGFyZ2V0LCBkYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG5cblx0XHRpZiAoYnVmZmVyKSB7XG5cdFx0XHRidWZmZXIuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblx0XHRcdGJ1ZmZlci5udW1JdGVtcyA9IGRhdGEubGVuZ3RoIC8gaXRlbVNpemU7XG5cdFx0fVxuXG5cdFx0aWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0cik7XG5cdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHIsIGJ1ZmZlci5pdGVtU2l6ZSwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYnVmZmVyO1xuXHR9XG5cblx0c3RhdGljIGdldFdlYmdsQ29udGV4dChjYW52YXMsIHVzZXJDb250ZXh0QXR0cmlidXRlcykge1xuXHRcdGNvbnN0IHdlYmdsSWRlbnRpZmllcnMgPSBbXCJ3ZWJnbFwiLCBcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBcIndlYmtpdC0zZFwiLCBcIm1vei13ZWJnbFwiXTtcblx0XHRsZXQgY29udGV4dCA9IG51bGw7XG5cdFx0Y29uc3QgY29udGV4dEF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRcdHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG5cdFx0XHRhbnRpYWxpYXM6IGZhbHNlXG5cdFx0fSwgdXNlckNvbnRleHRBdHRyaWJ1dGVzKTtcblxuXHRcdGZ1bmN0aW9uIG9uV2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvcihlKSB7XG5cdFx0XHRyZXR1cm4gZS5zdGF0dXNNZXNzYWdlO1xuXHRcdH1cblxuXHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvclwiLCBvbldlYmdsY29udGV4dGNyZWF0aW9uZXJyb3IpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB3ZWJnbElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQod2ViZ2xJZGVudGlmaWVyc1tpXSwgY29udGV4dEF0dHJpYnV0ZXMpO1xuXHRcdFx0fSBjYXRjaCAodCkge31cblx0XHRcdGlmIChjb250ZXh0KSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvclwiLCBvbldlYmdsY29udGV4dGNyZWF0aW9uZXJyb3IpO1xuXG5cdFx0cmV0dXJuIGNvbnRleHQ7XG5cdH1cblxuXHRzdGF0aWMgY3JlYXRlVGV4dHVyZShnbCwgdGV4dHVyZVRhcmdldCkge1xuXHRcdGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRnbC5iaW5kVGV4dHVyZSh0ZXh0dXJlVGFyZ2V0LCB0ZXh0dXJlKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUYXJnZXQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUYXJnZXQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUYXJnZXQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUYXJnZXQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRnbC5iaW5kVGV4dHVyZSh0ZXh0dXJlVGFyZ2V0LCBudWxsKTtcblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHdlYmdsIGF2YWlsYWJpbGl0eSBvZiB0aGUgY3VycmVudCBicm93c2VyLlxuXHQgKiBAbWV0aG9kIFdlYkdMVXRpbHMjaXNXZWJHTEF2YWlsYWJsZVxuXHQgKiBAcmV0dWVuIHtCb29sZWFufSBpc1dlYkdMQXZhaWxhYmxlXG5cdCAqL1xuXHRzdGF0aWMgaXNXZWJHTEF2YWlsYWJsZSgpIHtcblx0XHRpZiAod2ViZ2xBdmFpbGFiaWxpdHkgPT09IG51bGwpIHtcblx0XHRcdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cdFx0XHRjb25zdCB3ZWJnbENvbnRleHQgPSBXZWJHTFV0aWxzLmdldFdlYmdsQ29udGV4dChjYW52YXMpO1xuXG5cdFx0XHR3ZWJnbEF2YWlsYWJpbGl0eSA9ICEhd2ViZ2xDb250ZXh0O1xuXG5cdFx0XHQvLyB3ZWJnbENvbnRleHQgUmVzb3VyY2UgZm9yY2VkIGNvbGxlY3Rpb25cblx0XHRcdGlmICh3ZWJnbENvbnRleHQpIHtcblx0XHRcdFx0Y29uc3QgbG9zZUNvbnRleHRFeHRlbnNpb24gPSB3ZWJnbENvbnRleHQuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpO1xuXG5cdFx0XHRcdGxvc2VDb250ZXh0RXh0ZW5zaW9uICYmIGxvc2VDb250ZXh0RXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB3ZWJnbEF2YWlsYWJpbGl0eTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgd2ViZ2wgaXMgc3RhYmxlIGluIHRoZSBjdXJyZW50IGJyb3dzZXIuXG5cdCAqIEBtZXRob2QgV2ViR0xVdGlscyNpc1N0YWJsZVdlYkdMXG5cdCAqIEByZXR1ZW4ge0Jvb2xlYW59IGlzU3RhYmxlV2ViR0xcblx0ICovXG5cdHN0YXRpYyBpc1N0YWJsZVdlYkdMKCkge1xuXHRcdGNvbnN0IGFnZW50SW5mbyA9IGFnZW50KCk7XG5cdFx0bGV0IGlzU3RhYmxlV2ViZ2wgPSB0cnVlO1xuXG5cdFx0aWYgKGFnZW50SW5mby5vcy5uYW1lID09PSBcImFuZHJvaWRcIiAmJiBwYXJzZUZsb2F0KGFnZW50SW5mby5vcy52ZXJzaW9uKSA8PSA0LjMpIHtcblx0XHRcdGlzU3RhYmxlV2ViZ2wgPSBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKGFnZW50SW5mby5vcy5uYW1lID09PSBcImFuZHJvaWRcIiAmJiBwYXJzZUZsb2F0KGFnZW50SW5mby5vcy52ZXJzaW9uKSA9PT0gNC40KSB7XG5cdFx0XHRpZiAoYWdlbnRJbmZvLmJyb3dzZXIubmFtZSAhPT0gXCJjaHJvbWVcIikge1xuXHRcdFx0XHRpc1N0YWJsZVdlYmdsID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBpc1N0YWJsZVdlYmdsO1xuXHR9XG5cblx0c3RhdGljIGdldEVycm9yTmFtZUZyb21XZWJHTEVycm9yQ29kZShjb2RlKSB7XG5cdFx0aWYgKCEoY29kZSBpbiBXRUJHTF9FUlJPUl9DT0RFKSkge1xuXHRcdFx0cmV0dXJuIFwiVU5LTk9XTl9FUlJPUlwiO1xuXHRcdH1cblxuXHRcdHJldHVybiBXRUJHTF9FUlJPUl9DT0RFW2NvZGVdO1xuXHR9XG5cblxuXHQvKipcblx0ICogVGhpcyBmdW5jdGlvbiBpcyB3cmFwcGVyIGZvciB0ZXhJbWFnZTJEIHRvIGhhbmRsZSBleGNlcHRpb25zIG9uIHRleEltYWdlMkQuXG5cdCAqIFB1cnBvc2UgaXMgdG8gcHJldmVudCBzZXJ2aWNlIGZyb20gYmVpbmcgc3RvcHBlZCBieSBzY3JpcHQgZXJyb3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0gZ2xcblx0ICogQHBhcmFtIHsqfSB0YXJnZXRcblx0ICogQHBhcmFtIHsqfSBwaXhlbHNcblx0ICovXG5cdHN0YXRpYyB0ZXhJbWFnZTJEKGdsLCB0YXJnZXQsIHBpeGVscykge1xuXHRcdHRyeSB7XG5cdFx0XHRnbC50ZXhJbWFnZTJEKHRhcmdldCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIldlYkdMVXRpbHMudGV4SW1hZ2UyRCBlcnJvcjpcIiwgZXJyb3IpO1xuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cdFx0fVxuXHR9XG5cblx0c3RhdGljIGdldE1heFRleHR1cmVTaXplKGdsKSB7XG5cdFx0Ly8gV0FSTjogTUFYX1RFWFRVUkVfU0laRV9GT1JfVEVTVCBpcyB1c2VkIGZvciB0ZXN0XG5cdFx0cmV0dXJuIE1BWF9URVhUVVJFX1NJWkVfRk9SX1RFU1QgfHwgZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpO1xuXHR9XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIHVzZWQgaW4gc2VydmljZSBjb2RlLiBJdCdzIHByb3ZpZGVkIG9ubHkgZm9yIHRlc3QgcHVycG9zZS5cbiAqIEl0IHNob3VsZCBiZSBzZXQgdG8gbnVsbCBvciAwIHdoZW4gdGVzdCBpcyBkb25lLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzaXplXG4gKi9cbmZ1bmN0aW9uIHNldE1heFRleHR1cmVTaXplRm9yVGVzdE9ubHlQdXJwb3NlKHNpemUpIHtcblx0TUFYX1RFWFRVUkVfU0laRV9GT1JfVEVTVCA9IHNpemU7XG59XG5cbmV4cG9ydCB7XG5cdHNldE1heFRleHR1cmVTaXplRm9yVGVzdE9ubHlQdXJwb3NlXG59O1xuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG5pbXBvcnQgQWdlbnQgZnJvbSBcIkBlZ2pzL2FnZW50XCI7XG5cbmNvbnN0IGFnZW50ID0gQWdlbnQoKTtcbmNvbnN0IGlzSUUxMSA9IGFnZW50LmJyb3dzZXIubmFtZSA9PT0gXCJpZVwiICYmIGFnZW50LmJyb3dzZXIudmVyc2lvbiA9PT0gXCIxMS4wXCI7XG5cbmNvbnN0IEVWRU5UUyA9IHtcblx0RVJST1I6IFwiZXJyb3JcIlxufTtcblxuLyoqXG4gKlxuICogRXh0ZW5kcyBDb21wb25lbnQgZm9yIGZpcmluZyBlcnJvcnMgb2NjdXJzIGludGVybmFsbHkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0c3RhdGljIEVWRU5UUyA9IEVWRU5UUztcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuX2ZvcmNlRGltZW5zaW9uID0gbnVsbDtcblx0XHR0aGlzLl9waXhlbENhbnZhcyA9IG51bGw7XG5cdFx0dGhpcy5fcGl4ZWxDb250ZXh0ID0gbnVsbDtcblx0fVxuXHQvLyBEZWZpbmUgaW50ZXJmYWNlIGZvciBSZW5kZXJlcnNcblx0LyoqXG5cdCAqIEZvbGxvd2luZyBNVVNUIEJFIERFRklORUQgb24gQ2hpbGQgb2YgUmVuZGVyZXJcblx0ICpcblx0ICogREFUQVxuXHQgKlxuXHQgKiAgLSBnZXRWZXJ0ZXhQb3NpdGlvbkRhdGFcblx0ICogIC0gZ2V0SW5kZXhEYXRhXG5cdCAqICAtIGdldFRleHR1cmVDb29yZERhdGFcblx0ICpcblx0ICogU09VUkNFXG5cdCAqXG5cdCAqICAtIGdldFZlcnRleFNoYWRlclNvdXJjZVxuXHQgKiAgLSBnZXRGcmFnbWVudFNoYWRlclNvdXJjZVxuXHQgKlxuXHQgKiBURVhUVVJFXG5cdCAqXG5cdCAqICAtIGJpbmRUZXh0dXJlXG5cdCAqL1xuXHRnZXREaW1lbnNpb24ocGl4ZWxTb3VyY2UpIHtcblx0XHRjb25zdCB3aWR0aCA9IHBpeGVsU291cmNlLm5hdHVyYWxXaWR0aCB8fCBwaXhlbFNvdXJjZS52aWRlb1dpZHRoO1xuXHRcdGNvbnN0IGhlaWdodCA9IHBpeGVsU291cmNlLm5hdHVyYWxIZWlnaHQgfHwgcGl4ZWxTb3VyY2UudmlkZW9IZWlnaHQ7XG5cblx0XHRyZXR1cm4ge3dpZHRoLCBoZWlnaHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBkYXRhIHVzZWQgYnkgc2hhZGVyXG5cdCAqIFx0LVxuXHQgKlxuXHQgKlxuXHQgKiBAcGFyYW0geyp9IHBhcmFtXG5cdCAqL1xuXHR1cGRhdGVTaGFkZXJEYXRhKHBhcmFtKSB7XG5cdFx0Lypcblx0XHQqIFVwZGF0ZSBmb2xsb3dpbmcgZGF0YSBpbiBpbXBsZW1lbnRhdGlvbiBsYXllci5cblx0XHQqIElmIHRoZSBkYXRhIGlzIG5vdCBjaGFuZ2VkLCBpdCBkb2VzIG5vdCBuZWVkIHRvIGltcGxlbWVudCB0aGlzIGZ1bmN0aW9uLlxuXHRcdCpcblx0XHQqIC0gX1ZFUlRFWF9QT1NJVElPTl9EQVRBXG5cdFx0KiAtIF9URVhUVVJFX0NPT1JEX0RBVEFcblx0XHQqIC0gX0lOREVYX0RBVEFcblx0XHQqL1xuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnR9IGltYWdlXG5cdCAqIEBwYXJhbSB7T2JqZWN0ID0ge3dpZHRoLCBoZWlnaHR9fSBmb3JjZURpbWVuc2lvbiBGb3JjZWQgZGltZW5zaW9uIHRvIHJlc2l6ZVxuXHQgKi9cblx0X2luaXRQaXhlbFNvdXJjZShpbWFnZSwgZm9yY2VEaW1lbnNpb24pIHtcblx0XHRjb25zdCBpc0lFMTFWaWRlbyA9IGlzSUUxMSAmJiAoaW1hZ2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KTtcblxuXHRcdGlmIChpc0lFMTFWaWRlbyB8fCBmb3JjZURpbWVuc2lvbikge1xuXHRcdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gZm9yY2VEaW1lbnNpb24gfHwgdGhpcy5nZXREaW1lbnNpb24oaW1hZ2UpO1xuXG5cdFx0XHR0aGlzLl9waXhlbENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cdFx0XHR0aGlzLl9waXhlbENhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0dGhpcy5fcGl4ZWxDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0dGhpcy5fcGl4ZWxDb250ZXh0ID0gdGhpcy5fcGl4ZWxDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdH1cblx0XHR0aGlzLl9mb3JjZURpbWVuc2lvbiA9IGZvcmNlRGltZW5zaW9uO1xuXHR9XG5cblx0X2dldFBpeGVsU291cmNlKGltYWdlKSB7XG5cdFx0aWYgKCF0aGlzLl9waXhlbENhbnZhcykge1xuXHRcdFx0cmV0dXJuIGltYWdlO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIElFMTEgJiYgVmlkZW9cblx0XHQgKiBvclxuXHRcdCAqIERpbWVuc2lvbiBpcyBmb3JjZWQgKEltYWdlIGlzIGxhcmdlciB0aGFuIHRleHR1cmUgc2l6ZS4pXG5cdFx0ICovXG5cdFx0Y29uc3QgY29udGVudERpbWVuc2lvbiA9IHRoaXMuZ2V0RGltZW5zaW9uKGltYWdlKTtcblx0XHRjb25zdCB0ZXh0dXJlRGltZW5zaW9uID0gdGhpcy5fZm9yY2VEaW1lbnNpb24gfHwgY29udGVudERpbWVuc2lvbjtcblxuXHRcdGlmICh0aGlzLl9waXhlbENhbnZhcy53aWR0aCAhPT0gdGV4dHVyZURpbWVuc2lvbi53aWR0aCkge1xuXHRcdFx0dGhpcy5fcGl4ZWxDYW52YXMud2lkdGggPSB0ZXh0dXJlRGltZW5zaW9uLndpZHRoO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9waXhlbENhbnZhcy5oZWlnaHQgIT09IHRleHR1cmVEaW1lbnNpb24uaGVpZ2h0KSB7XG5cdFx0XHR0aGlzLl9waXhlbENhbnZhcy5oZWlnaHQgPSB0ZXh0dXJlRGltZW5zaW9uLmhlaWdodDtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fZm9yY2VEaW1lbnNpb24pIHtcblx0XHRcdHRoaXMuX3BpeGVsQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsXG5cdFx0XHRcdDAsIDAsIGNvbnRlbnREaW1lbnNpb24ud2lkdGgsIGNvbnRlbnREaW1lbnNpb24uaGVpZ2h0LFxuXHRcdFx0XHQwLCAwLCB0ZXh0dXJlRGltZW5zaW9uLndpZHRoLCB0ZXh0dXJlRGltZW5zaW9uLmhlaWdodCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3BpeGVsQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl9waXhlbENhbnZhcztcblx0fVxuXG5cdF9leHRyYWN0VGlsZUNvbmZpZyhpbWFnZUNvbmZpZykge1xuXHRcdGxldCB0aWxlQ29uZmlnID1cblx0XHRcdEFycmF5LmlzQXJyYXkoaW1hZ2VDb25maWcudGlsZUNvbmZpZykgP1xuXHRcdFx0XHRpbWFnZUNvbmZpZy50aWxlQ29uZmlnIDogQXJyYXkoLi4uQXJyYXkoNikpLm1hcCgoKSA9PiBpbWFnZUNvbmZpZy50aWxlQ29uZmlnKTtcblxuXHRcdHRpbGVDb25maWcgPSB0aWxlQ29uZmlnLm1hcChcblx0XHRcdGNvbmZpZyA9PiBPYmplY3QuYXNzaWduKHtcblx0XHRcdFx0ZmxpcEhvcml6b250YWw6IGZhbHNlLFxuXHRcdFx0XHRyb3RhdGlvbjogMFxuXHRcdFx0fSwgY29uZmlnKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGlsZUNvbmZpZztcblx0fVxuXG5cdF90cmlnZ2VyRXJyb3IoZXJyb3IpIHtcblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5cdFx0Y29uc29sZS5lcnJvcihcIlJlbmRlcmVyIEVycm9yOlwiLCBlcnJvcik7XG5cdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cblx0XHR0aGlzLnRyaWdnZXIoRVZFTlRTLkVSUk9SLCB7XG5cdFx0XHRtZXNzYWdlOiB0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIgPyBlcnJvciA6IGVycm9yLm1lc3NhZ2Vcblx0XHR9KTtcblx0fVxufVxuIiwiaW1wb3J0IEFnZW50IGZyb20gXCJAZWdqcy9hZ2VudFwiO1xuaW1wb3J0IFJlbmRlcmVyIGZyb20gXCIuL1JlbmRlcmVyLmpzXCI7XG5pbXBvcnQgV2ViR0xVdGlscyBmcm9tIFwiLi4vV2ViR0xVdGlsc1wiO1xuaW1wb3J0IHt1dGlsfSBmcm9tIFwiLi4vLi4vdXRpbHMvbWF0aC11dGlsLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1YmVSZW5kZXJlciBleHRlbmRzIFJlbmRlcmVyIHtcblx0c3RhdGljIF9WRVJURVhfUE9TSVRJT05fREFUQSA9IG51bGw7XG5cdHN0YXRpYyBfSU5ERVhfREFUQSA9IG51bGw7XG5cdGdldFZlcnRleFBvc2l0aW9uRGF0YSgpIHtcblx0XHRDdWJlUmVuZGVyZXIuX1ZFUlRFWF9QT1NJVElPTl9EQVRBID1cblx0XHRcdEN1YmVSZW5kZXJlci5fVkVSVEVYX1BPU0lUSU9OX0RBVEEgIT09IG51bGwgPyBDdWJlUmVuZGVyZXIuX1ZFUlRFWF9QT1NJVElPTl9EQVRBIDogW1xuXHRcdFx0XHQvLyBiYWNrXG5cdFx0XHRcdDEsIC0xLCAxLFxuXHRcdFx0XHQtMSwgLTEsIDEsXG5cdFx0XHRcdC0xLCAxLCAxLFxuXHRcdFx0XHQxLCAxLCAxLFxuXG5cdFx0XHRcdC8vIGZyb250XG5cdFx0XHRcdC0xLCAtMSwgLTEsXG5cdFx0XHRcdDEsIC0xLCAtMSxcblx0XHRcdFx0MSwgMSwgLTEsXG5cdFx0XHRcdC0xLCAxLCAtMSxcblxuXHRcdFx0XHQvLyB0b3Bcblx0XHRcdFx0LTEsIDEsIC0xLFxuXHRcdFx0XHQxLCAxLCAtMSxcblx0XHRcdFx0MSwgMSwgMSxcblx0XHRcdFx0LTEsIDEsIDEsXG5cblx0XHRcdFx0Ly8gYm90dG9tXG5cdFx0XHRcdDEsIC0xLCAtMSxcblx0XHRcdFx0LTEsIC0xLCAtMSxcblx0XHRcdFx0LTEsIC0xLCAxLFxuXHRcdFx0XHQxLCAtMSwgMSxcblxuXHRcdFx0XHQvLyByaWdodFxuXHRcdFx0XHQxLCAtMSwgLTEsXG5cdFx0XHRcdDEsIC0xLCAxLFxuXHRcdFx0XHQxLCAxLCAxLFxuXHRcdFx0XHQxLCAxLCAtMSxcblxuXHRcdFx0XHQvLyBsZWZ0XG5cdFx0XHRcdC0xLCAtMSwgMSxcblx0XHRcdFx0LTEsIC0xLCAtMSxcblx0XHRcdFx0LTEsIDEsIC0xLFxuXHRcdFx0XHQtMSwgMSwgMVxuXHRcdFx0XTtcblxuXHRcdHJldHVybiBDdWJlUmVuZGVyZXIuX1ZFUlRFWF9QT1NJVElPTl9EQVRBO1xuXHR9XG5cblx0Z2V0SW5kZXhEYXRhKCkge1xuXHRcdGlmIChDdWJlUmVuZGVyZXIuX0lOREVYX0RBVEEpIHtcblx0XHRcdHJldHVybiBDdWJlUmVuZGVyZXIuX0lOREVYX0RBVEE7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5kZXhEYXRhID0gW107XG5cdFx0Y29uc3QgdmVydGV4UG9zaXRpb25EYXRhID0gdGhpcy5nZXRWZXJ0ZXhQb3NpdGlvbkRhdGEoKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgKHZlcnRleFBvc2l0aW9uRGF0YS5sZW5ndGggLyAzKTsgaSArPSA0KSB7XG5cdFx0XHRpbmRleERhdGEucHVzaChcblx0XHRcdFx0aSxcblx0XHRcdFx0aSArIDIsXG5cdFx0XHRcdGkgKyAxLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRpICsgMyxcblx0XHRcdFx0aSArIDJcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Q3ViZVJlbmRlcmVyLl9JTkRFWF9EQVRBID0gaW5kZXhEYXRhO1xuXHRcdHJldHVybiBpbmRleERhdGE7XG5cdH1cblxuXHRzdGF0aWMgZXh0cmFjdE9yZGVyKGltYWdlQ29uZmlnKSB7XG5cdFx0cmV0dXJuIGltYWdlQ29uZmlnLm9yZGVyIHx8IFwiUkxVREJGXCI7XG5cdH1cblxuXHRnZXRUZXh0dXJlQ29vcmREYXRhKGltYWdlQ29uZmlnKSB7XG5cdFx0Y29uc3QgdmVydGV4T3JkZXIgPSBcIkJGVURSTFwiO1xuXHRcdGNvbnN0IG9yZGVyID0gQ3ViZVJlbmRlcmVyLmV4dHJhY3RPcmRlcihpbWFnZUNvbmZpZyk7XG5cdFx0Y29uc3QgYmFzZSA9IHRoaXMuZ2V0VmVydGV4UG9zaXRpb25EYXRhKCk7XG5cdFx0Y29uc3QgdGlsZUNvbmZpZyA9IHRoaXMuX2V4dHJhY3RUaWxlQ29uZmlnKGltYWdlQ29uZmlnKTtcblx0XHRjb25zdCBlbGVtU2l6ZSA9IDM7XG5cdFx0Y29uc3QgdmVydGV4UGVyVGlsZSA9IDQ7XG5cdFx0Y29uc3QgdGV4dHVyZUNvb3JkRGF0YSA9XG5cdFx0XHR2ZXJ0ZXhPcmRlci5zcGxpdChcIlwiKVxuXHRcdFx0XHQubWFwKGZhY2UgPT4gdGlsZUNvbmZpZ1tvcmRlci5pbmRleE9mKGZhY2UpXSlcblx0XHRcdFx0Lm1hcCgoY29uZmlnLCBpKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qgcm90YXRpb24gPSBwYXJzZUludChjb25maWcucm90YXRpb24gLyA5MCwgMTApO1xuXHRcdFx0XHRcdGNvbnN0IG9yZGVybWFwXyA9IGNvbmZpZy5mbGlwSG9yaXpvbnRhbCA/IFswLCAxLCAyLCAzXSA6IFsxLCAwLCAzLCAyXTtcblxuXHRcdFx0XHRcdGZvciAobGV0IHIgPSAwOyByIDwgTWF0aC5hYnMocm90YXRpb24pOyByKyspIHtcblx0XHRcdFx0XHRcdGlmICgoY29uZmlnLmZsaXBIb3Jpem9udGFsICYmIHJvdGF0aW9uID4gMCkgfHxcblx0XHRcdFx0XHRcdFx0KCFjb25maWcuZmxpcEhvcml6b250YWwgJiYgcm90YXRpb24gPCAwKSkge1xuXHRcdFx0XHRcdFx0XHRvcmRlcm1hcF8ucHVzaChvcmRlcm1hcF8uc2hpZnQoKSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRvcmRlcm1hcF8udW5zaGlmdChvcmRlcm1hcF8ucG9wKCkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IGVsZW1QZXJUaWxlID0gZWxlbVNpemUgKiB2ZXJ0ZXhQZXJUaWxlO1xuXHRcdFx0XHRcdGNvbnN0IHRpbGVWZXJ0ZXggPSBiYXNlLnNsaWNlKGkgKiBlbGVtUGVyVGlsZSwgaSAqIGVsZW1QZXJUaWxlICsgZWxlbVBlclRpbGUpO1xuXHRcdFx0XHRcdGNvbnN0IHRpbGVUZW1wID0gW107XG5cblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IHZlcnRleFBlclRpbGU7IGorKykge1xuXHRcdFx0XHRcdFx0dGlsZVRlbXBbb3JkZXJtYXBfW2pdXSA9IHRpbGVWZXJ0ZXguc3BsaWNlKDAsIGVsZW1TaXplKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRpbGVUZW1wO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuam9pbigpXG5cdFx0XHRcdC5zcGxpdChcIixcIilcblx0XHRcdFx0Lm1hcCh2ID0+IHBhcnNlSW50KHYsIDEwKSk7XG5cblx0XHRyZXR1cm4gdGV4dHVyZUNvb3JkRGF0YTtcblx0fVxuXG5cdGdldFZlcnRleFNoYWRlclNvdXJjZSgpIHtcblx0XHRyZXR1cm4gYFxuXHRcdFx0YXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xuXHRcdFx0YXR0cmlidXRlIHZlYzMgYVRleHR1cmVDb29yZDtcblx0XHRcdHVuaWZvcm0gbWF0NCB1TVZNYXRyaXg7XG5cdFx0XHR1bmlmb3JtIG1hdDQgdVBNYXRyaXg7XG5cdFx0XHR2YXJ5aW5nIGhpZ2hwIHZlYzMgdlZlcnRleERpcmVjdGlvblZlY3Rvcjtcblx0XHRcdHZvaWQgbWFpbih2b2lkKSB7XG5cdFx0XHRcdGdsX1Bvc2l0aW9uID0gdVBNYXRyaXggKiB1TVZNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcblx0XHRcdFx0dlZlcnRleERpcmVjdGlvblZlY3RvciA9IGFUZXh0dXJlQ29vcmQ7XG5cdFx0XHR9YDtcblx0fVxuXG5cdGdldEZyYWdtZW50U2hhZGVyU291cmNlKCkge1xuXHRcdHJldHVybiBgXG5cdFx0XHR2YXJ5aW5nIGhpZ2hwIHZlYzMgdlZlcnRleERpcmVjdGlvblZlY3Rvcjtcblx0XHRcdHVuaWZvcm0gc2FtcGxlckN1YmUgdVNhbXBsZXI7XG5cdFx0XHR2b2lkIG1haW4odm9pZCkge1xuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlQ3ViZSh1U2FtcGxlciwgdlZlcnRleERpcmVjdGlvblZlY3Rvcik7XG5cdFx0XHR9YDtcblx0fVxuXG5cdHVwZGF0ZVRleHR1cmUoZ2wsIGltYWdlLCBpbWFnZUNvbmZpZykge1xuXHRcdGNvbnN0IGJhc2VPcmRlciA9IFwiUkxVREJGXCI7XG5cdFx0Y29uc3Qgb3JkZXIgPSBDdWJlUmVuZGVyZXIuZXh0cmFjdE9yZGVyKGltYWdlQ29uZmlnKTtcblx0XHRjb25zdCBvcmRlck1hcCA9IHt9O1xuXG5cdFx0b3JkZXIuc3BsaXQoXCJcIikuZm9yRWFjaCgodiwgaSkgPT4ge1xuXHRcdFx0b3JkZXJNYXBbdl0gPSBpO1xuXHRcdH0pO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGlmIChpbWFnZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdGZvciAobGV0IHN1cmZhY2VJZHggPSAwOyBzdXJmYWNlSWR4IDwgNjsgc3VyZmFjZUlkeCsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgdGlsZUlkeCA9IG9yZGVyTWFwW2Jhc2VPcmRlcltzdXJmYWNlSWR4XV07XG5cblx0XHRcdFx0XHRXZWJHTFV0aWxzLnRleEltYWdlMkQoZ2wsIGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIHN1cmZhY2VJZHgsIGltYWdlW3RpbGVJZHhdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgbWF4Q3ViZU1hcFRleHR1cmVTaXplID0gdGhpcy5nZXRNYXhDdWJlTWFwVGV4dHVyZVNpemUoZ2wsIGltYWdlKTtcblxuXHRcdFx0XHRmb3IgKGxldCBzdXJmYWNlSWR4ID0gMDsgc3VyZmFjZUlkeCA8IDY7IHN1cmZhY2VJZHgrKykge1xuXHRcdFx0XHRcdGNvbnN0IHRpbGVJZHggPSBvcmRlck1hcFtiYXNlT3JkZXJbc3VyZmFjZUlkeF1dO1xuXHRcdFx0XHRcdGNvbnN0IHRpbGUgPSB0aGlzLmV4dHJhY3RUaWxlRnJvbUltYWdlKFxuXHRcdFx0XHRcdFx0aW1hZ2UsIHRpbGVJZHgsIG1heEN1YmVNYXBUZXh0dXJlU2l6ZVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRXZWJHTFV0aWxzLnRleEltYWdlMkQoZ2wsIGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIHN1cmZhY2VJZHgsIHRpbGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0dGhpcy5fdHJpZ2dlckVycm9yKGUpO1xuXHRcdH1cblx0fVxuXG5cdGJpbmRUZXh0dXJlKGdsLCB0ZXh0dXJlLCBpbWFnZSwgaW1hZ2VDb25maWcpIHtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlKTtcblx0XHR0aGlzLnVwZGF0ZVRleHR1cmUoZ2wsIGltYWdlLCBpbWFnZUNvbmZpZyk7XG5cdH1cblxuXHRnZXRTb3VyY2VUaWxlU2l6ZShpbWFnZSkge1xuXHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuZ2V0RGltZW5zaW9uKGltYWdlKTtcblx0XHRjb25zdCBhc3BlY3RSYXRpbyA9IHdpZHRoIC8gaGVpZ2h0O1xuXHRcdGxldCBpbnB1dFRleHR1cmVTaXplO1xuXG5cdFx0aWYgKGFzcGVjdFJhdGlvID09PSAxIC8gNikge1xuXHRcdFx0aW5wdXRUZXh0dXJlU2l6ZSA9IHdpZHRoO1xuXHRcdH0gZWxzZSBpZiAoYXNwZWN0UmF0aW8gPT09IDYpIHtcblx0XHRcdGlucHV0VGV4dHVyZVNpemUgPSBoZWlnaHQ7XG5cdFx0fSBlbHNlIGlmIChhc3BlY3RSYXRpbyA9PT0gMiAvIDMpIHtcblx0XHRcdGlucHV0VGV4dHVyZVNpemUgPSB3aWR0aCAvIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlucHV0VGV4dHVyZVNpemUgPSB3aWR0aCAvIDM7XG5cdFx0fVxuXHRcdHJldHVybiBpbnB1dFRleHR1cmVTaXplO1xuXHR9XG5cblx0ZXh0cmFjdFRpbGVGcm9tSW1hZ2UoaW1hZ2UsIHRpbGVJZHgsIG91dHB1dFRleHR1cmVTaXplKSB7XG5cdFx0Y29uc3Qge3dpZHRofSA9IHRoaXMuZ2V0RGltZW5zaW9uKGltYWdlKTtcblx0XHRjb25zdCBpbnB1dFRleHR1cmVTaXplID0gdGhpcy5nZXRTb3VyY2VUaWxlU2l6ZShpbWFnZSk7XG5cblx0XHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXG5cdFx0Y2FudmFzLndpZHRoID0gb3V0cHV0VGV4dHVyZVNpemU7XG5cdFx0Y2FudmFzLmhlaWdodCA9IG91dHB1dFRleHR1cmVTaXplO1xuXHRcdGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdGNvbnN0IHRpbGVQZXJSb3cgPSB3aWR0aCAvIGlucHV0VGV4dHVyZVNpemU7XG5cblx0XHRjb25zdCB4ID0gaW5wdXRUZXh0dXJlU2l6ZSAqIHRpbGVJZHggJSAoaW5wdXRUZXh0dXJlU2l6ZSAqIHRpbGVQZXJSb3cpO1xuXHRcdGNvbnN0IHkgPSBwYXJzZUludCh0aWxlSWR4IC8gdGlsZVBlclJvdywgMTApICogKGlucHV0VGV4dHVyZVNpemUpO1xuXG5cdFx0Y29udGV4dC5kcmF3SW1hZ2UoXG5cdFx0XHRpbWFnZSwgeCwgeSxcblx0XHRcdGlucHV0VGV4dHVyZVNpemUsIGlucHV0VGV4dHVyZVNpemUsIDAsIDAsIG91dHB1dFRleHR1cmVTaXplLCBvdXRwdXRUZXh0dXJlU2l6ZVxuXHRcdCk7XG5cdFx0cmV0dXJuIGNhbnZhcztcblx0fVxuXG5cdGdldE1heEN1YmVNYXBUZXh0dXJlU2l6ZShnbCwgaW1hZ2UpIHtcblx0XHRjb25zdCBhZ2VudCA9IEFnZW50KCk7XG5cdFx0Y29uc3QgbWF4Q3ViZU1hcFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUpO1xuXHRcdGxldCBfaW1hZ2VXaWR0aCA9IHRoaXMuZ2V0U291cmNlVGlsZVNpemUoaW1hZ2UpO1xuXG5cdFx0aWYgKGFnZW50LmJyb3dzZXIubmFtZSA9PT0gXCJpZVwiICYmIHBhcnNlSW50KGFnZW50LmJyb3dzZXIudmVyc2lvbiwgMTApID09PSAxMSkge1xuXHRcdFx0aWYgKCF1dGlsLmlzUG93ZXJPZlR3byhfaW1hZ2VXaWR0aCkpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCBtYXhDdWJlTWFwVGV4dHVyZVNpemU7IGkgKj0gMikge1xuXHRcdFx0XHRcdGlmIChpIDwgX2ltYWdlV2lkdGgpIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRfaW1hZ2VXaWR0aCA9IGk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gaW9zIDkg7J2YIOqyveyasCDthY3siqTss5Ag7LWc64yA7IKs7J207KaI64qUIDEwMjQg7J2064ukLlxuXHRcdGlmIChhZ2VudC5vcy5uYW1lID09PSBcImlvc1wiICYmIHBhcnNlSW50KGFnZW50Lm9zLnZlcnNpb24sIDEwKSA9PT0gOSkge1xuXHRcdFx0X2ltYWdlV2lkdGggPSAxMDI0O1xuXHRcdH1cblx0XHQvLyBpb3MgOCDsnZgg6rK97JqwIO2FjeyKpOyzkCDstZzrjIDsgqzsnbTspojripQgNTEyIOydtOuLpC5cblx0XHRpZiAoYWdlbnQub3MubmFtZSA9PT0gXCJpb3NcIiAmJiBwYXJzZUludChhZ2VudC5vcy52ZXJzaW9uLCAxMCkgPT09IDgpIHtcblx0XHRcdF9pbWFnZVdpZHRoID0gNTEyO1xuXHRcdH1cblx0XHQvLyBtYXhDdWJlTWFwVGV4dHVyZVNpemUg67O064uk64qUIOyekeqzoCwgaW1hZ2VXaWR0aCDrs7Tri6Qg7YGwIDLsnZgg7Iq57IiYIOykkSDqsIDsnqUg7J6R7J2AIOyImFxuXHRcdHJldHVybiBNYXRoLm1pbihtYXhDdWJlTWFwVGV4dHVyZVNpemUsIF9pbWFnZVdpZHRoKTtcblx0fVxufVxuIiwiXG5pbXBvcnQgUmVuZGVyZXIgZnJvbSBcIi4vUmVuZGVyZXIuanNcIjtcbmltcG9ydCBXZWJHTFV0aWxzIGZyb20gXCIuLi9XZWJHTFV0aWxzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1YmVTdHJpcFJlbmRlcmVyIGV4dGVuZHMgUmVuZGVyZXIge1xuXHRnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKSB7XG5cdFx0cmV0dXJuIGBcblx0XHRcdGF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcblx0XHRcdGF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG5cdFx0XHR1bmlmb3JtIG1hdDQgdU1WTWF0cml4O1xuXHRcdFx0dW5pZm9ybSBtYXQ0IHVQTWF0cml4O1xuXHRcdFx0dmFyeWluZyBoaWdocCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cdFx0XHR2b2lkIG1haW4odm9pZCkge1xuXHRcdFx0XHRnbF9Qb3NpdGlvbiA9IHVQTWF0cml4ICogdU1WTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24sIDEuMCk7XG5cdFx0XHRcdHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuXHRcdFx0fWA7XG5cdH1cblxuXHRnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpIHtcblx0XHRyZXR1cm4gYFxuXHRcdFx0I2RlZmluZSBQSSAzLjE0MTU5MjY1MzU5XG5cblx0XHRcdHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXHRcdFx0dmFyeWluZyBoaWdocCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcblx0XHRcdHVuaWZvcm0gYm9vbCB1SXNFQUM7XG5cblx0XHRcdGNvbnN0IHZlYzIgT1BFUkFURV9DT09SRFNfUkFOR0UgPSB2ZWMyKC0xLjAsIDEuMCk7XG5cdFx0XHRjb25zdCB2ZWMyIFRFWFRVUkVfQ09PUkRTX1JBTkdFID0gdmVjMigwLjAsIDEuMCk7XG5cdFx0XHQvLyB2ZWN0b3IgdHlwZSBpcyB1c2VkIGZvciBpbml0aWFsaXppbmcgdmFsdWVzIGluc3RlYWQgb2YgYXJyYXkuXG5cdFx0XHRjb25zdCB2ZWM0IFRFWFRVUkVfRElWSVNJT05fWCA9IHZlYzQoMC4wLCAxLjAgLyAzLjAsIDIuMCAvIDMuMCwgMS4wKTtcblx0XHRcdGNvbnN0IHZlYzMgVEVYVFVSRV9ESVZJU0lPTl9ZID0gdmVjMygwLjAsIDEuMCAvIDIuMCwgMS4wKTtcblx0XHRcdGNvbnN0IGZsb2F0IEVBQ19DT05TVCA9IDIuMCAvIFBJO1xuXG5cdFx0XHRmbG9hdCBzY2FsZSh2ZWMyIGRvbWFpblJhbmdlLCB2ZWMyIHRhcmdldFJhbmdlLCBmbG9hdCB2YWwpIHtcblx0XHRcdFx0ZmxvYXQgdW5pdCA9IDEuMCAvIChkb21haW5SYW5nZVsxXSAtIGRvbWFpblJhbmdlWzBdKTtcblx0XHRcdFx0cmV0dXJuIHRhcmdldFJhbmdlWzBdICsgKHRhcmdldFJhbmdlWzFdIC0gdGFyZ2V0UmFuZ2VbMF0pICogKHZhbCAtIGRvbWFpblJhbmdlWzBdKSAqIHVuaXQ7XG5cdFx0XHR9XG5cblx0XHRcdHZvaWQgbWFpbih2b2lkKSB7XG5cdFx0XHRcdGZsb2F0IHRyYW5zZm9ybWVkQ29vcmRYO1xuXHRcdFx0XHRmbG9hdCB0cmFuc2Zvcm1lZENvb3JkWTtcblxuXHRcdFx0XHRpZiAodUlzRUFDKSB7XG5cdFx0XHRcdFx0dmVjMiBvcmdUZXh0dXJlUmFuZ2VYO1xuXHRcdFx0XHRcdHZlYzIgb3JnVGV4dHVyZVJhbmdlWTtcblxuXHRcdFx0XHRcdC8vIEFwcGx5IEVBQyB0cmFuc2Zvcm1cblx0XHRcdFx0XHRpZiAodlRleHR1cmVDb29yZC5zID49IFRFWFRVUkVfRElWSVNJT05fWFsyXSkge1xuXHRcdFx0XHRcdFx0b3JnVGV4dHVyZVJhbmdlWCA9IHZlYzIoVEVYVFVSRV9ESVZJU0lPTl9YWzJdLCBURVhUVVJFX0RJVklTSU9OX1hbM10pO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodlRleHR1cmVDb29yZC5zID49IFRFWFRVUkVfRElWSVNJT05fWFsxXSkge1xuXHRcdFx0XHRcdFx0b3JnVGV4dHVyZVJhbmdlWCA9IHZlYzIoVEVYVFVSRV9ESVZJU0lPTl9YWzFdLCBURVhUVVJFX0RJVklTSU9OX1hbMl0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRvcmdUZXh0dXJlUmFuZ2VYID0gdmVjMihURVhUVVJFX0RJVklTSU9OX1hbMF0sIFRFWFRVUkVfRElWSVNJT05fWFsxXSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHZUZXh0dXJlQ29vcmQudCA+PSBURVhUVVJFX0RJVklTSU9OX1lbMV0pIHtcblx0XHRcdFx0XHRcdG9yZ1RleHR1cmVSYW5nZVkgPSB2ZWMyKFRFWFRVUkVfRElWSVNJT05fWVsxXSwgVEVYVFVSRV9ESVZJU0lPTl9ZWzJdKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0b3JnVGV4dHVyZVJhbmdlWSA9IHZlYzIoVEVYVFVSRV9ESVZJU0lPTl9ZWzBdLCBURVhUVVJFX0RJVklTSU9OX1lbMV0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHNjYWxpbmcgY29vcnMgYnkgdGhlIGNvb3JkaW5hdGVzIGZvbGxvd2luZyB0aGUgcmFuZ2UgZnJvbSAtMS4wIHRvIDEuMC5cblx0XHRcdFx0XHRmbG9hdCBweCA9IHNjYWxlKG9yZ1RleHR1cmVSYW5nZVgsIE9QRVJBVEVfQ09PUkRTX1JBTkdFLCB2VGV4dHVyZUNvb3JkLnMpO1xuXHRcdFx0XHRcdGZsb2F0IHB5ID0gc2NhbGUob3JnVGV4dHVyZVJhbmdlWSwgT1BFUkFURV9DT09SRFNfUkFOR0UsIHZUZXh0dXJlQ29vcmQudCk7XG5cblx0XHRcdFx0XHRmbG9hdCBxdSA9IEVBQ19DT05TVCAqIGF0YW4ocHgpICsgMC41O1xuXHRcdFx0XHRcdGZsb2F0IHF2ID0gRUFDX0NPTlNUICogYXRhbihweSkgKyAwLjU7XG5cblx0XHRcdFx0XHQvLyByZS1zY2FsaW5nIGNvb3JzIGJ5IG9yaWdpbmFsIGNvb3JkaW5hdGVzIHJhbmdlc1xuXHRcdFx0XHRcdHRyYW5zZm9ybWVkQ29vcmRYID0gc2NhbGUoVEVYVFVSRV9DT09SRFNfUkFOR0UsIG9yZ1RleHR1cmVSYW5nZVgsIHF1KTtcblx0XHRcdFx0XHR0cmFuc2Zvcm1lZENvb3JkWSA9IHNjYWxlKFRFWFRVUkVfQ09PUkRTX1JBTkdFLCBvcmdUZXh0dXJlUmFuZ2VZLCBxdik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gbm9ybWFsIGN1YmVtYXBcblx0XHRcdFx0XHR0cmFuc2Zvcm1lZENvb3JkWCA9IHZUZXh0dXJlQ29vcmQucztcblx0XHRcdFx0XHR0cmFuc2Zvcm1lZENvb3JkWSA9IHZUZXh0dXJlQ29vcmQudDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdmVjMih0cmFuc2Zvcm1lZENvb3JkWCwgdHJhbnNmb3JtZWRDb29yZFkpKTtcblx0XHRcdH1gO1xuXHR9XG5cblx0Z2V0VmVydGV4UG9zaXRpb25EYXRhKCkge1xuXHRcdGlmICghdGhpcy5fdmVydGljZXMpIHtcblx0XHRcdHRoaXMuX3ZlcnRpY2VzID0gW1xuXHRcdFx0XHQvLyBiYWNrXG5cdFx0XHRcdDEsIC0xLCAxLFxuXHRcdFx0XHQtMSwgLTEsIDEsXG5cdFx0XHRcdC0xLCAxLCAxLFxuXHRcdFx0XHQxLCAxLCAxLFxuXG5cdFx0XHRcdC8vIGZyb250XG5cdFx0XHRcdC0xLCAtMSwgLTEsXG5cdFx0XHRcdDEsIC0xLCAtMSxcblx0XHRcdFx0MSwgMSwgLTEsXG5cdFx0XHRcdC0xLCAxLCAtMSxcblxuXHRcdFx0XHQvLyB1cFxuXHRcdFx0XHQtMSwgMSwgLTEsXG5cdFx0XHRcdDEsIDEsIC0xLFxuXHRcdFx0XHQxLCAxLCAxLFxuXHRcdFx0XHQtMSwgMSwgMSxcblxuXHRcdFx0XHQvLyBkb3duXG5cdFx0XHRcdC0xLCAtMSwgMSxcblx0XHRcdFx0MSwgLTEsIDEsXG5cdFx0XHRcdDEsIC0xLCAtMSxcblx0XHRcdFx0LTEsIC0xLCAtMSxcblxuXHRcdFx0XHQvLyByaWdodFxuXHRcdFx0XHQxLCAtMSwgLTEsXG5cdFx0XHRcdDEsIC0xLCAxLFxuXHRcdFx0XHQxLCAxLCAxLFxuXHRcdFx0XHQxLCAxLCAtMSxcblxuXHRcdFx0XHQvLyBsZWZ0XG5cdFx0XHRcdC0xLCAtMSwgMSxcblx0XHRcdFx0LTEsIC0xLCAtMSxcblx0XHRcdFx0LTEsIDEsIC0xLFxuXHRcdFx0XHQtMSwgMSwgMVxuXHRcdFx0XTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fdmVydGljZXM7XG5cdH1cblxuXHRnZXRJbmRleERhdGEoKSB7XG5cdFx0Ly8gVE9ETzog7ZWc67KI66eMIOqzhOyCsO2VmOuPhOuhnSDsiJjsoJXtlZjquLBcblx0XHRjb25zdCBpbmRpY2VzID0gKCgpID0+IHtcblx0XHRcdGNvbnN0IGluZGV4RGF0YSA9IFtdO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8ICh0aGlzLl92ZXJ0aWNlcy5sZW5ndGggLyAzKTsgaSArPSA0KSB7XG5cdFx0XHRcdGluZGV4RGF0YS5wdXNoKFxuXHRcdFx0XHRcdGksXG5cdFx0XHRcdFx0aSArIDEsXG5cdFx0XHRcdFx0aSArIDIsXG5cdFx0XHRcdFx0aSxcblx0XHRcdFx0XHRpICsgMixcblx0XHRcdFx0XHRpICsgM1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGluZGV4RGF0YTtcblx0XHR9KSgpO1xuXG5cdFx0cmV0dXJuIGluZGljZXM7XG5cdH1cblxuXHRnZXRUZXh0dXJlQ29vcmREYXRhKGltYWdlQ29uZmlnKSB7XG5cdFx0Ly8gVE9ETzogbWFrZSBpdCBjb2xzLCByb3dzIGFzIGNvbmZpZy5cblx0XHRjb25zdCBjb2xzID0gMztcblx0XHRjb25zdCByb3dzID0gMjtcblx0XHRjb25zdCBvcmRlciA9IGltYWdlQ29uZmlnLm9yZGVyIHx8IFwiUkxVREZCXCI7XG5cdFx0bGV0IGNvb3JkcyA9IFtdO1xuXG5cdFx0Ly8g7YWN7Iqk7LOQ7J2YIOyijO2RnOuKlCDsnJfsqr3snbQg7YGwIOqwkuydhCDqsIDsp4Drr4DroZwgcm93IOuKlCDsl63siJzsnLzroZwg64Sj64qU64ukLlxuXHRcdGZvciAobGV0IHIgPSByb3dzIC0gMTsgciA+PSAwOyByLS0pIHtcblx0XHRcdGZvciAobGV0IGMgPSAwOyBjIDwgY29sczsgYysrKSB7XG5cdFx0XHRcdGNvbnN0IGNvb3JkID0gW1xuXHRcdFx0XHRcdGMgLyBjb2xzLCByIC8gcm93cyxcblx0XHRcdFx0XHQoYyArIDEpIC8gY29scywgciAvIHJvd3MsXG5cdFx0XHRcdFx0KGMgKyAxKSAvIGNvbHMsIChyICsgMSkgLyByb3dzLFxuXHRcdFx0XHRcdGMgLyBjb2xzLCAociArIDEpIC8gcm93c1xuXHRcdFx0XHRdO1xuXG5cdFx0XHRcdGNvb3Jkcy5wdXNoKGNvb3JkKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCB0aWxlQ29uZmlncyA9IHRoaXMuX2V4dHJhY3RUaWxlQ29uZmlnKGltYWdlQ29uZmlnKTtcblxuXHRcdC8vIFRyYW5zZm9ybSBDb29yZCBCeSBGbGlwICYgUm90YXRpb25cblx0XHRjb29yZHMgPSBjb29yZHNcblx0XHQvLyBzaHJpbmsgY29vcmQgdG8gYXZvaWQgcGl4ZWwgYmxlZWRpbmdcblx0XHRcdC5tYXAoY29vcmQgPT4gdGhpcy5fc2hyaW5rQ29vcmQoY29vcmQpKVxuXHRcdFx0Lm1hcCgoY29vcmQsIGkpID0+IHRoaXMuX3RyYW5zZm9ybUNvb3JkKGNvb3JkLCB0aWxlQ29uZmlnc1tpXSkpO1xuXG5cdFx0Ly8gdmVydGljZXMg7JeQ7IScIOyngOygleuQnCDsiJzshJzrjIDroZwg6re464yA66GcIOq3uOumrOq4sCDsnITtlbQgdmVydGV4IOydmCDsiJzshJzrpbwgQkZVRFJMIOuhnCDsnqzrsLDsuZhcblx0XHRyZXR1cm4gXCJCRlVEUkxcIi5zcGxpdChcIlwiKVxuXHRcdFx0Lm1hcChmYWNlID0+IG9yZGVyLmluZGV4T2YoZmFjZSkpXG5cdFx0XHQubWFwKGluZGV4ID0+IGNvb3Jkc1tpbmRleF0pXG5cdFx0XHQucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjLmNvbmNhdCh2YWwpLCBbXSk7XG5cdH1cblxuXHR1cGRhdGVUZXh0dXJlKGdsLCBpbWFnZSkge1xuXHRcdFdlYkdMVXRpbHMudGV4SW1hZ2UyRChnbCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5fZ2V0UGl4ZWxTb3VyY2UoaW1hZ2UpKTtcblx0fVxuXG5cdGJpbmRUZXh0dXJlKGdsLCB0ZXh0dXJlLCBpbWFnZSkge1xuXHRcdC8vIE1ha2Ugc3VyZSBpbWFnZSBpc24ndCB0b28gYmlnXG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy5nZXREaW1lbnNpb24oaW1hZ2UpO1xuXHRcdGNvbnN0IHNpemUgPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcblx0XHRjb25zdCBtYXhTaXplID0gV2ViR0xVdGlscy5nZXRNYXhUZXh0dXJlU2l6ZShnbCk7XG5cblx0XHRpZiAoc2l6ZSA+IG1heFNpemUpIHtcblx0XHRcdHRoaXMuX3RyaWdnZXJFcnJvcihgSW1hZ2Ugd2lkdGgoJHt3aWR0aH0pIGV4Y2VlZHMgZGV2aWNlIGxpbWl0KCR7bWF4U2l6ZX0pKWApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFBpeGVsIFNvdXJjZSBmb3IgSUUxMSAmIFZpZGVvXG5cdFx0dGhpcy5faW5pdFBpeGVsU291cmNlKGltYWdlKTtcblxuXHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuXHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuXG5cdFx0dGhpcy51cGRhdGVUZXh0dXJlKGdsLCBpbWFnZSk7XG5cdH1cblxuXHRfdHJhbnNmb3JtQ29vcmQoY29vcmQsIHRpbGVDb25maWcpIHtcblx0XHRsZXQgbmV3Q29vcmQgPSBjb29yZC5zbGljZSgpO1xuXG5cdFx0aWYgKHRpbGVDb25maWcuZmxpcEhvcml6b250YWwpIHtcblx0XHRcdG5ld0Nvb3JkID0gdGhpcy5fZmxpcEhvcml6b250YWxDb29yZChuZXdDb29yZCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRpbGVDb25maWcucm90YXRpb24pIHtcblx0XHRcdG5ld0Nvb3JkID0gdGhpcy5fcm90YXRlQ29vcmQobmV3Q29vcmQsIHRpbGVDb25maWcucm90YXRpb24pO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXdDb29yZDtcblx0fVxuXG5cdF9zaHJpbmtDb29yZChjb29yZCkge1xuXHRcdGNvbnN0IFNIUklOS19ZID0gMC4wMDtcblx0XHRjb25zdCBTSFJJTktfWCA9IDAuMDA7XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0Y29vcmRbMF0gKyBTSFJJTktfWCwgY29vcmRbMV0gKyBTSFJJTktfWSxcblx0XHRcdGNvb3JkWzJdIC0gU0hSSU5LX1gsIGNvb3JkWzNdICsgU0hSSU5LX1ksXG5cdFx0XHRjb29yZFs0XSAtIFNIUklOS19YLCBjb29yZFs1XSAtIFNIUklOS19ZLFxuXHRcdFx0Y29vcmRbNl0gKyBTSFJJTktfWCwgY29vcmRbN10gLSBTSFJJTktfWVxuXHRcdF07XG5cdH1cblxuXHRfcm90YXRlQ29vcmQoY29vcmQsIHJvdGF0aW9uQW5nbGUpIHtcblx0XHRjb25zdCBTSVpFID0gMjsgLy8gY29vcmQgbWVhbnMgeCx5IGNvb3JkaW5hdGVzLiBUd28gdmFsdWVzKHgsIHkpIG1ha2VzIGEgb25lIGNvb3JkLlxuXHRcdGNvbnN0IHNoaWZ0Q291bnQgPSBwYXJzZUludChyb3RhdGlvbkFuZ2xlIC8gOTAsIDEwKSAlIDQ7XG5cblx0XHRpZiAoc2hpZnRDb3VudCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIGNvb3JkO1xuXHRcdH1cblxuXHRcdGxldCBtb3ZlZDtcblx0XHRsZXQgcm90YXRlZENvb3JkID0gW107XG5cblx0XHRpZiAoc2hpZnRDb3VudCA+IDApIHtcblx0XHRcdG1vdmVkID0gY29vcmQuc3BsaWNlKDAsIHNoaWZ0Q291bnQgKiBTSVpFKTtcblx0XHRcdHJvdGF0ZWRDb29yZCA9IGNvb3JkLmNvbmNhdChtb3ZlZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1vdmVkID0gY29vcmQuc3BsaWNlKCg0ICsgc2hpZnRDb3VudCkgKiBTSVpFLCAtc2hpZnRDb3VudCAqIFNJWkUpO1xuXHRcdFx0cm90YXRlZENvb3JkID0gbW92ZWQuY29uY2F0KGNvb3JkKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcm90YXRlZENvb3JkO1xuXHR9XG5cblx0X2ZsaXBIb3Jpem9udGFsQ29vcmQoY29vcmQpIHtcblx0XHRyZXR1cm4gW1xuXHRcdFx0Y29vcmRbMl0sIGNvb3JkWzNdLFxuXHRcdFx0Y29vcmRbMF0sIGNvb3JkWzFdLFxuXHRcdFx0Y29vcmRbNl0sIGNvb3JkWzddLFxuXHRcdFx0Y29vcmRbNF0sIGNvb3JkWzVdXG5cdFx0XTtcblx0fVxufVxuIiwiaW1wb3J0IFJlbmRlcmVyIGZyb20gXCIuL1JlbmRlcmVyXCI7XG5pbXBvcnQgV2ViR0xVdGlscyBmcm9tIFwiLi4vV2ViR0xVdGlsc1wiO1xuXG5jb25zdCBsYXRpdHVkZUJhbmRzID0gNjA7XG5jb25zdCBsb25naXR1ZGVCYW5kcyA9IDYwO1xuY29uc3QgcmFkaXVzID0gMjtcbmNvbnN0IEFOR0xFX0NPUlJFQ1RJT05fRk9SX0NFTlRFUl9BTElHTiA9IC0wLjUgKiBNYXRoLlBJO1xuXG5jb25zdCB0ZXh0dXJlQ29vcmREYXRhID0gW107XG5jb25zdCB2ZXJ0ZXhQb3NpdGlvbkRhdGEgPSBbXTtcbmNvbnN0IGluZGV4RGF0YSA9IFtdO1xubGV0IGxhdElkeDtcbmxldCBsbmdJZHg7XG5cbmZvciAobGF0SWR4ID0gMDsgbGF0SWR4IDw9IGxhdGl0dWRlQmFuZHM7IGxhdElkeCsrKSB7XG5cdGNvbnN0IHRoZXRhID0gKGxhdElkeCAvIGxhdGl0dWRlQmFuZHMgLSAwLjUpICogTWF0aC5QSTtcblx0Y29uc3Qgc2luVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XG5cdGNvbnN0IGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xuXG5cdGZvciAobG5nSWR4ID0gMDsgbG5nSWR4IDw9IGxvbmdpdHVkZUJhbmRzOyBsbmdJZHgrKykge1xuXHRcdGNvbnN0IHBoaSA9IChsbmdJZHggLyBsb25naXR1ZGVCYW5kcyAtIDAuNSkgKiAyICogTWF0aC5QSSArIEFOR0xFX0NPUlJFQ1RJT05fRk9SX0NFTlRFUl9BTElHTjtcblx0XHRjb25zdCBzaW5QaGkgPSBNYXRoLnNpbihwaGkpO1xuXHRcdGNvbnN0IGNvc1BoaSA9IE1hdGguY29zKHBoaSk7XG5cdFx0Y29uc3QgeCA9IGNvc1BoaSAqIGNvc1RoZXRhO1xuXHRcdGNvbnN0IHkgPSBzaW5UaGV0YTtcblx0XHRjb25zdCB6ID0gc2luUGhpICogY29zVGhldGE7XG5cdFx0Y29uc3QgdSA9IGxuZ0lkeCAvIGxvbmdpdHVkZUJhbmRzO1xuXHRcdGNvbnN0IHYgPSBsYXRJZHggLyBsYXRpdHVkZUJhbmRzO1xuXG5cdFx0dGV4dHVyZUNvb3JkRGF0YS5wdXNoKHUsIHYpO1xuXHRcdHZlcnRleFBvc2l0aW9uRGF0YS5wdXNoKHJhZGl1cyAqIHgsIHJhZGl1cyAqIHksIHJhZGl1cyAqIHopO1xuXG5cdFx0aWYgKGxuZ0lkeCAhPT0gbG9uZ2l0dWRlQmFuZHMgJiYgbGF0SWR4ICE9PSBsYXRpdHVkZUJhbmRzKSB7XG5cdFx0XHRjb25zdCBhID0gbGF0SWR4ICogKGxvbmdpdHVkZUJhbmRzICsgMSkgKyBsbmdJZHg7XG5cdFx0XHRjb25zdCBiID0gYSArIGxvbmdpdHVkZUJhbmRzICsgMTtcblxuXHRcdFx0aW5kZXhEYXRhLnB1c2goYSwgYiwgYSArIDEsIGIsIGIgKyAxLCBhICsgMSk7XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwaGVyZVJlbmRlcmVyIGV4dGVuZHMgUmVuZGVyZXIge1xuXHRzdGF0aWMgX1ZFUlRFWF9QT1NJVElPTl9EQVRBID0gdmVydGV4UG9zaXRpb25EYXRhO1xuXHRzdGF0aWMgX1RFWFRVUkVfQ09PUkRfREFUQSA9IHRleHR1cmVDb29yZERhdGE7XG5cdHN0YXRpYyBfSU5ERVhfREFUQSA9IGluZGV4RGF0YTtcblxuXHRjb25zdHJ1Y3Rvcihjb25maWcpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5faXNTdGVyZW9zY29waWMgPSAoY29uZmlnICYmIGNvbmZpZy5pc1N0ZXJlb3Njb3BpYykgfHwgZmFsc2U7XG5cdH1cblxuXHRnZXRWZXJ0ZXhQb3NpdGlvbkRhdGEoKSB7XG5cdFx0cmV0dXJuIFNwaGVyZVJlbmRlcmVyLl9WRVJURVhfUE9TSVRJT05fREFUQTtcblx0fVxuXG5cdGdldEluZGV4RGF0YSgpIHtcblx0XHRyZXR1cm4gU3BoZXJlUmVuZGVyZXIuX0lOREVYX0RBVEE7XG5cdH1cblxuXHRnZXRUZXh0dXJlQ29vcmREYXRhKCkge1xuXHRcdGlmICh0aGlzLl9pc1N0ZXJlb3Njb3BpYykge1xuXHRcdFx0Ly8gVXNlIHZlcnRpY2FsIGhhbGYgc2l6ZSBvZiBpbWFnZS5cblx0XHRcdHJldHVybiBTcGhlcmVSZW5kZXJlci5fVEVYVFVSRV9DT09SRF9EQVRBLm1hcChcblx0XHRcdFx0KHZhbHVlLCBpbmRleCkgPT4gKGluZGV4ICUgMiA9PT0gMSA/IHZhbHVlIC8gMiA6IHZhbHVlKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gU3BoZXJlUmVuZGVyZXIuX1RFWFRVUkVfQ09PUkRfREFUQTtcblx0fVxuXG5cdGdldFZlcnRleFNoYWRlclNvdXJjZSgpIHtcblx0XHRyZXR1cm4gYFxuXHRcdFx0YXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xuXHRcdFx0YXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcblx0XHRcdHVuaWZvcm0gbWF0NCB1TVZNYXRyaXg7XG5cdFx0XHR1bmlmb3JtIG1hdDQgdVBNYXRyaXg7XG5cdFx0XHR2YXJ5aW5nIGhpZ2hwIHZlYzIgdlRleHR1cmVDb29yZDtcblx0XHRcdHZvaWQgbWFpbih2b2lkKSB7XG5cdFx0XHRcdGdsX1Bvc2l0aW9uID0gdVBNYXRyaXggKiB1TVZNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcblx0XHRcdFx0dlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XG5cdFx0XHR9YDtcblx0fVxuXG5cdGdldEZyYWdtZW50U2hhZGVyU291cmNlKCkge1xuXHRcdHJldHVybiBgXG5cdFx0XHR2YXJ5aW5nIGhpZ2hwIHZlYzIgdlRleHR1cmVDb29yZDtcblx0XHRcdHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuXHRcdFx0dm9pZCBtYWluKHZvaWQpIHtcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKFxuXHRcdFx0XHRcdHVTYW1wbGVyLFxuXHRcdFx0XHRcdHZlYzIodlRleHR1cmVDb29yZC5zLCB2VGV4dHVyZUNvb3JkLnQpXG5cdFx0XHRcdCk7XG5cdFx0XHR9YDtcblx0fVxuXG5cdHVwZGF0ZVRleHR1cmUoZ2wsIGltYWdlKSB7XG5cdFx0V2ViR0xVdGlscy50ZXhJbWFnZTJEKGdsLCBnbC5URVhUVVJFXzJELCB0aGlzLl9nZXRQaXhlbFNvdXJjZShpbWFnZSkpO1xuXHR9XG5cblx0YmluZFRleHR1cmUoZ2wsIHRleHR1cmUsIGltYWdlKSB7XG5cdFx0Ly8gTWFrZSBzdXJlIGltYWdlIGlzbid0IHRvbyBiaWdcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLmdldERpbWVuc2lvbihpbWFnZSk7XG5cdFx0Y29uc3Qgc2l6ZSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuXHRcdGNvbnN0IG1heFNpemUgPSBXZWJHTFV0aWxzLmdldE1heFRleHR1cmVTaXplKGdsKTtcblxuXHRcdGlmIChzaXplID4gbWF4U2l6ZSkge1xuXHRcdFx0dGhpcy5fdHJpZ2dlckVycm9yKGBJbWFnZSB3aWR0aCgke3dpZHRofSkgZXhjZWVkcyBkZXZpY2UgbGltaXQoJHttYXhTaXplfSkpYCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUGl4ZWwgU291cmNlIGZvciBJRTExICYgVmlkZW9cblx0XHR0aGlzLl9pbml0UGl4ZWxTb3VyY2UoaW1hZ2UpO1xuXG5cdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG5cdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG5cblx0XHR0aGlzLnVwZGF0ZVRleHR1cmUoZ2wsIGltYWdlKTtcblx0fVxufVxuIiwiaW1wb3J0IFJlbmRlcmVyIGZyb20gXCIuL1JlbmRlcmVyXCI7XG5pbXBvcnQgV2ViR0xVdGlscyBmcm9tIFwiLi4vV2ViR0xVdGlsc1wiO1xuaW1wb3J0IHtnbE1hdHJpeH0gZnJvbSBcIi4uLy4uL3V0aWxzL21hdGgtdXRpbC5qc1wiO1xuXG4vLyBjb25zdCBsYXRpdHVkZUJhbmRzID0gNjA7XG5jb25zdCBNSU5fQVNQRUNUX1JBVElPX0ZPUl9GVUxMX1BBTk9SQU1BID0gNjtcbmNvbnN0IGxvbmdpdHVkZUJhbmRzID0gNjA7XG5cbmNvbnN0IHRleHR1cmVDb29yZERhdGEgPSBbXTtcbmNvbnN0IHZlcnRleFBvc2l0aW9uRGF0YSA9IFtdO1xuY29uc3QgaW5kZXhEYXRhID0gW107XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN5bGluZGVyUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJlciB7XG5cdHN0YXRpYyBfVkVSVEVYX1BPU0lUSU9OX0RBVEEgPSB2ZXJ0ZXhQb3NpdGlvbkRhdGE7XG5cdHN0YXRpYyBfVEVYVFVSRV9DT09SRF9EQVRBID0gdGV4dHVyZUNvb3JkRGF0YTtcblx0c3RhdGljIF9JTkRFWF9EQVRBID0gaW5kZXhEYXRhO1xuXG5cdGdldFZlcnRleFBvc2l0aW9uRGF0YSgpIHtcblx0XHRyZXR1cm4gQ3lsaW5kZXJSZW5kZXJlci5fVkVSVEVYX1BPU0lUSU9OX0RBVEE7XG5cdH1cblxuXHRnZXRJbmRleERhdGEoKSB7XG5cdFx0cmV0dXJuIEN5bGluZGVyUmVuZGVyZXIuX0lOREVYX0RBVEE7XG5cdH1cblxuXHRnZXRUZXh0dXJlQ29vcmREYXRhKCkge1xuXHRcdHJldHVybiBDeWxpbmRlclJlbmRlcmVyLl9URVhUVVJFX0NPT1JEX0RBVEE7XG5cdH1cblxuXHRnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UoKSB7XG5cdFx0cmV0dXJuIGBcblx0XHRcdGF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcblx0XHRcdGF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG5cdFx0XHR1bmlmb3JtIG1hdDQgdU1WTWF0cml4O1xuXHRcdFx0dW5pZm9ybSBtYXQ0IHVQTWF0cml4O1xuXHRcdFx0dmFyeWluZyBoaWdocCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cdFx0XHR2b2lkIG1haW4odm9pZCkge1xuXHRcdFx0XHRnbF9Qb3NpdGlvbiA9IHVQTWF0cml4ICogdU1WTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24sIDEuMCk7XG5cdFx0XHRcdHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuXHRcdFx0fWA7XG5cdH1cblxuXHRnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpIHtcblx0XHRyZXR1cm4gYFxuXHRcdFx0dmFyeWluZyBoaWdocCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cdFx0XHR1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcblx0XHRcdHZvaWQgbWFpbih2b2lkKSB7XG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRChcblx0XHRcdFx0XHR1U2FtcGxlcixcblx0XHRcdFx0XHR2ZWMyKHZUZXh0dXJlQ29vcmQucywgdlRleHR1cmVDb29yZC50KVxuXHRcdFx0XHQpO1xuXHRcdFx0fWA7XG5cdH1cblxuXHR1cGRhdGVUZXh0dXJlKGdsLCBpbWFnZSkge1xuXHRcdFdlYkdMVXRpbHMudGV4SW1hZ2UyRChnbCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5fZ2V0UGl4ZWxTb3VyY2UoaW1hZ2UpKTtcblx0fVxuXG5cdGJpbmRUZXh0dXJlKGdsLCB0ZXh0dXJlLCBpbWFnZSkge1xuXHRcdC8vIE1ha2Ugc3VyZSBpbWFnZSBpc24ndCB0b28gYmlnXG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy5nZXREaW1lbnNpb24oaW1hZ2UpO1xuXHRcdGNvbnN0IHNpemUgPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcblx0XHRjb25zdCBtYXhTaXplID0gV2ViR0xVdGlscy5nZXRNYXhUZXh0dXJlU2l6ZShnbCk7XG5cdFx0bGV0IHJlc2l6ZURpbWVuc2lvbjtcblxuXHRcdGlmIChzaXplID4gbWF4U2l6ZSkge1xuXHRcdFx0dGhpcy5fdHJpZ2dlckVycm9yKGBJbWFnZSB3aWR0aCgke3dpZHRofSkgZXhjZWVkcyBkZXZpY2UgdGV4dHVyZSBsaW1pdCgke21heFNpemV9KSlgKTtcblxuXHRcdFx0Ly8gUmVxdWVzdCByZXNpemluZyB0ZXh0dXJlLlxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUT0RPOiBJcyBpdCBuZWVkIHRvIGFwcGx5IG9uIGFub3RoZXIgcHJvamVjdGlvbiB0eXBlP1xuXHRcdFx0ICovXG5cdFx0XHRyZXNpemVEaW1lbnNpb24gPSB3aWR0aCA+IGhlaWdodCA/XG5cdFx0XHRcdHt3aWR0aDogbWF4U2l6ZSwgaGVpZ2h0OiBtYXhTaXplICogaGVpZ2h0IC8gd2lkdGh9IDpcblx0XHRcdFx0e3dpZHRoOiBtYXhTaXplICogd2lkdGggLyBoZWlnaHQsIGhlaWdodDogbWF4U2l6ZX07XG5cdFx0fVxuXG5cdFx0Ly8gUGl4ZWwgU291cmNlIGZvciBJRTExICYgVmlkZW8gb3IgcmVzaXppbmcgbmVlZGVkXG5cdFx0dGhpcy5faW5pdFBpeGVsU291cmNlKGltYWdlLCByZXNpemVEaW1lbnNpb24pO1xuXG5cdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG5cdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG5cblx0XHR0aGlzLnVwZGF0ZVRleHR1cmUoZ2wsIGltYWdlKTtcblx0fVxuXG5cdHVwZGF0ZVNoYWRlckRhdGEoe2ltYWdlQXNwZWN0UmF0aW8gPSBNSU5fQVNQRUNUX1JBVElPX0ZPUl9GVUxMX1BBTk9SQU1BfSkge1xuXHRcdGxldCBsbmdJZHg7XG5cdFx0bGV0IGN5bGluZGVyTWF4UmFkaWFuO1xuXHRcdGxldCBoYWxmQ3lsaW5kZXJZO1xuXHRcdGxldCByb3RhdGVkO1xuXHRcdGxldCBhc3BlY3RSYXRpbztcblxuXHRcdC8vIEV4Y2VwdGlvbiBjYXNlOiBvcmllbnRhdGlvbiBpcyByb3RhdGVkLlxuXHRcdGlmIChpbWFnZUFzcGVjdFJhdGlvIDwgMSkge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBJZiByb3RhdGVkIGlzIHRydWUsIHdlIGFzc3VtZSB0aGF0IGltYWdlIGlzIHJvdGF0ZWQgY291bnRlciBjbG9ja3dpc2UuXG5cdFx0XHQgKiBUT0RPOiBJZiB0aGVyZSdzIG90aGVyIHJvdGF0aW9uLCBpdCBpcyBuZWVkIHRvIGltcGxlbWVudCBieSBlYWNoIHJvdGF0aW9uLlxuXHRcdFx0ICovXG5cdFx0XHRyb3RhdGVkID0gdHJ1ZTtcblx0XHRcdGFzcGVjdFJhdGlvID0gMSAvIGltYWdlQXNwZWN0UmF0aW87XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJvdGF0ZWQgPSBmYWxzZTtcblx0XHRcdGFzcGVjdFJhdGlvID0gaW1hZ2VBc3BlY3RSYXRpbztcblx0XHR9XG5cblx0XHRpZiAoYXNwZWN0UmF0aW8gPj0gTUlOX0FTUEVDVF9SQVRJT19GT1JfRlVMTF9QQU5PUkFNQSkge1xuXHRcdFx0Y29uc3QgZm92ID0gMzYwIC8gYXNwZWN0UmF0aW87XG5cblx0XHRcdGN5bGluZGVyTWF4UmFkaWFuID0gMiAqIE1hdGguUEk7IC8vIDM2MCBkZWdcblx0XHRcdGhhbGZDeWxpbmRlclkgPSBNYXRoLnRhbihnbE1hdHJpeC50b1JhZGlhbihmb3YgLyAyKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN5bGluZGVyTWF4UmFkaWFuID0gYXNwZWN0UmF0aW87XG5cdFx0XHRoYWxmQ3lsaW5kZXJZID0gMC41Oy8vIFJhbmdlIG9mIGN5bGluZGVyIGlzIFstMC41LCAwLjVdIHRvIG1ha2UgaGVpZ2h0IHRvIDEuXG5cdFx0fVxuXG5cdFx0Ly8gaW50aWFsaXplIHNoYWRlciBkYXRhIGJlZm9yZSB1cGRhdGVcblx0XHR0ZXh0dXJlQ29vcmREYXRhLmxlbmd0aCA9IDA7XG5cdFx0dmVydGV4UG9zaXRpb25EYXRhLmxlbmd0aCA9IDA7XG5cdFx0aW5kZXhEYXRhLmxlbmd0aCA9IDA7XG5cblx0XHRjb25zdCBDWUxJREVSX1kgPSBbLWhhbGZDeWxpbmRlclksIGhhbGZDeWxpbmRlclldO1xuXHRcdGNvbnN0IHN0YXJ0QW5nbGVGb3JDZW50ZXJBbGlnbiA9IE1hdGguUEkgLyAyICsgKDIgKiBNYXRoLlBJIC0gY3lsaW5kZXJNYXhSYWRpYW4pIC8gMjsgLy8gTWF0aC5QSSAvIDIgc3RhcnQgcG9pbnQgd2hlbiBjeWxpbmRlck1heFJhZGlhbiBpcyAyIHBoaSgzNjApXG5cblx0XHQvLyBjb25zb2xlLmxvZyhcImN5bGluZGVyTWF4UmFkaWFuOlwiLCBnbE1hdHJpeC50b0RlZ3JlZShjeWxpbmRlck1heFJhZGlhbiksIFwiQ1lMSURFUl9ZXCIsIENZTElERVJfWSwgXCJzdGFydCBhbmdsZVwiLCBnbE1hdHJpeC50b0RlZ3JlZShzdGFydEFuZ2xlRm9yQ2VudGVyQWxpZ24pKTtcblx0XHRmb3IgKGxldCB5SWR4ID0gMCwgeUxlbmd0aCA9IENZTElERVJfWS5sZW5ndGg7IHlJZHggPCB5TGVuZ3RoLyogYm90dG9tICYgdG9wICovOyB5SWR4KyspIHtcblx0XHRcdGZvciAobG5nSWR4ID0gMDsgbG5nSWR4IDw9IGxvbmdpdHVkZUJhbmRzOyBsbmdJZHgrKykge1xuXHRcdFx0XHRjb25zdCBhbmdsZSA9IHN0YXJ0QW5nbGVGb3JDZW50ZXJBbGlnbiArIChsbmdJZHggLyBsb25naXR1ZGVCYW5kcyAqIGN5bGluZGVyTWF4UmFkaWFuKTtcblx0XHRcdFx0Y29uc3QgeCA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRcdFx0Y29uc3QgeSA9IENZTElERVJfWVt5SWR4XTtcblx0XHRcdFx0Y29uc3QgeiA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHRcdFx0bGV0IHU7XG5cdFx0XHRcdGxldCB2O1xuXG5cdFx0XHRcdGlmIChyb3RhdGVkKSB7XG5cdFx0XHRcdFx0Ly8gUm90YXRlZCA5MCBkZWdyZWUgKGNvdW50ZXIgY2xvY2sgd2lzZSlcblx0XHRcdFx0XHR1ID0gMSAtIHlJZHg7IC8vIHlMZW5ndGggLSB5SWR4O1xuXHRcdFx0XHRcdHYgPSBsbmdJZHggLyBsb25naXR1ZGVCYW5kcztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gXHQvLyBOb3JtYWwgY2FzZSAoTm90IHJvdGF0ZWQpXG5cdFx0XHRcdFx0dSA9IGxuZ0lkeCAvIGxvbmdpdHVkZUJhbmRzO1xuXHRcdFx0XHRcdHYgPSB5SWR4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dHVyZUNvb3JkRGF0YS5wdXNoKHUsIHYpO1xuXHRcdFx0XHR2ZXJ0ZXhQb3NpdGlvbkRhdGEucHVzaCh4LCB5LCB6KTtcblxuXHRcdFx0XHRpZiAoeUlkeCA9PT0gMCAmJiBsbmdJZHggPCBsb25naXR1ZGVCYW5kcykge1xuXHRcdFx0XHRcdGNvbnN0IGEgPSBsbmdJZHg7XG5cdFx0XHRcdFx0Y29uc3QgYiA9IGEgKyBsb25naXR1ZGVCYW5kcyArIDE7XG5cblx0XHRcdFx0XHRpbmRleERhdGEucHVzaChhLCBiLCBhICsgMSwgYiwgYiArIDEsIGEgKyAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuIiwiLyoqXG4gKiBDb25zdGFudCB2YWx1ZSBmb3IgZ3lybyBtb2RlLiA8YnI+KFJlZmVyZW5jZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtdmlldzM2MC93aWtpL1Bhbm9WaWV3ZXItMy4wLVVzZXItR3VpZGV9KVxuICogQGtvIGd5cm8g66qo65OcIOuMgO2VnCDsg4HsiJgg6rCSLiA8YnI+KHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy12aWV3MzYwL3dpa2kvUGFub1ZpZXdlci0zLjAtVXNlci1HdWlkZX0g7LC46rOgKVxuICogQG5hbWVzcGFjZVxuICogQG5hbWUgR1lST19NT0RFXG4gKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyXG4gKi9cbi8qKlxuICogRGlzYWJsZSBneXJvXG4gKiBAa28gZ3lybyDruYTtmZzshLHtmZRcbiAqIEBuYW1lIE5PTkVcbiAqIEBtZW1iZXJvZiBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuR1lST19NT0RFXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdCBcIm5vbmVcIlxuICovXG4vKipcbiAqIFlhd1BpdGNoIE1vZGVcbiAqIEBrbyBZYXdQaXRjaCBNb2RlXG4gKiBAbmFtZSBZQVdQSVRDSFxuICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlci5HWVJPX01PREVcbiAqIEBjb25zdGFudFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0IFwieWF3UGl0Y2hcIlxuICovXG4vKipcbiAqIFZSIE1vZGVcbiAqIEBrbyBWUiBNb2RlXG4gKiBAbmFtZSBWUlxuICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlci5HWVJPX01PREVcbiAqIEBjb25zdGFudFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0IFwiVlJcIlxuICovXG5pbXBvcnQge0dZUk9fTU9ERX0gZnJvbSBcIi4uL1lhd1BpdGNoQ29udHJvbC9jb25zdHNcIjtcblxuLyoqXG4gKiBDb25zdGFudCB2YWx1ZSBmb3IgZXJyb3JzXG4gKiBAa28g7JeQ65+s7JeQIOuMgO2VnCDsg4HsiJgg6rCSXG4gKiBAbmFtZXNwYWNlXG4gKiBAbmFtZSBFUlJPUl9UWVBFXG4gKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyXG4gKi9cbmNvbnN0IEVSUk9SX1RZUEUgPSB7XG5cdC8qKlxuXHQgKiBVbnN1cHBvcnRlZCBkZXZpY2Vcblx0ICogQGtvIOuvuOyngOybkCDquLDquLBcblx0ICogQG5hbWUgSU5WQUxJRF9ERVZJQ0Vcblx0ICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlci5FUlJPUl9UWVBFXG5cdCAqIEBjb25zdGFudFxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAxMFxuXHQgKi9cblx0SU5WQUxJRF9ERVZJQ0U6IDEwLFxuXHQvKipcblx0ICogV2ViZ2wgbm90IHN1cHBvcnRcblx0ICogQGtvIFdFQkdMIOuvuOyngOybkFxuXHQgKiBAbmFtZSBOT19XRUJHTFxuXHQgKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyLkVSUk9SX1RZUEVcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDExXG5cdCAqL1xuXHROT19XRUJHTDogMTEsXG5cdC8qKlxuXHQgKiBGYWlsZWQgdG8gbG9hZCBpbWFnZVxuXHQgKiBAa28g7J2066+47KeAIOuhnOuTnCDsi6TtjKhcblx0ICogQG5hbWUgRkFJTF9JTUFHRV9MT0FEXG5cdCAqIEBtZW1iZXJvZiBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuRVJST1JfVFlQRVxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgMTJcblx0ICovXG5cdEZBSUxfSU1BR0VfTE9BRDogMTIsXG5cdC8qKlxuXHQgKiBGYWlsZWQgdG8gYmluZCB0ZXh0dXJlXG5cdCAqIEBrbyDthY3siqTss5Ag67CU7J2465SpIOyLpO2MqFxuXHQgKiBAbmFtZSBGQUlMX0JJTkRfVEVYVFVSRVxuXHQgKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyLkVSUk9SX1RZUEVcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDEzXG5cdCAqL1xuXHRGQUlMX0JJTkRfVEVYVFVSRTogMTMsXG5cdC8qKlxuXHQgKiBPbmx5IG9uZSByZXNvdXJjZShpbWFnZSBvciB2aWRlbykgc2hvdWxkIGJlIHNwZWNpZmllZFxuXHQgKiBAa28g66as7IaM7IqkIOyngOyglSDsmKTrpZggKGltYWdlIO2YueydgCB2aWRlbyDspJEg7ZWY64KY66eMIOyngOygleuQmOyWtOyVvCDtlagpXG5cdCAqIEBuYW1lIElOVkFMSURfUkVTT1VSQ0Vcblx0ICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlci5FUlJPUl9UWVBFXG5cdCAqIEBjb25zdGFudFxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAxNFxuXHQgKi9cblx0SU5WQUxJRF9SRVNPVVJDRTogMTQsXG5cdC8qKlxuXHQgKiBXZWJHTCBjb250ZXh0IGxvc3Qgb2NjdXJyZWRcblx0ICogQGtvIFdlYkdMIGNvbnRleHQgbG9zdCDrsJzsg51cblx0ICogQG5hbWUgUkVOREVSSU5HX0NPTlRFWFRfTE9TVFxuXHQgKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyLkVSUk9SX1RZUEVcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDE1XG5cdCAqL1xuXHRSRU5ERVJJTkdfQ09OVEVYVF9MT1NUOiAxNVxufTtcblxuLyoqXG4gKiBDb25zdGFudCB2YWx1ZSBmb3IgZXZlbnRzXG4gKiBAa28g7J2067Kk7Yq47JeQIOuMgO2VnCDsg4HsiJgg6rCSXG4gKiBAbmFtZXNwYWNlXG4gKiBAbmFtZSBFVkVOVFNcbiAqIEBtZW1iZXJvZiBlZy52aWV3MzYwLlBhbm9WaWV3ZXJcbiAqL1xuY29uc3QgRVZFTlRTID0ge1xuXHQvKipcblx0ICogRXZlbnRzIHRoYXQgaXMgZmlyZWQgd2hlbiBQYW5vVmlld2VyIGlzIHJlYWR5IHRvIHNob3cgaW1hZ2UgYW5kIGhhbmRsZSB1c2VyIGludGVyYWN0aW9uLlxuXHQgKiBAa28gUGFub1ZpZXdlciDqsIAg7IKs7Jqp7J6Q7J2YIOyduO2EsOugieyFmCDrsI8g66CM642U66eB7J20IOykgOu5hOuQmOyDge2DnOyXkCDrsJzsg53tlZjripQg7J2067Kk7Yq4XG5cdCAqIEBuYW1lIFJFQURZXG5cdCAqIEBtZW1iZXJvZiBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuRVZFTlRTXG5cdCAqIEBjb25zdGFudFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCByZWFkeVxuXHQgKi9cblx0UkVBRFk6IFwicmVhZHlcIixcblx0LyoqXG5cdCAqIEV2ZW50cyB0aGF0IGlzIGZpcmVkIHdoZW4gZGlyZWN0aW9uIG9yIGZvdiBpcyBjaGFuZ2VkLlxuXHQgKiBAa28gUGFub1ZpZXdlciDsl5DshJwg67CU652867O06rOgIOyeiOuKlCDrsKntlqXsnbTrgpggRk9WKO2ZlOqwgSnqsIAg67OA6rK965CY7JeI7J2E65WMIOuwnOyDne2VmOuKlCDsnbTrsqTtirhcblx0ICogQG5hbWUgVklFV19DSEFOR0Vcblx0ICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlci5FVkVOVFNcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHZpZXdDaGFuZ2Vcblx0ICovXG5cdFZJRVdfQ0hBTkdFOiBcInZpZXdDaGFuZ2VcIixcblx0LyoqXG5cdCAqIEV2ZW50cyB0aGF0IGlzIGZpcmVkIHdoZW4gYW5pbWF0aW9uIHdoaWNoIGlzIHRyaWdnZXJlZCBieSBpbmVydGlhIGlzIGVuZGVkLlxuXHQgKiBAa28g6rSA7ISx7JeQIOydmO2VnCDslaDri4jrqZTsnbTshZgg64+Z7J6R7J20IOyZhOujjOuQmOyXiOydhOuVjCDrsJzsg53tlZjripQg7J2067Kk7Yq4XG5cdCAqIEBuYW1lIEFOSU1BVElPTl9FTkRcblx0ICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlci5FVkVOVFNcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGFuaW1hdGlvbkVuZFxuXHQgKi9cblx0QU5JTUFUSU9OX0VORDogXCJhbmltYXRpb25FbmRcIixcblx0LyoqXG5cdCAqIEV2ZW50cyB0aGF0IGlzIGZpcmVkIHdoZW4gZXJyb3Igb2NjdXJzXG5cdCAqIEBrbyDsl5Drn6wg67Cc7IOdIOyLnCDrsJzsg53tlZjripQg7J2067Kk7Yq4XG5cdCAqIEBuYW1lIEVSUk9SXG5cdCAqIEBtZW1iZXJvZiBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuRVZFTlRTXG5cdCAqIEBjb25zdGFudFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBlcnJvclxuXHQgKi9cblx0RVJST1I6IFwiZXJyb3JcIlxufTtcblxuLyoqXG4gKiBDb25zdGFudCB2YWx1ZSBmb3IgcHJvamVjdGlvbiB0eXBlXG4gKiBAa28g7ZSE66Gc7KCd7IWYIO2DgOyehSDrjIDtlZwg7IOB7IiYIOqwklxuICogQG5hbWVzcGFjZVxuICogQG5hbWUgUFJPSkVDVElPTl9UWVBFXG4gKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyXG4gKi9cbmNvbnN0IFBST0pFQ1RJT05fVFlQRSA9IHtcblx0LyoqXG5cdCAqIENvbnN0YW50IHZhbHVlIGZvciBlcXVpcmVjdGFuZ3VsYXIgdHlwZS5cblx0ICogQGtvIGVxdWlyZWN0YW5ndWxhciDsl5Ag64yA7ZWcIOyDgeyImCDqsJIuXG5cdCAqIEBuYW1lIEVRVUlSRUNUQU5HVUxBUlxuXHQgKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyLlBST0pFQ1RJT05fVFlQRVxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgZXF1aXJlY3Rhbmd1bGFyXG5cdCAqL1xuXHRFUVVJUkVDVEFOR1VMQVI6IFwiZXF1aXJlY3Rhbmd1bGFyXCIsXG5cdC8qKlxuXHQgKiBDb25zdGFudCB2YWx1ZSBmb3IgY3ViZW1hcCB0eXBlLlxuXHQgKiBAa28gY3ViZW1hcCDsl5Ag64yA7ZWcIOyDgeyImCDqsJIuXG5cdCAqIEBuYW1lIENVQkVNQVBcblx0ICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlci5QUk9KRUNUSU9OX1RZUEVcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGN1YmVtYXBcblx0ICovXG5cdENVQkVNQVA6IFwiY3ViZW1hcFwiLFxuXHQvKipcblx0ICogQ29uc3RhbnQgdmFsdWUgZm9yIGN1YmVzdHJpcCB0eXBlLlxuXHQgKiBDdWJlc3RyaXAgaXMgYSBmb3JtYXQgZm9yIGEgc2luZ2xlIGltYWdlIHdpdGggYSBjb21iaW5hdGlvbiBvZiBzaXggY3ViZSBmYWNlcy4gSXQgaXMgYWxtb3N0IGlkZW50aWNhbCB0byBjdWJlbWFwLCBidXQgaXQgaXMgaW1wbGVtZW50ZWQgaW4gYSBkaWZmZXJlbnQgd2F5LiBJdCBhaW1zIGF0IGJldHRlciBwZXJmb3JtYW5jZSBhbmQgZWZmaWNpZW5jeS4gSW4gYWRkaXRpb24sIGl0IGF1dG9tYXRpY2FsbHkgZGV0ZWN0cyBhbmQgc3VwcG9ydHMgRUFDLlxuXHQgKlxuXHQgKiBAa28gY3ViZW1hcCDsl5Ag64yA7ZWcIOyDgeyImCDqsJIuQ3ViZXN0cmlwIOydgCBjdWJlIOuptOydtCA26rCc6rCAIOyhsO2VqeuQnCDsobDtlansnYQg7ZWc7J6l7J2YIOydtOuvuOyngOulvCDsnITtlZwg7Y+s66e37J2064ukLiBjdWJlbWFwIOqzvCDsgqzsmqnrsKnrspXsnbQg6rGw7J2YIOuPmeydvO2VmOyngOunjCDri6Trpbgg67Cp7Iud7Jy866GcIOq1rO2YhOuQmOyXiOuLpC4g67O064ukIOyii+ydgCDshLHriqXqs7wg7Zqo7Jyo7ISx7J2EIOuqqeyggeycvOuhnCDtlZzri6QuIOuNlOu2iOyWtCDsnpDrj5nsnLzroZwgRUFDIOulvCDqsJDsp4DtlZjqs6Ag7KeA7JuQ7ZWc64ukLlxuXHQgKiBAbmFtZSBDVUJFU1RSSVBcblx0ICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlci5QUk9KRUNUSU9OX1RZUEVcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGN1YmVzdHJpcFxuXHQgKi9cblx0Q1VCRVNUUklQOiBcImN1YmVzdHJpcFwiLFxuXHQvKipcblx0ICogQ29uc3RhbnQgdmFsdWUgZm9yIFBBTk9SQU1BIHR5cGUuXG5cdCAqXG5cdCAqIFBBTk9SQU1BIGlzIGEgZm9ybWF0IGZvciBhIHBhbm9ybWEgaW1hZ2Ugd2hpY2ggaXMgdGFrZW4gZnJvbSBzbWFydHBob25lLlxuXHQgKlxuXHQgKiBAa28gUEFOT1JBTUEg7JeQIOuMgO2VnCDsg4HsiJjqsJIuIO2MjOuFuOudvOuniOuKlCDsiqTrp4jtirgg7Y+w7JeQ7IScIOqwgOyguOyYqCDtjIzrhbjrnbzrp4gg7J2066+47KeA7J2YIO2YleyLneyeheuLiOuLpC5cblx0ICpcblx0ICogQG5hbWUgUEFOT1JBTUFcblx0ICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlci5QUk9KRUNUSU9OX1RZUEVcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHBhbm9yYW1hXG5cdCAqL1xuXHRQQU5PUkFNQTogXCJwYW5vcmFtYVwiLFxuXHQvKipcblx0ICogQ29uc3RhbnQgdmFsdWUgZm9yIEVRVUlfU1RFUkVPU0NPUFkgdHlwZS5cblx0ICpcblx0ICogQ29uc3RhbnQgdmFsdWUgZm9yIEVRVUlfU1RFUkVPU0NPUFkuIFN0ZXJlb3Njb3B5IGltYWdlIGZvcm1hdCBvZiBFUVVJUkVDVEFOR1VMQVIuIEl0IGlzIGFuIGV4cGVyaW1lbnRhbCBmdW5jdGlvbiB0byBzaG93IGEgc3RlcmVvc2NvcGljIHR5cGUgZXF1aXJlY3Rhbmd1bGFyIGltYWdlIG9uIGEgcGxhbmUuIEl0IGRvZXMgbm90IHN1cHBvcnQgc3RlcmVvc2NvcGljIHZpZXdpbmcgZnVuY3Rpb24gdGhyb3VnaCBzcGVjaWFsIHZpc3VhbCBlcXVpcG1lbnQgYXQgcHJlc2VudC5cblx0ICpcblx0ICogQGtvIEVRVUlfU1RFUkVPU0NPUFkg7JeQIOuMgO2VnCDsg4HsiJjqsJIuIEVRVUlSRUNUQU5HVUxBUiDsnZggU3RlcmVvc2NvcHkg7J2066+47KeAIO2YleyLneyeheuLiOuLpC4gU3RlcmVvc2NvcGljIO2Yle2DnOydmCBlcXVpcmVjdGFuZ3VsYXIg7J2066+47KeA66W8IO2PieuptOyXkCDrs7Tsl6zso7zquLAg7JyE7ZWcIOyLpO2XmOyggeyduCDquLDriqXsnLzroZwg7ZiE7J6s64qUIO2KueyImO2VnCDsi5zqsIEg7J6l67mE66W8IO2Gte2VnCDsnoXssrTsoIHsnbgg67O06riwIOq4sOuKpeydgCDsp4Dsm5DtlZjsp4Ag7JWK7Iq164uI64ukLlxuXHQgKlxuXHQgKiBAbmFtZSBTVEVSRU9TQ09QSUNfRVFVSVxuXHQgKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyLlBST0pFQ1RJT05fVFlQRVxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgc3RlcmVvZXF1aVxuXHQgKi9cblx0U1RFUkVPU0NPUElDX0VRVUk6IFwic3RlcmVvZXF1aVwiLFxufTtcblxuZXhwb3J0IHtcblx0R1lST19NT0RFLFxuXHRFVkVOVFMsXG5cdEVSUk9SX1RZUEUsXG5cdFBST0pFQ1RJT05fVFlQRVxufTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIkBlZ2pzL2NvbXBvbmVudFwiO1xuaW1wb3J0IEltYWdlTG9hZGVyIGZyb20gXCIuL0ltYWdlTG9hZGVyXCI7XG5pbXBvcnQgVmlkZW9Mb2FkZXIgZnJvbSBcIi4vVmlkZW9Mb2FkZXJcIjtcbmltcG9ydCBXZWJHTFV0aWxzIGZyb20gXCIuL1dlYkdMVXRpbHNcIjtcbmltcG9ydCBDdWJlUmVuZGVyZXIgZnJvbSBcIi4vcmVuZGVyZXIvQ3ViZVJlbmRlcmVyXCI7XG5pbXBvcnQgQ3ViZVN0cmlwUmVuZGVyZXIgZnJvbSBcIi4vcmVuZGVyZXIvQ3ViZVN0cmlwUmVuZGVyZXJcIjtcbmltcG9ydCBTcGhlcmVSZW5kZXJlciBmcm9tIFwiLi9yZW5kZXJlci9TcGhlcmVSZW5kZXJlclwiO1xuaW1wb3J0IEN5bGluZGVyUmVuZGVyZXIgZnJvbSBcIi4vcmVuZGVyZXIvQ3lsaW5kZXJSZW5kZXJlclwiO1xuaW1wb3J0IHtnbE1hdHJpeCwgbWF0NCwgcXVhdH0gZnJvbSBcIi4uL3V0aWxzL21hdGgtdXRpbC5qc1wiO1xuaW1wb3J0IHtkZXZpY2VQaXhlbFJhdGlvfSBmcm9tIFwiLi4vdXRpbHMvYnJvd3NlckZlYXR1cmVcIjtcbmltcG9ydCB7UFJPSkVDVElPTl9UWVBFfSBmcm9tIFwiLi4vUGFub1ZpZXdlci9jb25zdHNcIjtcbmltcG9ydCBSZW5kZXJlciBmcm9tIFwiLi9yZW5kZXJlci9SZW5kZXJlclwiO1xuXG5jb25zdCBJbWFnZVR5cGUgPSBQUk9KRUNUSU9OX1RZUEU7XG5cbmxldCBERVZJQ0VfUElYRUxfUkFUSU8gPSBkZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cbi8vIERFVklDRV9QSVhFTF9SQVRJTyDqsIAgMuulvCDstIjqs7ztlZjripQg6rK97Jqw64qUIOumrOyGjOyKpCDrgq3ruYTsnbTrr4DroZwgMuuhnCDrp57stpjri6QuXG5pZiAoREVWSUNFX1BJWEVMX1JBVElPID4gMikge1xuXHRERVZJQ0VfUElYRUxfUkFUSU8gPSAyO1xufVxuXG4vLyBkZWZpbmUgY3VzdG9tIGV2ZW50cyBuYW1lXG4vKipcbiAqIFRPRE86IGhvdyB0byBtYW5hZ2UgZXZlbnRzL2Vycm9ydHlwZSB3aXRoIFBhbm9WaWV3ZXJcbiAqXG4gKiBJIHRoaW5rIHJlbmRlcmVyIGV2ZW50cyBzaG91bGQgYmUgc2VwZXJhdGVkIGZyb20gdmlld2VyIGV2ZW50cyBhbHRob3VnaCBpdCBoYXMgc2FtZSBuYW1lLlxuICovXG5jb25zdCBFVkVOVFMgPSB7XG5cdEJJTkRfVEVYVFVSRTogXCJiaW5kVGV4dHVyZVwiLFxuXHRJTUFHRV9MT0FERUQ6IFwiaW1hZ2VMb2FkZWRcIixcblx0RVJST1I6IFwiZXJyb3JcIixcblx0UkVOREVSSU5HX0NPTlRFWFRfTE9TVDogXCJyZW5kZXJpbmdDb250ZXh0TG9zdFwiLFxuXHRSRU5ERVJJTkdfQ09OVEVYVF9SRVNUT1JFOiBcInJlbmRlcmluZ0NvbnRleHRSZXN0b3JlXCIsXG59O1xuXG5jb25zdCBFUlJPUl9UWVBFID0ge1xuXHRJTlZBTElEX0RFVklDRTogMTAsXG5cdE5PX1dFQkdMOiAxMSxcblx0RkFJTF9JTUFHRV9MT0FEOiAxMixcblx0UkVOREVSRVJfRVJST1I6IDEzXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYW5vSW1hZ2VSZW5kZXJlciBleHRlbmRzIENvbXBvbmVudCB7XG5cdHN0YXRpYyBFVkVOVFMgPSBFVkVOVFM7XG5cdHN0YXRpYyBFUlJPUl9UWVBFID0gRVJST1JfVFlQRTtcblx0Y29uc3RydWN0b3IoaW1hZ2UsIHdpZHRoLCBoZWlnaHQsIGlzVmlkZW8sIHNwaGVyaWNhbENvbmZpZywgcmVuZGVyaW5nQ29udGV4dEF0dHJpYnV0ZXMpIHtcblx0XHQvLyBTdXBlciBjb25zdHJ1Y3RvclxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnNwaGVyaWNhbENvbmZpZyA9IHNwaGVyaWNhbENvbmZpZztcblx0XHR0aGlzLmZpZWxkT2ZWaWV3ID0gc3BoZXJpY2FsQ29uZmlnLmZpZWxkT2ZWaWV3O1xuXG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdFx0dGhpcy5fbGFzdFF1YXRlcm5pb24gPSBudWxsO1xuXHRcdHRoaXMuX2xhc3RZYXcgPSBudWxsO1xuXHRcdHRoaXMuX2xhc3RQaXRjaCA9IG51bGw7XG5cdFx0dGhpcy5fbGFzdEZpZWxkT2ZWaWV3ID0gbnVsbDtcblxuXHRcdHRoaXMucE1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cdFx0dGhpcy5tdk1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cblx0XHQvLyBpbml0aWFsemllIHBNYXRyaXhcblx0XHRtYXQ0LnBlcnNwZWN0aXZlKHRoaXMucE1hdHJpeCwgZ2xNYXRyaXgudG9SYWRpYW4odGhpcy5maWVsZE9mVmlldyksIHdpZHRoIC8gaGVpZ2h0LCAwLjEsIDEwMCk7XG5cblx0XHR0aGlzLnRleHR1cmVDb29yZEJ1ZmZlciA9IG51bGw7XG5cdFx0dGhpcy52ZXJ0ZXhCdWZmZXIgPSBudWxsO1xuXHRcdHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuXHRcdHRoaXMuY2FudmFzID0gdGhpcy5faW5pdENhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcblx0XHR0aGlzLl9yZW5kZXJpbmdDb250ZXh0QXR0cmlidXRlcyA9IHJlbmRlcmluZ0NvbnRleHRBdHRyaWJ1dGVzO1xuXHRcdHRoaXMuX2ltYWdlID0gbnVsbDtcblx0XHR0aGlzLl9pbWFnZUNvbmZpZyA9IG51bGw7XG5cdFx0dGhpcy5faW1hZ2VJc1JlYWR5ID0gZmFsc2U7XG5cdFx0dGhpcy5fc2hvdWxkRm9yY2VEcmF3ID0gZmFsc2U7XG5cdFx0dGhpcy5fa2VlcFVwZGF0ZSA9IGZhbHNlOyAvLyBGbGFnIHRvIHNwZWNpZnkgJ2NvbnRpbnVvdXMgdXBkYXRlJyBvbiB2aWRlbyBldmVuIHdoZW4gc3RpbGwuXG5cblx0XHR0aGlzLl9vbkNvbnRlbnRMb2FkID0gXHR0aGlzLl9vbkNvbnRlbnRMb2FkLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5fb25Db250ZW50RXJyb3IgPSBcdHRoaXMuX29uQ29udGVudEVycm9yLmJpbmQodGhpcyk7XG5cblx0XHRpZiAoaW1hZ2UpIHtcblx0XHRcdHRoaXMuc2V0SW1hZ2Uoe1xuXHRcdFx0XHRpbWFnZSxcblx0XHRcdFx0aW1hZ2VUeXBlOiBzcGhlcmljYWxDb25maWcuaW1hZ2VUeXBlLFxuXHRcdFx0XHRpc1ZpZGVvLFxuXHRcdFx0XHRjdWJlbWFwQ29uZmlnOiBzcGhlcmljYWxDb25maWcuY3ViZW1hcENvbmZpZ1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0Q29udGVudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2U7XG5cdH1cblxuXHRzZXRJbWFnZSh7aW1hZ2UsIGltYWdlVHlwZSwgaXNWaWRlbyA9IGZhbHNlLCBjdWJlbWFwQ29uZmlnfSkge1xuXHRcdHRoaXMuX2ltYWdlSXNSZWFkeSA9IGZhbHNlO1xuXHRcdHRoaXMuX2lzVmlkZW8gPSBpc1ZpZGVvO1xuXHRcdHRoaXMuX2ltYWdlQ29uZmlnID0gT2JqZWN0LmFzc2lnbihcblx0XHRcdHtcblx0XHRcdFx0LyogUkxVREJGIGlzIGFibm9ybWFsLCB3ZSB1c2UgaXQgb24gQ1VCRU1BUCBvbmx5ICovXG5cdFx0XHRcdG9yZGVyOiAoaW1hZ2VUeXBlID09PSBJbWFnZVR5cGUuQ1VCRU1BUCkgPyBcIlJMVURCRlwiIDogXCJSTFVERkJcIixcblx0XHRcdFx0dGlsZUNvbmZpZzoge1xuXHRcdFx0XHRcdGZsaXBIaXJvem9udGFsOiBmYWxzZSxcblx0XHRcdFx0XHRyb3RhdGlvbjogMFxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Y3ViZW1hcENvbmZpZ1xuXHRcdCk7XG5cdFx0dGhpcy5fc2V0SW1hZ2VUeXBlKGltYWdlVHlwZSk7XG5cblx0XHRpZiAodGhpcy5fY29udGVudExvYWRlcikge1xuXHRcdFx0dGhpcy5fY29udGVudExvYWRlci5kZXN0cm95KCk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzVmlkZW8pIHtcblx0XHRcdHRoaXMuX2NvbnRlbnRMb2FkZXIgPSBuZXcgVmlkZW9Mb2FkZXIoKTtcblx0XHRcdHRoaXMuX2tlZXBVcGRhdGUgPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jb250ZW50TG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKCk7XG5cdFx0XHR0aGlzLl9rZWVwVXBkYXRlID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaW1nIGVsZW1lbnQgb3IgaW1nIHVybFxuXHRcdHRoaXMuX2NvbnRlbnRMb2FkZXIuc2V0KGltYWdlKTtcblxuXHRcdC8vIOydtOuvuOyngOydmCDsgqzsnbTspojrpbwg7LqQ7Iuc7ZWc64ukLlxuXHRcdC8vIGltYWdlIGlzIHJlZmVyZW5jZSBmb3IgY29udGVudCBpbiBjb250ZW50TG9hZGVyLCBzbyBpdCBtYXkgYmUgbm90IHZhbGlkIGlmIGNvbnRlbnRMb2FkZXIgaXMgZGVzdHJveWVkLlxuXHRcdHRoaXMuX2ltYWdlID0gdGhpcy5fY29udGVudExvYWRlci5nZXRFbGVtZW50KCk7XG5cblx0XHRyZXR1cm4gdGhpcy5fY29udGVudExvYWRlci5nZXQoKVxuXHRcdFx0LnRoZW4odGhpcy5fb25Db250ZW50TG9hZCwgdGhpcy5fb25Db250ZW50RXJyb3IpXG5cdFx0XHQuY2F0Y2goZSA9PiBzZXRUaW1lb3V0KCgpID0+IHsgdGhyb3cgZTsgfSkpOy8vIFByZXZlbnQgZXhjZXB0aW9ucyBmcm9tIGJlaW5nIGlzb2xhdGVkIGluIHByb21pc2UgY2hhaW4uXG5cdH1cblxuXHRfc2V0SW1hZ2VUeXBlKGltYWdlVHlwZSkge1xuXHRcdGlmICghaW1hZ2VUeXBlIHx8IHRoaXMuX2ltYWdlVHlwZSA9PT0gaW1hZ2VUeXBlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5faW1hZ2VUeXBlID0gaW1hZ2VUeXBlO1xuXHRcdHRoaXMuX2lzQ3ViZU1hcCA9IGltYWdlVHlwZSA9PT0gSW1hZ2VUeXBlLkNVQkVNQVA7XG5cblx0XHRpZiAodGhpcy5fcmVuZGVyZXIpIHtcblx0XHRcdHRoaXMuX3JlbmRlcmVyLm9mZigpO1xuXHRcdH1cblxuXHRcdHN3aXRjaCAoaW1hZ2VUeXBlKSB7XG5cdFx0XHRjYXNlIEltYWdlVHlwZS5DVUJFTUFQOlxuXHRcdFx0XHR0aGlzLl9yZW5kZXJlciA9IG5ldyBDdWJlUmVuZGVyZXIoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIEltYWdlVHlwZS5DVUJFU1RSSVA6XG5cdFx0XHRcdHRoaXMuX3JlbmRlcmVyID0gbmV3IEN1YmVTdHJpcFJlbmRlcmVyKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBJbWFnZVR5cGUuUEFOT1JBTUE6XG5cdFx0XHRcdHRoaXMuX3JlbmRlcmVyID0gbmV3IEN5bGluZGVyUmVuZGVyZXIoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIEltYWdlVHlwZS5TVEVSRU9TQ09QSUNfRVFVSTpcblx0XHRcdFx0dGhpcy5fcmVuZGVyZXIgPSBuZXcgU3BoZXJlUmVuZGVyZXIoe2lzU3RlcmVvc2NvcGljOiB0cnVlfSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhpcy5fcmVuZGVyZXIgPSBuZXcgU3BoZXJlUmVuZGVyZXIoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmVuZGVyZXIub24oUmVuZGVyZXIuRVZFTlRTLkVSUk9SLCBlID0+IHtcblx0XHRcdHRoaXMudHJpZ2dlcihFVkVOVFMuRVJST1IsIHtcblx0XHRcdFx0dHlwZTogRVJST1JfVFlQRS5SRU5ERVJFUl9FUlJPUixcblx0XHRcdFx0bWVzc2FnZTogZS5tZXNzYWdlXG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX2luaXRXZWJHTCgpO1xuXHR9XG5cblx0X2luaXRDYW52YXMod2lkdGgsIGhlaWdodCkge1xuXHRcdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cblx0XHRjYW52YXMud2lkdGggPSB3aWR0aDtcblx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdGNhbnZhcy5zdHlsZS5ib3R0b20gPSAwO1xuXHRcdGNhbnZhcy5zdHlsZS5sZWZ0ID0gMDtcblx0XHRjYW52YXMuc3R5bGUucmlnaHQgPSAwO1xuXHRcdGNhbnZhcy5zdHlsZS50b3AgPSAwO1xuXHRcdGNhbnZhcy5zdHlsZS5tYXJnaW4gPSBcImF1dG9cIjtcblx0XHRjYW52YXMuc3R5bGUubWF4SGVpZ2h0ID0gXCIxMDAlXCI7XG5cdFx0Y2FudmFzLnN0eWxlLm1heFdpZHRoID0gXCIxMDAlXCI7XG5cdFx0Y2FudmFzLnN0eWxlLm91dGxpbmUgPSBcIm5vbmVcIjtcblx0XHRjYW52YXMuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cblx0XHR0aGlzLl9vbldlYmdsY29udGV4dGxvc3QgPSB0aGlzLl9vbldlYmdsY29udGV4dGxvc3QuYmluZCh0aGlzKTtcblx0XHR0aGlzLl9vbldlYmdsY29udGV4dHJlc3RvcmVkID0gdGhpcy5fb25XZWJnbGNvbnRleHRyZXN0b3JlZC5iaW5kKHRoaXMpO1xuXG5cdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsIHRoaXMuX29uV2ViZ2xjb250ZXh0bG9zdCk7XG5cdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRyZXN0b3JlZFwiLCB0aGlzLl9vbldlYmdsY29udGV4dHJlc3RvcmVkKTtcblxuXHRcdHJldHVybiBjYW52YXM7XG5cdH1cblxuXHRfb25Db250ZW50RXJyb3IoZXJyb3IpIHtcblx0XHR0aGlzLl9pbWFnZUlzUmVhZHkgPSBmYWxzZTtcblx0XHR0aGlzLl9pbWFnZSA9IG51bGw7XG5cdFx0dGhpcy50cmlnZ2VyKEVWRU5UUy5FUlJPUiwge1xuXHRcdFx0dHlwZTogRVJST1JfVFlQRS5GQUlMX0lNQUdFX0xPQUQsXG5cdFx0XHRtZXNzYWdlOiBcImZhaWxlZCB0byBsb2FkIGltYWdlXCJcblx0XHR9KTtcblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdF90cmlnZ2VyQ29udGVudExvYWQoKSB7XG5cdFx0dGhpcy50cmlnZ2VyKEVWRU5UUy5JTUFHRV9MT0FERUQsIHtcblx0XHRcdGNvbnRlbnQ6IHRoaXMuX2ltYWdlLFxuXHRcdFx0aXNWaWRlbzogdGhpcy5faXNWaWRlbyxcblx0XHRcdHByb2plY3Rpb25UeXBlOiB0aGlzLl9pbWFnZVR5cGVcblx0XHR9KTtcblx0fVxuXHRfb25Db250ZW50TG9hZChpbWFnZSkge1xuXHRcdHRoaXMuX2ltYWdlSXNSZWFkeSA9IHRydWU7XG5cblx0XHR0aGlzLl90cmlnZ2VyQ29udGVudExvYWQoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlzSW1hZ2VMb2FkZWQoKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5faW1hZ2UgJiYgdGhpcy5faW1hZ2VJc1JlYWR5ICYmXG5cdFx0XHQoIXRoaXMuX2lzVmlkZW8gfHwgdGhpcy5faW1hZ2UucmVhZHlTdGF0ZSA+PSAyIC8qIEhBVkVfQ1VSUkVOVF9EQVRBICovKTtcblx0fVxuXG5cdGJpbmRUZXh0dXJlKCkge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblx0XHRcdGlmICghdGhpcy5fY29udGVudExvYWRlcikge1xuXHRcdFx0XHRyZWooXCJJbWFnZUxvYWRlciBpcyBub3QgaW5pdGlhbGl6ZWRcIik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fY29udGVudExvYWRlci5nZXQoKVxuXHRcdFx0XHQudGhlbigoKSA9PiB0aGlzLl9iaW5kVGV4dHVyZSgpLCByZWopXG5cdFx0XHRcdC50aGVuKHJlcyk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyDrtoDrqqgg7JeY66as66i87Yq47JeQIGNhbnZhcyDrpbwg67aZ7J6EXG5cdGF0dGFjaFRvKHBhcmVudEVsZW1lbnQpIHtcblx0XHR0aGlzLmRldGFjaCgpO1xuXHRcdHBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuXHR9XG5cblx0Zm9yY2VDb250ZXh0TG9zcygpIHtcblx0XHRpZiAodGhpcy5oYXNSZW5kZXJpbmdDb250ZXh0KCkpIHtcblx0XHRcdGNvbnN0IGxvc2VDb250ZXh0RXh0ZW5zaW9uID0gdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKTtcblxuXHRcdFx0aWYgKGxvc2VDb250ZXh0RXh0ZW5zaW9uKSB7XG5cdFx0XHRcdGxvc2VDb250ZXh0RXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8g67aA66qoIOyXmOumrOuovO2KuOyXkOyEnCBjYW52YXMg66W8IOygnOqxsFxuXHRkZXRhY2goKSB7XG5cdFx0aWYgKHRoaXMuY2FudmFzLnBhcmVudEVsZW1lbnQpIHtcblx0XHRcdHRoaXMuY2FudmFzLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuXHRcdH1cblx0fVxuXG5cdGRlc3Ryb3koKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRlbnRMb2FkZXIpIHtcblx0XHRcdHRoaXMuX2NvbnRlbnRMb2FkZXIuZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZGV0YWNoKCk7XG5cdFx0dGhpcy5mb3JjZUNvbnRleHRMb3NzKCk7XG5cblx0XHR0aGlzLm9mZigpO1xuXG5cdFx0dGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dGxvc3RcIiwgdGhpcy5fb25XZWJnbGNvbnRleHRsb3N0KTtcblx0XHR0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0cmVzdG9yZWRcIiwgdGhpcy5fb25XZWJnbGNvbnRleHRyZXN0b3JlZCk7XG5cdH1cblxuXHRoYXNSZW5kZXJpbmdDb250ZXh0KCkge1xuXHRcdGlmICghKHRoaXMuY29udGV4dCAmJiAhdGhpcy5jb250ZXh0LmlzQ29udGV4dExvc3QoKSkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0dGhpcy5jb250ZXh0ICYmXG5cdFx0XHQhdGhpcy5jb250ZXh0LmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5zaGFkZXJQcm9ncmFtLCB0aGlzLmNvbnRleHQuTElOS19TVEFUVVMpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0X29uV2ViZ2xjb250ZXh0bG9zdChlKSB7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdHRoaXMudHJpZ2dlcihFVkVOVFMuUkVOREVSSU5HX0NPTlRFWFRfTE9TVCk7XG5cdH1cblxuXHRfb25XZWJnbGNvbnRleHRyZXN0b3JlZChlKSB7XG5cdFx0dGhpcy5faW5pdFdlYkdMKCk7XG5cdFx0dGhpcy50cmlnZ2VyKEVWRU5UUy5SRU5ERVJJTkdfQ09OVEVYVF9SRVNUT1JFKTtcblx0fVxuXG5cdHVwZGF0ZUZpZWxkT2ZWaWV3KGZpZWxkT2ZWaWV3KSB7XG5cdFx0dGhpcy5maWVsZE9mVmlldyA9IGZpZWxkT2ZWaWV3O1xuXHRcdHRoaXMuX3VwZGF0ZVZpZXdwb3J0KCk7XG5cdH1cblxuXHR1cGRhdGVWaWV3cG9ydERpbWVuc2lvbnMod2lkdGgsIGhlaWdodCkge1xuXHRcdGxldCB2aWV3UG9ydENoYW5nZWQgPSBmYWxzZTtcblxuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuXHRcdGNvbnN0IHcgPSB3aWR0aCAqIERFVklDRV9QSVhFTF9SQVRJTztcblx0XHRjb25zdCBoID0gaGVpZ2h0ICogREVWSUNFX1BJWEVMX1JBVElPO1xuXG5cdFx0aWYgKHcgIT09IHRoaXMuY2FudmFzLndpZHRoKSB7XG5cdFx0XHR0aGlzLmNhbnZhcy53aWR0aCA9IHc7XG5cdFx0XHR2aWV3UG9ydENoYW5nZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChoICE9PSB0aGlzLmNhbnZhcy5oZWlnaHQpIHtcblx0XHRcdHRoaXMuY2FudmFzLmhlaWdodCA9IGg7XG5cdFx0XHR2aWV3UG9ydENoYW5nZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICghdmlld1BvcnRDaGFuZ2VkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlVmlld3BvcnQoKTtcblx0XHR0aGlzLl9zaG91bGRGb3JjZURyYXcgPSB0cnVlO1xuXHR9XG5cblx0X3VwZGF0ZVZpZXdwb3J0KCkge1xuXHRcdG1hdDQucGVyc3BlY3RpdmUoXG5cdFx0XHR0aGlzLnBNYXRyaXgsXG5cdFx0XHRnbE1hdHJpeC50b1JhZGlhbih0aGlzLmZpZWxkT2ZWaWV3KSxcblx0XHRcdHRoaXMuY2FudmFzLndpZHRoIC8gdGhpcy5jYW52YXMuaGVpZ2h0LFxuXHRcdFx0MC4xLFxuXHRcdFx0MTAwKTtcblxuXHRcdHRoaXMuY29udGV4dC52aWV3cG9ydCgwLCAwLCB0aGlzLmNvbnRleHQuZHJhd2luZ0J1ZmZlcldpZHRoLCB0aGlzLmNvbnRleHQuZHJhd2luZ0J1ZmZlckhlaWdodCk7XG5cdH1cblxuXHRfaW5pdFdlYkdMKCkge1xuXHRcdGxldCBnbDtcblxuXHRcdC8vIFRPRE86IEZvbGxvd2luZyBjb2RlIGRvZXMgbmVlZCB0byBiZSBleGVjdXRlZCBvbmx5IGlmIHdpZHRoL2hlaWdodCwgY3ViaWNTdHJpcCBwcm9wZXJ0eSBpcyBjaGFuZ2VkLlxuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLl9pbml0UmVuZGVyaW5nQ29udGV4dCgpO1xuXHRcdFx0Z2wgPSB0aGlzLmNvbnRleHQ7XG5cblx0XHRcdHRoaXMudXBkYXRlVmlld3BvcnREaW1lbnNpb25zKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuXHRcdFx0aWYgKHRoaXMuc2hhZGVyUHJvZ3JhbSkge1xuXHRcdFx0XHRnbC5kZWxldGVQcm9ncmFtKHRoaXMuc2hhZGVyUHJvZ3JhbSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2hhZGVyUHJvZ3JhbSA9IHRoaXMuX2luaXRTaGFkZXJQcm9ncmFtKGdsKTtcblx0XHRcdGlmICghdGhpcy5zaGFkZXJQcm9ncmFtKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGludGlhbGl6ZSBzaGFkZXJzOiAke1dlYkdMVXRpbHMuZ2V0RXJyb3JOYW1lRnJvbVdlYkdMRXJyb3JDb2RlKGdsLmdldEVycm9yKCkpfWApO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHRoaXMudHJpZ2dlcihFVkVOVFMuRVJST1IsIHtcblx0XHRcdFx0dHlwZTogRVJST1JfVFlQRS5OT19XRUJHTCxcblx0XHRcdFx0bWVzc2FnZTogXCJubyB3ZWJnbCBzdXBwb3J0XCJcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRjb25zb2xlLmVycm9yKGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Ly8g7LqU67KE7Iqk66W8IO2IrOuqheycvOuhnCDssYTsmrTri6QuXG5cdFx0Z2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcblx0XHRjb25zdCB0ZXh0dXJlVGFyZ2V0ID0gdGhpcy5faXNDdWJlTWFwID8gZ2wuVEVYVFVSRV9DVUJFX01BUCA6IGdsLlRFWFRVUkVfMkQ7XG5cblx0XHRpZiAodGhpcy50ZXh0dXJlKSB7XG5cdFx0XHRnbC5kZWxldGVUZXh0dXJlKHRoaXMudGV4dHVyZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy50ZXh0dXJlID0gV2ViR0xVdGlscy5jcmVhdGVUZXh0dXJlKGdsLCB0ZXh0dXJlVGFyZ2V0KTtcblxuXHRcdGlmICh0aGlzLl9pbWFnZVR5cGUgPT09IEltYWdlVHlwZS5DVUJFU1RSSVApIHtcblx0XHRcdC8vIFRPRE86IEFwcGx5IGZvbGxvd2luZyBvcHRpb25zIG9uIG90aGVyIHByb2plY3Rpb24gdHlwZS5cblx0XHRcdGdsLmVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xuXHRcdFx0Ly8gZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuXHRcdH1cblx0fVxuXG5cdF9pbml0UmVuZGVyaW5nQ29udGV4dCgpIHtcblx0XHRpZiAodGhpcy5oYXNSZW5kZXJpbmdDb250ZXh0KCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIldlYkdMUmVuZGVyaW5nQ29udGV4dCBub3QgYXZhaWxhYmxlLlwiKTtcblx0XHR9XG5cblx0XHR0aGlzLmNvbnRleHQgPSBXZWJHTFV0aWxzLmdldFdlYmdsQ29udGV4dCh0aGlzLmNhbnZhcywgdGhpcy5fcmVuZGVyaW5nQ29udGV4dEF0dHJpYnV0ZXMpO1xuXG5cdFx0aWYgKCF0aGlzLmNvbnRleHQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBhY3F1aXJlIDNEIHJlbmRlcmluZyBjb250ZXh0XCIpO1xuXHRcdH1cblx0fVxuXG5cdF9pbml0U2hhZGVyUHJvZ3JhbShnbCkge1xuXHRcdGNvbnN0IHZlcnRleFNoYWRlclNvdXJjZSA9IHRoaXMuX3JlbmRlcmVyLmdldFZlcnRleFNoYWRlclNvdXJjZSgpO1xuXHRcdGNvbnN0IHZlcnRleFNoYWRlciA9IFdlYkdMVXRpbHMuY3JlYXRlU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpO1xuXG5cdFx0aWYgKCF2ZXJ0ZXhTaGFkZXIpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRjb25zdCBmcmFnbWVudFNoYWRlclNvdXJjZSA9IHRoaXMuX3JlbmRlcmVyLmdldEZyYWdtZW50U2hhZGVyU291cmNlKCk7XG5cdFx0Y29uc3QgZnJhZ21lbnRTaGFkZXIgPSBXZWJHTFV0aWxzLmNyZWF0ZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG5cblx0XHRpZiAoIWZyYWdtZW50U2hhZGVyKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2hhZGVyUHJvZ3JhbSA9IFdlYkdMVXRpbHMuY3JlYXRlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcik7XG5cblx0XHRpZiAoIXNoYWRlclByb2dyYW0pIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGdsLnVzZVByb2dyYW0oc2hhZGVyUHJvZ3JhbSk7XG5cdFx0c2hhZGVyUHJvZ3JhbS52ZXJ0ZXhQb3NpdGlvbkF0dHJpYnV0ZSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHNoYWRlclByb2dyYW0sIFwiYVZlcnRleFBvc2l0aW9uXCIpO1xuXHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlclByb2dyYW0udmVydGV4UG9zaXRpb25BdHRyaWJ1dGUpO1xuXHRcdHNoYWRlclByb2dyYW0ucE1hdHJpeFVuaWZvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgXCJ1UE1hdHJpeFwiKTtcblx0XHRzaGFkZXJQcm9ncmFtLm12TWF0cml4VW5pZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXJQcm9ncmFtLCBcInVNVk1hdHJpeFwiKTtcblx0XHRzaGFkZXJQcm9ncmFtLnNhbXBsZXJVbmlmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlclByb2dyYW0sIFwidVNhbXBsZXJcIik7XG5cdFx0c2hhZGVyUHJvZ3JhbS50ZXh0dXJlQ29vcmRBdHRyaWJ1dGUgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihzaGFkZXJQcm9ncmFtLCBcImFUZXh0dXJlQ29vcmRcIik7XG5cblx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzaGFkZXJQcm9ncmFtLnRleHR1cmVDb29yZEF0dHJpYnV0ZSk7XG5cblx0XHQvLyBjbGVhciBidWZmZXJcblx0XHRnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCB8IGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XG5cdFx0Ly8gVXNlIFRFWFRVUkUwXG5cdFx0Z2wudW5pZm9ybTFpKHNoYWRlclByb2dyYW0uc2FtcGxlclVuaWZvcm0sIDApO1xuXG5cdFx0cmV0dXJuIHNoYWRlclByb2dyYW07XG5cdH1cblxuXHRfaW5pdEJ1ZmZlcnMoKSB7XG5cdFx0Y29uc3QgdmVydGV4UG9zaXRpb25EYXRhID0gdGhpcy5fcmVuZGVyZXIuZ2V0VmVydGV4UG9zaXRpb25EYXRhKCk7XG5cdFx0Y29uc3QgaW5kZXhEYXRhID0gdGhpcy5fcmVuZGVyZXIuZ2V0SW5kZXhEYXRhKCk7XG5cdFx0Y29uc3QgdGV4dHVyZUNvb3JkRGF0YSA9IHRoaXMuX3JlbmRlcmVyLmdldFRleHR1cmVDb29yZERhdGEodGhpcy5faW1hZ2VDb25maWcpO1xuXHRcdGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuXG5cdFx0dGhpcy52ZXJ0ZXhCdWZmZXIgPSBXZWJHTFV0aWxzLmluaXRCdWZmZXIoXG5cdFx0XHRnbCwgZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHZlcnRleFBvc2l0aW9uRGF0YSksIDMsXG5cdFx0XHR0aGlzLnNoYWRlclByb2dyYW0udmVydGV4UG9zaXRpb25BdHRyaWJ1dGUpO1xuXG5cdFx0dGhpcy5pbmRleEJ1ZmZlciA9IFdlYkdMVXRpbHMuaW5pdEJ1ZmZlcihcblx0XHRcdGdsLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbmV3IFVpbnQxNkFycmF5KGluZGV4RGF0YSksIDEpO1xuXG5cdFx0dGhpcy50ZXh0dXJlQ29vcmRCdWZmZXIgPSBXZWJHTFV0aWxzLmluaXRCdWZmZXIoXG5cdFx0XHRnbCwgZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHRleHR1cmVDb29yZERhdGEpLCB0aGlzLl9pc0N1YmVNYXAgPyAzIDogMixcblx0XHRcdHRoaXMuc2hhZGVyUHJvZ3JhbS50ZXh0dXJlQ29vcmRBdHRyaWJ1dGUpO1xuXHR9XG5cblx0X2JpbmRUZXh0dXJlKCkge1xuXHRcdC8vIERldGVjdCBpZiBpdCBpcyBFQUMgRm9ybWF0IHdoaWxlIENVQkVTVFJJUCBtb2RlLlxuXHRcdC8vIFdlIGFzc3VtZSBpdCBpcyBFQUMgaWYgaW1hZ2UgaXMgbm90IDMvMiByYXRpby5cblx0XHRpZiAodGhpcy5faW1hZ2VUeXBlID09PSBJbWFnZVR5cGUuQ1VCRVNUUklQKSB7XG5cdFx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLl9yZW5kZXJlci5nZXREaW1lbnNpb24odGhpcy5faW1hZ2UpO1xuXHRcdFx0Y29uc3QgaXNFQUMgPSB3aWR0aCAmJiBoZWlnaHQgJiYgd2lkdGggLyBoZWlnaHQgIT09IDEuNTtcblxuXHRcdFx0dGhpcy5jb250ZXh0LnVuaWZvcm0xZih0aGlzLmNvbnRleHQuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuc2hhZGVyUHJvZ3JhbSwgXCJ1SXNFQUNcIiksIGlzRUFDKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuX2ltYWdlVHlwZSA9PT0gSW1hZ2VUeXBlLlBBTk9SQU1BKSB7XG5cdFx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLl9yZW5kZXJlci5nZXREaW1lbnNpb24odGhpcy5faW1hZ2UpO1xuXHRcdFx0Y29uc3QgaW1hZ2VBc3BlY3RSYXRpbyA9IHdpZHRoICYmIGhlaWdodCAmJiB3aWR0aCAvIGhlaWdodDtcblxuXHRcdFx0dGhpcy5fcmVuZGVyZXIudXBkYXRlU2hhZGVyRGF0YSh7aW1hZ2VBc3BlY3RSYXRpb30pO1xuXHRcdH1cblxuXHRcdC8vIGludGlhbGl6ZSBzaGFkZXIgYnVmZmVycyBhZnRlciBpbWFnZSBpcyBsb2FkZWQuKGJ5IHVwZGF0ZVNoYWRlckRhdGEpXG5cdFx0Ly8gYmVjYXVzZSBidWZmZXIgbWF5IGJlIGRpZmZlciBieSBpbWFnZSBzaXplLihlZy4gQ3lsaW5kZXJSZW5kZXJlcilcblx0XHR0aGlzLl9pbml0QnVmZmVycygpO1xuXG5cdFx0dGhpcy5fcmVuZGVyZXIuYmluZFRleHR1cmUoXG5cdFx0XHR0aGlzLmNvbnRleHQsXG5cdFx0XHR0aGlzLnRleHR1cmUsXG5cdFx0XHR0aGlzLl9pbWFnZSxcblx0XHRcdHRoaXMuX2ltYWdlQ29uZmlnLFxuXHRcdCk7XG5cdFx0dGhpcy5fc2hvdWxkRm9yY2VEcmF3ID0gdHJ1ZTtcblxuXHRcdHRoaXMudHJpZ2dlcihFVkVOVFMuQklORF9URVhUVVJFKTtcblx0fVxuXG5cdF91cGRhdGVUZXh0dXJlKCkge1xuXHRcdHRoaXMuX3JlbmRlcmVyLnVwZGF0ZVRleHR1cmUoXG5cdFx0XHR0aGlzLmNvbnRleHQsXG5cdFx0XHR0aGlzLl9pbWFnZSxcblx0XHRcdHRoaXMuX2ltYWdlQ29uZmlnLFxuXHRcdCk7XG5cdH1cblxuXHRrZWVwVXBkYXRlKGRvVXBkYXRlKSB7XG5cdFx0aWYgKGRvVXBkYXRlICYmIHRoaXMuaXNJbWFnZUxvYWRlZCgpID09PSBmYWxzZSkge1xuXHRcdFx0Ly8gRm9yY2UgdG8gZHJhdyBhIGZyYW1lIGFmdGVyIGltYWdlIGlzIGxvYWRlZCBvbiByZW5kZXIoKVxuXHRcdFx0dGhpcy5fc2hvdWxkRm9yY2VEcmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHR0aGlzLl9rZWVwVXBkYXRlID0gZG9VcGRhdGU7XG5cdH1cblxuXHRyZW5kZXJXaXRoUXVhdGVybmlvbihxdWF0ZXJuaW9uLCBmaWVsZE9mVmlldykge1xuXHRcdGlmICghdGhpcy5pc0ltYWdlTG9hZGVkKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fa2VlcFVwZGF0ZSA9PT0gZmFsc2UgJiZcblx0XHRcdHRoaXMuX2xhc3RRdWF0ZXJuaW9uICYmIHF1YXQuZXhhY3RFcXVhbHModGhpcy5fbGFzdFF1YXRlcm5pb24sIHF1YXRlcm5pb24pICYmXG5cdFx0XHR0aGlzLmZpZWxkT2ZWaWV3ICYmIHRoaXMuZmllbGRPZlZpZXcgPT09IGZpZWxkT2ZWaWV3ICYmXG5cdFx0XHR0aGlzLl9zaG91bGRGb3JjZURyYXcgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlZmllbGRPZlZpZXcgb25seSBpZiBmaWVsZE9mVmlldyBpcyBjaGFuZ2VkLlxuXHRcdGlmIChmaWVsZE9mVmlldyAhPT0gdW5kZWZpbmVkICYmIGZpZWxkT2ZWaWV3ICE9PSB0aGlzLmZpZWxkT2ZWaWV3KSB7XG5cdFx0XHR0aGlzLnVwZGF0ZUZpZWxkT2ZWaWV3KGZpZWxkT2ZWaWV3KTtcblx0XHR9XG5cblx0XHR0aGlzLm12TWF0cml4ID0gbWF0NC5mcm9tUXVhdChtYXQ0LmNyZWF0ZSgpLCBxdWF0ZXJuaW9uKTtcblxuXHRcdHRoaXMuX2RyYXcoKTtcblxuXHRcdHRoaXMuX2xhc3RRdWF0ZXJuaW9uID0gcXVhdC5jbG9uZShxdWF0ZXJuaW9uKTtcblx0XHRpZiAodGhpcy5fc2hvdWxkRm9yY2VEcmF3KSB7XG5cdFx0XHR0aGlzLl9zaG91bGRGb3JjZURyYXcgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRyZW5kZXIoeWF3LCBwaXRjaCwgZmllbGRPZlZpZXcpIHtcblx0XHRpZiAoIXRoaXMuaXNJbWFnZUxvYWRlZCgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2tlZXBVcGRhdGUgPT09IGZhbHNlICYmXG5cdFx0XHRcdHRoaXMuX2xhc3RZYXcgIT09IG51bGwgJiYgdGhpcy5fbGFzdFlhdyA9PT0geWF3ICYmXG5cdFx0XHRcdHRoaXMuX2xhc3RQaXRjaCAhPT0gbnVsbCAmJiB0aGlzLl9sYXN0UGl0Y2ggPT09IHBpdGNoICYmXG5cdFx0XHRcdHRoaXMuZmllbGRPZlZpZXcgJiYgdGhpcy5maWVsZE9mVmlldyA9PT0gZmllbGRPZlZpZXcgJiZcblx0XHRcdFx0dGhpcy5fc2hvdWxkRm9yY2VEcmF3ID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZpZWxkT2ZWaWV3IOqwgCDsobTsnqztlZjrqbTshJwg6riw7KG07J2YIOqwkuqzvCDri6Trpbwg6rK97Jqw7JeQ66eMIOyXheuNsOydtO2KuCDtmLjstpxcblx0XHRpZiAoZmllbGRPZlZpZXcgIT09IHVuZGVmaW5lZCAmJiBmaWVsZE9mVmlldyAhPT0gdGhpcy5maWVsZE9mVmlldykge1xuXHRcdFx0dGhpcy51cGRhdGVGaWVsZE9mVmlldyhmaWVsZE9mVmlldyk7XG5cdFx0fVxuXG5cdFx0bWF0NC5pZGVudGl0eSh0aGlzLm12TWF0cml4KTtcblx0XHRtYXQ0LnJvdGF0ZVgodGhpcy5tdk1hdHJpeCwgdGhpcy5tdk1hdHJpeCwgLWdsTWF0cml4LnRvUmFkaWFuKHBpdGNoKSk7XG5cdFx0bWF0NC5yb3RhdGVZKHRoaXMubXZNYXRyaXgsIHRoaXMubXZNYXRyaXgsIC1nbE1hdHJpeC50b1JhZGlhbih5YXcpKTtcblxuXHRcdHRoaXMuX2RyYXcoKTtcblxuXHRcdHRoaXMuX2xhc3RZYXcgPSB5YXc7XG5cdFx0dGhpcy5fbGFzdFBpdGNoID0gcGl0Y2g7XG5cdFx0aWYgKHRoaXMuX3Nob3VsZEZvcmNlRHJhdykge1xuXHRcdFx0dGhpcy5fc2hvdWxkRm9yY2VEcmF3ID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0X2RyYXcoKSB7XG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG5cblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMuc2hhZGVyUHJvZ3JhbS5wTWF0cml4VW5pZm9ybSwgZmFsc2UsIHRoaXMucE1hdHJpeCk7XG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLnNoYWRlclByb2dyYW0ubXZNYXRyaXhVbmlmb3JtLCBmYWxzZSwgdGhpcy5tdk1hdHJpeCk7XG5cblx0XHRpZiAodGhpcy5faXNWaWRlbyAmJiB0aGlzLl9rZWVwVXBkYXRlKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVUZXh0dXJlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaW5kZXhCdWZmZXIpIHtcblx0XHRcdGdsLmRyYXdFbGVtZW50cyhcblx0XHRcdFx0Z2wuVFJJQU5HTEVTLCB0aGlzLmluZGV4QnVmZmVyLm51bUl0ZW1zLCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgcHJvamVjdGlvbiByZW5kZXJlciBieSBlYWNoIHR5cGVcblx0ICovXG5cdGdldFByb2plY3Rpb25SZW5kZXJlcigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmVuZGVyZXI7XG5cdH1cbn1cbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSBcIkBlZ2pzL2NvbXBvbmVudFwiO1xuaW1wb3J0IHtcblx0RGV2aWNlTW90aW9uRXZlbnRcbn0gZnJvbSBcIi4uL3V0aWxzL2Jyb3dzZXJGZWF0dXJlXCI7XG5cbmltcG9ydCBZYXdQaXRjaENvbnRyb2wgZnJvbSBcIi4uL1lhd1BpdGNoQ29udHJvbC9ZYXdQaXRjaENvbnRyb2xcIjtcbmltcG9ydCBQYW5vSW1hZ2VSZW5kZXJlciBmcm9tIFwiLi4vUGFub0ltYWdlUmVuZGVyZXIvUGFub0ltYWdlUmVuZGVyZXJcIjtcbmltcG9ydCBXZWJHTFV0aWxzIGZyb20gXCIuLi9QYW5vSW1hZ2VSZW5kZXJlci9XZWJHTFV0aWxzXCI7XG5pbXBvcnQge0VSUk9SX1RZUEUsIEVWRU5UUywgR1lST19NT0RFLCBQUk9KRUNUSU9OX1RZUEV9IGZyb20gXCIuL2NvbnN0c1wiO1xuaW1wb3J0IHtnbE1hdHJpeH0gZnJvbSBcIi4uL3V0aWxzL21hdGgtdXRpbC5qc1wiO1xuaW1wb3J0IHtWRVJTSU9OfSBmcm9tIFwiLi4vdmVyc2lvblwiO1xuaW1wb3J0IHtJU19TQUZBUklfT05fREVTS1RPUH0gZnJvbSBcIi4uL3V0aWxzL2Jyb3dzZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFub1ZpZXdlciBleHRlbmRzIENvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBWZXJzaW9uIGluZm8gc3RyaW5nXG5cdCAqIEBrbyDrsoTsoITsoJXrs7Qg66y47J6Q7Je0XG5cdCAqIEBuYW1lIFZFUlNJT05cblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZXhhbXBsZVxuXHQgKiBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuVkVSU0lPTjsgIC8vIGV4KSAzLjAuMVxuXHQgKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyXG5cdCAqL1xuXHRzdGF0aWMgVkVSU0lPTiA9IFZFUlNJT047XG5cdHN0YXRpYyBFUlJPUl9UWVBFID0gRVJST1JfVFlQRTtcblx0c3RhdGljIEVWRU5UUyA9IEVWRU5UUztcblx0c3RhdGljIFBST0pFQ1RJT05fVFlQRSA9IFBST0pFQ1RJT05fVFlQRTtcblx0c3RhdGljIEdZUk9fTU9ERSA9IEdZUk9fTU9ERTtcblx0Ly8gSXQgc2hvdWxkIGJlIGRlcHJlY2F0ZWQhXG5cdHN0YXRpYyBQcm9qZWN0aW9uVHlwZSA9IFBST0pFQ1RJT05fVFlQRTtcblx0LyoqXG5cdCAqIENvbnN0YW50IHZhbHVlIGZvciB0b3VjaCBkaXJlY3Rpb25zXG5cdCAqIEBrbyDthLDsuZgg67Cp7Zal7JeQIOuMgO2VnCDsg4HsiJgg6rCSLlxuXHQgKiBAbmFtZXNwYWNlXG5cdCAqIEBuYW1lIFRPVUNIX0RJUkVDVElPTlxuXHQgKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyXG5cdCAqL1xuXHRzdGF0aWMgVE9VQ0hfRElSRUNUSU9OID0ge1xuXHRcdC8qKlxuXHRcdCAqIENvbnN0YW50IHZhbHVlIGZvciBub25lIGRpcmVjdGlvbi5cblx0XHQgKiBAa28gbm9uZSDrsKntlqXsl5Ag64yA7ZWcIOyDgeyImCDqsJIuXG5cdFx0ICogQG5hbWUgTk9ORVxuXHRcdCAqIEBtZW1iZXJvZiBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OXG5cdFx0ICogQGNvbnN0YW50XG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICovXG5cdFx0Tk9ORTogWWF3UGl0Y2hDb250cm9sLlRPVUNIX0RJUkVDVElPTl9OT05FLFxuXHRcdC8qKlxuXHRcdCAqIENvbnN0YW50IHZhbHVlIGZvciBob3Jpem9udGFsKHlhdykgZGlyZWN0aW9uLlxuXHRcdCAqIEBrbyBob3Jpem9udGFsKHlhdykg67Cp7Zal7JeQIOuMgO2VnCDsg4HsiJgg6rCSLlxuXHRcdCAqIEBuYW1lIFlBV1xuXHRcdCAqIEBtZW1iZXJvZiBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OXG5cdFx0ICogQGNvbnN0YW50XG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCA2XG5cdFx0ICovXG5cdFx0WUFXOiBZYXdQaXRjaENvbnRyb2wuVE9VQ0hfRElSRUNUSU9OX1lBVyxcblx0XHQvKipcblx0XHQgKiBDb25zdGFudCB2YWx1ZSBmb3IgdmVydGljYWwgZGlyZWN0aW9uLlxuXHRcdCAqIEBrbyB2ZXJ0aWNhbChwaXRjaCkg67Cp7Zal7JeQIOuMgO2VnCDsg4HsiJgg6rCSLlxuXHRcdCAqIEBuYW1lIFBJVENIXG5cdFx0ICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlci5UT1VDSF9ESVJFQ1RJT05cblx0XHQgKiBAY29uc3RhbnRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDI0XG5cdFx0ICovXG5cdFx0UElUQ0g6IFlhd1BpdGNoQ29udHJvbC5UT1VDSF9ESVJFQ1RJT05fUElUQ0gsXG5cdFx0LyoqXG5cdFx0ICogQ29uc3RhbnQgdmFsdWUgZm9yIGFsbCBkaXJlY3Rpb24uXG5cdFx0ICogQGtvIGFsbCDrsKntlqXsl5Ag64yA7ZWcIOyDgeyImCDqsJIuXG5cdFx0ICogQG5hbWUgQUxMXG5cdFx0ICogQG1lbWJlcm9mIGVnLnZpZXczNjAuUGFub1ZpZXdlci5UT1VDSF9ESVJFQ1RJT05cblx0XHQgKiBAY29uc3RhbnRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDMwXG5cdFx0ICovXG5cdFx0QUxMOiBZYXdQaXRjaENvbnRyb2wuVE9VQ0hfRElSRUNUSU9OX0FMTFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAY2xhc3NkZXNjIDM2MCBtZWRpYSB2aWV3ZXJcblx0ICogQGtvIDM2MCDrr7jrlJTslrQg67ew7Ja0XG5cdCAqIEBjbGFzc1xuXHQgKiBAbmFtZSBlZy52aWV3MzYwLlBhbm9WaWV3ZXJcblx0ICogQGV4dGVuZHMgZWcuQ29tcG9uZW50XG5cdCAqXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBUaGUgY29udGFpbmVyIGVsZW1lbnQgZm9yIHRoZSByZW5kZXJlci4gPGtvPuugjOuNlOufrOydmCDsu6jthYzsnbTrhIgg7JeY66as66i87Yq4PC9rbz5cblx0ICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xJbWFnZX0gY29uZmlnLmltYWdlIElucHV0IGltYWdlIHVybCBvciBlbGVtZW50IChVc2Ugb25seSBpbWFnZSBwcm9wZXJ0eSBvciB2aWRlbyBwcm9wZXJ0eSk8a28+7J6F66ClIOydtOuvuOyngCBVUkwg7Zi57J2AIOyXmOumrOuovO2KuChpbWFnZSDsmYAgdmlkZW8g65GYIOykkSDtlZjrgpjrp4wg7ISk7KCVKTwva28+XG5cdCAqIEBwYXJhbSB7U3RyaW5nfEhUTUxWaWRlb0VsZW1lbnR9IGNvbmZpZy52aWRlbyBJbnB1dCB2aWRlbyB1cmwgb3IgZWxlbWVudChVc2Ugb25seSBpbWFnZSBwcm9wZXJ0eSBvciB2aWRlbyBwcm9wZXJ0eSk8a28+7J6F66ClIOu5hOuUlOyYpCBVUkwg7Zi57J2AIOyXmOumrOuovO2KuChpbWFnZSDsmYAgdmlkZW8g65GYIOykkSDtlZjrgpjrp4wg7ISk7KCVKTwva28+XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnByb2plY3Rpb25UeXBlPWVxdWlyZWN0YW5ndWxhcl0gVGhlIHR5cGUgb2YgcHJvamVjdGlvbjogZXF1aXJlY3Rhbmd1bGFyLCBjdWJlbWFwIDxici8+e0BsaW5rIGVnLnZpZXczNjAuUGFub1ZpZXdlci5QUk9KRUNUSU9OX1RZUEV9PGtvPlByb2plY3Rpb24g7Jyg7ZiVIDogZXF1aXJlY3Rhbmd1bGFyLCBjdWJlbWFwIDxici8+e0BsaW5rIGVnLnZpZXczNjAuUGFub1ZpZXdlci5QUk9KRUNUSU9OX1RZUEV9PC9rbz5cblx0ICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZy5jdWJlbWFwQ29uZmlnIGNvbmZpZyBjdWJlbWFwIHByb2plY3Rpb24gbGF5b3V0LiBJdCBpcyBhcHBsaWVkIHdoZW4gcHJvamVjdGlvblR5cGUgaXMge0BsaW5rIGVnLnZpZXczNjAuUGFub1ZpZXdlci5QUk9KRUNUSU9OX1RZUEUuQ1VCRU1BUH0gb3Ige0BsaW5rIGVnLnZpZXczNjAuUGFub1ZpZXdlci5QUk9KRUNUSU9OX1RZUEUuQ1VCRVNUUklQfTxrbz5jdWJlbWFwIHByb2plY3Rpb24gdHlwZSDsnZgg66CI7J207JWE7JuD7J2EIOyEpOygle2VnOuLpC4g7J20IOyEpOygleydgCBQcm9qZWN0aW9uVHlwZSDsnbQge0BsaW5rIGVnLnZpZXczNjAuUGFub1ZpZXdlci5QUk9KRUNUSU9OX1RZUEUuQ1VCRU1BUH0g7Zi57J2AIHtAbGluayBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuUFJPSkVDVElPTl9UWVBFLkNVQkVTVFJJUH0g7J24IOqyveyasOyXkOunjCDsoIHsmqnrkJzri6QuPC9rbz5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuY3ViZW1hcENvbmZpZy5vcmRlciA9IFwiUkxVREJGXCIoUHJvamVjdGlvblR5cGUgPT09IENVQkVNQVApIHwgXCJSTFVERkJcIiAoUHJvamVjdGlvblR5cGUgPT09IENVQkVTVFJJUCldIE9yZGVyIG9mIGN1YmVtYXAgZmFjZXMgPGtvPkN1YmVtYXAg7ZiV7YOc7J2YIOydtOuvuOyngOqwgCDrsLDsuZjrkJwg7Iic7IScPC9rbz5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuY3ViZW1hcENvbmZpZy50aWxlQ29uZmlnID0ge2ZsaXBIaXJvem9udGFsOmZhbHNlLCByb3RhdGlvbjogMH1dIFNldHRpbmcgYWJvdXQgcm90YXRpb24gYW5nbGUoZGVncmVlKSBhbmQgd2hldGhlciB0byBmbGlwIGhvcml6b250YWwgZm9yIGVhY2ggY3ViZW1hcCBmYWNlcywgaWYgeW91IHB1dCB0aGlzIG9iamVjdCBhcyBhIGFycmF5LCB5b3UgY2FuIHNldCBlYWNoIGZhY2VzIHdpdGggZGlmZmVyZW50IHNldHRpbmcuIEZvciBleGFtcGxlLCBbe2ZsaXBIb3Jpem9udGFsOmZhbHNlLCByb3RhdGlvbjo5MH0sIHtmbGlwSG9yaXpvbnRhbDogdHJ1ZSwgcm90YXRpb246IDE4MH0sIC4uLl08a28+6rCBIEN1YmVtYXAg66m07JeQIOuMgO2VnCDtmozsoIQg6rCB64+EL+yijOyasOuwmOyghCDsl6zrtoAg7ISk7KCVLCDqsJ3ssrTrpbwg67Cw7Je0IO2Yle2DnOuhnCDsp4DsoJXtlZjsl6wg6rCBIOuptOyXkCDrjIDtlZwg7ISk7KCV7J2EIOuLpOultOqyjCDsp4DsoJXtlaAg7IiY64+EIOyeiOuLpC4g7JiI66W8IOuTpOyWtCBbe2ZsaXBIb3Jpem9udGFsOmZhbHNlLCByb3RhdGlvbjo5MH0sIHtmbGlwSG9yaXpvbnRhbDogdHJ1ZSwgcm90YXRpb246IDE4MH0sIC4uLl3qs7wg6rCZ7J20IOyngOygle2VoCDsiJgg7J6I64ukLjwva28+XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoPXdpZHRoIG9mIGNvbnRhaW5lcl0gdGhlIHZpZXdlcidzIHdpZHRoLiAoaW4gcHgpIDxrbz7rt7DslrTsnZgg64SI67mEIChweCDri6jsnIQpPC9rbz5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0PWhlaWdodCBvZiBjb250YWluZXJdIHRoZSB2aWV3ZXIncyBoZWlnaHQuKGluIHB4KSA8a28+67ew7Ja07J2YIOuGkuydtCAocHgg64uo7JyEKTwva28+XG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnlhdz0wXSBJbml0aWFsIFlhdyBvZiBjYW1lcmEgKGluIGRlZ3JlZSkgPGtvPuy5tOuplOudvOydmCDstIjquLAgWWF3IChkZWdyZWUg64uo7JyEKTwva28+XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnBpdGNoPTBdIEluaXRpYWwgUGl0Y2ggb2YgY2FtZXJhIChpbiBkZWdyZWUpIDxrbz7subTrqZTrnbzsnZgg7LSI6riwIFBpdGNoIChkZWdyZWUg64uo7JyEKTwva28+XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZvdj02NV0gSW5pdGlhbCB2ZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IG9mIGNhbWVyYSAoaW4gZGVncmVlKSA8a28+7Lm066mU65287J2YIOy0iOq4sCDsiJjsp4EgZmllbGQgb2YgdmlldyAoZGVncmVlIOuLqOychCk8L2tvPlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hvd1BvbGVQb2ludD1mYWxzZV0gSWYgZmFsc2UsIHRoZSBwb2xlIGlzIG5vdCBkaXNwbGF5ZWQgaW5zaWRlIHRoZSB2aWV3cG9ydCA8a28+ZmFsc2Ug7J24IOqyveyasCwg6re57KCQ7J2AIOu3sO2PrO2KuCDrgrTrtoDsl5Ag7ZGc7Iuc65CY7KeAIOyViuyKteuLiOuLpDwva28+XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy51c2Vab29tPXRydWVdIFdoZW4gdHJ1ZSwgZW5hYmxlcyB6b29tIHdpdGggdGhlIHdoZWVsIGFuZCBQaW5jaCBnZXN0dXJlIDxrbz50cnVlIOydvCDrlYwg7ZygIOuwjyDsp5HquLAg7KCc7Iqk7Law66GcIO2ZleuMgCAvIOy2leyGjCDtlaAg7IiYIOyeiOyKteuLiOuLpC48L2tvPlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudXNlS2V5Ym9hcmQ9dHJ1ZV0gV2hlbiB0cnVlLCBlbmFibGVzIHRoZSBrZXlib2FyZCBtb3ZlIGtleSBjb250cm9sOiBhd3NkLCBhcnJvdyBrZXlzIDxrbz50cnVlIOydtOuptCDtgqTrs7Trk5wg7J2064+ZIO2CpCDsu6jtirjroaTsnYQg7Zmc7ISx7ZmU7ZWp64uI64ukOiBhd3NkLCDtmZTsgrTtkZwg7YKkPC9rbz5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZ3lyb01vZGU9eWF3UGl0Y2hdIEVuYWJsZXMgY29udHJvbCB0aHJvdWdoIGRldmljZSBtb3Rpb24uIChcIm5vbmVcIiwgXCJ5YXdQaXRjaFwiLCBcIlZSXCIpIDxici8+e0BsaW5rIGVnLnZpZXczNjAuUGFub1ZpZXdlci5HWVJPX01PREV9IDxrbz7rlJTrsJTsnbTsiqQg7JuA7KeB7J6E7J2EIO2Gte2VnCDsu6jtirjroaTsnYQg7Zmc7ISx7ZmUIO2VqeuLiOuLpC4gKFwibm9uZVwiLCBcInlhd1BpdGNoXCIsIFwiVlJcIikgPGJyLz57QGxpbmsgZWcudmlldzM2MC5QYW5vVmlld2VyLkdZUk9fTU9ERX0gPC9rbz5cblx0ICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy55YXdSYW5nZT1bLTE4MCwgMTgwXV0gUmFuZ2Ugb2YgY29udHJvbGxhYmxlIFlhdyB2YWx1ZXMgPGtvPuygnOyWtCDqsIDriqXtlZwgWWF3IOqwkuydmCDrspTsnIQ8L2tvPlxuXHQgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLnBpdGNoUmFuZ2U9Wy05MCwgOTBdXSBSYW5nZSBvZiBjb250cm9sbGFibGUgUGl0Y2ggdmFsdWVzIDxrbz7soJzslrQg6rCA64ql7ZWcIFBpdGNoIOqwkuydmCDrspTsnIQ8L2tvPlxuXHQgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZvdlJhbmdlPVszMCwgMTEwXV0gUmFuZ2Ugb2YgY29udHJvbGxhYmxlIHZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgdmFsdWVzIDxrbz7soJzslrQg6rCA64ql7ZWcIOyImOyngSBmaWVsZCBvZiB2aWV3IOqwkuydmCDrspTsnIQ8L2tvPlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy50b3VjaERpcmVjdGlvbj0ge0BsaW5rIGVnLnZpZXczNjAuUGFub1ZpZXdlci5UT1VDSF9ESVJFQ1RJT04uQUxMfSg2KV0gRGlyZWN0aW9uIG9mIHRvdWNoIHRoYXQgY2FuIGJlIGNvbnRyb2xsZWQgYnkgdXNlciA8YnIvPntAbGluayBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OfTxrbz7sgqzsmqnsnpDqsIAg7YSw7LmY66GcIOyhsOyekSDqsIDriqXtlZwg67Cp7ZalIDxici8+e0BsaW5rIGVnLnZpZXczNjAuUGFub1ZpZXdlci5UT1VDSF9ESVJFQ1RJT059PC9rbz5cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogLy8gUGFub1ZpZXdlciBDcmVhdGlvblxuXHQgKiAvLyBjcmVhdGUgUGFub1ZpZXdlciB3aXRoIG9wdGlvblxuXHQgKiB2YXIgUGFub1ZpZXdlciA9IGVnLnZpZXczNjAuUGFub1ZpZXdlcjtcblx0ICogLy8gQXJlYSB3aGVyZSB0aGUgaW1hZ2Ugd2lsbCBiZSBkaXNwbGF5ZWQoSFRNTEVsZW1lbnQpXG5cdCAqIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15UGFub1ZpZXdlclwiKTtcblx0ICpcblx0ICogdmFyIHBhbm9WaWV3ZXIgPSBuZXcgUGFub1ZpZXdlcihjb250YWluZXIsIHtcblx0ICogICAgIC8vIElmIHByb2plY3Rpb25UeXBlIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZWZhdWx0IGlzIFwiZXF1aXJlY3Rhbmd1bGFyXCIuXG5cdCAqICAgICAvLyBTcGVjaWZpZXMgYW4gaW1hZ2Ugb2YgdGhlIFwiZXF1aXJlY3Rhbmd1bGFyXCIgdHlwZS5cblx0ICogICAgIGltYWdlOiBcIi9wYXRoL3RvL2ltYWdlL2ltYWdlLmpwZ1wiXG5cdCAqfSk7XG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIEN1YmVtYXAgQ29uZmlnIFNldHRpbmcgRXhhbXBsZVxuXHQgKiAvLyBGb3Igc3VwcG9ydCBZb3V0dWJlIEVBQyBwcm9qZWN0aW9uLCBZb3Ugc2hvdWxkIHNldCBjdWJlbWFwQ29uZmlnIGFzIGZvbGxvd3MuXG5cdCAqIGN1YmVtYXBDb25maWc6IHtcblx0ICogXHRvcmRlcjogXCJMRlJEQlVcIixcblx0ICogXHR0aWxlQ29uZmlnOiBbXG5cdCAqIFx0XHR0aWxlQ29uZmlnOiBbe3JvdGF0aW9uOiAwfSwge3JvdGF0aW9uOiAwfSwge3JvdGF0aW9uOiAwfSwge3JvdGF0aW9uOiAwfSwge3JvdGF0aW9uOiAtOTB9LCB7cm90YXRpb246IDE4MH1dXG5cdCAqIFx0XVxuXHQgKiB9XG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihjb250YWluZXIsIG9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHQvLyBSYWlzZXMgdGhlIGVycm9yIGV2ZW50IGlmIHdlYmdsIGlzIG5vdCBzdXBwb3J0ZWQuXG5cdFx0aWYgKCFXZWJHTFV0aWxzLmlzV2ViR0xBdmFpbGFibGUoKSkge1xuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdHRoaXMudHJpZ2dlcihFVkVOVFMuRVJST1IsIHtcblx0XHRcdFx0XHR0eXBlOiBFUlJPUl9UWVBFLk5PX1dFQkdMLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IFwibm8gd2ViZ2wgc3VwcG9ydFwiXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSwgMCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIVdlYkdMVXRpbHMuaXNTdGFibGVXZWJHTCgpKSB7XG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0dGhpcy50cmlnZ2VyKEVWRU5UUy5FUlJPUiwge1xuXHRcdFx0XHRcdHR5cGU6IEVSUk9SX1RZUEUuSU5WQUxJRF9ERVZJQ0UsXG5cdFx0XHRcdFx0bWVzc2FnZTogXCJibGFja2xpc3RlZCBicm93c2VyXCJcblx0XHRcdFx0fSk7XG5cdFx0XHR9LCAwKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKCEhb3B0aW9ucy5pbWFnZSAmJiAhIW9wdGlvbnMudmlkZW8pIHtcblx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHR0aGlzLnRyaWdnZXIoRVZFTlRTLkVSUk9SLCB7XG5cdFx0XHRcdFx0dHlwZTogRVJST1JfVFlQRS5JTlZBTElEX1JFU09VUkNFLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IFwiU3BlY2lmeWluZyBtdWx0aSByZXNvdWNlcyhib3RoIGltYWdlIGFuZCB2aWRlbykgaXMgbm90IHZhbGlkLlwiXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSwgMCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG5cdFx0dGhpcy5faW1hZ2UgPSBvcHRpb25zLmltYWdlIHx8IG9wdGlvbnMudmlkZW87XG5cdFx0dGhpcy5faXNWaWRlbyA9ICEhb3B0aW9ucy52aWRlbztcblx0XHR0aGlzLl9wcm9qZWN0aW9uVHlwZSA9IG9wdGlvbnMucHJvamVjdGlvblR5cGUgfHwgUFJPSkVDVElPTl9UWVBFLkVRVUlSRUNUQU5HVUxBUjtcblx0XHR0aGlzLl9jdWJlbWFwQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0XHQvKiBSTFVEQkYgaXMgYWJub3JtYWwsIHdlIHVzZSBpdCBvbiBDVUJFTUFQIG9ubHkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkqL1xuXHRcdFx0b3JkZXI6IHRoaXMuX3Byb2plY3Rpb25UeXBlID09PSBQUk9KRUNUSU9OX1RZUEUuQ1VCRU1BUCA/IFwiUkxVREJGXCIgOiBcIlJMVURGQlwiLFxuXHRcdFx0dGlsZUNvbmZpZzoge1xuXHRcdFx0XHRmbGlwSGlyb3pvbnRhbDogZmFsc2UsXG5cdFx0XHRcdHJvdGF0aW9uOiAwXG5cdFx0XHR9XG5cdFx0fSwgb3B0aW9ucy5jdWJlbWFwQ29uZmlnKTtcblxuXHRcdC8vIElmIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBub3QgcHJvdmlkZWQsIHdpbGwgdXNlIHRoZSBzaXplIG9mIHRoZSBjb250YWluZXIuXG5cdFx0dGhpcy5fd2lkdGggPSBvcHRpb25zLndpZHRoIHx8IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcikud2lkdGgsIDEwKTtcblx0XHR0aGlzLl9oZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpLmhlaWdodCwgMTApO1xuXG5cdFx0LyoqXG5cdFx0ICogQ2FjaGUgdGhlIGRpcmVjdGlvbiBmb3IgdGhlIHBlcmZvcm1hbmNlIGluIHJlbmRlckxvb3Bcblx0XHQgKlxuXHRcdCAqIFRoaXMgdmFsdWUgc2hvdWxkIGJlIHVwZGF0ZWQgYnkgXCJjaGFuZ2VcIiBldmVudCBvZiBZYXdQaXRjaENvbnRyb2wuXG5cdFx0ICovXG5cdFx0dGhpcy5feWF3ID0gb3B0aW9ucy55YXcgfHwgMDtcblx0XHR0aGlzLl9waXRjaCA9IG9wdGlvbnMucGl0Y2ggfHwgMDtcblx0XHR0aGlzLl9mb3YgPSBvcHRpb25zLmZvdiB8fCA2NTtcblxuXHRcdHRoaXMuX2d5cm9Nb2RlID0gb3B0aW9ucy5neXJvTW9kZSB8fCBHWVJPX01PREUuWUFXUElUQ0g7XG5cdFx0dGhpcy5fcXVhdGVybmlvbiA9IG51bGw7XG5cblx0XHR0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuX2hlaWdodCAhPT0gMCA/IHRoaXMuX3dpZHRoIC8gdGhpcy5faGVpZ2h0IDogMTtcblx0XHRjb25zdCBmb3ZSYW5nZSA9IG9wdGlvbnMuZm92UmFuZ2UgfHwgWzMwLCAxMTBdO1xuXHRcdGNvbnN0IHRvdWNoRGlyZWN0aW9uID0gUGFub1ZpZXdlci5faXNWYWxpZFRvdWNoRGlyZWN0aW9uKG9wdGlvbnMudG91Y2hEaXJlY3Rpb24pID9cblx0XHRcdG9wdGlvbnMudG91Y2hEaXJlY3Rpb24gOiBZYXdQaXRjaENvbnRyb2wuVE9VQ0hfRElSRUNUSU9OX0FMTDtcblx0XHRjb25zdCB5YXdQaXRjaENvbmZpZyA9IE9iamVjdC5hc3NpZ24ob3B0aW9ucywge1xuXHRcdFx0ZWxlbWVudDogY29udGFpbmVyLFxuXHRcdFx0eWF3OiB0aGlzLl95YXcsXG5cdFx0XHRwaXRjaDogdGhpcy5fcGl0Y2gsXG5cdFx0XHRmb3Y6IHRoaXMuX2Zvdixcblx0XHRcdGd5cm9Nb2RlOiB0aGlzLl9neXJvTW9kZSxcblx0XHRcdGZvdlJhbmdlLFxuXHRcdFx0YXNwZWN0UmF0aW86IHRoaXMuX2FzcGVjdFJhdGlvLFxuXHRcdFx0dG91Y2hEaXJlY3Rpb25cblx0XHR9KTtcblxuXHRcdHRoaXMuX2lzUmVhZHkgPSBmYWxzZTtcblxuXHRcdHRoaXMuX2luaXRZYXdQaXRjaENvbnRyb2woeWF3UGl0Y2hDb25maWcpO1xuXHRcdHRoaXMuX2luaXRSZW5kZXJlcih0aGlzLl95YXcsIHRoaXMuX3BpdGNoLCB0aGlzLl9mb3YsIHRoaXMuX3Byb2plY3Rpb25UeXBlLCB0aGlzLl9jdWJlbWFwQ29uZmlnKTtcblx0fVxuXG5cdC8qKlxuXHRcdCogR2V0IHRoZSB2aWRlbyBlbGVtZW50IHRoYXQgdGhlIHZpZXdlciBpcyBjdXJyZW50bHkgcGxheWluZy4gWW91IGNhbiB1c2UgdGhpcyBmb3IgcGxheWJhY2suXG5cdFx0KiBAa28g67ew7Ja06rCAIO2YhOyerCDsgqzsmqkg7KSR7J24IOu5hOuUlOyYpCDsmpTshozrpbwg7Ja77Iq164uI64ukLiDsnbQg7JqU7IaM66W8IOydtOyaqe2VtCDruYTrlJTsmKTsnZgg7Luo7Yq466Gk7J2EIO2VoCDsiJgg7J6I7Iq164uI64ukLlxuXHRcdCogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjZ2V0VmlkZW9cblx0XHQqIEByZXR1cm4ge0hUTUxWaWRlb0VsZW1lbnR9IEhUTUxWaWRlb0VsZW1lbnQ8a28+SFRNTFZpZGVvRWxlbWVudDwva28+XG5cdFx0KiBAZXhhbXBsZVxuXHRcdCogdmFyIHZpZGVvVGFnID0gcGFub1ZpZXdlci5nZXRWaWRlbygpO1xuXHRcdCogdmlkZW9UYWcucGxheSgpOyAvLyBwbGF5IHZpZGVvIVxuXHRcdCovXG5cdGdldFZpZGVvKCkge1xuXHRcdGlmICghdGhpcy5faXNWaWRlbykge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX3Bob3RvU3BoZXJlUmVuZGVyZXIuZ2V0Q29udGVudCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgdmlkZW8gaW5mb3JtYXRpb24gdG8gYmUgdXNlZCBieSB0aGUgdmlld2VyLlxuXHQgKiBAa28g67ew7Ja06rCAIOyCrOyaqe2VoCDsnbTrr7jsp4Ag7KCV67O066W8IOyEpOygle2VqeuLiOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjc2V0VmlkZW9cblx0ICogQHBhcmFtIHtTdHJpbmd8SFRNTFZpZGVvRWxlbWVudHxPYmplY3R9IHZpZGVvIElucHV0IHZpZGVvIHVybCBvciBlbGVtZW50IG9yIGNvbmZpZyBvYmplY3Q8a28+7J6F66ClIOu5hOuUlOyYpCBVUkwg7Zi57J2AIOyXmOumrOuovO2KuCDtmLnsnYAg7ISk7KCV6rCd7LK066W8IO2ZnOyaqShpbWFnZSDsmYAgdmlkZW8g65GYIOykkSDtlZjrgpjrp4wg7ISk7KCVKTwva28+XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtLnByb2plY3Rpb25UeXBlPXtAbGluayBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuUFJPSkVDVElPTl9UWVBFLkVRVUlSRUNUQU5HVUxBUn0oXCJlcXVpcmVjdGFuZ3VsYXJcIildIFByb2plY3Rpb24gVHlwZTxrbz7tlITroZzsoJ3shZgg7YOA7J6FPC9rbz5cblx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtLmN1YmVtYXBDb25maWcgY29uZmlnIGN1YmVtYXAgcHJvamVjdGlvbiBsYXlvdXQuIDxrbz5jdWJlbWFwIHByb2plY3Rpb24gdHlwZSDsnZgg66CI7J207JWE7JuDIOyEpOyglTwva28+XG5cdCAqXG5cdCAqIEByZXR1cm4ge2VnLnZpZXczNjAuUGFub1ZpZXdlcn0gUGFub1ZpZXdlciBpbnN0YW5jZTxrbz5QYW5vVmlld2VyIOyduOyKpO2EtOyKpDwva28+XG5cdCAqIEBleGFtcGxlXG5cdCAqIHBhbm9WaWV3ZXIuc2V0VmlkZW8oXCIvcGF0aC90by92aWRlby92aWRlby5tcDRcIiwge1xuXHQgKiAgICAgcHJvamVjdGlvblR5cGU6IGVnLnZpZXczNjAuUGFub1ZpZXdlci5QUk9KRUNUSU9OX1RZUEUuRVFVSVJFQ1RBTkdVTEFSXG5cdCAqIH0pO1xuXHQgKi9cblx0c2V0VmlkZW8odmlkZW8sIHBhcmFtID0ge30pIHtcblx0XHRpZiAodmlkZW8pIHtcblx0XHRcdHRoaXMuc2V0SW1hZ2UodmlkZW8sIHtcblx0XHRcdFx0cHJvamVjdGlvblR5cGU6IHBhcmFtLnByb2plY3Rpb25UeXBlLFxuXHRcdFx0XHRpc1ZpZGVvOiB0cnVlLFxuXHRcdFx0XHRjdWJlbWFwQ29uZmlnOiBwYXJhbS5jdWJlbWFwQ29uZmlnXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGltYWdlIGluZm9ybWF0aW9uIHRoYXQgdGhlIHZpZXdlciBpcyBjdXJyZW50bHkgdXNpbmcuXG5cdCAqIEBrbyDrt7DslrTqsIAg7ZiE7J6sIOyCrOyaqe2VmOqzoOyeiOuKlCDsnbTrr7jsp4Ag7KCV67O066W8IOyWu+yKteuLiOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjZ2V0SW1hZ2Vcblx0ICogQHJldHVybiB7SW1hZ2V9IEltYWdlIE9iamVjdDxrbz7snbTrr7jsp4Ag6rCd7LK0PC9rbz5cblx0ICogQGV4YW1wbGVcblx0ICogdmFyIGltYWdlT2JqID0gcGFub1ZpZXdlci5nZXRJbWFnZSgpO1xuXHQgKi9cblx0Z2V0SW1hZ2UoKSB7XG5cdFx0aWYgKHRoaXMuX2lzVmlkZW8pIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl9waG90b1NwaGVyZVJlbmRlcmVyLmdldENvbnRlbnQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGltYWdlIGluZm9ybWF0aW9uIHRvIGJlIHVzZWQgYnkgdGhlIHZpZXdlci5cblx0ICogQGtvIOu3sOyWtOqwgCDsgqzsmqntlaAg7J2066+47KeAIOygleuztOulvCDshKTsoJXtlanri4jri6QuXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI3NldEltYWdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEltYWdlfE9iamVjdH0gaW1hZ2UgSW5wdXQgaW1hZ2UgdXJsIG9yIGVsZW1lbnQgb3IgY29uZmlnIG9iamVjdDxrbz7snoXroKUg7J2066+47KeAIFVSTCDtmLnsnYAg7JeY66as66i87Yq4IO2YueydgCDshKTsoJXqsJ3ssrTrpbwg7Zmc7JqpKGltYWdlIOyZgCB2aWRlbyDrkZgg7KSRIO2VmOuCmOunjCDshKTsoJXtlZzri6QuKTwva28+XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSBBZGRpdGlvbmFsIGluZm9ybWF0aW9uPGtvPuydtOuvuOyngCDstpTqsIAg7KCV67O0PC9rbz5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXJhbS5wcm9qZWN0aW9uVHlwZT1cImVxdWlyZWN0YW5ndWxhclwiXSBQcm9qZWN0aW9uIFR5cGU8a28+7ZSE66Gc7KCd7IWYIO2DgOyehTwva28+XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbS5jdWJlbWFwQ29uZmlnIGNvbmZpZyBjdWJlbWFwIHByb2plY3Rpb24gbGF5b3V0LiA8a28+Y3ViZW1hcCBwcm9qZWN0aW9uIHR5cGUg66CI7J207JWE7JuDPC9rbz5cblx0ICpcblx0ICogQHJldHVybiB7ZWcudmlldzM2MC5QYW5vVmlld2VyfSBQYW5vVmlld2VyIGluc3RhbmNlPGtvPlBhbm9WaWV3ZXIg7J247Iqk7YS07IqkPC9rbz5cblx0ICogQGV4YW1wbGVcblx0ICogcGFub1ZpZXdlci5zZXRJbWFnZShcIi9wYXRoL3RvL2ltYWdlL2ltYWdlLnBuZ1wiLCB7XG5cdCAqICAgICBwcm9qZWN0aW9uVHlwZTogZWcudmlldzM2MC5QYW5vVmlld2VyLlBST0pFQ1RJT05fVFlQRS5DVUJFTUFQXG5cdCAqIH0pO1xuXHQgKi9cblx0c2V0SW1hZ2UoaW1hZ2UsIHBhcmFtID0ge30pIHtcblx0XHRjb25zdCBjdWJlbWFwQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0XHRvcmRlcjogXCJSTFVEQkZcIixcblx0XHRcdHRpbGVDb25maWc6IHtcblx0XHRcdFx0ZmxpcEhpcm96b250YWw6IGZhbHNlLFxuXHRcdFx0XHRyb3RhdGlvbjogMFxuXHRcdFx0fVxuXHRcdH0sIHBhcmFtLmN1YmVtYXBDb25maWcpO1xuXHRcdGNvbnN0IGlzVmlkZW8gPSAhIShwYXJhbS5pc1ZpZGVvKTtcblxuXHRcdGlmICh0aGlzLl9pbWFnZSAmJiB0aGlzLl9pc1ZpZGVvICE9PSBpc1ZpZGVvKSB7XG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5cdFx0XHRjb25zb2xlLndhcm4oXCJDdXJyZW50bHkgbm90IHN1cHBvcnRpbmcgdG8gY2hhbmdlIGNvbnRlbnQgdHlwZShJbWFnZSA8LS0+IFZpZGVvKVwiKTtcblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKGltYWdlKSB7XG5cdFx0XHR0aGlzLl9pbWFnZSA9IGltYWdlO1xuXHRcdFx0dGhpcy5faXNWaWRlbyA9IGlzVmlkZW87XG5cdFx0XHR0aGlzLl9wcm9qZWN0aW9uVHlwZSA9IHBhcmFtLnByb2plY3Rpb25UeXBlIHx8IFBST0pFQ1RJT05fVFlQRS5FUVVJUkVDVEFOR1VMQVI7XG5cdFx0XHR0aGlzLl9jdWJlbWFwQ29uZmlnID0gY3ViZW1hcENvbmZpZztcblxuXHRcdFx0dGhpcy5fZGVhY3RpdmF0ZSgpO1xuXHRcdFx0dGhpcy5faW5pdFJlbmRlcmVyKHRoaXMuX3lhdywgdGhpcy5fcGl0Y2gsIHRoaXMuX2ZvdiwgdGhpcy5fcHJvamVjdGlvblR5cGUsIHRoaXMuX2N1YmVtYXBDb25maWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB3aGV0aGVyIHRoZSByZW5kZXJlciBhbHdheXMgdXBkYXRlcyB0aGUgdGV4dHVyZSBhbmQgcmVuZGVycy5cblx0ICogQGtvIOugjOuNlOufrOqwgCDtla3sg4Eg7YWN7Iqk7LOQ66W8IOqwseyLoO2VmOqzoCDtmZTrqbTsnYQg66CM642U66eBIO2VoOyngCDsl6zrtoDrpbwg7ISk7KCV7ZWgIOyImCDsnojsirXri4jri6QuXG5cdCAqXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI2tlZXBVcGRhdGVcblx0ICogQHBhcmFtIHtCb29sZWFufSBkb1VwZGF0ZSBXaGVuIHRydWUgdmlld2VyIHdpbGwgYWx3YXlzIHVwZGF0ZSB0ZXh0dXJlIGFuZCByZW5kZXIsIHdoZW4gZmFsc2Ugdmlld2VyIHdpbGwgbm90IHVwZGF0ZSB0ZXh0dXJlIGFuZCByZW5kZXIgb25seSBjYW1lcmEgY29uZmlnIGlzIGNoYW5nZWQuPGtvPnRydWXrqbQg7ZWt7IOBIO2FjeyKpOyzkOulvCDqsLHsi6DtlZjqs6Ag7ZmU66m07J2EIOq3uOumrOuKlCDrsJjrqbQsIGZhbHNl66m0IO2FjeyKpOyzkCDqsLHsi6DsnYAg7ZWY7KeAIOyViuycvOupsCwg7Lm066mU6528IOyalOyGjOyXkCDrs4DtmZTqsIAg7J6I7J2EIOuVjOyXkOunjCDtmZTrqbTsnYQg6re466a964uI64ukLjwva28+XG5cdCAqIEByZXR1cm4ge2VnLnZpZXczNjAuUGFub1ZpZXdlcn0gUGFub1ZpZXdlciBpbnN0YW5jZTxrbz5QYW5vVmlld2VyIOyduOyKpO2EtOyKpDwva28+XG5cdCAqL1xuXHRrZWVwVXBkYXRlKGRvVXBkYXRlKSB7XG5cdFx0dGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlci5rZWVwVXBkYXRlKGRvVXBkYXRlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgcHJvamVjdGlvbiB0eXBlIChlcXVpcmVjdGFuZ3VsYXIvY3ViZSlcblx0ICogQGtvIO2UhOuhnOygneyFmCDtg4DsnoUoRXF1aXJlY3Rhbmd1bGFyIO2YueydgCBDdWJlKeydhCDrsJjtmZjtlanri4jri6QuXG5cdCAqXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI2dldFByb2plY3Rpb25UeXBlXG5cdCAqIEByZXR1cm4ge1N0cmluZ30ge0BsaW5rIGVnLnZpZXczNjAuUGFub1ZpZXdlci5QUk9KRUNUSU9OX1RZUEV9XG5cdCAqL1xuXHRnZXRQcm9qZWN0aW9uVHlwZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdGlvblR5cGU7XG5cdH1cblxuXHRfaW5pdFJlbmRlcmVyKHlhdywgcGl0Y2gsIGZvdiwgcHJvamVjdGlvblR5cGUsIGN1YmVtYXBDb25maWcpIHtcblx0XHR0aGlzLl9waG90b1NwaGVyZVJlbmRlcmVyID0gbmV3IFBhbm9JbWFnZVJlbmRlcmVyKFxuXHRcdFx0dGhpcy5faW1hZ2UsXG5cdFx0XHR0aGlzLl93aWR0aCxcblx0XHRcdHRoaXMuX2hlaWdodCxcblx0XHRcdHRoaXMuX2lzVmlkZW8sXG5cdFx0XHR7XG5cdFx0XHRcdGluaXRpYWxZYXc6IHlhdyxcblx0XHRcdFx0aW5pdGlhbFBpdGNoOiBwaXRjaCxcblx0XHRcdFx0ZmllbGRPZlZpZXc6IGZvdixcblx0XHRcdFx0aW1hZ2VUeXBlOiBwcm9qZWN0aW9uVHlwZSxcblx0XHRcdFx0Y3ViZW1hcENvbmZpZ1xuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHR0aGlzLl9iaW5kUmVuZGVyZXJIYW5kbGVyKCk7XG5cblx0XHR0aGlzLl9waG90b1NwaGVyZVJlbmRlcmVyXG5cdFx0XHQuYmluZFRleHR1cmUoKVxuXHRcdFx0LnRoZW4oKCkgPT4gdGhpcy5fYWN0aXZhdGUoKSlcblx0XHRcdC5jYXRjaCgoKSA9PiB7XG5cdFx0XHRcdHRoaXMuX3RyaWdnZXJFdmVudChFVkVOVFMuRVJST1IsIHtcblx0XHRcdFx0XHR0eXBlOiBFUlJPUl9UWVBFLkZBSUxfQklORF9URVhUVVJFLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IFwiZmFpbGVkIHRvIGJpbmQgdGV4dHVyZVwiXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogdXBkYXRlIHZhbHVlcyBvZiBZYXdQaXRjaENvbnRyb2wgaWYgbmVlZGVkLlxuXHQgKiBGb3IgZXhhbXBsZSwgSW4gUGFub3JhbWEgbW9kZSwgaW5pdGlhbCBmb3YgYW5kIHBpdGNoUmFuZ2UgaXMgY2hhbmdlZCBieSBhc3BlY3QgcmF0aW8gb2YgaW1hZ2UuXG5cdCAqXG5cdCAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBpc1JlYWR5IHN0YXR1cyBpcyB0cnVlLlxuXHQgKi9cblx0X3VwZGF0ZVlhd1BpdGNoSWZOZWVkZWQoKSB7XG5cdFx0aWYgKHRoaXMuX3Byb2plY3Rpb25UeXBlID09PSBQYW5vVmlld2VyLlByb2plY3Rpb25UeXBlLlBBTk9SQU1BKSB7XG5cdFx0XHQvLyB1cGRhdGUgZm92IGJ5IGFzcGVjdCByYXRpb1xuXHRcdFx0Y29uc3QgaW1hZ2UgPSB0aGlzLl9waG90b1NwaGVyZVJlbmRlcmVyLmdldENvbnRlbnQoKTtcblx0XHRcdGxldCBpbWFnZUFzcGVjdFJhdGlvID0gaW1hZ2UubmF0dXJhbFdpZHRoIC8gaW1hZ2UubmF0dXJhbEhlaWdodDtcblx0XHRcdGxldCBpc0NpcmN1bGFyO1xuXHRcdFx0bGV0IHlhd1NpemU7XG5cdFx0XHRsZXQgbWF4Rm92O1xuXG5cdFx0XHQvLyBJZiBoZWlnaHQgaXMgbGFyZ2VyIHRoYW4gd2lkdGgsIHRoZW4gd2UgYXNzdW1lIGl0J3Mgcm90YXRlZCBieSA5MCBkZWdyZWUuXG5cdFx0XHRpZiAoaW1hZ2VBc3BlY3RSYXRpbyA8IDEpIHtcblx0XHRcdFx0Ly8gU28gaW52ZXJzZSB0aGUgYXNwZWN0IHJhdGlvLlxuXHRcdFx0XHRpbWFnZUFzcGVjdFJhdGlvID0gMSAvIGltYWdlQXNwZWN0UmF0aW87XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpbWFnZUFzcGVjdFJhdGlvIDwgNikge1xuXHRcdFx0XHR5YXdTaXplID0gZ2xNYXRyaXgudG9EZWdyZWUoaW1hZ2VBc3BlY3RSYXRpbyk7XG5cdFx0XHRcdGlzQ2lyY3VsYXIgPSBmYWxzZTtcblx0XHRcdFx0Ly8gMC41IG1lYW5zIHJhdGlvIG9mIGhhbGYgaGVpZ2h0IG9mIGN5bGluZGVyKDAuNSkgYW5kIHJhZGl1cyBvZiBjeWxpZGVyKDEpLiAwLjUvMSA9IDAuNVxuXHRcdFx0XHRtYXhGb3YgPSBnbE1hdHJpeC50b0RlZ3JlZShNYXRoLmF0YW4oMC41KSkgKiAyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eWF3U2l6ZSA9IDM2MDtcblx0XHRcdFx0aXNDaXJjdWxhciA9IHRydWU7XG5cdFx0XHRcdG1heEZvdiA9ICgzNjAgLyBpbWFnZUFzcGVjdFJhdGlvKTsgLy8gTWFrZSBpdCA1IGZpeGVkIGFzIGF4ZXMgZG9lcy5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY29uc29sZS5sb2coXCJfdXBkYXRlWWF3UGl0Y2hJZk5lZWRlZFwiLCBtYXhGb3YsIFwiYXNwZWN0UmF0aW9cIiwgaW1hZ2UubmF0dXJhbFdpZHRoLCBpbWFnZS5uYXR1cmFsSGVpZ2h0LCBcInlhd1NpemVcIiwgeWF3U2l6ZSk7XG5cdFx0XHRjb25zdCBtaW5Gb3YgPSAodGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcImZvdlJhbmdlXCIpKVswXTtcblxuXHRcdFx0Ly8gdGhpcyBvcHRpb24gc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBmb3YgaXMgc2V0LlxuXHRcdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbih7XG5cdFx0XHRcdFwiZm92XCI6IG1heEZvdiwgLyogcGFyYW1ldGVyIGZvciBpbnRlcm5hbCB2YWxpZGF0aW9uIGZvciBwaXRjaHJhbmdlICovXG5cdFx0XHRcdFwieWF3UmFuZ2VcIjogWy15YXdTaXplIC8gMiwgeWF3U2l6ZSAvIDJdLFxuXHRcdFx0XHRpc0NpcmN1bGFyLFxuXHRcdFx0XHRcInBpdGNoUmFuZ2VcIjogWy1tYXhGb3YgLyAyLCBtYXhGb3YgLyAyXSxcblx0XHRcdFx0XCJmb3ZSYW5nZVwiOiBbbWluRm92LCBtYXhGb3ZdXG5cdFx0XHR9KTtcblx0XHRcdHRoaXMubG9va0F0KHtmb3Y6IG1heEZvdn0pO1xuXHRcdH1cblx0fVxuXG5cdF9iaW5kUmVuZGVyZXJIYW5kbGVyKCkge1xuXHRcdHRoaXMuX3Bob3RvU3BoZXJlUmVuZGVyZXIub24oUGFub0ltYWdlUmVuZGVyZXIuRVZFTlRTLkVSUk9SLCBlID0+IHtcblx0XHRcdHRoaXMudHJpZ2dlcihFVkVOVFMuRVJST1IsIGUpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlci5vbihQYW5vSW1hZ2VSZW5kZXJlci5FVkVOVFMuUkVOREVSSU5HX0NPTlRFWFRfTE9TVCwgZSA9PiB7XG5cdFx0XHR0aGlzLl9kZWFjdGl2YXRlKCk7XG5cdFx0XHR0aGlzLnRyaWdnZXIoRVZFTlRTLkVSUk9SLCB7XG5cdFx0XHRcdHR5cGU6IEVSUk9SX1RZUEUuUkVOREVSSU5HX0NPTlRFWFRfTE9TVCxcblx0XHRcdFx0bWVzc2FnZTogXCJ3ZWJnbCByZW5kZXJpbmcgY29udGV4dCBsb3N0XCJcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0X2luaXRZYXdQaXRjaENvbnRyb2woeWF3UGl0Y2hDb25maWcpIHtcblx0XHR0aGlzLl95YXdQaXRjaENvbnRyb2wgPSBuZXcgWWF3UGl0Y2hDb250cm9sKHlhd1BpdGNoQ29uZmlnKTtcblxuXHRcdHRoaXMuX3lhd1BpdGNoQ29udHJvbC5vbihFVkVOVFMuQU5JTUFUSU9OX0VORCwgZSA9PiB7XG5cdFx0XHR0aGlzLl90cmlnZ2VyRXZlbnQoRVZFTlRTLkFOSU1BVElPTl9FTkQsIGUpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLm9uKFwiY2hhbmdlXCIsIGUgPT4ge1xuXHRcdFx0dGhpcy5feWF3ID0gZS55YXc7XG5cdFx0XHR0aGlzLl9waXRjaCA9IGUucGl0Y2g7XG5cdFx0XHR0aGlzLl9mb3YgPSBlLmZvdjtcblx0XHRcdHRoaXMuX3F1YXRlcm5pb24gPSBlLnF1YXRlcm5pb247XG5cblx0XHRcdHRoaXMuX3RyaWdnZXJFdmVudChFVkVOVFMuVklFV19DSEFOR0UsIGUpO1xuXHRcdH0pO1xuXHR9XG5cblx0X3RyaWdnZXJFdmVudChuYW1lLCBwYXJhbSkge1xuXHRcdGNvbnN0IGV2dCA9IHBhcmFtIHx8IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogRXZlbnRzIHRoYXQgaXMgZmlyZWQgd2hlbiBlcnJvciBvY2N1cnNcblx0XHQgKiBAa28g7JeQ65+sIOuwnOyDnSDsi5wg67Cc7IOd7ZWY64qUIOydtOuypO2KuFxuXHRcdCAqIEBuYW1lIGVnLnZpZXczNjAuUGFub1ZpZXdlciNlcnJvclxuXHRcdCAqIEBldmVudFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSBUaGUgb2JqZWN0IG9mIGRhdGEgdG8gYmUgc2VudCB0byBhbiBldmVudCA8a28+7J2067Kk7Yq47JeQIOyghOuLrOuQmOuKlCDrjbDsnbTthLAg6rCd7LK0PC9rbz5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gcGFyYW0udHlwZSBFcnJvciB0eXBlXG5cdFx0ICogXHRcdDEwOiBJTlZBTElEX0RFVklDRTogVW5zdXBwb3J0ZWQgZGV2aWNlXG5cdFx0ICogXHRcdDExOiBOT19XRUJHTDogV2ViZ2wgbm90IHN1cHBvcnRcblx0XHQgKiBcdFx0MTIsIEZBSUxfSU1BR0VfTE9BRDogRmFpbGVkIHRvIGxvYWQgaW1hZ2Vcblx0XHQgKiBcdFx0MTM6IEZBSUxfQklORF9URVhUVVJFOiBGYWlsZWQgdG8gYmluZCB0ZXh0dXJlXG5cdFx0ICogXHRcdDE0OiBJTlZBTElEX1JFU09VUkNFOiBPbmx5IG9uZSByZXNvdXJjZShpbWFnZSBvciB2aWRlbykgc2hvdWxkIGJlIHNwZWNpZmllZFxuXHRcdCAqIFx0XHQxNTogUkVOREVSSU5HX0NPTlRFWFRfTE9TVDogV2ViR0wgY29udGV4dCBsb3N0IG9jY3VycmVkXG5cdFx0ICogPGtvPuyXkOufrCDsooXrpZhcblx0XHQgKiBcdFx0MTA6IElOVkFMSURfREVWSUNFOiDrr7jsp4Dsm5Ag6riw6riwXG5cdFx0ICogXHRcdDExOiBOT19XRUJHTDogV0VCR0wg66+47KeA7JuQXG5cdFx0ICogXHRcdDEyLCBGQUlMX0lNQUdFX0xPQUQ6IOydtOuvuOyngCDroZzrk5wg7Iuk7YyoXG5cdFx0ICogXHRcdDEzOiBGQUlMX0JJTkRfVEVYVFVSRTog7YWN7Iqk7LOQIOuwlOyduOuUqSDsi6TtjKhcblx0XHQgKiBcdFx0MTQ6IElOVkFMSURfUkVTT1VSQ0U6IOumrOyGjOyKpCDsp4DsoJUg7Jik66WYIChpbWFnZSDtmLnsnYAgdmlkZW8g7KSRIO2VmOuCmOunjCDsp4DsoJXrkJjslrTslbwg7ZWoKVxuXHRcdCAqIFx0XHQxNTogUkVOREVSSU5HX0NPTlRFWFRfTE9TVDogV2ViR0wgY29udGV4dCBsb3N0IOuwnOyDnVxuXHRcdCAqIDwva28+XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtLm1lc3NhZ2UgRXJyb3IgbWVzc2FnZSA8a28+7JeQ65+sIOuplOyLnOyngDwva28+XG5cdFx0ICogQHNlZSB7QGxpbmsgZWcudmlldzM2MC5QYW5vVmlld2VyLkVSUk9SX1RZUEV9XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKlxuXHRcdCAqIHZpd2VyLm9uKHtcblx0XHQgKlx0XCJlcnJvclwiIDogZnVuY3Rpb24oZXZ0KSB7XG5cdFx0ICpcdFx0Ly8gZXZ0LnR5cGUgPT09IDEzXG5cdFx0ICpcdFx0Ly8gZXZ0Lm1lc3NhZ2UgPT09IFwiZmFpbGVkIHRvIGJpbmQgdGV4dHVyZVwiXG5cdFx0ICogfSk7XG5cdFx0ICpcblx0XHQgKiAvLyBjb25zdGFudCBjYW4gYmUgdXNlZFxuXHRcdCAqIHZpd2VyLm9uKHtcblx0XHQgKlx0ZWcudmlldzM2MC5QYW5vVmlld2VyLkVWRU5UUy5FUlJPUiA6IGZ1bmN0aW9uKGV2dCkge1xuXHRcdCAqXHRcdC8vIGV2dC50eXBlID09PSBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuRVJST1JfVFlQRS5GQUlMX0JJTkRfVEVYVFVSRVxuXHRcdCAqXHRcdC8vIGV2dC5tZXNzYWdlID09PSBcImZhaWxlZCB0byBiaW5kIHRleHR1cmVcIlxuXHRcdCAqIH0pO1xuXHRcdCAqL1xuXG5cdFx0LyoqXG5cdFx0ICogRXZlbnRzIHRoYXQgaXMgZmlyZWQgd2hlbiBQYW5vVmlld2VyIGlzIHJlYWR5IHRvIGdvLlxuXHRcdCAqIEBrbyBQYW5vVmlld2VyIOqwgCDspIDruYTrkJwg7IOB7YOc7JeQIOuwnOyDne2VmOuKlCDsnbTrsqTtirhcblx0XHQgKiBAbmFtZSBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjcmVhZHlcblx0XHQgKiBAZXZlbnRcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICpcblx0XHQgKiB2aXdlci5vbih7XG5cdFx0ICpcdFwicmVhZHlcIiA6IGZ1bmN0aW9uKGV2dCkge1xuXHRcdCAqXHRcdC8vIFBhbm9WaWV3ZXIgaXMgcmVhZHkgdG8gc2hvdyBpbWFnZSBhbmQgaGFuZGxlIHVzZXIgaW50ZXJhY3Rpb24uXG5cdFx0ICogfSk7XG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiBFdmVudHMgdGhhdCBpcyBmaXJlZCB3aGVuIGRpcmVjdGlvbiBvciBmb3YgaXMgY2hhbmdlZC5cblx0XHQgKiBAa28gUGFub1ZpZXdlciDsl5DshJwg67CU652867O06rOgIOyeiOuKlCDrsKntlqXsnbTrgpggRk9WKO2ZlOqwgSnqsIAg67OA6rK965CY7JeI7J2E65WMIOuwnOyDne2VmOuKlCDsnbTrsqTtirhcblx0XHQgKiBAbmFtZSBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjdmlld0NoYW5nZVxuXHRcdCAqIEBldmVudFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbSBUaGUgb2JqZWN0IG9mIGRhdGEgdG8gYmUgc2VudCB0byBhbiBldmVudCA8a28+7J2067Kk7Yq47JeQIOyghOuLrOuQmOuKlCDrjbDsnbTthLAg6rCd7LK0PC9rbz5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gcGFyYW0ueWF3IHlhdzxrbz55YXc8L2tvPlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbS5waXRjaCBwaXRjaCA8a28+cGl0Y2g8L2tvPlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbS5mb3YgRmllbGQgb2YgdmlldyAoZm92KSA8a28+7ZmU6rCBPC9rbz5cblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqXG5cdFx0ICogdml3ZXIub24oe1xuXHRcdCAqXHRcInZpZXdDaGFuZ2VcIiA6IGZ1bmN0aW9uKGV2dCkge1xuXHRcdCAqXHRcdC8vZXZ0LnlhdywgZXZ0LnBpdGNoLCBldnQuZm92IGlzIGF2YWlsYWJsZS5cblx0XHQgKiB9KTtcblx0XHQgKi9cblxuXHRcdC8qKlxuXHRcdCAqIEV2ZW50cyB0aGF0IGlzIGZpcmVkIHdoZW4gYW5pbWF0aW9uIHdoaWNoIGlzIHRyaWdnZXJlZCBieSBpbmVydGlhIGlzIGVuZGVkLlxuXHRcdCAqIEBrbyDqtIDshLHsl5Ag7J2Y7ZWcIOyVoOuLiOuplOydtOyFmCDrj5nsnpHsnbQg7JmE66OM65CY7JeI7J2E65WMIOuwnOyDne2VmOuKlCDsnbTrsqTtirhcblx0XHQgKiBAbmFtZSBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjYW5pbWF0aW9uRW5kXG5cdFx0ICogQGV2ZW50XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKlxuXHRcdCAqIHZpd2VyLm9uKHtcblx0XHQgKlx0XCJhbmltYXRpb25FbmRcIiA6IGZ1bmN0aW9uKGV2dCkge1xuXHRcdCAqXHRcdC8vIGFuaW1hdGlvbiBpcyBlbmRlZC5cblx0XHQgKiB9KTtcblx0XHQgKi9cblx0XHRyZXR1cm4gdGhpcy50cmlnZ2VyKG5hbWUsIGV2dCk7XG5cdH1cblxuXHQvKipcblx0ICogV2hlbiBzZXQgdHJ1ZSwgZW5hYmxlcyB6b29tIHdpdGggdGhlIHdoZWVsIG9yIHBpbmNoIGdlc3R1cmUuIEhvd2V2ZXIsIGluIHRoZSBjYXNlIG9mIHRvdWNoLCBwaW5jaCB3b3JrcyBvbmx5IHdoZW4gdGhlIHRvdWNoRGlyZWN0aW9uIHNldHRpbmcgaXMge0BsaW5rIGVnLnZpZXczNjAuUGFub1ZpZXdlci5UT1VDSF9ESVJFQ1RJT04uQUxMfS5cblx0ICogQGtvIHRydWUg66GcIOyEpOyglSDsi5wg7ZygIO2YueydgCDsp5HquLAg64+Z7J6R7Jy866GcIO2ZleuMgC/stpXshowg7ZWgIOyImCDsnojsirXri4jri6QuIGZhbHNlIOyEpOyglSDsi5wg7ZmV64yAL+y2leyGjCDquLDriqXsnYQg67mE7Zmc7ISx7ZmUIO2VqeuLiOuLpC4g64uoLCDthLDsuZjsnbgg6rK97JqwIHRvdWNoRGlyZWN0aW9uIOyEpOygleydtCB7QGxpbmsgZWcudmlldzM2MC5QYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTi5BTEx9IOyduCDqsr3smrDsl5Drp4wgcGluY2gg6rCAIOuPmeyeke2VqeuLiOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjc2V0VXNlWm9vbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHVzZVpvb21cblx0ICogQHJldHVybiB7ZWcudmlldzM2MC5QYW5vVmlld2VyfSBQYW5vVmlld2VyIGluc3RhbmNlPGtvPlBhbm9WaWV3ZXIg7J247Iqk7YS07IqkPC9rbz5cblx0ICovXG5cdHNldFVzZVpvb20odXNlWm9vbSkge1xuXHRcdHR5cGVvZiB1c2Vab29tID09PSBcImJvb2xlYW5cIiAmJiB0aGlzLl95YXdQaXRjaENvbnRyb2wub3B0aW9uKFwidXNlWm9vbVwiLCB1c2Vab29tKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdoZW4gdHJ1ZSwgZW5hYmxlcyB0aGUga2V5Ym9hcmQgbW92ZSBrZXkgY29udHJvbDogYXdzZCwgYXJyb3cga2V5c1xuXHQgKiBAa28gdHJ1ZeydtOuptCDtgqTrs7Trk5wg7J2064+ZIO2CpCDsu6jtirjroaTsnYQg7Zmc7ISx7ZmU7ZWp64uI64ukLiAoYXdzZCwg7ZmU7IK07ZGcIO2CpClcblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjc2V0VXNlS2V5Ym9hcmRcblx0ICogQHBhcmFtIHtCb29sZWFufSB1c2VLZXlib2FyZFxuXHQgKiBAcmV0dXJuIHtlZy52aWV3MzYwLlBhbm9WaWV3ZXJ9IFBhbm9WaWV3ZXIgaW5zdGFuY2U8a28+UGFub1ZpZXdlciDsnbjsiqTthLTsiqQ8L2tvPlxuXHQgKi9cblx0c2V0VXNlS2V5Ym9hcmQodXNlS2V5Ym9hcmQpIHtcblx0XHR0aGlzLl95YXdQaXRjaENvbnRyb2wub3B0aW9uKFwidXNlS2V5Ym9hcmRcIiwgdXNlS2V5Ym9hcmQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgY29udHJvbCB0aHJvdWdoIGRldmljZSBtb3Rpb24uIChcIm5vbmVcIiwgXCJ5YXdQaXRjaFwiLCBcIlZSXCIpXG5cdCAqIEBrbyDrlJTrsJTsnbTsiqQg7JuA7KeB7J6E7J2EIO2Gte2VnCDsu6jtirjroaTsnYQg7Zmc7ISx7ZmUIO2VqeuLiOuLpC4gKFwibm9uZVwiLCBcInlhd1BpdGNoXCIsIFwiVlJcIilcblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjc2V0R3lyb01vZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGd5cm9Nb2RlIHtAbGluayBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuR1lST19NT0RFfVxuXHQgKiBAcmV0dXJuIHtlZy52aWV3MzYwLlBhbm9WaWV3ZXJ9IFBhbm9WaWV3ZXIgaW5zdGFuY2U8a28+UGFub1ZpZXdlciDsnbjsiqTthLTsiqQ8L2tvPlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBwYW5vVmlld2VyLnNldEd5cm9Nb2RlKFwieWF3UGl0Y2hcIik7XG5cdCAqIC8vZXF1aXZhbGVudFxuXHQgKiBwYW5vVmlld2VyLnNldEd5cm9Nb2RlKGVnLnZpZXczNjAuUGFub1ZpZXdlci5HWVJPX01PREUuWUFXUElUQ0gpO1xuXHQgKi9cblx0c2V0R3lyb01vZGUoZ3lyb01vZGUpIHtcblx0XHR0aGlzLl95YXdQaXRjaENvbnRyb2wub3B0aW9uKFwiZ3lyb01vZGVcIiwgZ3lyb01vZGUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgcmFuZ2Ugb2YgY29udHJvbGxhYmxlIEZPViB2YWx1ZXNcblx0ICogQGtvIOygnOyWtCDqsIDriqXtlZwgRk9WIOq1rOqwhOydhCDshKTsoJXtlanri4jri6QuXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI3NldEZvdlJhbmdlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhbmdlXG5cdCAqIEByZXR1cm4ge2VnLnZpZXczNjAuUGFub1ZpZXdlcn0gUGFub1ZpZXdlciBpbnN0YW5jZTxrbz5QYW5vVmlld2VyIOyduOyKpO2EtOyKpDwva28+XG5cdCAqIEBleGFtcGxlXG5cdCAqIHBhbm9WaWV3ZXIuc2V0Rm92UmFuZ2UoWzUwLCA5MF0pO1xuXHQgKi9cblx0c2V0Rm92UmFuZ2UocmFuZ2UpIHtcblx0XHR0aGlzLl95YXdQaXRjaENvbnRyb2wub3B0aW9uKFwiZm92UmFuZ2VcIiwgcmFuZ2UpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHRpbmcgdGhlIHJhbmdlIG9mIGNvbnRyb2xsYWJsZSBGT1YgdmFsdWVzXG5cdCAqIEBrbyDsoJzslrQg6rCA64ql7ZWcIEZPViDqtazqsITsnYQg67CY7ZmY7ZWp64uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNnZXRGb3ZSYW5nZVxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICogQGV4YW1wbGVcblx0ICogdmFyIHJhbmdlID0gcGFub1ZpZXdlci5nZXRGb3ZSYW5nZSgpOyAvL1s1MCwgOTBdXG5cdCAqL1xuXHRnZXRGb3ZSYW5nZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcImZvdlJhbmdlXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBzaXplIG9mIGNhbnZhcyBlbGVtZW50IGJ5IGl0J3MgY29udGFpbmVyIGVsZW1lbnQncyBvciBzcGVjaWZpZWQgc2l6ZS4gSWYgc2l6ZSBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgc2l6ZSBvZiB0aGUgY29udGFpbmVyIGFyZWEgaXMgb2J0YWluZWQgYW5kIHVwZGF0ZWQgdG8gdGhhdCBzaXplLlxuXHQgKiBAa28g7LqU67KE7IqkIOyXmOumrOuovO2KuOydmCDtgazquLDrpbwg7Luo7YWM7J2064SIIOyXmOumrOuovO2KuOydmCDtgazquLDrgpgg7KeA7KCV65CcIO2BrOq4sOuhnCDsl4XrjbDsnbTtirjtlanri4jri6QuIOunjOyVvSBzaXplIOqwgCDsp4DsoJXrkJjsp4Ag7JWK7Jy866m0IOy7qO2FjOydtOuEiCDsmIHsl63snZgg7YGs6riw66W8IOyWu+yWtOyZgCDtlbTri7kg7YGs6riw66GcIOqwseyLoO2VqeuLiOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjdXBkYXRlVmlld3BvcnREaW1lbnNpb25zXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbc2l6ZV1cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzaXplLndpZHRoPXdpZHRoIG9mIGNvbnRhaW5lcl1cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzaXplLmhlaWdodD1oZWlnaHQgb2YgY29udGFpbmVyXVxuXHQgKiBAcmV0dXJuIHtlZy52aWV3MzYwLlBhbm9WaWV3ZXJ9IFBhbm9WaWV3ZXIgaW5zdGFuY2U8a28+UGFub1ZpZXdlciDsnbjsiqTthLTsiqQ8L2tvPlxuXHQgKi9cblx0dXBkYXRlVmlld3BvcnREaW1lbnNpb25zKHNpemUgPSB7d2lkdGg6IHVuZGVmaW5lZCwgaGVpZ2h0OiB1bmRlZmluZWR9KSB7XG5cdFx0aWYgKCF0aGlzLl9pc1JlYWR5KSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRsZXQgY29udGFpbmVyU2l6ZTtcblxuXHRcdGlmIChzaXplLndpZHRoID09PSB1bmRlZmluZWQgfHwgc2l6ZS5oZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29udGFpbmVyU2l6ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgd2lkdGggPSBzaXplLndpZHRoIHx8IHBhcnNlSW50KGNvbnRhaW5lclNpemUud2lkdGgsIDEwKTtcblx0XHRjb25zdCBoZWlnaHQgPSBzaXplLmhlaWdodCB8fCBwYXJzZUludChjb250YWluZXJTaXplLmhlaWdodCwgMTApO1xuXG5cdFx0Ly8gU2tpcCBpZiB2aWV3cG9ydCBpcyBub3QgY2hhbmdlZC5cblx0XHRpZiAod2lkdGggPT09IHRoaXMuX3dpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5faGVpZ2h0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuXHRcdHRoaXMuX2FzcGVjdFJhdGlvID0gd2lkdGggLyBoZWlnaHQ7XG5cdFx0dGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlci51cGRhdGVWaWV3cG9ydERpbWVuc2lvbnMod2lkdGgsIGhlaWdodCk7XG5cdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcImFzcGVjdFJhdGlvXCIsIHRoaXMuX2FzcGVjdFJhdGlvKTtcblx0XHR0aGlzLl95YXdQaXRjaENvbnRyb2wudXBkYXRlUGFuU2NhbGUoe2hlaWdodH0pO1xuXG5cdFx0dGhpcy5sb29rQXQoe30sIDApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgY3VycmVudCBmaWVsZCBvZiB2aWV3KEZPVilcblx0ICogQGtvIO2YhOyerCBmaWVsZCBvZiB2aWV3KEZPVikg6rCS7J2EIOuwmO2ZmO2VqeuLiOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjZ2V0Rm92XG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICovXG5cdGdldEZvdigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZm92O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgaG9yaXpvbnRhbCBmaWVsZCBvZiB2aWV3IGluIGRlZ3JlZVxuXHQgKi9cblx0X2dldEhGb3YoKSB7XG5cdFx0cmV0dXJuIGdsTWF0cml4LnRvRGVncmVlKFxuXHRcdFx0MiAqIE1hdGguYXRhbih0aGlzLl9hc3BlY3RSYXRpbyAqIE1hdGgudGFuKGdsTWF0cml4LnRvUmFkaWFuKHRoaXMuX2ZvdikgLyAyKSkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBjdXJyZW50IHlhdyB2YWx1ZVxuXHQgKiBAa28g7ZiE7J6sIHlhdyDqsJLsnYQg67CY7ZmY7ZWp64uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNnZXRZYXdcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKi9cblx0Z2V0WWF3KCkge1xuXHRcdHJldHVybiB0aGlzLl95YXc7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGN1cnJlbnQgcGl0Y2ggdmFsdWVcblx0ICogQGtvIO2YhOyerCBwaXRjaCDqsJLsnYQg67CY7ZmY7ZWp64uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNnZXRQaXRjaFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqL1xuXHRnZXRQaXRjaCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGl0Y2g7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSByYW5nZSBvZiBjb250cm9sbGFibGUgWWF3IHZhbHVlc1xuXHQgKiBAa28g7Luo7Yq466GkIOqwgOuKpe2VnCBZYXcg6rWs6rCE7J2EIOuwmO2ZmO2VqeuLiOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjZ2V0WWF3UmFuZ2Vcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqL1xuXHRnZXRZYXdSYW5nZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcInlhd1JhbmdlXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgcmFuZ2Ugb2YgY29udHJvbGxhYmxlIFBpdGNoIHZhbHVlc1xuXHQgKiBAa28g7Luo7Yq466GkIOqwgOuKpe2VnCBQaXRjaCDqtazqsITsnYQg6rCA7KC47Ji164uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNnZXRQaXRjaFJhbmdlXG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKi9cblx0Z2V0UGl0Y2hSYW5nZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcInBpdGNoUmFuZ2VcIik7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRoZSByYW5nZSBvZiBjb250cm9sbGFibGUgeWF3XG5cdCAqIEBrbyDsu6jtirjroaQg6rCA64ql7ZWcIFlhdyDqtazqsITsnYQg67CY7ZmY7ZWp64uI64ukLlxuXHQgKiBAbWV0aG9kIGVnLnZpZXczNjAuUGFub1ZpZXdlciNzZXRZYXdSYW5nZVxuXHQgKiBAcGFyYW0ge0FycmF5fSByYW5nZVxuXHQgKiBAcmV0dXJuIHtlZy52aWV3MzYwLlBhbm9WaWV3ZXJ9IFBhbm9WaWV3ZXIgaW5zdGFuY2U8a28+UGFub1ZpZXdlciDsnbjsiqTthLTsiqQ8L2tvPlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBwYW5vVmlld2VyLnNldFlhd1JhbmdlKFstOTAsIDkwXSk7XG5cdCAqL1xuXHRzZXRZYXdSYW5nZSh5YXdSYW5nZSkge1xuXHRcdHRoaXMuX3lhd1BpdGNoQ29udHJvbC5vcHRpb24oXCJ5YXdSYW5nZVwiLCB5YXdSYW5nZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRoZSByYW5nZSBvZiBjb250cm9sbGFibGUgUGl0Y2ggdmFsdWVzXG5cdCAqIEBrbyDsu6jtirjroaQg6rCA64ql7ZWcIFBpdGNoIOq1rOqwhOydhCDshKTsoJXtlanri4jri6QuXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI3NldFBpdGNoUmFuZ2Vcblx0ICogQHBhcmFtIHtBcnJheX0gcmFuZ2Vcblx0ICogQHJldHVybiB7ZWcudmlldzM2MC5QYW5vVmlld2VyfSBQYW5vVmlld2VyIGluc3RhbmNlPGtvPlBhbm9WaWV3ZXIg7J247Iqk7YS07IqkPC9rbz5cblx0ICogQGV4YW1wbGVcblx0ICogcGFub1ZpZXdlci5zZXRQaXRjaFJhbmdlKFstNDAsIDQwXSk7XG5cdCAqL1xuXHRzZXRQaXRjaFJhbmdlKHBpdGNoUmFuZ2UpIHtcblx0XHR0aGlzLl95YXdQaXRjaENvbnRyb2wub3B0aW9uKFwicGl0Y2hSYW5nZVwiLCBwaXRjaFJhbmdlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgd2hldGhlciB0byBkaXNwbGF5IHRoZSBwb2xlIGJ5IGxpbWl0aW5nIHRoZSBwaXRjaCByYW5nZS4gSWYgaXQgaXMgdHJ1ZSwgcG9sZSBwb2ludCBjYW4gYmUgZGlzcGxheWVkLiBJZiBpdCBpcyBmYWxzZSwgaXQgaXMgbm90IGRpc3BsYXllZC5cblx0ICogQGtvIHBpdGNoIOuylOychOulvCDsoJztlZztlZjsl6wg6re57KCQ7J2EIO2RnOyLnO2VoOyngOulvCDsp4DsoJXtlanri4jri6QuIHRydWUg7J24IOqyveyasCDqt7nsoJDquYzsp4Ag7ZGc7ZiE7ZWgIOyImCDsnojsnLzrqbAgZmFsc2Ug7J24IOqyveyasCDqt7nsoJDquYzsp4Ag7ZGc7Iuc7ZWY7KeAIOyViuyKteuLiOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjc2V0U2hvd1BvbGVQb2ludFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3dQb2xlUG9pbnRcblx0ICogQHJldHVybiB7ZWcudmlldzM2MC5QYW5vVmlld2VyfSBQYW5vVmlld2VyIGluc3RhbmNlPGtvPlBhbm9WaWV3ZXIg7J247Iqk7YS07IqkPC9rbz5cblx0ICovXG5cdHNldFNob3dQb2xlUG9pbnQoc2hvd1BvbGVQb2ludCkge1xuXHRcdHRoaXMuX3lhd1BpdGNoQ29udHJvbC5vcHRpb24oXCJzaG93UG9sZVBvaW50XCIsIHNob3dQb2xlUG9pbnQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCBhIG5ldyB2aWV3IGJ5IHNldHRpbmcgY2FtZXJhIGNvbmZpZ3VyYXRpb24uIEFueSBwYXJhbWV0ZXJzIG5vdCBzcGVjaWZpZWQgcmVtYWluIHRoZSBzYW1lLlxuXHQgKiBAa28g7Lm066mU6528IOyEpOygleydhCDsp4DsoJXtlZjsl6wg7ZmU66m07J2EIOqwseyLoO2VqeuLiOuLpC4g7KeA7KCV65CY7KeAIOyViuydgCDrp6TqsJwg67OA7IiY64qUIOuPmeydvO2VmOqyjCDsnKDsp4DrkKnri4jri6QuXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI2xvb2tBdFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3JpZW50YXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG9yaWVudGF0aW9uLnlhdyBUYXJnZXQgeWF3IGluIGRlZ3JlZSA8a28+66qp7ZGcIHlhdyAoZGVncmVlIOuLqOychCk8L2tvPlxuXHQgKiBAcGFyYW0ge051bWJlcn0gb3JpZW50YXRpb24ucGl0Y2ggVGFyZ2V0IHBpdGNoIGluIGRlZ3JlZSA8a28+66qp7ZGcIHBpdGNoIChkZWdyZWUg64uo7JyEKTwva28+XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBvcmllbnRhdGlvbi5mb3YgVGFyZ2V0IHZlcnRpY2FsIGZvdiBpbiBkZWdyZWUgPGtvPuuqqe2RnCDsiJjsp4EgZm92IChkZWdyZWUg64uo7JyEKTwva28+XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIDxrbz7slaDri4jrqZTsnbTshZgg7Iuc6rCEICjrsIDrpqwg7LSIKTwva28+XG5cdCAqIEByZXR1cm4ge2VnLnZpZXczNjAuUGFub1ZpZXdlcn0gUGFub1ZpZXdlciBpbnN0YW5jZTxrbz5QYW5vVmlld2VyIOyduOyKpO2EtOyKpDwva28+XG5cdCAqIEBleGFtcGxlXG5cdCAqIC8vIENoYW5nZSB0aGUgeWF3IGFuZ2xlIChhYnNvbHV0ZSBhbmdsZSkgdG8gMzAgZGVncmVlcyBmb3Igb25lIHNlY29uZC5cblx0ICogcGFub1ZpZXdlci5sb29rQXQoe3lhdzogMzB9LCAxMDAwKTtcblx0ICovXG5cdGxvb2tBdChvcmllbnRhdGlvbiwgZHVyYXRpb24pIHtcblx0XHRpZiAoIXRoaXMuX2lzUmVhZHkpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGNvbnN0IHlhdyA9IG9yaWVudGF0aW9uLnlhdyAhPT0gdW5kZWZpbmVkID8gb3JpZW50YXRpb24ueWF3IDogdGhpcy5feWF3O1xuXHRcdGNvbnN0IHBpdGNoID0gb3JpZW50YXRpb24ucGl0Y2ggIT09IHVuZGVmaW5lZCA/IG9yaWVudGF0aW9uLnBpdGNoIDogdGhpcy5fcGl0Y2g7XG5cdFx0Y29uc3QgcGl0Y2hSYW5nZSA9IHRoaXMuX3lhd1BpdGNoQ29udHJvbC5vcHRpb24oXCJwaXRjaFJhbmdlXCIpO1xuXHRcdGNvbnN0IHZlcnRpY2FsQW5nbGVPZkltYWdlID0gcGl0Y2hSYW5nZVsxXSAtIHBpdGNoUmFuZ2VbMF07XG5cdFx0bGV0IGZvdiA9IG9yaWVudGF0aW9uLmZvdiAhPT0gdW5kZWZpbmVkID8gb3JpZW50YXRpb24uZm92IDogdGhpcy5fZm92O1xuXG5cdFx0aWYgKHZlcnRpY2FsQW5nbGVPZkltYWdlIDwgZm92KSB7XG5cdFx0XHRmb3YgPSB2ZXJ0aWNhbEFuZ2xlT2ZJbWFnZTtcblx0XHR9XG5cblx0XHR0aGlzLl95YXdQaXRjaENvbnRyb2wubG9va0F0KHt5YXcsIHBpdGNoLCBmb3Z9LCBkdXJhdGlvbik7XG5cblx0XHRpZiAoZHVyYXRpb24gPT09IDApIHtcblx0XHRcdHRoaXMuX3Bob3RvU3BoZXJlUmVuZGVyZXIucmVuZGVyKHlhdywgcGl0Y2gsIGZvdik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0X2FjdGl2YXRlKCkge1xuXHRcdHRoaXMuX3Bob3RvU3BoZXJlUmVuZGVyZXIuYXR0YWNoVG8odGhpcy5fY29udGFpbmVyKTtcblx0XHR0aGlzLl95YXdQaXRjaENvbnRyb2wuZW5hYmxlKCk7XG5cblx0XHR0aGlzLnVwZGF0ZVZpZXdwb3J0RGltZW5zaW9ucygpO1xuXG5cdFx0dGhpcy5faXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyB1cGRhdGUgeWF3UGl0Y2hDb250cm9sIGFmdGVyIGlzUmVhZHkgc3RhdHVzIGlzIHRydWUuXG5cdFx0dGhpcy5fdXBkYXRlWWF3UGl0Y2hJZk5lZWRlZCgpO1xuXG5cdFx0dGhpcy5fdHJpZ2dlckV2ZW50KEVWRU5UUy5SRUFEWSk7XG5cdFx0dGhpcy5fc3RhcnRSZW5kZXIoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciB0aGUgY2FsbGJhY2sgb24gdGhlIHJhZiB0byBjYWxsIF9yZW5kZXJMb29wIGV2ZXJ5IGZyYW1lLlxuXHQgKi9cblx0X3N0YXJ0UmVuZGVyKCkge1xuXHRcdGlmIChJU19TQUZBUklfT05fREVTS1RPUCkge1xuXHRcdFx0dGhpcy5fcmVuZGVyTG9vcCA9IHRoaXMuX3JlbmRlckxvb3BGb3JOZXh0VGljay5iaW5kKHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZW5kZXJMb29wID0gdGhpcy5fcmVuZGVyTG9vcC5iaW5kKHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3JhZklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9yZW5kZXJMb29wKTtcblx0fVxuXG5cdF9yZW5kZXIoKSB7XG5cdFx0aWYgKHRoaXMuX3Bob3RvU3BoZXJlUmVuZGVyZXIpIHtcblx0XHRcdGlmICh0aGlzLl9xdWF0ZXJuaW9uKSB7XG5cdFx0XHRcdHRoaXMuX3Bob3RvU3BoZXJlUmVuZGVyZXIucmVuZGVyV2l0aFF1YXRlcm5pb24odGhpcy5fcXVhdGVybmlvbiwgdGhpcy5fZm92KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3Bob3RvU3BoZXJlUmVuZGVyZXIucmVuZGVyKHRoaXMuX3lhdywgdGhpcy5fcGl0Y2gsIHRoaXMuX2Zvdik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0X3JlbmRlckxvb3AoKSB7XG5cdFx0dGhpcy5fcmVuZGVyKCk7XG5cblx0XHR0aGlzLl9yYWZJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fcmVuZGVyTG9vcCk7XG5cdH1cblxuXHQvKipcblx0ICogTWFjT1MgWCBTYWZhcmkgQnVnIEZpeFxuXHQgKiBUaGlzIGNvZGUgZ3VhcmFudGVlcyB0aGF0IHJlbmRlcmluZyBzaG91bGQgYmUgb2NjdXJyZWQuXG5cdCAqXG5cdCAqIEluIE1hY09TIFgoMTAuMTQuMiksIFNhZmFyaSAoMTIuMC4yKVxuXHQgKiBUaGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKFJBRikgY2FsbGJhY2sgaXMgY2FsbGVkIGp1c3QgYWZ0ZXIgcHJldmlvdXMgUkFGIGNhbGxiYWNrIHdpdGhvdXQgdGVybVxuXHQgKiBvbmx5IGlmIHJlcXVlc3RBbmltYXRpb25GcmFtZSBpcyBjYWxsZWQgZm9yIG5leHQgZnJhbWUgd2hpbGUgdXBkYXRpbmcgZnJhbWUgaXMgZGVsYXllZCAofm92ZXIgMm1zKVxuXHQgKiBTbyBicm93c2VyIGNhbm5vdCByZW5kZXIgdGhlIGZyYW1lIGFuZCBtYXkgYmUgZnJlZXppbmcuXG5cdCAqL1xuXHRfcmVuZGVyTG9vcEZvck5leHRUaWNrKCkge1xuXHRcdGNvbnN0IGJlZm9yZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG5cdFx0dGhpcy5fcmVuZGVyKCk7XG5cblx0XHRjb25zdCBkaWZmID0gcGVyZm9ybWFuY2Uubm93KCkgLSBiZWZvcmU7XG5cblx0XHRpZiAodGhpcy5fcmFmVGltZXIpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9yYWZUaW1lcik7XG5cdFx0XHR0aGlzLl9yYWZUaW1lciA9IG51bGw7XG5cdFx0fVxuXG5cdFx0LyoqIFVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgb25seSBpZiBjdXJyZW50IHJlbmRlcmluZyBjb3VsZCBiZSBwb3NzaWJsZSBvdmVyIDYwZnBzICgxMDAwLzYwKSAqL1xuXHRcdGlmIChkaWZmIDwgMTYpIHtcblx0XHRcdHRoaXMuX3JhZklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9yZW5kZXJMb29wKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0LyoqIE90aGVyd2lzZSwgQ2FsbCBzZXRUaW1lb3V0IGluc3RlYWQgb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRvIGdhdXJhbnRlZSByZW5lcmluZyBzaG91bGQgYmUgb2NjdXJyZWQqL1xuXHRcdFx0dGhpcy5fcmFmVGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuX3JlbmRlckxvb3AsIDApO1xuXHRcdH1cblx0fVxuXG5cdF9zdG9wUmVuZGVyKCkge1xuXHRcdGlmICh0aGlzLl9yYWZJZCkge1xuXHRcdFx0d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JhZklkKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fcmFmVGltZXIpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLl9yYWZUaW1lcik7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIHRoaXMuX3JhZklkO1xuXHRcdGRlbGV0ZSB0aGlzLl9yYWZUaW1lcjtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXN0cm95IHdlYmdsIGNvbnRleHQgYW5kIGJsb2NrIHVzZXIgaW50ZXJhY3Rpb24gYW5kIHN0b3AgcmVuZGVyaW5nXG5cdCAqL1xuXHRfZGVhY3RpdmF0ZSgpIHtcblx0XHRpZiAodGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlcikge1xuXHRcdFx0dGhpcy5fcGhvdG9TcGhlcmVSZW5kZXJlci5kZXN0cm95KCk7XG5cdFx0XHR0aGlzLl9waG90b1NwaGVyZVJlbmRlcmVyID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5faXNSZWFkeSkge1xuXHRcdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLmRpc2FibGUoKTtcblx0XHRcdHRoaXMuX3N0b3BSZW5kZXIoKTtcblx0XHRcdHRoaXMuX2lzUmVhZHkgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRzdGF0aWMgX2lzVmFsaWRUb3VjaERpcmVjdGlvbihkaXJlY3Rpb24pIHtcblx0XHRyZXR1cm4gZGlyZWN0aW9uID09PSBQYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTi5OT05FIHx8XG5cdFx0XHRkaXJlY3Rpb24gPT09IFBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OLllBVyB8fFxuXHRcdFx0ZGlyZWN0aW9uID09PSBQYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTi5QSVRDSCB8fFxuXHRcdFx0ZGlyZWN0aW9uID09PSBQYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTi5BTEw7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRvdWNoIGRpcmVjdGlvbiBieSB3aGljaCB1c2VyIGNhbiBjb250cm9sLlxuXHQgKiBAa28g7IKs7Jqp7J6Q6rCAIOyhsOyekeqwgOuKpe2VnCDthLDsuZgg67Cp7Zal7J2EIOyngOygle2VqeuLiOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjc2V0VG91Y2hEaXJlY3Rpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvbiBvZiB0aGUgdG91Y2guIHtAbGluayBlZy52aWV3MzYwLlBhbm9WaWV3ZXIuVE9VQ0hfRElSRUNUSU9OfTxrbz7su6jtirjroaQg6rCA64ql7ZWcIOuwqe2WpSB7QGxpbmsgZWcudmlldzM2MC5QYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTn08L2tvPlxuXHQgKiBAcmV0dXJuIHtlZy52aWV3MzYwLlBhbm9WaWV3ZXJ9IFBhbm9WaWV3ZXIgaW5zdGFuY2Vcblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogcGFub1ZpZXdlciA9IG5ldyBQYW5vVmlld2VyKGVsKTtcblx0ICogLy8gTGltaXQgdGhlIHRvdWNoIGRpcmVjdGlvbiB0byB0aGUgeWF3IGRpcmVjdGlvbiBvbmx5LlxuXHQgKiBwYW5vVmlld2VyLnNldFRvdWNoRGlyZWN0aW9uKGVnLnZpZXczNjAuUGFub1ZpZXdlci5UT1VDSF9ESVJFQ1RJT04uWUFXKTtcblx0ICovXG5cdHNldFRvdWNoRGlyZWN0aW9uKGRpcmVjdGlvbikge1xuXHRcdGlmIChQYW5vVmlld2VyLl9pc1ZhbGlkVG91Y2hEaXJlY3Rpb24oZGlyZWN0aW9uKSkge1xuXHRcdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcInRvdWNoRGlyZWN0aW9uXCIsIGRpcmVjdGlvbik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0b3VjaCBkaXJlY3Rpb24gYnkgd2hpY2ggdXNlciBjYW4gY29udHJvbFxuXHQgKiBAa28g7IKs7Jqp7J6Q6rCAIOyhsOyekeqwgOuKpe2VnCDthLDsuZgg67Cp7Zal7J2EIOuwmO2ZmO2VnOuLpC5cblx0ICogQG1ldGhvZCBlZy52aWV3MzYwLlBhbm9WaWV3ZXIjZ2V0VG91Y2hEaXJlY3Rpb25cblx0ICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb24gb2YgdGhlIHRvdWNoLiB7QGxpbmsgZWcudmlldzM2MC5QYW5vVmlld2VyLlRPVUNIX0RJUkVDVElPTn08a28+7Luo7Yq466GkIOqwgOuKpe2VnCDrsKntlqUge0BsaW5rIGVnLnZpZXczNjAuUGFub1ZpZXdlci5UT1VDSF9ESVJFQ1RJT059PC9rbz5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogcGFub1ZpZXdlciA9IG5ldyBQYW5vVmlld2VyKGVsKTtcblx0ICogLy8gUmV0dXJucyB0aGUgY3VycmVudCB0b3VjaCBkaXJlY3Rpb24uXG5cdCAqIHZhciBkaXIgPSBwYW5vVmlld2VyLmdldFRvdWNoRGlyZWN0aW9uKCk7XG5cdCAqL1xuXHRnZXRUb3VjaERpcmVjdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feWF3UGl0Y2hDb250cm9sLm9wdGlvbihcInRvdWNoRGlyZWN0aW9uXCIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlc3Ryb3kgdmlld2VyLiBSZW1vdmUgYWxsIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzIGFuZCByZW1vdmUgdmlld2VyIGNhbnZhcy5cblx0ICogQGtvIOu3sOyWtCDsnbjsiqTthLTsiqTrpbwg7ZW07KCc7ZWp64uI64ukLiDrqqjrk6Ag65Ox66Gd65CcIOydtOuypO2KuOumrOyKpOuEiOulvCDsoJzqsbDtlZjqs6Ag67ew7Ja0IOy6lOuyhOyKpOulvCDsgq3soJztlanri4jri6QuXG5cdCAqIEBtZXRob2QgZWcudmlldzM2MC5QYW5vVmlld2VyI2Rlc3Ryb3lcblx0ICogQHJldHVybiB7ZWcudmlldzM2MC5QYW5vVmlld2VyfSBQYW5vVmlld2VyIGluc3RhbmNlPGtvPlBhbm9WaWV3ZXIg7J247Iqk7YS07IqkPC9rbz5cblx0ICovXG5cdGRlc3Ryb3koKSB7XG5cdFx0dGhpcy5fZGVhY3RpdmF0ZSgpO1xuXG5cdFx0aWYgKHRoaXMuX3lhd1BpdGNoQ29udHJvbCkge1xuXHRcdFx0dGhpcy5feWF3UGl0Y2hDb250cm9sLmRlc3Ryb3koKTtcblx0XHRcdHRoaXMuX3lhd1BpdGNoQ29udHJvbCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgd2hldGhlciB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBjYW4gZXhlY3V0ZSBQYW5vVmlld2VyXG5cdCAqIEBrbyDtmITsnqwg67iM65287Jqw7KCAIO2ZmOqyveyXkOyEnCBQYW5vVmlld2VyIOyLpO2WieydtCDqsIDriqXtlZzsp4Ag7Jes67aA66W8IOuwmO2ZmO2VqeuLiOuLpC5cblx0ICogQGZ1bmN0aW9uIGlzU3VwcG9ydGVkXG5cdCAqIEBtZW1iZXJvZiBlZy52aWV3MzYwLlBhbm9WaWV3ZXJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUGFub1ZpZXdlciBleGVjdXRhYmxlIDxrbz5QYW5vVmlld2VyIOyLpO2WieqwgOuKpSDsl6zrtoA8L2tvPlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XG5cdFx0cmV0dXJuIFdlYkdMVXRpbHMuaXNXZWJHTEF2YWlsYWJsZSgpICYmIFdlYkdMVXRpbHMuaXNTdGFibGVXZWJHTCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgc3VwcG9ydHMgdGhlIFdlYkdMXG5cdCAqIEBrbyDtmITsnqwg67iM65287Jqw7KCAIO2ZmOqyveydtCBXZWJHTCDsnYQg7KeA7JuQ7ZWY64qU7KeAIOyXrOu2gOulvCDtmZXsnbjtlanri4jri6QuXG5cdCAqIEBmdW5jdGlvbiBpc1dlYkdMQXZhaWxhYmxlXG5cdCAqIEBtZW1iZXJvZiBlZy52aWV3MzYwLlBhbm9WaWV3ZXJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gV2ViR0wgc3VwcG9ydCA8a28+V2ViR0wg7KeA7JuQ7Jes67aAPC9rbz5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGlzV2ViR0xBdmFpbGFibGUoKSB7XG5cdFx0cmV0dXJuIFdlYkdMVXRpbHMuaXNXZWJHTEF2YWlsYWJsZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgc3VwcG9ydHMgdGhlIGd5cm8gc2Vuc29yLlxuXHQgKiBAa28g7ZiE7J6sIOu4jOudvOyasOyggCDtmZjqsr3snbQg7J6Q7J2066GcIOyEvOyEnOulvCDsp4Dsm5DtlZjripTsp4Ag7Jes67aA66W8IO2ZleyduO2VqeuLiOuLpC5cblx0ICogQGZ1bmN0aW9uIGlzR3lyb1NlbnNvckF2YWlsYWJsZVxuXHQgKiBAbWVtYmVyb2YgZWcudmlldzM2MC5QYW5vVmlld2VyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIHRha2UgdGhlIGd5cm8gc2Vuc29yIGF2YWlsYWJpbGl0eSBhcyBhcmd1bWVudCA8a28+7J6Q7J2066GcIOyEvOyEnOulvCDsp4Dsm5DtlZjripTsp4Ag7Jes67aA66W8IOyduOyekOuhnCDrsJvripQg7ZWo7IiYPC9rbz5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGlzR3lyb1NlbnNvckF2YWlsYWJsZShjYWxsYmFjaykge1xuXHRcdGlmICghRGV2aWNlTW90aW9uRXZlbnQpIHtcblx0XHRcdGNhbGxiYWNrICYmIGNhbGxiYWNrKGZhbHNlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgb25EZXZpY2VNb3Rpb25DaGFuZ2U7XG5cblx0XHRmdW5jdGlvbiBjaGVja0d5cm8oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cdFx0XHRcdG9uRGV2aWNlTW90aW9uQ2hhbmdlID0gZnVuY3Rpb24oZGV2aWNlTW90aW9uKSB7XG5cdFx0XHRcdFx0Y29uc3QgaXNHeXJvU2Vuc29yQXZhaWxhYmxlID0gIShkZXZpY2VNb3Rpb24ucm90YXRpb25SYXRlLmFscGhhID09IG51bGwpO1xuXG5cdFx0XHRcdFx0cmVzKGlzR3lyb1NlbnNvckF2YWlsYWJsZSk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkZXZpY2Vtb3Rpb25cIiwgb25EZXZpY2VNb3Rpb25DaGFuZ2UpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdGltZW91dCgpIHtcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiByZXMoZmFsc2UpLCAxMDAwKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdFByb21pc2UucmFjZShbY2hlY2tHeXJvKCksIHRpbWVvdXQoKV0pLnRoZW4oaXNHeXJvU2Vuc29yQXZhaWxhYmxlID0+IHtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGV2aWNlbW90aW9uXCIsIG9uRGV2aWNlTW90aW9uQ2hhbmdlKTtcblxuXHRcdFx0Y2FsbGJhY2sgJiYgY2FsbGJhY2soaXNHeXJvU2Vuc29yQXZhaWxhYmxlKTtcblxuXHRcdFx0UGFub1ZpZXdlci5pc0d5cm9TZW5zb3JBdmFpbGFibGUgPSBmdW5jdGlvbihmYikge1xuXHRcdFx0XHRmYiAmJiBmYihpc0d5cm9TZW5zb3JBdmFpbGFibGUpO1xuXHRcdFx0XHRyZXR1cm4gaXNHeXJvU2Vuc29yQXZhaWxhYmxlO1xuXHRcdFx0fTtcblx0XHR9KTtcblx0fVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==